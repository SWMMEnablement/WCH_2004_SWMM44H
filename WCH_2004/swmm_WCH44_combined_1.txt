 
REM File: AREAL.FOR 
 
      SUBROUTINE AREAL(WSNOW,SI,NEWSNO,ASC,AWE,SBA,SBWS,RIN,ADC,DELT) 
C     RUNOFF BLOCK 
C     CALLED BY SNOW NEAR LINES 87 and 90 
C======================================================================= 
C 
C     FOR UF SNOW MELT ROUTINES, THIS ROUTINE FINDS FRACTION OF AREA 
C        COVERED BY SNOW (ASC). 
C     DEVELOPED JULY 1, 1977, BY W. HUBER AND UPDATED OCT. 4, 1977. 
C     USE ANDERSON'S NWS REPORT METHODS FOR HANDLING NEW SNOW. 
C     USES AREAL DEPLETION CURVE IN ARRAY ADC, (FOR VALUES OF ASC). 
C 
C     Fix computation when just moving down regular curve with no new 
C       snow.  WCH, 1/23/04. 
C======================================================================= 
      DIMENSION ADC(10) 
C 
      IF(WSNOW.LT.SI) GO TO 10 
C 
C     HERE IF COMPLETE SNOW COVERAGE FOR AREA. 
C 
      NEWSNO = 0 
      ASC    = 1.0 
      RETURN 
   10 IF(WSNOW.GT.0.0) GO TO 20 
C 
C     HERE IF NO SNOW. 
C 
      NEWSNO = 0 
      ASC    = 0.0 
      RETURN 
C======================================================================= 
C     "Normal" or easiest case is no new snow (either dry or rain), and 
C     operating on regular (not temporary) depletion curve.  We know 
C     we're not on temporary depletion curve if NEWSNO = 0. 
C     The statement below should be strictly RIN.LT.0, since if dry or  
C     rain, can just move down regular curve.   
C======================================================================= 
Cwch 1/23/04 Change IF as indicated above. 
C   20 IF(RIN.LE.0.0.OR.NEWSNO.EQ.1) GO TO 30 
   20 IF(RIN.LT.0.0.OR.NEWSNO.EQ.1) GO TO 30 
C 
C      HERE IF DESCENDING DOWN DEPLETION CURVE. 
C      Here if RIN >= 0 (rain or dry) *and* NEWSNO = 0 (not operating 
C      on temporary depletion curve).   
C 
      AWESI = WSNOW/SI 
C 
C     USE SUBROUTINE FINDSC FOR LINEAR INTERPOLATION. 
C 
Cwch 1/23/04.  Where did it go?? 
C     Must call FINDSC  
      CALL FINDSC(AWESI,ASC,ADC) 
C*********************************************************************** 
      NEWSNO = 0 
      RETURN 
C 
   30 IF(RIN.GE.0.0) GO TO 40 
C 
C     HERE IF NEW SNOW HAS FALLEN WHILE ON DEPLETION CURVE. 
C     MUST SET UP NEW PARAMETERS FOR TEMPORARY LINEAR DEPLETION CURVE. 
C     PARAMETER NEWSNO INDICATES NEW SNOW ON PARTIALLY BARE GROUND. 
C     If NEWSNO = 1, means start out on temporary depletion curve.  
C     If NEWSNO = 0, operate on regular depletion curve.  
C 
C     FIND AMOUNT OF SNOW PRESENT AT LAST TIME STEP 
C 
                     AWE = (WSNOW+RIN*DELT)/SI 
      IF(AWE.LE.0.0) AWE = 0.0 
C 
      CALL FINDSC(AWE,SBA,ADC) 
C*********************************************************************** 
C 
                      SBWS = AWE - RIN * 0.75 * DELT / SI 
      IF(SBWS.GT.1.0) SBWS = 1.0 
      ASC    = 1.0 
      NEWSNO = 1 
      RETURN 
C 
C     HERE IF ON TEMPORARY DEPLETION CURVE, but no new snow. 
C 
   40 AWESI = WSNOW/SI 
      IF(AWESI.GE.AWE) GO TO 50 
C 
C     HERE IF HAVE MOVED BACK TO REGULAR DEPLETION CURVE. 
C 
      CALL FINDSC(AWESI,ASC,ADC) 
C*********************************************************************** 
C 
      NEWSNO = 0 
      RETURN 
   50 IF(AWESI.LT.SBWS) GO TO 60 
C 
C     HERE IF STILL HAVE 100 % COVER OF NEW SNOW. 
C 
      ASC    = 1.0 
      NEWSNO = 1 
      RETURN 
C 
C     HERE IF ON TEMPORARY LINEAR DEPLETION CURVE. 
C 
   60 ASC = SBA+(1.0-SBA)/(SBWS-AWE)*(AWESI-AWE) 
      NEWSNO = 1 
      RETURN 
      END 
 
REM File: CIRCLE.FOR 
 
      SUBROUTINE CIRCLE(ALPHA,PS,DN,ID) 
C     TRANSPORT BLOCK 
C     CALLED BY FINDA NEAR LINE 41 
C======================================================================= 
C     ROUTINE TO COMPUTE HYDRAULIC ELEMENTS OF CIRCULAR PIPE. 
C                USES NEWTON-RAPHSON ITERATION TO FIND THETA. 
C     PARABOLIC STARTING GUESS VALID ONLY FOR THETA < 1.3 RADIANS, 
C                                        (ALPHA < 0.04, PSI < 0.015). 
C     WEAKER STARTING GUESSES FOR HIGHER VALUES COULD CONCEIVABLY 
C                                         CAUSE CONVERGENCE PROBLEMS. 
C     UPDATED (NEW COMMON) BY W.C.H., SEPTEMBER 1981. 
C     Modified by A.H.Elliot, Nat. Inst. Water Atm. Res, NZ, 29/6/00 to  
C     improve convergence for large theta.  Added to SWMM44gu by  
C     WCH, 8/10/00. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
C======================================================================= 
C     ALPHA = A/AFULL 
C     PS    = PSI = Q/QFULL 
C     DN    = DEPTH/DIAMETER 
C     THETA = SUBTENDED ANGLE 
C 
C     ID = 1, GIVEN ALPHA, COMPUTE THETA THEN PSI. 
C     ID = 2, GIVEN ALPHA, COMPUTE THETA THEN DN. 
C     ID = 3, GIVEN PSI,   COMPUTE THETA THEN ALPHA. 
C======================================================================= 
      IF(ID.LE.2) THEN 
         IF(ALPHA.LE.0.0.OR.ALPHA.GE.1.0) GO TO 200 
         IF(ALPHA.LE.1.0E-5)              GO TO 400 
C======================================================================= 
C     FIRST CALCULATE THETA GIVEN ALPHA. 
C     USE PARABOLIC APPROXIMATION FOR FIRST GUESS FOR ALPHA < 0.04 
C======================================================================= 
         THETA = 0.031715 - 12.79384 * ALPHA + 8.28479 * SQRT(ALPHA) 
         IF(ALPHA.GT.0.04) THETA = 1.2 + 5.08 * (ALPHA - 0.04) / 0.96 
         TH1 = THETA 
         AP  = 6.283185 * ALPHA 
C======================================================================= 
         DO 20 K = 1,40 
         D       = - (AP - THETA + SIN(THETA)) / (1 - COS(THETA)) 
C     Modification by AHE, NIWA 29/6/00 to improve convergence for  
C     large theta 
	   IF(D>1) D=SIGN(1.,D) 
         THETA   = THETA - D 
         IF(ABS(D).LE.0.0001) GO TO 40 
   20    CONTINUE 
C======================================================================= 
C     IF NO CONVERGENCE, USE FIRST GUESS. 
C======================================================================= 
         THETA = TH1 
         WRITE(N6,35) ID,ALPHA,THETA 
C======================================================================= 
C     CALCULATE PSI. 
C======================================================================= 
   40    IF(ID.NE.2) THEN 
                  PS = (THETA - SIN(THETA)) ** 1.666667 / 
     +                 6.283185 / THETA ** .66667 
C======================================================================= 
C                 CALCULATE NORMALIZED DEPTH. 
C======================================================================= 
                  ELSE 
                  DN = (1.0 - COS(THETA / 2.0)) / 2.0 
                  ENDIF 
C======================================================================= 
C     END OF ID LE 2 
C======================================================================= 
         RETURN 
         ENDIF 
C======================================================================= 
C     START OF ID EQ 3 
C======================================================================= 
      IF(PS.LE.0.0.OR.PS.GE.1.0) GO TO 300 
      IF(PS.LE.1.0E-6)           GO TO 500 
C======================================================================= 
C        FIRST COMPUTE THETA GIVEN PSI. 
C        USE PARABOLIC APPROXIMATION FOR FIRST GUESS FOR PS < 0.015 
C======================================================================= 
      THETA = 0.12103 - 55.5075 * PS + 15.62254 * SQRT(PS) 
      IF(PS.GT.0.015) THETA = 1.2 + 1.94 * (PS - 0.015) / 0.485 
      IF(PS.GT.0.5)   THETA = 3.14 + 1.03 * (PS - 0.5) / 0.4 
      IF(PS.GT.0.90)  THETA = 4.17 + 1.12 * (PS - 0.90) / 0.176 
      TH1   = THETA 
      AP    = 6.283185 * PS 
C======================================================================= 
      DO 120 K = 1,40 
      THETA    = ABS(THETA) 
      TT       = THETA - SIN(THETA) 
      TT23     = TT ** 0.666667 
      T3       = THETA ** 0.333333 
      D        = AP * THETA / T3 - TT * TT23 
      D        = D/(AP*.666667/T3-1.666667*TT23*(1.0-COS(THETA))) 
      THETA    = THETA - D 
      IF(ABS(D).LE.0.0001) GO TO 140 
 120  CONTINUE 
C======================================================================= 
C     IF NO CONVERGENCE, USE FIRST GUESS. 
C======================================================================= 
      THETA = TH1 
      WRITE(N6,35) ID,PS,THETA 
C======================================================================= 
C     CALCULATE ALPHA 
C======================================================================= 
  140 ALPHA = (THETA - SIN(THETA)) / 6.283185 
      RETURN 
C======================================================================= 
  200 IF(ALPHA.GE.1.0) THEN 
                       PS    = 1.0 
                       DN    = 1.0 
                       ELSE 
                       PS    = 0.0 
                       DN    = 0.0 
                       ENDIF 
      RETURN 
C======================================================================= 
  300 IF(PS.GE.1.0) THEN 
                    ALPHA = 1.0 
                    ELSE 
                    ALPHA = 0.0 
                    ENDIF 
      RETURN 
C======================================================================= 
C     FOR SMALL ALPHA (HENCE THETA), USE EXPANSION FOR SIN & COSINE. 
C======================================================================= 
  400 THETA          = (37.69911 * ALPHA) ** 0.33333 
      IF(ID.EQ.1) PS = THETA ** 4.33333 / 124.4797 
      IF(ID.EQ.2) DN = THETA ** 2 / 16.0 
      RETURN 
C======================================================================= 
C     FOR SMALL PS (HENCE THETA), USE EXPANSION FOR SIN & COSINE. 
C======================================================================= 
  500 THETA = (124.4797 * PS) ** 0.2307692 
      ALPHA = THETA ** 3 / 37.69911 
      RETURN 
C======================================================================= 
   35 FORMAT(/,' ===>  WARNING  NO CONVERGENCE IN SUBROUTINE CIRCLE. 
     1. ID =',I8,'   ALPHA OR PSI =',1PE15.7,'   THETA1 =',1PE15.7,/) 
C======================================================================= 
      END 
 
REM File: CLINEDVS.FOR 
 
      SUBROUTINE CLINEDVS 
c2013 USE DFLIB 
C======================================================================= 
C   Option for command line input of file names. 
C   Written by Chuck Moore of CDM, 8/93. 
C======================================================================= 
C   This subroutine uses RMFortran-specific functions ARGC and ARGV to 
C     return number of arguments on command line (including .EXE file) 
C     and character values of the arguments, respectively. 
C   For Lahey Fortran, must include Function ARGC to accomplish same 
C     task. 
C======================================================================= 
C     WCH, 10/2/96.  Declare FPOS as integer to avoid Watcom compiler 
C       errors.  (Bruce LaZerte) 
C   Modified for Digital Visual Fortran 
C   CIM 6/97 
C======================================================================= 
      INCLUDE 'CLNAME.INC' 
      CHARACTER*128 FNAME 
      CHARACTER*1 FIRSTCH 
      INTEGER*2 I,IFIL 
C 
      INAMES=0 
      IFIL = NARGS() 
      NNAMES=0 
      IF (IFIL.EQ.1) RETURN 
C======================================================================= 
C   Note that program name is first name recognized; hence, ARGC always 
C     > 0. 
C======================================================================= 
      DO 100 I= 1,IFIL-1 
      CALL GETARG (I,FNAME) 
      FIRSTCH=FNAME 
C======================================================================= 
C   Allow for RM Fortran switch options to be included on command line. 
C======================================================================= 
      IF (FIRSTCH.EQ.'/')   GO TO 100 
       NNAMES=NNAMES+1 
       CNAMES(NNAMES) = FNAME 
100    CONTINUE 
      RETURN 
      END 
 
REM File: COMB1.FOR 
 
      SUBROUTINE COMB1(ICOMB) 
C	COMBINE BLOCK 
C======================================================================= 
C     COMB1 does the analysis for ICOMB options 3, 5, 6 and 7. 
C     WCH, 11/30/93.  Fix units for quality totals and modify time step 
C       multiplication during summations.  
C     WCH, 8/1/95.  Change precip. station ID to character. 
C     WCH, 7/25/96.  Add option to create ASCII rainfall interface file. 
C======================================================================= 
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'COMB.INC' 
C#### WCH, 8/1/95.  MAKE JSTA A CHARACTER VARIABLE. 
C####      DIMENSION JSTA(10),PCONV(10),SUMM(11) 
CIMT change dimensions from 10 to MQUAL, and 11 to MQUAL+1 
      DIMENSION PCONV(MQUAL),SUMM(MQUAL+1) 
C#### WCH, 7/25/96. 
      CHARACTER*128 NEWFIL 
cred  up the number of rainfall stations to 2000 from 10 - 6/22/01 
      CHARACTER JOHNNY*10,NOTED(3)*10,MOTED(3)*10 
      DATA NOTED/'  Pounds  ',' Quantity ',' Unit*cf  '/ 
C#### WCH, 11/30/93.  CHANGE TO:             Unit*cum and Unit*cf. 
      DATA MOTED/' Kilograms',' Quantity ',' Unit*cum '/ 
      DATA JOHNNY/' ---------'/ 
C======================================================================= 
C#### WCH, 7/25/96.  Open formatted file on JOUT (= NEXT). 
C======================================================================= 
      IF(ICOMB.EQ.7.or.ICOMB.EQ.12) THEN 
               INQUIRE(NEXT,NAME=NEWFIL) 
               CLOSE(NEXT) 
               OPEN(NEXT,FILE=NEWFIL,FORM='FORMATTED',STATUS='UNKNOWN') 
               ENDIF 
      IF(ICOMB.EQ.10) THEN 
             INQUIRE(LAST,NAME=NEWFIL) 
             CLOSE(LAST) 
             OPEN(LAST,FILE=NEWFIL,FORM='UNFORMATTED',STATUS='UNKNOWN') 
             INQUIRE(NEXT,NAME=NEWFIL) 
             CLOSE(NEXT) 
c2013        OPEN(NEXT,FILE=NEWFIL,FORM='binary',STATUS='UNKNOWN') 
             ENDIF 
      IF(ICOMB.EQ.11) THEN 
             INQUIRE(LAST,NAME=NEWFIL) 
             CLOSE(LAST) 
c2013        OPEN(LAST,FILE=NEWFIL,FORM='binary',STATUS='UNKNOWN') 
             INQUIRE(NEXT,NAME=NEWFIL) 
             CLOSE(NEXT) 
             OPEN(NEXT,FILE=NEWFIL,FORM='UNFORMATTED',STATUS='UNKNOWN') 
             ENDIF 
      IF(ICOMB.EQ.8.or.ICOMB.EQ.14) THEN 
               INQUIRE(LAST,NAME=NEWFIL) 
               CLOSE(LAST) 
               OPEN(LAST,FILE=NEWFIL,FORM='FORMATTED',STATUS='UNKNOWN') 
               ENDIF 
C======================================================================= 
C===> Read interface file headers (ICOMB=3) 
C======================================================================= 
      IF(ICOMB.EQ.3) THEN 
                     IF(LAST.GT.0) CALL INFACE(1,LAST) 
                     RETURN 
                     ENDIF 
C======================================================================= 
C===> Read file headers and calculate simple statistics (ICOMB=5). 
C======================================================================= 
      IF(ICOMB.EQ.5) THEN 
                     METRIC = 1 
                     XTIME  = 0.0 
                     IF(LAST.GT.0) CALL INFACE(1,LAST) 
                     IF(QCONV.NE.1.0) METRIC = 2 
                     DO 7990 I = 1,LOCATS 
C======================================================================= 
C#### WCH, 11/30/93. Fix U.S. conversion factors. 
C                        MULT BY SEC AND 
C     NDIM  CONC  LOAD     CONVERT TO    PCONV  
C       0   MG/L CFS*MG/L     LB        62.425E-6 = 28.316*2.2046/1E6      
C       1    X/L CFS*X/L       X         28.316 
C       2     X  CFS*X       CF*X         1.0 
C======================================================================= 
                     IF(NQUAL.GT.0) THEN 
                         DO 7995 J  = 1,NQUAL 
                            IF(METRIC.EQ.1) THEN 
                               PCONV(J) = 62.425E-6 
                               IF(NDIM(J).EQ.1) PCONV(J) = 28.316 
                               ELSE 
C======================================================================= 
C#### WCH, 11/30/93.  Fix metric conversion factors. 
C                        MULT BY SEC AND 
C     NDIM  CONC  LOAD     CONVERT TO        PCONV  
C       0   MG/L CMS*MG/L     KG             0.001 
C       1    X/L CMS*X/L       X             1000. 
C       2     X  CMS*X       CUM*X            1.0 
C======================================================================= 
                               PCONV(J) = 0.001 
                               IF(NDIM(J).EQ.1) PCONV(J) = 1000.0 
                               ENDIF 
                         IF(NDIM(J).GE.2) PCONV(J) = 1.0 
 7995                    POLL2(J,I) = 0.0 
                         ENDIF 
 7990                QO2(I)    = 0.0 
C======================================================================= 
C                    Read the interface file. 
C======================================================================= 
                     ITEST     = 0 
                     DELT1     = 0.0 
                     DO 8888 K = 1,1000000 
                     IF(NQUAL.LE.0) READ(LAST,END=8100) JDAY,TMDAY, 
     +                              DELT2,(QO1(I),I=1,LOCATS) 
                     IF(NQUAL.GT.0) READ(LAST,END=8100) JDAY,TMDAY, 
     +                              DELT2,(QO1(I),(POLL1(J,I), 
     +                              J=1,NQUAL),I=1,LOCATS) 
                     JYEAR = JDAY/1000 
                     IF (JYEAR.LT.100) THEN 
                     JDAY = JDAY-JYEAR*1000 
                     JYEAR = JYEAR + 1900 
                     JDAY = JDAY + JYEAR*1000 
                     ENDIF 
C======================================================================= 
C                    Calculate cumulative volumes and loads 
C                    using trapezoidal integration. 
C======================================================================= 
                     XTIME         = XTIME + DELT2 
C======================================================================= 
C#### WCH, 11/30/93 
C   Because time steps are variable from the Runoff Block there is the 
C   possibility of a long, DRY time step, at end of which is a non-zero 
C   runoff value although wouldn't expect this to happen.  (Would 
C   expect zero at the end of DRY, followed by a WET time step and a 
C   non-zero value.  However, this doesn't always happen.)  Thus: 
C   Whenever a non-zero flow follows a zero flow, use the time step 
C   associated with the non-zero flow for that time step only.  This 
C   will usually mean that the first non-zero flow will be multiplied 
C   by WET to get the volume, not DRY or WETDRY.  For continuous flows, 
C   use average of old and new time step as before. 
C======================================================================= 
C   First, check to see if there is flow during this time step, then 
C   use average or just new DELT2, depending on whether there was flow 
C   last time step (ITEST = 1). 
C======================================================================= 
                     DO 8003 I = 1,LOCATS 
                     IF(QO1(I).NE.0.0) THEN 
                          POOP = 0.5*(DELT1 + DELT2) 
                          IF(ITEST.EQ.0) POOP = DELT2 
                          GO TO 8004 
                          ENDIF 
 8003                CONTINUE 
C======================================================================= 
C   Here no flow, so skip calculations. 
C======================================================================= 
                     ITEST = 0 
                     GO TO 8888 
C#### WCH, 11/30/93.  DON'T THINK SHOULD MULT DT BY 2 HERE. 
C####                     IF(ITEST.EQ.0) POOP = 2.0*DELT2 
 8004                ITEST         = 1 
                     DO 8000 I     = 1,LOCATS 
                     IF(NQUAL.GT.0) THEN 
                        DO 8005 J  = 1,NQUAL 
C#### WCH, 11/30/93.  MULT BY PCONV JUST ONCE, LATER. 
 8005                   POLL2(J,I) = POLL2(J,I)+POLL1(J,I)*POOP 
                        ENDIF 
C#### WCH, 11/30/93          IF(QO1(I).NE.0.0) ITEST = 1 
                     QO2(I)        = QO2(I) + QO1(I)*POOP 
 8000                CONTINUE 
                     DELT1         = DELT2 
C#### WCH, 11/30/93          IF(ITEST.EQ.0) DELT1 = 0.0 
 8888                CONTINUE 
 8100                CONTINUE 
C======================================================================= 
C                    Write junction/inlet/manhole summaries. 
C======================================================================= 
                     NPOINT = K - 1 
                                    IEND = 1 
                     IF(NQUAL.GT.0) IEND = NQUAL + 1 
                     IF(NQUAL.EQ.0) WRITE(N6,8290) 
                     IF(NQUAL.GT.0) WRITE(N6,8290) (PNAME(J),J=1,NQUAL) 
                     IF(METRIC.EQ.1.AND.NQUAL.EQ.0) WRITE(N6,8295) 
                     IF(METRIC.EQ.1.AND.NQUAL.GT.0) WRITE(N6,8295) 
     +                            (NOTED(NDIM(J)+1),J=1,NQUAL) 
                     IF(METRIC.EQ.2.AND.NQUAL.EQ.0) WRITE(N6,8296) 
                     IF(METRIC.EQ.2.AND.NQUAL.GT.0) WRITE(N6,8296) 
     +                            (MOTED(NDIM(J)+1),J=1,NQUAL) 
                     WRITE(N6,8297) (JOHNNY,J=1,IEND) 
                     XT        = XTIME/3600.0 
CIMT change upper limit of loop from 11 to MQUAL + 1 
                     DO 8190 I = 1,MQUAL+1 
 8190                SUMM(I)   = 0.0 
                     DO 8200 I = 1,LOCATS 
                     IF(NQUAL.GT.0) THEN 
                                    DO 8205 J  = 1,NQUAL 
C#### WCH, 11/30/93.  DO QUALITY CONVERSIONS HERE. 
                                    POLL2(J,I) = POLL2(J,I) * PCONV(J) 
 8205                               SUMM(J+1)  = SUMM(J+1) + POLL2(J,I) 
                                    ENDIF 
                     SUMM(1)   = SUMM(1) + QO2(I) 
                     IF(XTIME.EQ.0.0) THEN 
                                      XTIME = 1.0 
                                      WRITE(N6,8301) 
                                      ENDIF 
                     IF(JCE.EQ.0.AND.NQUAL.EQ.0) WRITE(N6,8300) NLOC(I), 
     +                                             QO2(I)/XTIME,QO2(I) 
                     IF(JCE.EQ.0.AND.NQUAL.GT.0) WRITE(N6,8300) NLOC(I), 
     +                        QO2(I)/XTIME,QO2(I),(POLL2(J,I),J=1,NQUAL) 
                     IF(JCE.EQ.1.AND.NQUAL.EQ.0) WRITE(N6,8305) KAN(I), 
     +                                             QO2(I)/XTIME,QO2(I) 
                     IF(JCE.EQ.1.AND.NQUAL.GT.0) WRITE(N6,8305) KAN(I), 
     +                       QO2(I)/XTIME,QO2(I),(POLL2(J,I),J=1,NQUAL) 
 8200                CONTINUE 
C======================================================================= 
C                    Write the overall summary. 
C======================================================================= 
                     WRITE(N6,8310) (JOHNNY,J=1,IEND) 
C#### WCH, 11/30/93.  CHECK FOR ZERO AREA. NOTE, TRIBA ALWAYS IN ACRES. 
                     TERRA = 0.0 
                     IF(TRIBA.GT.0.0) TERRA = SUMM(1)/(3630.0*TRIBA) 
     1                                         *QCONV 
                     IF(METRIC.EQ.2) TERRA = 25.4*TERRA 
                     IF(NQUAL.EQ.0) WRITE(N6,8315) TERRA,SUMM(1) 
                     IF(NQUAL.GT.0) WRITE(N6,8315) TERRA,SUMM(1), 
     +                              (SUMM(J+1),J=1,NQUAL) 
                     WRITE(N6,8311) (JOHNNY,J=1,IEND) 
                     IF(METRIC.EQ.1.AND.NQUAL.EQ.0) WRITE(N6,8316) 
                     IF(METRIC.EQ.1.AND.NQUAL.GT.0) WRITE(N6,8316) 
     +                            (NOTED(NDIM(J)+1),J=1,NQUAL) 
                     IF(METRIC.EQ.2.AND.NQUAL.EQ.0) WRITE(N6,8317) 
                     IF(METRIC.EQ.2.AND.NQUAL.GT.0) WRITE(N6,8317) 
     +                            (MOTED(NDIM(J)+1),J=1,NQUAL) 
                     WRITE(N6,8320) XT,NPOINT 
                     RETURN 
                     ENDIF 
C======================================================================= 
C===> Read Rain Block interface file (ICOMB = 6 or 7) 
C======================================================================= 
      IF(ICOMB.ge.6.and.ICOMB.le.11) THEN 
              	   call combine_rain(ICOMB) 
                     RETURN 
                     ENDIF 
      IF(ICOMB.ge.12) THEN 
              	   call combine_temp(ICOMB) 
                     RETURN 
                     ENDIF 
C======================================================================= 
C#### WCH, 8/1/95.  CHANGE I13 TO A13. 
 2120 FORMAT(' Location Station number',/, 
     +       ' -------- --------------',/, 
     +       10(I9,'. ',A13,/)) 
 8290 FORMAT(/, 
     +' ################################################',/ 
     +' #   Simple flow statistics from interface file #',/, 
     +' ################################################',//, 
     +'  Location #   Mean Flow  Total Flow ',99(2X,A8,2X)) 
 8295 FORMAT('                  cfs      cubic ft. ', 
     +    10(2X,A10)) 
 8296 FORMAT('                  cms     cubic met. ', 
     +    10(2X,A10)) 
 8297 FORMAT('  ----------   ---------',11(2X,A10)) 
 8301 FORMAT(/,' ===> Error  Total time was 0.0 hours.') 
 8300 FORMAT(1X,I10,1X,F12.5,11(1PE12.4)) 
 8305 FORMAT(2X,A10,F12.5,11(1PE12.4)) 
 8310 FORMAT( 
     +'  ----------  ----------',11(2X,A10)) 
 8311 FORMAT( 
     +'                --------',11(2X,A10)) 
 8315 FORMAT(' Total       ',F11.4,11(1PE12.4)) 
 8316 FORMAT('                  inches   cubic ft. ', 
     +    10(2X,A10)) 
 8317 FORMAT('             millimeters  cubic met. ', 
     +    10(2X,A10)) 
 8320 FORMAT(//,' Total simulation time ===> ',F20.4,' hours',//, 
     +          ' Total number of steps ===> ',10X,I10) 
 9500 FORMAT(/,' ===> Error   This file is probably not a Rain', 
     +' or Temp Block interface file.') 
C======================================================================= 
      END 
 
REM File: COMBIN.FOR 
 
      SUBROUTINE COMBIN 
C	COMBINE BLOCK 
C======================================================================= 
C     Rewritten   June 1988 by R. Dickinson 
C     Updated      May 1989 by R.E.D. 
C     Updated November 1990 by Laura Terrell, CDM 
C     Updated December 1990 by R.E.D. 
C     Updated   August 1992 by WCH and May 1993 by RED 
C     Add error message, WCH, 8/93. 
C     Make combine and collate options compatible with alphanumeric  
C       labels and minor format changes, WCH, 11/19/93. 
C     Add option for printing concentrations instead of loads on  
C       ASCII file, WCH, 11/23/93. 
C     Create readable ASCII version of rainfall interface file, WCH,  
C       7/25/96. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'COMB.INC' 
C======================================================================= 
      CHARACTER KODEOT*10 
      INTEGER   SECOND,FIRST,ILAG 
C#####'################################################################# 
C REMOVE DOUBLE PRECISION FROM DELT, DELT1, DELT2,   WCH, 8/28/92 
C     DOUBLE PRECISION DELT, DELT1,DELT2,DIFF,TDIFF 
C AND FROM DIFF, TDIFF,  RED 5/28/93 
cred  make diff and tdiff double precision - 6/5/2003 
CRED  DOUBLE PRECISION DIFF,TDIFF 
C####################################################################### 
      LOGICAL*1 OK1,OK2 
C======================================================================= 
C     This subroutine has six main objectives: 
C 
C     ICOMB      => IF = 0, COLLATE OPTION 
C                   IF = 1, COMBINE OPTION 
C                   IF = 2, EXTRACT (AND OPTIONALLY RENUMBER) 
C                           NODES FROM A SINGLE INPUT FILE. 
C                   IF = 3, READ FILE HEADER 
C                   IF = 4, CREATE ASCII FILE FROM BINARY INTERFACE FILE 
C                   IF = 5, CALCULATE THE SIMPLE STATISTICS (SUMS) OF 
C                           AN INTERFACE FILE 
C                   IF = 6, CALCULATE THE SIMPLE STATISTICS (SUMS) OF 
C                           A RAIN BLOCK INTERFACE FILE 
C#### WCH, 7/25/96.  
C                   IF = 7, SAME AS 6, PLUS CREATE ASCII FILE OF  
C                           RAINFALL INTERFACE FILE.   
C                   IF = 8, CALCULATE THE SIMPLE STATISTICS (SUMS) OF 
C                           A temp BLOCK INTERFACE FILE 
C                   IF = 9, SAME AS 6, PLUS CREATE ASCII FILE OF  
C                           Temperature INTERFACE FILE.   
C======================================================================= 
C     Define statement function for linear interpolation. 
C======================================================================= 
CIM ITS NOT USED 
CIM      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1) 
C======================================================================= 
      WRITE(N6,10) 
      WRITE(*,10) 
C======================================================================= 
C     Initialization. 
C======================================================================= 
      INCNT      = INCNT  + 1 
      IOUTCT     = IOUTCT + 1 
      LAST       = JIN(INCNT) 
      NEXT       = JOUT(IOUTCT) 
      SECOND     = NSCRAT(1) 
      IF(LAST.LE.0) CALL ERROR(100) 
C======================================================================= 
C     Open files for the Combine Block. 
C======================================================================= 
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR. 
     +      FFNAME(INCNT).EQ.'JIN.UF')) 
     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND. 
     +      FFNAME(INCNT).NE.'JIN.UF') 
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
C#### WCH, 7/25/96.  CHECK FOR POSSIBLE FILE FORM MIS-MATCH, BECAUSE 
C     JOUT MIGHT BE USED FOR FORMATTED FILE. 
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR. 
     +   FFNAME(25+IOUTCT).EQ.'JIN.UF')) THEN 
            OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH') 
            ELSE       
            CALL FILECK(JOUT(IOUTCT),FFNAME(25+IOUTCT),'UNFORMATTED') 
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND. 
     +   FFNAME(25+IOUTCT).NE.'JIN.UF') 
     +   OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED', 
     +   STATUS='UNKNOWN',ACCESS='SEQUENTIAL') 
            ENDIF 
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).NE.'SCRT1.UF') OPEN(NSCRAT(1), 
     +             FILE=FFNAME(51),FORM='UNFORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).EQ.'SCRT1.UF') OPEN(NSCRAT(1), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(NSCRAT(7).gt.0) then 
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).NE.'SCRT7.UF') OPEN(NSCRAT(7), 
     +             FILE=FFNAME(57),FORM='UNFORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).EQ.'SCRT7.UF') OPEN(NSCRAT(7), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
	 endif 
C======================================================================= 
C     Data initialization. 
C======================================================================= 
C#### WCH, 11/23/93 
      IPOLLU     = 0 
CIMT  Change upper range from 10 to MQUAL 
      DO 8 J     = 1,MQUAL 
      NDIM(J)    = 0 
      NDIM2(J)   = 0 
      PNAM1(J)   = ' ' 
      PNAM2(J)   = ' ' 
      PUNIT(J)   = ' ' 
      PUNIT2(J)  = ' ' 
      PUNIT1(J)  = ' ' 
      NDIM1(J)   = 0 
      DO 8 I     = 1,NIE 
      CPOLL(J,I) = 0.0 
      POLL1(J,I) = 0.0 
      POLL2(J,I) = 0.0 
      POLL3(J,I) = 0.0 
      POLD1(J,I) = 0.0 
      POLD2(J,I) = 0.0 
      IF(J.GT.1) GO TO 8 
      QO1(I)     = 0.0 
      QO2(I)     = 0.0 
      QO3(I)     = 0.0 
      QQO(I)     = 0.0 
      QOLD1(I)   = 0.0 
      QOLD2(I)   = 0.0 
      INPOS1(I)  = 0 
      INPOS2(I)  = 0 
      JCOMB(I)   = 0 
    8 CONTINUE 
C======================================================================= 
C>>>>>READ DATA GROUP A1<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,ICOMB 
      WRITE(N6,71) ICOMB 
      IF(NEXT.LE.0.AND.ICOMB.LT.2) CALL ERROR(101) 
C#### WCH, 7/25/96. 
C####      IF(NEXT.LE.0.AND.ICOMB.EQ.4) CALL ERROR(101) 
      IF(NEXT.LE.0.AND.(ICOMB.EQ.4.OR.ICOMB.EQ.7)) CALL ERROR(101) 
      IF(NEXT.LE.0.AND. ICOMB.EQ.8)                CALL ERROR(101) 
C======================================================================= 
      IF(ICOMB.EQ.3.OR.ICOMB.GT.4) THEN 
                                   CALL COMB1(ICOMB) 
                                   WRITE(N6,9000) 
ECHO is off.
		                         WRITE(*,9000) 
                                   RETURN  
                                   ENDIF 
C======================================================================= 
C     End of Combine Block if ICOMB = 3, 5, 6 or 7.  
C======================================================================= 
C     Read remaining Combine Block input. 
C======================================================================= 
C>>>>>READ DATA GROUP B1<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,TITLE(3) 
      READ(N5,*,ERR=888) CC,TITLE(4) 
      WRITE(N6,660)         TITLE(3),TITLE(4) 
C======================================================================= 
C>>>>>READ DATA GROUP B2<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
C     NODEOT => Node number for output. 
C     KODEOT => Node name   for output. 
C#### WCH, 11/23/93. 
C     NPOLL  => Number of pollutants to be placed on new file. 
C     If NPOLL < 0, then for ICOMB = 4, print concentrations on ASCII 
C       file, not loads. 
C======================================================================= 
      IF(JCE.EQ.0) THEN 
                   READ(N5,*,ERR=888) CC,NODEOT,NPOLL 
C#### WCH, 11/23/93. 
                   IF(NPOLL.LT.0) THEN 
                      IPOLLU = 1 
                      NPOLL = -NPOLL 
                      ENDIF 
C#### WCH, 11/19/93.  OUTPUT DATA SET = JOUT, NOT JIN 
                   WRITE(N6,410)         NODEOT,JOUT(IOUTCT),NPOLL 
                   ELSE 
C#### WCH, 8/2/93. ADD ADDITIONAL ERROR MESSAGE.  GO TO 887. 
                   READ(N5,*,ERR=887) CC,KODEOT,NPOLL 
C#### WCH, 11/23/93. 
                   IF(NPOLL.LT.0) THEN 
                      IPOLLU = 1 
                      NPOLL = -NPOLL 
                      ENDIF 
                   WRITE(N6,411)         KODEOT,JOUT(IOUTCT),NPOLL 
                   ENDIF 
	IF (NPOLL.GT.MQUAL) THEN 
	WRITE(N6,*) 'ERROR *** NPOLL IS GREATER THAN MAXIMUM ALLOWED.' 
	STOP 'ERROR *** NPOLL IS GREATER THAN MAXIMUM ALLOWED.' 
	ENDIF 
C#### WCH, 11/23/93 
      IF(ICOMB.EQ.4.AND.NPOLL.GT.0) THEN 
           IF(IPOLLU.EQ.0) WRITE(N6,415) 
           IF(IPOLLU.EQ.1) WRITE(N6,416) 
           ENDIF 
C======================================================================= 
C>>>>>READ DATA GROUP B3<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(NPOLL.GT.0) THEN 
                     READ(N5,*,ERR=888) CC,(NPOS1(J),NPOS2(J),J=1,NPOLL) 
                     WRITE(N6,420)       (J,NPOS1(J),NPOS2(J),J=1,NPOLL) 
                     ENDIF 
C======================================================================= 
C>>>>>READ DATA GROUP C1<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,NUMX,NUMR 
      WRITE(N6,430)         NUMX,NUMR 
C======================================================================= 
C>>>>>READ DATA GROUP C2<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(NUMX.GT.0) THEN 
              IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,(NODEX(I),I=1,NUMX) 
C#### WCH, 8/2/93. ADD ADDITIONAL ERROR MESSAGE.  GO TO 887. 
              IF(JCE.EQ.1) READ(N5,*,ERR=887) CC,(KODEX(I),I=1,NUMX) 
              WRITE(N6,440) 
              IF(JCE.EQ.0) WRITE(N6,450) (NODEX(I),I=1,NUMX) 
              IF(JCE.EQ.1) WRITE(N6,451) (KODEX(I),I=1,NUMX) 
              ENDIF 
C======================================================================= 
C>>>>>READ DATA GROUP C3<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(NUMR.GT.0) THEN 
              IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,(NODER(I),I=1,NUMR) 
C#### WCH, 8/2/93. ADD ADDITIONAL ERROR MESSAGE.  GO TO 887. 
              IF(JCE.EQ.1) READ(N5,*,ERR=887) CC,(KODER(I),I=1,NUMR) 
              WRITE(N6,445) 
              IF(JCE.EQ.0) WRITE(N6,450) (NODER(I),I=1,NUMR) 
              IF(JCE.EQ.1) WRITE(N6,451) (KODER(I),I=1,NUMR) 
              ENDIF 
C======================================================================= 
C     Extract and renumber an interface file (ICOMB=2). 
C======================================================================= 
      IF(ICOMB.EQ.2.AND.NUMX.EQ.0) CALL ERROR(102) 
      IF(ICOMB.EQ.2) THEN 
               CALL INFACE(1,LAST) 
C======================================================================= 
C     Transfer information to file NEXT. 
C======================================================================= 
               REWIND NEXT 
               WRITE(NEXT) NUMX,NQUAL 
               IF(JCE.EQ.0.AND.NUMR.GT.0) WRITE(NEXT)(NODER(I),I=1,NUMX) 
               IF(JCE.EQ.0.AND.NUMR.EQ.0) WRITE(NEXT)(NODEX(I),I=1,NUMX) 
               IF(JCE.EQ.1.AND.NUMR.GT.0) WRITE(NEXT)(KODER(I),I=1,NUMX) 
               IF(JCE.EQ.1.AND.NUMR.EQ.0) WRITE(NEXT)(KODEX(I),I=1,NUMX) 
               SOURCE = 'COMBINE BLOCK' 
               CALL INFACE(2,NEXT) 
C======================================================================= 
C     Read input interface file information. 
C======================================================================= 
  50           IF(NQUAL.LE.0) READ(LAST,END=90) JDAY,TMDAY, 
     +                        DELT,(QO1(I),I=1,LOCATS) 
               IF(NQUAL.GT.0) READ(LAST,END=90) JDAY,TMDAY, 
     +                  DELT,(QO1(I),(POLL1(J,I),J=1,NQUAL),I=1,LOCATS) 
                   IF(JDAY.EQ.99999) JDAY = 9999999 
                   JYEAR = JDAY/1000 
                   IF (JYEAR.LT.100) THEN 
                   JDAY = JDAY - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JDAY = JDAY + JYEAR*1000 
                   ENDIF 
C======================================================================= 
C     Extract only selected nodes. 
C======================================================================= 
               DO 55 J = 1,LOCATS 
               DO 60 K = 1,NUMX 
               IF(JCE.EQ.0.AND.NODEX(K).EQ.NLOC(J)) THEN 
                                           QO2(K) = QO1(J) 
                                           IF(NQUAL.GT.0) THEN 
                                           DO 70 KK    = 1,NQUAL 
   70                                      POLL2(KK,K) = POLL1(KK,J) 
                                           ENDIF 
                                           ENDIF 
               IF(JCE.EQ.1.AND.KODEX(K).EQ.KAN(J)) THEN 
                                           QO2(K) = QO1(J) 
                                           IF(NQUAL.GT.0) THEN 
                                           DO 75 KK    = 1,NQUAL 
   75                                      POLL2(KK,K) = POLL1(KK,J) 
                                           ENDIF 
                                           ENDIF 
   60          CONTINUE 
   55          CONTINUE 
C======================================================================= 
C     Write output file information. 
C======================================================================= 
               IF(NQUAL.EQ.0) WRITE(NEXT) JDAY,TMDAY, 
     +                        DELT,(QO2(I),I=1,NUMX) 
               IF(NQUAL.GT.0) WRITE(NEXT) JDAY,TMDAY, 
     +            DELT,(QO2(I),(POLL2(J,I),J=1,NQUAL),I=1,NUMX) 
               GO TO 50 
  90           WRITE(N6,9000) 
               WRITE(*,9000) 
               RETURN 
               ENDIF 
C======================================================================= 
C     End of ICOMB = 2 option. 
C======================================================================= 
      IF(ICOMB.EQ.4) THEN 
                     CALL COMB2(ICOMB) 
                     WRITE(N6,9000) 
                     WRITE(*,9000) 
                     RETURN 
                     ENDIF 
C======================================================================= 
C     End of ICOMB = 4 option. 
C======================================================================= 
C     COLLATE (ICOMB=0) and COMBINE (ICOMB=1) options are left. 
C     The pollutant names and units are saved from the first 
C     data-set and written on the output data-set. 
C======================================================================= 
C     LOCAT1 = Total number of inlets on first input data set. 
C     LOCAT2 = Total number of inlets on second input data set. 
C     NQ1    = Total number of water quality constituents on 1st data set 
C     NQ2    = Total number of water quality constituents on 2nd data set 
C======================================================================= 
C     Read file headers from file # 2. 
C======================================================================= 
      IF(SECOND.LE.0) CALL ERROR(103) 
      WRITE(N6,9005) 
      CALL INFACE(1,SECOND) 
      LOCAT2   = LOCATS 
      NQ2      = NQUAL 
      DO 210 I = 1,LOCAT2 
C#### WCH, 11/19/93.  FIX FOR ALPHA LABELS. 
      IF(JCE.EQ.0) THEN 
           JUNC2(I) = NLOC(I) 
           ELSE 
           KUNC2(I) = KAN(I) 
           ENDIF 
      IF(NQ2.GT.0) THEN 
                   DO 220 J  = 1,NQ2 
                   PNAM2(J)  = PNAME(J) 
                   PUNIT2(J) = PUNIT(J) 
  220              NDIM2(J)  = NDIM(J) 
                   ENDIF 
  210 CONTINUE 
C======================================================================= 
C     Add the tributary areas together in variable TRIBBA. 
C======================================================================= 
      TRIBBA = 0.0 
      TRIBBA = TRIBBA + TRIBA 
C======================================================================= 
C     Read file headers from file # 1. 
C======================================================================= 
      IF(LAST.LE.0) CALL ERROR(103) 
      WRITE(N6,9010) 
      CALL INFACE(1,LAST) 
      LOCAT1   = LOCATS 
      NQ1      = NQUAL 
      DO 230 I = 1,LOCAT1 
C#### WCH, 11/19/93.  FIX FOR ALPHA LABELS. 
      IF(JCE.EQ.0) THEN 
           JUNC1(I) = NLOC(I) 
           ELSE 
           KUNC1(I) = KAN(I) 
           ENDIF 
      IF(NQ1.GT.0) THEN 
                   DO 240 J  = 1,NQ1 
                   PNAM1(J)  = PNAME(J) 
                   PUNIT1(J) = PUNIT(J) 
  240              NDIM1(J)  = NDIM(J) 
                   ENDIF 
  230 CONTINUE 
      TRIBA  = TRIBBA + TRIBA 
C======================================================================= 
C     Determine the names of the quality constituents on the new 
C     interface file.  The names will be duplicates of the names on 
C     the first input file except for the case in which 
C     NPOS1(KPOLL) equals zero, in which case the names will be copied 
C     from the second input file.   
C======================================================================= 
      IF(NPOLL.GT.0) THEN 
                     DO 470 KPOLL = 1,NPOLL 
                     IF(NPOS1(KPOLL).LE.0) GO TO 460 
                     K1           = NPOS1(KPOLL) 
                     PNAME(KPOLL) = PNAM1(K1) 
                     PUNIT(KPOLL) = PUNIT1(K1) 
                     NDIM(KPOLL)  = NDIM1(K1) 
                     GO TO 470 
  460                K2 = NPOS2(KPOLL) 
C======================================================================= 
C     Error if both NPOS1 and NPOS2 = 0. 
C======================================================================= 
                     IF(K2.LE.0) GO TO 2200 
                     PNAME(KPOLL)   = PNAM2(K2) 
                     PUNIT(KPOLL)   = PUNIT2(K2) 
                     NDIM(KPOLL)    = NDIM2(K2) 
  470                CONTINUE 
                     ENDIF 
C======================================================================= 
C     Read the first line of the two interface files. 
C======================================================================= 
      IF(NQ1.EQ.0) THEN 
                   READ(LAST) JULDAY,TIMDAY,DELT1,(QO1(I),I=1,LOCAT1) 
                   IF(JULDAY.EQ.99999) JULDAY = 9999999 
                   JYEAR = JULDAY/1000 
				 IF (JYEAR.LT.100) THEN 
                   JULDAY = JULDAY - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JULDAY = JULDAY + JYEAR*1000 
                   ENDIF 
                   ELSE 
                   READ(LAST) JULDAY,TIMDAY,DELT1, 
     +                        (QO1(I),(POLL1(J,I),J=1,NQ1),I=1,LOCAT1) 
                   IF(JULDAY.EQ.99999) JULDAY = 9999999 
                   JYEAR = JULDAY/1000 
                   IF (JYEAR.LT.100) THEN 
                   JULDAY = JULDAY - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JULDAY = JULDAY + JYEAR*1000 
                   ENDIF 
                   JDAY3   = JULDAY 
                   if(timday.gt.86400.0) timday = 0.0 
	             TIMDAY3 = TIMDAY 
                   ENDIF 
      IF(NQ2.EQ.0) THEN 
                   READ(SECOND) JDAY2,TMDAY2,DELT2,(QO2(I),I=1,LOCAT2) 
                   IF(JDAY.EQ.99999) JDAY = 9999999 
                   JYEAR = JDAY2/1000 
                   IF (JYEAR.LT.100) THEN 
                   JDAY2 = JDAY2 - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JDAY2 = JDAY2 + JYEAR*1000 
                   ENDIF 
                   ELSE 
                   READ(SECOND) JDAY2,TMDAY2,DELT2, 
     +                          (QO2(I),(POLL2(J,I),J=1,NQ2),I=1,LOCAT2) 
                   IF(JDAY2.EQ.99999) JDAY2 = 9999999 
                   JYEAR = JDAY2/1000 
                   IF (JYEAR.LT.100) THEN 
                   JDAY2 = JDAY2 - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JDAY2 = JDAY2 + JYEAR*1000 
                   ENDIF 
                   if(tmday2.gt.86400.0) tmday2 = 0.0 
	             JDAY4   = JDAY2 
	             TIMDAY4 = TMDAY2 
                   ENDIF 
C======================================================================= 
C     Determine TZERO and IDATEZ for the new interface file. 
C======================================================================= 
      CALL NTIME(JDAY2,TMDAY2,DIFF) 
    make this double precision - 6/5/2003 
      IF(DIFF.GE.0.0) THEN 
                      TZERO  = TIMDAY 
                      FIRST  = 1 
                      IDATEZ = JULDAY 
                      ENDIF 
      IF(DIFF.LT.0.0) THEN 
                      TZERO  = TMDAY2 
                      FIRST  = 2 
                      IDATEZ = JDAY2 
                      ENDIF 
C======================================================================= 
C     If ICOMB equals 0 and the collate option is requested, it is 
C     necessary to interleave the file locations from input files 
C     one and two.  If the two files include identical location 
C     numbers in their inlet arrays, the flow and quality constituent 
C     values (loads = flow x concentration) will be added together for  
C     those locations.  If the inlet number appears in only one file,  
C     the flow and quality constituent values will be transfered  
C     intact to the new interface file. 
C======================================================================= 
C    The new interface file's location numbers will be arranged in the 
C    following order:  First --> locations (inlets) in both input files 
C                      Second -> locations in file one not  
C                                already transfered 
C                      Third --> locations in file two not 
C                                already transfered 
C======================================================================== 
C     NPOSIT    = INLET position on the new interface file. 
C     INPOS1    = INLET position on input file 1 corresponding 
C                 to NPOSIT position on the new interface file. 
C     INPOS2    = INLET position on input file 2 corresponding 
C                 to NPOSIT position on the new interface file. 
C     JUNC1     = INLET array from input file 1. 
C     JUNC2     = INLET array from input file 2. 
C     NLOC      = INLET array for the new interface file. 
C     LOCATS    = Number of inlets on both files 1 and 2. 
C======================================================================= 
C     Find the INLET locations that are on both interface files. 
C======================================================================= 
      NPOSIT         = 0 
      DO 575 I       = 1,LOCAT1 
      DO 550 N       = 1,LOCAT2 
C#### WCH, 11/19/93 
      IF(JCE.EQ.0.AND.JUNC1(I).NE.JUNC2(N)) GO TO 550 
      IF(JCE.EQ.1.AND.KUNC1(I).NE.KUNC2(N)) GO TO 550 
      NPOSIT         = NPOSIT + 1 
      INPOS1(NPOSIT) = I 
      INPOS2(NPOSIT) = N 
C#### WCH, 11/19/93 
      IF(JCE.EQ.0) NLOC(NPOSIT)   = JUNC1(I) 
      IF(JCE.EQ.1) KAN(NPOSIT)    = KUNC1(I) 
      GO TO 575 
  550 CONTINUE 
  575 CONTINUE 
C======================================================================= 
C     Find the INLET locations that are only on interface file # 1. 
C======================================================================= 
      LOCATS         = NPOSIT 
      DO 625  I      = 1,LOCAT1 
      DO 600  N      = 1,LOCATS 
C#### WCH, 11/19/93 
      IF(JCE.EQ.0.AND.NLOC(N).EQ.JUNC1(I)) GO TO 625 
      IF(JCE.EQ.1.AND.KAN(N).EQ.KUNC1(I))  GO TO 625 
  600 CONTINUE 
      NPOSIT         = NPOSIT + 1 
C#### WCH, 11/19/93 
      IF(JCE.EQ.0) NLOC(NPOSIT) = JUNC1(I) 
      IF(JCE.EQ.1) KAN(NPOSIT)  = KUNC1(I) 
      INPOS1(NPOSIT) = I 
      INPOS2(NPOSIT) = 0 
  625 CONTINUE 
C======================================================================= 
C     Find the INLET locations that are only on interface file # 2. 
C======================================================================= 
      LOCATS         = NPOSIT 
      DO 675 I       = 1,LOCAT2 
      DO 650 N       = 1,LOCATS 
C#### WCH, 11/19/93 
      IF(JCE.EQ.0.AND.NLOC(N).EQ.JUNC2(I)) GO TO 675 
      IF(JCE.EQ.1.AND.KAN(N).EQ.KUNC2(I))  GO TO 675 
  650 CONTINUE 
      NPOSIT         = NPOSIT + 1 
C#### WCH, 11/19/93 
      IF(JCE.EQ.0) NLOC(NPOSIT) = JUNC2(I) 
      IF(JCE.EQ.1) KAN(NPOSIT)  = KUNC2(I) 
      INPOS1(NPOSIT) = 0 
      INPOS2(NPOSIT) = I 
  675 CONTINUE 
      LOCATS         = NPOSIT 
C======================================================================= 
C     Now create another tester array - JCOMB(200) 
C         If JCOMB = 1 then both files one and two have an inlet 
C                      corresponding to NPOSIT on the new interface file 
C         If JCOMB = 2 then only the first file has an inlet 
C                      corresponding to NPOSIT on the new interface file 
C         If JCOMB = 3 then only the second file has an inlet 
C                      corresponding to NPOSIT on the new interface file 
C======================================================================= 
      DO 700 NPOSIT = 1,LOCATS 
      IF(INPOS1(NPOSIT).GT.0.AND.INPOS2(NPOSIT).GT.0) JCOMB(NPOSIT) = 1 
      IF(INPOS1(NPOSIT).GT.0.AND.INPOS2(NPOSIT).LE.0) JCOMB(NPOSIT) = 2 
      IF(INPOS1(NPOSIT).LE.0.AND.INPOS2(NPOSIT).GT.0) JCOMB(NPOSIT) = 3 
  700 CONTINUE 
C======================================================================= 
C     The next statements (and the later summation) are essentially 
C     the only difference between the Combine option and the Collate 
C     option.  The Combine and Collate options have the same input 
C     requirements except that for Combine, the sumation sequence 
C     sums all the flows and loads from all input locations (inlets) 
C     and outputs these summations at location NODEOT. 
C======================================================================= 
      IF(ICOMB.EQ.1) THEN 
                     KPOSIT  = 1 
C======================================================================= 
C     Offer a default output location ID. 
C======================================================================= 
                     IF(NODEOT.LE.0)   NODEOT =  12345 
                     IF(KODEOT.EQ.' ') KODEOT = '12345' 
                     IF(JCE.EQ.0) NLOC(1) = NODEOT 
                     IF(JCE.EQ.1)  KAN(1) = KODEOT 
                     LOCATS  = 1 
                     ENDIF 
C======================================================================= 
C     Write the header information on the new interface file. 
C======================================================================= 
      IF(NEXT.GT.0) THEN 
                    REWIND NEXT 
                    WRITE(NEXT) LOCATS,NPOLL 
                    IF(JCE.EQ.0) WRITE(NEXT) (NLOC(I),I=1,LOCATS) 
                    IF(JCE.EQ.1) WRITE(NEXT)  (KAN(I),I=1,LOCATS) 
                    SOURCE = 'COMBINE BLOCK' 
                    WRITE(N6,9015) 
                    CALL INFACE(2,NEXT) 
                    CALL INFACE(1,NEXT) 
                    ENDIF 
C======================================================================= 
C     DO-loop for reading all input data. 
C======================================================================= 
      XTIM1      = 0.0 
      XTIM2      = 0.0 
      DELT1      = 0.0 
      DELT2      = 0.0 
	OK1        = .FALSE. 
      OK2        = .FALSE. 
C##### WCH, 5/28/93.  CHANGE DABS TO ABS 
      DIFF       = ABS(DIFF) 
      ILAG       = 1 
      J1LAG      = 0 
      J2LAG      = 0 
      IF(FIRST.EQ.1)  OK1 = .TRUE. 
      IF(FIRST.EQ.2)  OK2 = .TRUE. 
      IF(DIFF.EQ.0.0) OK2 = .TRUE. 
C======================================================================= 
C     Initialize arrays CPOLL and QQO for each time step. 
cred  allow for more time steps in the interface file  
cred  this used to be 1000000 - 5/6/01 
C======================================================================= 
      DO 999 KDT = 1,10000000 
      DO 750   K = 1,LOCATS 
      DO 740   L = 1,NPOLL 
  740 CPOLL(L,K) = 0.0 
  750 QQO(K)     = 0.0 
C======================================================================= 
C     Read the two input files. 
C======================================================================= 
      IF(FIRST.EQ.2.AND.XTIM2.GE.DIFF) OK1 = .TRUE. 
      IF(FIRST.EQ.1.AND.XTIM1.GE.DIFF) OK2 = .TRUE. 
C======================================================================= 
      IF(JULDAY.NE.9999999.AND.OK1) THEN 
      IF(ILAG.NE.2) THEN 
                   IF(NQ1.EQ.0) READ(LAST,END=1000) JULDAY,TIMDAY,DELT1, 
     +                                 (QO1(I),I=1,LOCAT1) 
                   IF(NQ1.GT.0) READ(LAST,END=1000) JULDAY,TIMDAY,DELT1, 
     +                         (QO1(I),(POLL1(J,I),J=1,NQ1),I=1,LOCAT1) 
                   if(julday.lt.jday3) julday = jday3 
				 if(jday3.eq.0) jday3 = julday 
	             if(timday.gt.86400.0) timday = 0.0 
                   IF(delt1.le.0.0) delt1 = timday - timday3 
	             timday = timday3 + delt1 
	             if(timday.gt.86400.0) then 
				    timday = timday3 + delt1 - 86400.0 
	                if(julday.eq.jday3)  julday  = julday  + 1 
	                else 
	                if(julday.gt.jday3) julday = jday3 
	                endif 
				 timday = anint(timday) 
				 jday3   = julday 
                   timday3 = timday 
                   IF(JULDAY.EQ.99999) JULDAY = 9999999 
                   JYEAR = JULDAY/1000 
                   IF (JYEAR.LT.100) THEN 
                   JULDAY = JULDAY - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JULDAY = JULDAY + JYEAR*1000 
                   ENDIF 
                   ELSE 
                   DO 744 I   = 1,LOCAT1 
                   QO1(I)     = QO3(I) 
                   DO 743 J   = 1,NQ1 
                   POLL1(J,I) = POLL3(J,I) 
  743              CONTINUE 
  744              CONTINUE 
                   ENDIF 
      DELT = DELT1 
      ENDIF 
C======================================================================= 
      IF(JDAY2.NE.9999999.AND.OK2) THEN 
      IF(ILAG.NE.3) THEN 
                   IF(NQ2.EQ.0) READ(SECOND,END=1010) JDAY2,TMDAY2, 
     +                                    DELT2,(QO2(I),I=1,LOCAT2) 
                   IF(NQ2.GT.0) READ(SECOND,END=1010) JDAY2,TMDAY2, 
     +               DELT2,(QO2(I),(POLL2(J,I),J=1,NQ2),I=1,LOCAT2) 
                   if(jday2.lt.jday4) jday2 = jday4 
	             if(tmday2.gt.86400.0) tmday2 = 0.0 
                   IF(delt2.le.0.0) delt2 = tmday2 - timday4 
	             tmday2 = timday4 + delt2 
                   if(jday4.eq.0) jday4 = jday2 
				 if(tmday2.gt.86400.0) then 
				    tmday2 = timday4 + delt2 - 86400.0 
	                if(jday2.eq.jday4) jday2 = jday2 + 1 
	                else 
	                if(jday2.gt.jday4) jday2 = jday4 
	                endif 
				 tmday2 = anint(tmday2)  
	             jday4  = jday2 
                   IF(JDAY2.EQ.99999) JDAY2 = 9999999 
                   timday4 = tmday2 
				 JYEAR = JDAY2/1000 
                   IF (JYEAR.LT.100) THEN 
                   JDAY2 = JDAY2 - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JDAY2 = JDAY2 + JYEAR*1000 
                   ENDIF 
                   ELSE 
                   DO 746 I   = 1,LOCAT2 
                   QO2(I)     = QO3(I) 
                   DO 745 J   = 1,NQ2 
                   POLL2(J,I) = POLL3(J,I) 
  745              CONTINUE 
  746              CONTINUE 
                   ENDIF 
      DELT = DELT2 
      ENDIF 
C======================================================================= 
C     The end of both input files has been found.  Branch to 1020. 
C======================================================================= 
      IF(JULDAY.EQ.9999999.AND.JDAY2.EQ.9999999) GO TO 1020 
C======================================================================= 
C     Calculate the time difference in seconds between two data sets. 
C======================================================================= 
      CALL NTIME(JDAY2,TMDAY2,DIFF) 
    make this double precision - 6/5/2003 
C======================================================================= 
C                      Calculate the variable ILAG. 
C 
C     ILAG = 1 ==> The difference in time between files 2 & 1 = 0. 
C                  No changes from the original COMBINE code. 
C     ILAG = 2 ==> The difference in time between files 2 & 1 is < 0. 
C                  This means that file 2's time is before file 1's 
C                  time.  File 1's values for flow and pollutants will 
C                  be set to zero.  File 1's values will be temporarily 
C                  stored in QO3 and POLL3. 
C     ILAG = 3 ==> The difference in time between FILE 2 & 1 is > 0. 
C                  This means that File 1's time is before file 2's 
C                  time.  File 2's values for flow and pollutants will 
C                  be set to zero.  File 2's values will be temporarily 
C                  stored in QO3 and POLL3. 
C 
C======================================================================= 
      IF(DIFF.EQ.0.0) THEN 
                      ILAG        = 1 
                      J1LAG       = 0 
                      J2LAG       = 0 
                      DO 7400 I   = 1,LOCAT1 
                      QOLD1(I)    = QO1(I) 
                      DO 7410 J   = 1,NQ1 
7410                  POLD1(J,I)  = POLL1(J,I) 
7400                  CONTINUE 
                      DO 7420 I   = 1,LOCAT2 
                      QOLD2(I)    = QO2(I) 
                      DO 7430 J   = 1,NQ2 
7430                  POLD2(J,I)  = POLL2(J,I) 
7420                  CONTINUE 
                      XTIM1      = XTIM1 + DELT 
                      XTIM2      = XTIM2 + DELT 
                      ENDIF 
      IF(DIFF.LT.0.0) THEN 
           ILAG       = 2 
           J2LAG      = 0 
           J1LAG      = J1LAG + 1 
C##### WCH, 5/28/93.  CHANGE DABS TO ABS 
           TDIFF      = ABS(DIFF) 
           IF(J1LAG.EQ.1) TDIF1(I) = TDIFF + DELT2 
cred       add an error check for division by zero - 2/12/2003 
           if(TDIF1(I).ne.0.0) then 
		    slope      = (TDIF1(I)-TDIFF)/TDIF1(I) 
	        else 
	        slope      =  0.0 
	        endif 
cred       SLOPE      = (TDIF1(I)-TDIFF)/TDIF1(I) 
           DO 748 I   = 1,LOCAT1 
           QO3(I)     = QO1(I) 
           QO1(I)     = (QO1(I)-QOLD1(I))*SLOPE + QOLD1(I) 
           IF(QO1(I).LT.0.0) QO1(I) = 0.0 
           DO 747 J   = 1,NQ1 
           POLL3(J,I) = POLL1(J,I) 
           POLL1(J,I) = (POLL1(J,I)-POLD1(J,I))*SLOPE + POLD1(J,I) 
           IF(POLL1(J,I).LT.0.0) POLL1(J,I) = 0.0 
  747      CONTINUE 
  748      CONTINUE 
cred       update the values of Qold2 and POLD2 - 5/6/01 
cred       this should have been updated for Diff > 0 as well as 
cred       diff = 0; from Mitch Heinemann and Mark Yeboah of CDM 
           DO I             = 1,LOCAT2 
              QOLD2(I)      = QO2(I) 
              DO J          = 1,NQ2 
                 POLD2(J,I) = POLL2(J,I) 
	           enddo 
              enddo 
		 if(DELT2.LT.DELT1) DELT1 = DELT1 - DELT2 
           DELT       = DELT2 
           if(XTIM1.le.xtim2) XTIM1  = XTIM1 + DELT1 
                              XTIM2  = XTIM2 + DELT2 
           ENDIF 
      IF(DIFF.GT.0.0) THEN 
           ILAG       = 3 
           J1LAG      = 0 
           J2LAG      = J2LAG + 1 
           IF(J2LAG.EQ.1) TDIF2(I) = DIFF + DELT1 
cred       add an error check for division by zero - 2/12/2003 
           if(TDIF2(I).ne.0.0) then 
		    slope      = (TDIF2(I)-DIFF)/TDIF2(I) 
	        else 
	        slope      =  0.0 
	        endif 
           DO 751 I   = 1,LOCAT2 
           QO3(I)     = QO2(I) 
           QO2(I)     = (QO2(I)-QOLD2(I))*SLOPE + QOLD2(I) 
           IF(QO2(I).LT.0.0) QO2(I) = 0.0 
	     if(nq2.gt.0) then 
           DO 749 J   = 1,NQ2 
           POLL3(J,I) = POLL2(J,I) 
           POLL2(J,I) = (POLL2(J,I)-POLD2(J,I))*SLOPE + POLD2(J,I) 
           IF(POLL2(J,I).LT.0.0) POLL2(J,I) = 0.0 
  749      CONTINUE 
           endif 
  751      CONTINUE 
cred       update the values of Qold1 and POLD1 - 5/6/01 
cred       this should have been updated for Diff > 0 as well as 
cred       diff = 0; from Mitch Heinemann and Mark Yeboah of CDM 
           DO I             = 1,LOCAT1 
              QOLD1(I)      = QO1(I) 
              DO J          = 1,NQ1 
                 POLD1(J,I) = POLL1(J,I) 
	           enddo 
              enddo 
		 if(DELT1.Lt.DELT2) DELT2  = DELT2 - DELT1 
           DELT       = DELT1 
           XTIM1      = XTIM1 + DELT1 
           if(XTIM2.le.xtim1) XTIM2  = XTIM2 + DELT2 
           ENDIF 
C======================================================================= 
C     Combine all the input locations into one output location. 
C======================================================================= 
      IF(ICOMB.EQ.1) THEN 
                     DO 940 KK1  = 1,LOCAT1 
                     QQO(KPOSIT) = QQO(KPOSIT) + QO1(KK1) 
                     IF(NPOLL.GT.0) THEN 
                              DO 945  MM       = 1,NPOLL 
                              K1               = NPOS1( MM ) 
  945                         CPOLL(MM,KPOSIT) = CPOLL(MM,KPOSIT) 
     +                                            + POLL1(K1,KK1) 
                              ENDIF 
  940                CONTINUE 
                     DO 950 KK2  = 1,LOCAT2 
                     QQO(KPOSIT) = QQO(KPOSIT) + QO2(KK2) 
                     IF(NPOLL.GT.0) THEN 
                              DO 955  MM       = 1,NPOLL 
                              K2               = NPOS2( MM ) 
  955                         CPOLL(MM,KPOSIT) = CPOLL(MM,KPOSIT) 
     +                                            + POLL2(K2,KK2) 
                              ENDIF 
  950                CONTINUE 
                     ENDIF 
C======================================================================= 
C     Collate (interleave) all the input locations together. 
C======================================================================= 
      IF(ICOMB.EQ.0) THEN 
                     DO 960 NPOSIT = 1,LOCATS 
                     KK1         = INPOS1(NPOSIT) 
                     KK2         = INPOS2(NPOSIT) 
                     IF(JCOMB(NPOSIT).EQ.1) QQO(NPOSIT) = 
     +                               QQO(NPOSIT) + QO1(KK1) + QO2(KK2) 
                     IF(JCOMB(NPOSIT).EQ.2) QQO(NPOSIT) = 
     +                                          QQO(NPOSIT) + QO1(KK1) 
                     IF(JCOMB(NPOSIT).EQ.3) QQO(NPOSIT) = 
     +                                          QQO(NPOSIT) + QO2(KK2) 
                     IF(NPOLL.GT.0) THEN 
                        DO 920 MM        = 1,NPOLL 
                        K1               = NPOS1( MM ) 
                        K2               = NPOS2( MM ) 
                        IF(JCOMB(NPOSIT).EQ.1) CPOLL(MM,NPOSIT) = 
     +                  CPOLL(MM,NPOSIT) + POLL1(K1,KK1) + POLL2(K2,KK2) 
                        IF(JCOMB(NPOSIT).EQ.2) CPOLL(MM,NPOSIT) = 
     +                                  CPOLL(MM,NPOSIT) + POLL1(K1,KK1) 
                        IF(JCOMB(NPOSIT).EQ.3) CPOLL(MM,NPOSIT) = 
     +                                  CPOLL(MM,NPOSIT) + POLL2(K2,KK2) 
  920                   CONTINUE 
                        ENDIF 
  960                   CONTINUE 
                     ENDIF 
C======================================================================= 
C     Write the actual interface data line. 
C======================================================================= 
  990 IF(NPOLL.EQ.0) WRITE(NEXT) JULDAY,TIMDAY,DELT,(QQO(K),K=1,LOCATS) 
      IF(NPOLL.GT.0) THEN 
      IF(ILAG.EQ.2)  THEN 
                     WRITE(NEXT) JDAY2,TMDAY2,DELT2,(QQO(K), 
     +                      (CPOLL(M,K),M=1,NPOLL),K=1,LOCATS) 
                     ELSE 
                     WRITE(NEXT) JULDAY,TIMDAY,DELT1,(QQO(K), 
     +                      (CPOLL(M,K),M=1,NPOLL),K=1,LOCATS) 
                     ENDIF 
                     ENDIF 
      GO TO 999 
C======================================================================= 
C     End of the first file is reached. 
C======================================================================= 
 1000 CONTINUE 
      JULDAY    = 9999999 
      TIMDAY    =   0.0 
      DO 1050 I = 1,LOCAT1 
      QO1(I)    = 0.0 
      QOLD1(I)  = 0.0 
      IF(NQ1.GT.0) THEN 
                   DO 1060 J  = 1,NQ1 
                   POLL1(J,I) = 0.0 
 1060              POLD1(J,I) = 0.0 
                   ENDIF 
 1050 CONTINUE 
      GO TO 999 
C======================================================================= 
C     End of the second file is reached. 
C======================================================================= 
 1010 CONTINUE 
      JDAY2     = 9999999 
      TMDAY2    =   0.0 
      DO 1100 I = 1,LOCAT2 
      QO2(I)    = 0.0 
      QOLD2(I)  = 0.0 
      IF(NQ2.GT.0) THEN 
                   DO 1110 J  = 1,NQ2 
                   POLL2(J,I) = 0.0 
 1110              POLD2(J,I) = 0.0 
                   ENDIF 
 1100 CONTINUE 
  999 CONTINUE 
 1020 CONTINUE 
      WRITE(N6,9000) 
      WRITE(*,9000) 
      RETURN 
C#### WCH, 11/22/93 
 2200 WRITE(N6,2210) KPOLL 
      STOP 
C#### WCH, 8/2/93.  ADD ADDITIONAL ERROR MESSAGE. 
  887 WRITE (*,9500) CC 
      WRITE(N6,9500) CC 
  888 CALL IERROR 
C======================================================================= 
  10  FORMAT(/, 
     +' ################################################',/, 
     +' # Entry made to Combine Block. Last updated at #',/, 
     +' # CDM, July 2001.                              #',/, 
     +' ################################################',/) 
C#### WCH, 7/25/96.  CHANGE FORMAT 71 SLIGHTLY 
  71  FORMAT(/,' ICOMB...................................',I5,/, 
     +         ' = 0 ==> Collate option',/, 
     +         '   1 ==> Combine option',/, 
     +         '   2 ==> Extract option',/, 
     +         '   3 ==> File reader option',/, 
     +         '   4 ==> ASCII file creation',/, 
     +         '   5 ==> Interface file summation option',/, 
     +         '   6 ==> Rain Block interface file summation option',/, 
     +         '   7 ==> Rain Block interface file summation and ASCII f 
     +ile creation on JOUT',/) 
  410 FORMAT(/,' Output node number is............',I10,//, 
     1         ' Output data-set unit number is...',I10,//, 
     2         ' Number of quality constituents...',I10,/) 
  411 FORMAT(/,' Output node name is..............',A10,//, 
     1         ' Output data-set unit number is...',I10,//, 
     2         ' Number of quality constituents...',I10,/) 
C#### WCH, 11/23/93 
  415 FORMAT(' Output ASCII file will give loads (flow x concentration)  
     1for pollutant units.') 
  416 FORMAT(' Output ASCII file will give concentrations for pollutant  
     1units (NPOLL < 0).') 
  420 FORMAT(/,' Water quality constituent........',I3,/, 
     +         ' Position on input file one.......',I3,/, 
     +         ' Position on input file two.......',I3) 
  430 FORMAT(/,' Locations to be extracted (NUMX).',I3,//, 
     +         ' Locations to be renumbered (NUMR)',I3) 
  440 FORMAT(/, 
     +' #########################################',/, 
     +' # The following nodes will be extracted #',/, 
     +' #     from the input file(s).           #',/, 
     +' #########################################',/) 
  445 FORMAT(/, 
     +' ##################################################',/, 
     +' # The following numbers are the new node numbers #',/, 
     +' # assigned to the extracted/renumbered nodes.    #',/, 
     +' ##################################################',/) 
  450 FORMAT(1X,10I10) 
  451 FORMAT(1X,10A10) 
  455 FORMAT(///,' Ending time in seconds for file 1 --->',F15.2, 
     +        /, ' Ending time in seconds for file 2 --->',F15.2) 
  660 FORMAT(1H1,4X,A80,/,5X,A80) 
C#### WCH, 11/22/93 
 2210 FORMAT(//,' Error NPOS1 and NPOS2 (data group B3) are both zero f 
     +or pollutant number',I2,/,' At least one must be non-zero.  Run st 
     +opped from the Combine Block.') 
 9000 FORMAT(/,' ===> Combine Block ended normally.') 
 9005 FORMAT(/, 
     +' **************************************************',/, 
     +' *  Reading information from the NSCRAT(1) file.  *',/, 
     +' **************************************************') 
 9010 FORMAT(/, 
     +' ********************************************',/, 
     +' *  Reading information from the JIN file.  *',/, 
     +' ********************************************') 
 9015 FORMAT(/, 
     +' *******************************************',/, 
     +' *  Writing information on the JOUT file.  *',/, 
     +' *******************************************') 
C#### WCH, 8/2/93. 
 9500 FORMAT (/' $$$ YOU ARE ABOUT TO RECEIVE AN ERROR MESSAGE WHILE TRY 
     1ING TO READ LINE ',A2,/,'    IT IS POSSIBLE THIS IS CAUSED BY NOT  
     2USING ALPHANUMERIC VALUES (ENCLOSED',/,'     IN QUOTES) WHEN' 
     3 ,' NODE NUMBERS ARE REQUESTED AS INPUT.  FOR EXAMPLE,'/ 
     4'     A ZERO INPUT FOR ALPHANUMERIC IS JUST TWO QUOTES',4H ''.) 
      END 
 
 
REM File: DATED.FOR 
 
      SUBROUTINE DATED 
C####################################################################### 
C     FIND THE YEAR, MONTH, DAY, HOUR, MINUTE AND SECOND CORRESPONDING 
C     TO THE EXISTING JULDAY AND TIMDAY 
C 
C     JULDAY = JULIAN DAY 
C     TIMDAY = TIME OF DAY IN SECONDS 
C     CORRECTION BY WCH, 4/93 TO FIX CONVERSION FROM TIMDAY IN  
C       SECONDS TO HR/MIN/SEC. 
C####################################################################### 
      INCLUDE 'STIMER.INC' 
C======================================================================= 
      NYEAR = JULDAY/1000 
      JEWEL = JULDAY - 1000*NYEAR 
      IF (NYEAR.LT.100) THEN 
           NYEAR  = NYEAR + 1900 
           JULDAY = JEWEL + NYEAR*1000 
           ENDIF 
      IFEB  = 28 
      IF((NYEAR/4)*4-NYEAR.EQ.0) IFEB = 29 
      IF(JEWEL.LE.31)      THEN 
                           MONTH = 1 
                           NDAY  = JEWEL 
                           GO TO 100 
                           ENDIF 
      IF(JEWEL.LE.31+IFEB) THEN 
                           MONTH = 2 
                           NDAY  = JEWEL - 31 
                           GO TO 100 
                           ENDIF 
      IF(JEWEL.LE.62+IFEB) THEN 
                           MONTH = 3 
                           NDAY  = JEWEL - 31 - IFEB 
                           GO TO 100 
                           ENDIF 
      IF(JEWEL.LE.92+IFEB) THEN 
                           MONTH = 4 
                           NDAY  = JEWEL - 62 - IFEB 
                           GO TO 100 
                           ENDIF 
      IF(JEWEL.LE.123+IFEB) THEN 
                            MONTH = 5 
                            NDAY  = JEWEL - 92 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.153+IFEB) THEN 
                            MONTH = 6 
                            NDAY  = JEWEL - 123 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.184+IFEB) THEN 
                            MONTH = 7 
                            NDAY  = JEWEL - 153 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.215+IFEB) THEN 
                            MONTH = 8 
                            NDAY  = JEWEL - 184 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.245+IFEB) THEN 
                            MONTH = 9 
                            NDAY  = JEWEL - 215 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.276+IFEB) THEN 
                            MONTH = 10 
                            NDAY  = JEWEL - 245 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.306+IFEB) THEN 
                            MONTH = 11 
                            NDAY  = JEWEL - 276 - IFEB 
                            GO TO 100 
                            ENDIF 
      IF(JEWEL.LE.337+IFEB) THEN 
                            MONTH = 12 
                            NDAY  = JEWEL - 306 - IFEB 
                            ENDIF 
C#### WCH, 4/20/93. CHANGE FRACTION ADDED TO 0.0001 HR.  MUST BE < 1 SEC. 
  100 JHR     = IFIX(TIMDAY/3600.0 + 0.0001) 
      JSEC    = IFIX(TIMDAY - FLOAT(JHR)*3600.0 + 0.01) 
      MINUTE  = JSEC / 60 
      JSEC    = JSEC - 60*MINUTE 
      RETURN 
      END 
 
 
REM File: DEPTH.FOR 
 
      FUNCTION DEPTH(ALPHA) 
C	TRANSPORT BLOCK 
C 
C======================================================================= 
C     COMPUTES NORMALIZED DEPTH IN CONDUIT GIVEN 
C     NORMALIZED AREA, ALPHA.   LAST UPDATED BY RED IN NOVEMBER, 1988. 
C     RED, 12/31/93.  CHECK FOR RANGE OF SUBSCRIPT. 
C     WCH, 12/5/94.  CHECK FOR RANGE OF SUBSCRIPT FOR MOD. BASKET HAND. 
C     CIM, 9/8/00.  Add option for detailed calculation of irregular 
C                   sections. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEW81.INC' 
      INCLUDE 'FLODAT.INC' 
C#### CIM 9/8/00  Add NEWTR common block 
      INCLUDE 'NEWTR.INC' 
      DIMENSION QI(NET),QO(NET) 
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2)) 
C======================================================================= 
C     KDEPTH(NTPE) = 1 FOR CONDUIT WITH A FUNCTIONAL D-A RELATIONSHIP. 
C     KDEPTH(NTPE) = 2 FOR CONDUIT WITH A TABULAR D-A RELATIONSHIP. 
C     KDEPTH(NTPE) = 3 FOR ELEMENT OTHER THAN CONDUIT. 
C======================================================================= 
      NTPE = NTYPE(M) 
C======================================================================= 
C     IN RECTANGULAR CONDUIT, NORMALIZED DEPTH EQUALS NORMALIZED AREA. 
C======================================================================= 
      IF(NTPE.EQ.2.OR.ALPHA.EQ.0.0) THEN 
                                  DEPTH = ALPHA 
                                  RETURN 
                                  ENDIF 
C======================================================================= 
C     ROUTINE FOR TABULAR D-A CURVE. 
C     LINEAR  INTERPOLATION BETWEEN TABULAR POINTS IS USED. 
C======================================================================= 
      IF(KDEPTH(NTPE).EQ.2) THEN 
C======================================================================= 
C     PARABOLIC, POWER FUNCTION OR NATURAL CHANNELS 
C     Note that NTPE = 16 for all three channel types.  
C======================================================================= 
           IF(NTPE.EQ.16) THEN 
                   I     = 1 + IFIX(ALPHA/0.04) 
                   IF(I.GT.25) I = 25 
C#### RED (WCH), 12/31/93.  ADD ANOTHER CHECK FOR VALUE OF I. 
                   IF(I.LE.0)  I = 1 
CIM###  9/8/00  CIMDETAIL   add if here 
             IF(IDETAIL.EQ.0.OR.I.GE.2) THEN 
                   DELTA = (ALPHA - 0.04*FLOAT(I-1))/0.04 
                   M1    = NQC(M) 
                   DEPTH = (QCURVE(M1,2,I) + 
     +                    (QCURVE(M1,2,I+1)-QCURVE(M1,2,I))*DELTA) 
CIM###  9/8/00  CIMDETAIL   here is code for detailed section 
             ELSE     HERE IDETAIL = 1 and I LT 2 
                   I  =  1 + IFIX(ALPHA/0.0016) 
                   IF (I.LE.0) I = 1 
                   DELTA = (ALPHA - 0.0016*FLOAT(I-1))/0.0016 
                   M1    = NQC(M) 
                   DEPTH = (QCURV2(M1,2,I) + 
     +                    (QCURV2(M1,2,I+1)-QCURV2(M1,2,I))*DELTA) 
cim      WRITE(N6,*) 'DEPTH2',M,M1,ALPHA,I,DELTA,DEPTH,QCURV2(M1,2,I), 
cim     +QCURV2(M1,2,I+1) 
             ENDIF 
CIM###  9/8/00 end of change 
                   RETURN 
                   ENDIF 
C======================================================================= 
C     NON-CIRCULAR CONDUITS OR CIRCULAR CONDUITS WITH LARGE DEPTHS 
C======================================================================= 
           IF(NTPE.NE.1.OR.ALPHA.GE.0.04) THEN 
                          DALPHA = 1.0 / (FLOAT(NN(NTPE)) - 1.0) 
                          I      = IFIX(ALPHA/DALPHA) + 1 
                          IF(I.GE.NN(NTPE)) THEN 
                              DEPTH = DNORM(NTPE,I) 
                              ELSE 
                          DEPTH = DNORM(NTPE,I)+(ALPHA - ANORM(NTPE,I))/ 
     +                            DALPHA*(DNORM(NTPE,I+1)-DNORM(NTPE,I)) 
                              ENDIF 
C======================================================================= 
C                        IMPROVE ESTIMATE WITH PARABOLIC INTERPOLATION 
*                                FOR NON-CIRCULAR CONDUITS. 
C======================================================================= 
                         IF(ALPHA.LT.0.04) DEPTH = DEPTH + (ALPHA - 
     +                  ANORM(NTPE,I)) * (DNORM(NTPE,I) - 2.0 * 
     +                  DNORM(NTPE,I+1)+DNORM(NTPE,I+2))/(2.0*DALPHA**2) 
                         RETURN 
                         ENDIF 
C======================================================================= 
C     SPECIAL ROUTINE FOR HIGH ACCURACY AT LOW FLOWS. 
C======================================================================= 
           ALF = ALPHA 
           CALL CIRCLE(ALF,PS,DN,2) 
                        DEPTH = DN 
           IF(NTPE.EQ.12) DEPTH = DEPTH*2.0*GEOM3(M)/(P2(M)*DIST(M)) 
           RETURN 
           ENDIF 
C======================================================================= 
C     END OF TABULAR COMPUTATIONS. 
C     BEGIN FUNCTIONAL-FORM COMPUTATIONS (KEPTH = 1). 
C======================================================================= 
C     FUNCTIONAL FORM FOR MODIFIED BASKET-HANDLE. 
C======================================================================= 
      IF (NTPE.EQ.10) THEN 
                    AA = ALPHA*AFULL(M) 
                    IF(AA.LE.GEOM3(M)) THEN 
                          DEPTH = AA/GEOM2(M)/(GEOM1(M)+GEOM2(M)/2.0) 
                          RETURN 
                          ENDIF 
                    ALF   = (AA-GEOM3(M)+P5(M)/2.0)/P5(M) 
                    I     = IFIX(ALF/0.02) + 1 
C#### WCH, 12/5/94.  CHECK FOR POSSIBLE I GT 51.  CHANGE EQ TO GE. 
                    IF(I.GE.51) THEN 
                            DD = DNORM(1,I) 
                            ELSE 
                            DD    = DNORM(1,I)+(ALF-ANORM(1,I))/0.02 * 
     +                              (DNORM(1,I+1)-DNORM(1,I)) 
                            DEPTH = ((DD-0.5)*GEOM2(M)+GEOM1(M))/ 
     +                              (GEOM1(M) + GEOM2(M)/2.0) 
                            ENDIF 
                    RETURN 
                    ENDIF 
C======================================================================= 
C     FUNCTIONAL FORM FOR RECTANGULAR, TRIANGULAR BOTTOM. 
C======================================================================= 
      IF (NTPE.EQ.11) THEN 
                    AA = ALPHA*AFULL(M) 
                    AB = GEOM3(M)*GEOM2(M)/2.0 
                    IF(AA-AB.LT.0.0) DEPTH = GEOM3(M)/GEOM1(M) * 
     +                                       SQRT(AA/AB) 
                    IF(AA-AB.EQ.0.0) DEPTH = GEOM3(M)/GEOM1(M) 
                    IF(AA-AB.GT.0.0) DEPTH = (GEOM3(M) + 
     +                                       (AA-AB)/GEOM2(M))/GEOM1(M) 
                    RETURN 
                    ENDIF 
C======================================================================= 
C     FUNCTIONAL FORM FOR RECTANGULAR, ROUND BOTTOM. 
C======================================================================= 
      IF (NTPE.EQ.12) THEN 
                    AA = ALPHA*AFULL(M) 
                    IF (AA.GT.P6(M)) THEN 
                                     DD    = P2(M)*DIST(M)-GEOM1(M) 
                                     DEPTH = (DD+(AA-P6(M))/GEOM2(M))/ 
     +                                       (P2(M)*DIST(M)) 
                                     RETURN 
                                     ENDIF 
                    ALF = ALPHA*AFULL(M)/(3.1415965*GEOM3(M)*GEOM3(M)) 
                    IF(ALF.LT.0.04) THEN 
                           CALL CIRCLE(ALF,PS,DN,2) 
                           DEPTH = DN 
                           IF(NTPE.EQ.12) DEPTH = DEPTH*2.0*GEOM3(M)/ 
     +                                          (P2(M)*DIST(M)) 
                           RETURN 
                           ENDIF 
                    I     = IFIX(ALF/0.02) + 1 
                    IF(I.EQ.51) THEN 
                            DEPTH = DNORM(1,I) 
                            ELSE 
                            DEPTH = DNORM(1,I) + (DNORM(1,I+1) - 
     +                              DNORM(1,I))/0.02*(ALF-ANORM(1,I)) 
                            ENDIF 
                    DEPTH = DEPTH*2.0*GEOM3(M)/(P2(M)*DIST(M)) 
                    RETURN 
                    ENDIF 
C======================================================================= 
C    FUNCTIONAL FORM FOR TRAPEZOID 
C======================================================================= 
      IF(NTPE.EQ.13) THEN 
                   AA = ALPHA * AFULL(M) 
                   DEPTH = (-GEOM2(M) + SQRT(GEOM2(M)**2 + 
     +                     4.0 * AA/GEOM3(M))) * GEOM3(M)/2.0/GEOM1(M) 
                   RETURN 
                   ENDIF 
      END 
 
REM File: EXTRAN.FOR 
 
      SUBROUTINE EXTRAN 
C======================================================================= 
C        EXTENDED TRANSPORT MODEL IS UPDATED CONTINUOUSLY 
C                             BY 
C                 CAMP DRESSER AND MCKEE, INC. 
C                      LARRY A. ROESNER 
C                     ROBERT P. SHUBINSKI 
C                       JOHN A. ALDRICH 
C   BRETT A. CUNNINGHAM, CHARLES I. MOORE, MICHAEL F. SCHMIDT 
C 
C                             AND 
C                (FORMERLY) UNIVERSITY OF FLORIDA 
C                       ROBERT E. DICKINSON -- CDM 
C                        WAYNE C. HUBER -- Oregon State University 
C======================================================================= 
C     ADD NO-QUOTE OPTION, WCH, 11/29/93. 
C     INITIALIZE QINN AND QINNK3, WCH, 10/17/95. 
C     Modified statement 103 and 104 to include warning, CIM 9/8/00 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'BND.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'TIDE.INC' 
CIM TRANAID START 
cim include common block for tranaid transfer file 
      INCLUDE 'TRANAID.INC' 
CIM TRANAID END 
C======================================================================= 
C     Set up transfer files. 
C======================================================================= 
      INCNT  = INCNT  + 1 
      IOUTCT = IOUTCT + 1 
      LAST   = JIN(INCNT) 
      NEXT   =  JOUT(IOUTCT) 
      WRITE(*,100) 
      WRITE(N6,100) 
C#### WCH, 11/39/93.  ADD NO-QUOTE OPTION TO EXTRAN. 
      IF(NOQ.EQ.0) THEN 
           WRITE(*,102) 
           WRITE(N6,102) 
           ELSE 
           WRITE(*,101) 
           WRITE(N6,101) 
           ENDIF 
C======================================================================= 
C     Open all scratch files for the Extran Block. 
C======================================================================= 
CIM 2/99 Why open this input file as scratch???? 
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR. 
     +      FFNAME(INCNT).EQ.'JIN.UF')) THEN 
c     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      WRITE(N6,103) 
	JIN(INCNT) = 0 
      LAST = 0 
      ENDIF 
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND. 
     +      FFNAME(INCNT).NE.'JIN.UF') 
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
CIM 2/99  change next line to avoid writing data to JOUT if 
CIM       it won't be saved 
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR. 
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF')) THEN 
c     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH') 
c	Reset JOUT(IOUTCT to 0 to avoid writing all this data to 
c     an scratch file that is not saved. 
      WRITE(N6,104) 
      JOUT(IOUTCT) = 0 
	NEXT = 0 
      ENDIF 
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND. 
     +      FFNAME(25+IOUTCT).NE.'JIN.UF') 
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED', 
     +      STATUS='REPLACE') 
cim change to unformatted 
cim      IF(NSCRAT(1).GT.0.AND.FFNAME(51).NE.'SCRT1.UF') OPEN(NSCRAT(1), 
cim     +             FILE=FFNAME(51),FORM='FORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).NE.'SCRT1.UF') OPEN(NSCRAT(1), 
     +             FILE=FFNAME(51),FORM='UNFORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(2).GT.0.AND.FFNAME(52).NE.'SCRT2.UF') OPEN(NSCRAT(2), 
     +             FILE=FFNAME(52),FORM='UNFORMATTED',STATUS='UNKNOWN') 
cim 3 starts out formatted 
      IF(NSCRAT(3).GT.0.AND.FFNAME(53).NE.'SCRT3.UF') OPEN(NSCRAT(3), 
     +             FILE=FFNAME(53),FORM='FORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(4).GT.0.AND.FFNAME(54).NE.'SCRT4.UF') OPEN(NSCRAT(4), 
     +             FILE=FFNAME(54),FORM='UNFORMATTED',STATUS='UNKNOWN') 
cim 5 is formatted 
      IF(NSCRAT(5).GT.0.AND.FFNAME(55).NE.'SCRT5.UF') OPEN(NSCRAT(5), 
     +             FILE=FFNAME(55),FORM='FORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(6).GT.0.AND.FFNAME(56).NE.'SCRT6.UF') OPEN(NSCRAT(6), 
     +             FILE=FFNAME(56),FORM='UNFORMATTED',STATUS='UNKNOWN') 
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).NE.'SCRT7.UF') OPEN(NSCRAT(7), 
     +             FILE=FFNAME(57),FORM='UNFORMATTED',STATUS='UNKNOWN') 
CIM 8 IS FORMATTED EXTRAN TO WASP HYDRODYNAMICS INTERFACE FILE 
	IF(NSCRAT(8).GT.0.AND.FFNAME(58).NE.'SCRT8.UF') OPEN(NSCRAT(8), 
     +             FILE=FFNAME(58),STATUS='UNKNOWN') 
cim 
cim change 1 to unformatted 
cim      IF(NSCRAT(1).GT.0.AND.FFNAME(51).EQ.'SCRT1.UF') OPEN(NSCRAT(1), 
cim     +             FORM='FORMATTED',STATUS='SCRATCH') 
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).EQ.'SCRT1.UF') OPEN(NSCRAT(1), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(NSCRAT(2).GT.0.AND.FFNAME(52).EQ.'SCRT2.UF') OPEN(NSCRAT(2), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
cim 3 starts out formatted 
      IF(NSCRAT(3).GT.0.AND.FFNAME(53).EQ.'SCRT3.UF') OPEN(NSCRAT(3), 
     +             FORM='FORMATTED',STATUS='SCRATCH') 
      IF(NSCRAT(4).GT.0.AND.FFNAME(54).EQ.'SCRT4.UF') OPEN(NSCRAT(4), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
cim 5 is formatted 
      IF(NSCRAT(5).GT.0.AND.FFNAME(55).EQ.'SCRT5.UF') OPEN(NSCRAT(5), 
     +             FORM='FORMATTED',STATUS='SCRATCH') 
      IF(NSCRAT(6).GT.0.AND.FFNAME(56).EQ.'SCRT6.UF') OPEN(NSCRAT(6), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).EQ.'SCRT7.UF') OPEN(NSCRAT(7), 
     +             FORM='UNFORMATTED',STATUS='SCRATCH') 
CIM 8 IS FORMATTED EXTRAN TO WASP HYDRODYNAMICS INTERFACE FILE 
      IF(NSCRAT(8).GT.0.AND.FFNAME(58).EQ.'SCRT8.UF') OPEN(NSCRAT(8), 
     +             STATUS='SCRATCH') 
C======================================================================= 
C     INITIALIZATION 
C======================================================================= 
      DO 5    N    = 1,NEE 
CIM   TRANAID START 
      qsum(n)      = 0.0 
      qisum(n)     = 0.0 
CIM   TRANAID END 
      ICHECK(N)    = IND(1) 
      JCHECK(N)    = IND(1) 
      PMAX(N,1)    = 0.0 
      PMAX(N,2)    = 0.0 
      JSKIP(N)     = 0 
      INGATE(N)    = 0 
      YTOT(N)      = 0.0 
      QTOT(N)      = 0.0 
      YDEV(N)      = 0.0 
      QDEV(N)      = 0.0 
      Y(N)         = 0.0 
      YT(N)        = 0.0 
      YO(N)        = 0.0 
      A(N)         = 0.0 
      AT(N)        = 0.0 
      V(N)         = 0.0 
      VT(N)        = 0.0 
      Q(N)         = 0.0 
      QO(N)        = 0.0 
      QT(N)        = 0.0 
      AS(N)        = 0.0 
      ASFULL(N)    = 0.0 
      WIDE(N)      = 0.0 
      AMAX(N)      = 0.0 
      HMAX(N)      = 0.0 
      AFULL(N)     = 0.0 
      RFULL(N)     = 0.0 
      H(N,1)       = 0.0 
      H(N,2)       = 0.0 
      ZD(N)        = 0.0 
      ZU(N)        = 0.0 
C#### WCH, 10/17/95.  INITIALIZE QINN AND QINNK3 
      DO 4    M    = 1,2 
      QINN(N,M)    = 0.0 
    4 QINNK3(N,M)  = 0.0 
      DO 5    M    = 1,NCHN 
    5 NCHAN(N,M)   = 0 
      DO 6    M    = 1,NVORF 
      DO 6    N    = 1,NVOTIM 
      VORIF(M,N,1) = 999999.0 
      VORIF(M,N,2) = 0.0 
      VORIF(M,N,3) = 0.0 
    6 CONTINUE 
      DO 900 N   = 1,NEE 
      VMAXX(N)   = 0.0 
      QMAXX(N)   = 0.0 
      IVHR(N)    = 0 
      IVMIN(N)   = 0 
      IQHR(N)    = 0 
      IQMIN(N)   = 0 
  900 CONTINUE 
Cim   Done in Sub. OUTPUT:   SUMQIN     = 0.0 
      VLEFT      = 0.0 
      VINIT      = 0.0 
      DO 950 J   = 1,NEE 
      JCHECK(J)  = IND(1) 
      SUMQ(J)    = 0.0 
      SUMQS(J)   = 0.0 
      SUMAL(J)   = 0.0 
      SURLEN(J)  = 0.0 
      DEPMAX(J)  = 0.0 
      QOU(J)     = 0.0 
      FLDLEN(J)  = 0.0 
      ASMAXX(J)  = 0.0 
      IDHR(J)    = 0 
      IDMIN(J)   = 0 
	GRELEV(J) = 0.0 
	SURELEV(J) = 0.0 
  950 CONTINUE 
C======================================================================= 
C     Read input data. 
C======================================================================= 
      CALL INDAT1 
      CALL INDAT2 
      CALL INDAT3 
C======================================================================= 
C     Call TRANSX the driver routine for modified Euler solution. 
C======================================================================= 
c      TIME  = TZERO 
C   TIME SHOULD BE TIME IN HOURS FROM START OF SIMULATION 
C     TIMDAY IS THE TIME OF DAY, JULDAY DESCRIBES THE DAY 
      TIME = 0.0 
      CALL TRANSX 
      WRITE(*,1610) 
      CALL OUTPUT 
      WRITE(*,150) 
      WRITE(N6,150) 
      RETURN 
C======================================================================= 
C#### WCH, 11/29/93. 
  100 FORMAT(/, 
     +' *********************************************************',/, 
     +' * Entry made to the EXTENDED TRANSPORT MODEL (EXTRAN)   *',/, 
     1' * developed 1973 by Camp, Dresser and McKee (CDM) with  *',/, 
     1' * modifications 1977-1991 by the University of Florida. *',/, 
     1' *                                                       *',/, 
     1' * Most recent update: July 2004 by CDM and Oregon      *',/, 
     1' * State University                                      *') 
  101 FORMAT( 
     1' *********************************************************',/) 
  102 FORMAT( 
     1' *                                                       *',/, 
     1' * "Smooth runs the water where the brook is deep."      *',/, 
     1' *                   Shakespeare, Henry VI, II, III, 1   *',/, 
     1' *********************************************************',/) 
CIM 9/8/00 add Warning to message to allow search to find problem 
  103 FORMAT(5X,'WARNING : ', 
     a'JIN WAS SET TO NONZERO BUT FILE NAME WAS NOT', 
     a' SPECIFIED THROUGH @ LINES',/,5X,'JIN IS SET TO ZERO') 
  104 FORMAT(5X,'WARNING : ', 
     a'JOUT WAS SET TO NONZERO BUT FILE NAME WAS NOT ', 
     a'SPECIFIED THROUGH @ LINES',/,5X,'JOUT WAS SET TO ZERO TO ', 
     a'AVOID WRITING DATA TO UNSAVED SCRATCH FILE') 
  150 FORMAT(/,' ===> Extended Transport model simulation', 
     1         ' ended normally.') 
 1610 FORMAT(/,' Calling output and graph subroutines.') 
C======================================================================= 
      END 
 
REM File: FILECK.FOR 
 
      SUBROUTINE FILECK(IO,FNAME,DEFORM) 
C      ADD FOLLOWING LINE FOR DIGITAL VISUAL FORTRAN 
c2013  USE DFPORT 
C======================================================================= 
C     Subroutine to check form (formatted vs. unformatted) of existing 
C     file to avoid run-stopping error when desired form does not 
C     match existing form. 
C     This problem does not occur with an empty file, only one  
C     previously used that contains data in the wrong form.   
C     At program pause, user will have option to allow deletion of 
C     existing file (FNAME), and continue run. 
C     Note: Subroutine SYSTEM may be Lahey-specific, in which case  
C     do not use this subroutine or references to it, and just suffer 
C     through resulting error message. 
C     Wayne Huber, 7/25/96. 
C     Modified 7/97 to check if file exists  C. Moore CDM 6/25/97 
C     Add EX to logical, INQUIRE, and add check to return if file 
C     doesn't exist. 
C======================================================================= 
C     IO    = unit number of file to be checked. 
C     FNAME = DOS name of file 
C     DEFORM = desired form for file (FORMATTED or UNFORMATTED) 
C======================================================================= 
      CHARACTER*128 FNAME 
      CHARACTER*11 DEFORM,ACFORM 
      LOGICAL OPEND,EX 
C======================================================================= 
C     If no file is specified (IO = 0), do nothing. 
C======================================================================= 
      IF(IO.LE.0) RETURN 
C======================================================================= 
C     Otherwise, check form of file FNAME to see if is OK to open. 
C     OK if form about to be used matches existing form.   
C     Otherwise, print message and ask user if it is OK to delete 
C     the offending file. 
C======================================================================= 
      INQUIRE(IO,FORM=ACFORM,OPENED=OPEND,exist=EX) 
      IF (.NOT.EX) RETURN 
      IF(ACFORM.EQ.DEFORM) THEN 
           IF(OPEND) REWIND IO 
           RETURN 
           ELSE 
CIM ELIMINATE WRITE AND PAUSE 
c           WRITE(*,9000) IO,FNAME,DEFORM,IO 
c           PAUSE 
C======================================================================= 
C     Prepare a delete command by concatenating DOS delete command 
C     with offending file name. 
C     Caution.  Subroutine SYSTEM allows a DOS command to be executed. 
C     This may be Lahey-specific. 
C======================================================================= 
c the following line is lahey 
C           CALL SYSTEM('del '//FNAME) 
c  the following line is digital visual fortran 
           IOEER = SYSTEM('del '//FNAME) 
           ENDIF 
      RETURN 
C======================================================================= 
c 9000 FORMAT(/,' Program is about to stop with error message for unit', 
c     1 I3,/,' about ''form'' of file: ',A60,/, 
c     2' File momentarily should be of form: ',A11,', but is not.',/, 
c     3' At prompt, press <enter> to delete above file and then',/, 
c     4' over-write it, or press <control>-C or <control>-break',/, 
c     5' to end run and not delete the file.  In this latter case,',/, 
c     6' provide new file name on @-line for unit',I3,' and run again.') 
      END 
ECHO is off.
 
REM File: FINDA.FOR 
 
      SUBROUTINE FINDA(PS,AA) 
C     TRANSPORT BLOCK 
C     CALLED BY ROUTE NEAR LINE 240 
C               INITAL NEAR LINE 211 
C======================================================================= 
C     CALCULATES THE FLOW AREA IN CONDUITS GIVEN THE FLOW RATE. 
C 
C     UPDATED (NEW COMMON) BY W.C.H., SEPTMEBER 1981. 
C     UPDATED 12/31/93 BY RED.  FIX DO LOOP RANGE. 
C     UPDATED 09/08/00 BY CIM.  Changes to add option for additional 
C                               detail in irregular sections. 
C     Use QCURVE(4), not (3), for flow.  WCH, 7/6/01 
C     No change to QCURV2. 
C     Fix possible error at end of search for correct PS range.   
C        WCH, 5/24/02.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEW81.INC' 
      INCLUDE 'FLODAT.INC' 
CIM## 9/8/00 add new common 
      INCLUDE 'NEWTR.INC' 
C======================================================================= 
      AA = 0.0 
      IF(PS.EQ.0.0) RETURN 
      NTPE = NTYPE(M) 
C======================================================================= 
C     CONDUITS WITH FUNCTIONAL Q-A RELATIONSHIP. 
C======================================================================= 
      IF(KLASS(NTPE).EQ.1) THEN 
                         C2    = -PS 
                         ALPHA = 0.2 
                         CALL NEWTON(ALPHA,PS,0.0,C2,KFLAG) 
                         IF(KFLAG.EQ.2) THEN 
                                 IF(JCE.EQ.0) WRITE(N6,910) 
     +                                 TIME,N,NOE(M),A(M,1,1) 
                                 IF(JCE.EQ.1) WRITE(N6,911) 
     +                                 TIME,N,KOE(M),A(M,1,1) 
                                 AA = A(M,1,1) 
                                 ELSE 
                                 AA = ALPHA*AFULL(M) 
                                 ENDIF 
                         RETURN 
                         ENDIF 
C======================================================================= 
C      SPECIAL ROUTINE FOR HIGH ACCURACY AT LOW FLOWS FOR CIRCULAR PIPE. 
C======================================================================= 
      IF(NTPE.EQ.1.AND.PS.LE.0.015) THEN 
                                  CALL CIRCLE(ALPHA,PS,DN,3) 
                                  AA = ALPHA*AFULL(M) 
                                  RETURN 
                                  ENDIF 
C======================================================================= 
C     CONDUITS WITH TABULAR Q-A RELATIONSHIP. 
C     Note, NTPE also = 16 for parabolic and power functions (changed  
C     from 14 and 15 in Sub. INTRAN). 
C======================================================================= 
      IF(NTPE.EQ.16) THEN 
C======================================================================= 
C     PARABOLIC, POWER FUNCTION, OR NATURAL CROSS SECTIONS 
C======================================================================= 
         MMM     = 26 
         KK      = NQC(M) 
         DALPHA  = 0.04 
C#### RED (WCH), 12/31/93.  CHANGE END OF LOOP TO MMM-1 FROM MMM TO 
C####                       AVOID OUT OF BOUNDS ERROR IN LINE 207. 
         DO 210 I = 1,MMM-1 
         II = I 
Cwch, 7/6/01.  Use QCURVE(4), not (3), for flow.  
         IF(PS-QCURVE(KK,4,I+1)) 207,208,210 
  210    CONTINUE 
         ALPHA = 1.0 
         AA = ALPHA*AFULL(M) 
         RETURN 
  208    I = II 
CIM### 9/8/00 Change next if 
         IF ((IDETAIL.EQ.0).OR.(I.GE.2)) THEN 
            ALPHA = FLOAT(I-1)*0.04 
            AA    = ALPHA*AFULL(M) 
            RETURN 
            ENDIF 
  207    I = II 
CIM### 9/8/00 Add if statement major changes throughout next section. 
         IF ((IDETAIL.EQ.0).OR.(I.GE.2)) THEN 
Cwch, 7/6/01.  Use QCURVE(4), not (3), for flow.  
            ALPHA = FLOAT(I-1)*0.04 + (PS-QCURVE(KK,4,I))/ 
     +                      (QCURVE(KK,4,I+1)- QCURVE(KK,4,I))*DALPHA 
C======================================================================= 
C        IMPROVE ESTIMATE WITH PARABOLIC INTERPOLATION. 
C======================================================================= 
            IF(PS.LT.0.015) ALPHA = ALPHA + (PS - QCURVE(KK,4,I)) * 
     +        (PS - QCURVE(KK,4,I+1)) * (DALPHA/(QCURVE(KK,4,I+2) - 
     +         QCURVE(KK,4,I+1))      - DALPHA/(QCURVE(KK,4,I+1) 
     +       - QCURVE(KK,4,I)))/(QCURVE(KK,4,I+2) - QCURVE(KK,4,I)) 
            AA = ALPHA*AFULL(M) 
            RETURN 
            ELSE     here when IDETAIL.EQ.1 AND I LE 1 
            DALPHA = 0.0016 
            DO 205 J = 1,MMM-1 
            JJ = J 
            IF(PS-QCURV2(KK,3,J+1)) 203,204,205 
  205       CONTINUE 
CIM SHOULD NOT GET HERE 
            write(n6,*) 'Error in FINDA - 1',ps,m,kk,qcurv2(kk,3,26) 
            STOP ' ERROR IN FINDA - 1' 
  203       J=JJ 
            ALPHA = FLOAT(J-1)*0.0016 + (PS-QCURV2(KK,3,J))/ 
     +                    (QCURV2(KK,3,J+1) - QCURV2(KK,3,J))*DALPHA 
            AA = ALPHA*AFULL(M) 
c     write(n6,*) 'finda3',ps,J,qcurv2(kk,3,J),qcurv2(kk,3,J+1), 
c    .alpha,aa,afull(m) 
            RETURN 
  204       J=JJ 
            ALPHA = FLOAT(J-1)*0.0016 
            AA = ALPHA*AFULL(M) 
c     write(n6,*) 'finda4',ps,J,qcurv2(kk,3,J),QCURV2(KK,3,J+1), 
c    .alpha,aa,afull(m) 
            RETURN 
            ENDIF 
CIM### 9/8/00 end of changes. 
C======================================================================= 
C     OTHER TABULAR CROSS SECTIONS 
C======================================================================= 
         ELSE   Here tabular, but not NTPE = 16.  
         MMM      = MM(NTPE) 
         DALPHA   = ANORM(NTPE,2) - ANORM(NTPE,1) 
         DO 110 I = 1,MMM-1 
         IF(PS-QNORM(NTPE,I+1)) 107,108,110 
  107    ALPHA = ANORM(NTPE,I) + (PS-QNORM(NTPE,I))/(QNORM(NTPE,I+1) - 
     +                        QNORM(NTPE,I))*DALPHA 
C======================================================================= 
C        IMPROVE ESTIMATE WITH PARABOLIC INTERPOLATION. 
C======================================================================= 
         IF(PS.LT.0.015) ALPHA = ALPHA + 
     1                       (PS-QNORM(NTPE,I))*(PS-QNORM(NTPE,I+1))* 
     2                       (DALPHA/(QNORM(NTPE,I+2)-QNORM(NTPE,I+1))- 
     3                       DALPHA/(QNORM(NTPE,I+1) - 
     4                       QNORM(NTPE,I)))/ 
     5                       (QNORM(NTPE,I+2)-QNORM(NTPE,I)) 
         AA = ALPHA*AFULL(M) 
         RETURN 
  108    ALPHA = ANORM(NTPE,I+1) 
         AA    = ALPHA*AFULL(M) 
         RETURN 
  110    CONTINUE 
C======================================================================= 
Cwch, 5/24/02. Since PS should be <= 1.0 and since QNORM-max should be  
C     1.0, should not exit DO-loop this way. but in case we do, because 
C     of numerical error or something, we want max. value for area, not 
C     zero. (Lew Rossman) 
C======================================================================= 
C         AA = ALPHA*AFULL(M) 
         AA = AFULL(M) 
         ENDIF 
C======================================================================= 
      RETURN 
C======================================================================= 
  910 FORMAT (/,' ===> WARNING  NEWTON UNABLE TO FIND AREA GIVEN FLOW. 
     1TIME = ',F7.1,', TIME STEP= ',I3,', EXT. ELE. NUM.=',I10,', USE OL 
     2D UPSTREAM AREA = ',F6.2) 
  911 FORMAT (/,' ===> WARNING  NEWTON UNABLE TO FIND AREA GIVEN FLOW. 
     1TIME = ',F7.1,', TIME STEP= ',I3,', EXT. ELE. NUM.=',A10,', USE OL 
     2D UPSTREAM AREA = ',F6.2) 
C======================================================================= 
      END 
 
REM File: G3RAIN.FOR 
 
      SUBROUTINE G3RAIN(IDO,IGO,ILOST) 
C	RAIN BLOCK 
C	CALLED BY RAIN NEAR LINES 440 AND 465 
C	 
C####################################################################### 
C     This program reads a user defined time series. 
C     Updated 2/93 by WCH to correct hour values for user-supplied data. 
C     Updated 11/12/93 by WCH to allow for hours to range from 1 - 24. 
C     Updated 10/25/94 by WCH to allow YEAR and NEWYR to be read as 
C       either 19XX or XX.  Program uses two-digit form. 
C     Updated 8/1/95 by WCH to change station ID to character after 
C       input for IFORM = 3. 
C     WCH, 8/1/95.  Make changes for character station ID.  No longer 
C       compare requested ID with ID on data lines, to avoid character 
C       comparison complications. 
C     WCH, 10/2/96. Add new error message for READ(IO). 
C     WCH, 12/3/96. Remove unused statement number 777.  Backspace IO 
C       after reading first record of next year, to avoid missing that 
C       record when returning to G3RAIN. 
C####################################################################### 
C     IFORM = 3 MEANS USER DEFINED FORMAT 
C     IDO   = 0 SEARCH FOR STATION NUMBER 
C     IDO   = 1 READ STATION RAINFALL 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'PRECIP.INC' 
C#### WCH, 8/1/95.  CHANGE STATION ID TO CHARACTER. 
C####      INTEGER DAY,YEAR,STA,FF(6),XRAIN(24) 
      INTEGER DAY,YEAR,FF(6),XRAIN(24) 
      CHARACTER*8 IBUF, STA 
	character text(80) 
C======================================================================= 
C     First find the correct rainfall station (IDO = 0) 
C======================================================================= 
      IF(IDO.EQ.0)   THEN 
C#### WCH, 8/1/95. 
      IPRINT = 0 
C======================================================================= 
      IF(F1.GT.0) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
C#### 5              READ(IO,FIRMAT,ERR=5,END=40) (FF(I),I=1,6) 
5              READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) (FF(I),I=1,6) 
C#### WCH, 8/1/95.  CONVERT STATION ID TO CHARACTER. 
C####               IBUF   = FF(F1) 
               WRITE(IBUF,'(I8)') FF(F1) 
C 
               NEWYR  = FF(F2) 
C#### WCH, 10/25/94. 
c               IF(NEWYR.GT.1900) NEWYR = NEWYR - 1900 
                IF(NEWYR.LT.100)  NEWYR = NEWYR + 1900 
               NEWMON = FF(F3) 
               NEWDAY = FF(F4) 
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY. 
C####               IF(IBUF.NE.ISTA) GO TO 5 
               IF(IPRINT.EQ.0) THEN 
                    WRITE(N6,990) IBUF,ISTA 
                    WRITE(*,990) IBUF,ISTA 
                    IPRINT = 1 
                    ENDIF 
C 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 5 
               IF(NEWMON.LT.IYBEG(2).AND. 
     +                            NEWYR.EQ.IYBEG(1))    GO TO 5 
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3) 
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 5 
CC$$$$$5/3/92 
                  BACKSPACE IO 
               ENDIF 
C======================================================================= 
      IF(F1.EQ.0) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
6              READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) (FF(I),I=1,5) 
               NEWYR  = FF(F2) 
C#### WCH, 10/25/94. 
c               IF(NEWYR.GT.1900) NEWYR = NEWYR - 1900 
                IF(NEWYR.LT.100)  NEWYR = NEWYR + 1900 
               NEWMON = FF(F3) 
               NEWDAY = FF(F4) 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 6 
               IF(NEWMON.LT.IYBEG(2).AND. 
     +                            NEWYR.EQ.IYBEG(1))    GO TO 6 
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3) 
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 6 
CC$$$$$5/3/92 
                   BACKSPACE IO 
               ENDIF 
C======================================================================= 
      ENDIF 
C======================================================================= 
C====> End of IDO = 0 (Executed only once). 
C======================================================================= 
C     Read the rainfall values (IDO = 1) 
C======================================================================= 
C     CLEAR THIS YEAR'S MATRIX 
C     BACKSPACE FOR A NEW YEAR OR NEW STATION 
C     COMPUTE STARTING DAY NUMBER FOR THIS YEAR 
C======================================================================= 
      IF(IDO.EQ.1) THEN 
      CALL SETIA(HOUR,366,27,0) 
cim 11/07 update LIMRN values 
c      CALL SETIA(RDAY,3000,1,0) 
      CALL SETIA(RDAY,LIMRN,1,0) 
      ILOST  = 1 
      NSTORM = 0 
      IDAST  = KDATE(0,1,NEWYR) 
C======================================================================= 
C     Read this year's rainfall. 
C======================================================================= 
C     Read Rainfall and station number > 0 for a 
C             User defined time series. 
C======================================================================= 
   10 CONTINUE 
      IF(NUVAL.EQ.1) THEN 
           IF(F1.GT.0.AND.F7.EQ.7) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
                     READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) 
     1                   (FF(I),I=1,6),REIN 
                     IF(REIN.NE.0.0) THEN 
C#### WCH, 8/1/95.  CONVERT STATION ID TO CHARACTER. 
C####                      STA   = FF(F1) 
                          WRITE(STA,'(I8)') FF(F1) 
C 
                          YEAR  = FF(F2) 
C#### WCH, 10/25/94. 
c                         IF(YEAR.GT.1900) YEAR = YEAR - 1900 
                          IF(YEAR.LT.100) YEAR = YEAR + 1900 
                          MONTH = FF(F3) 
                          DAY   = FF(F4) 
                          REIN  = REIN*CONV 
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR 
                          IHR   = FF(F5) 
                          MINU  = FF(F6) 
                          IF(METRIC.EQ.1) THEN 
                               IRAIN = IFIX(REIN*1000.0+0.1) 
                               ELSE 
                               IRAIN = IFIX(REIN*100.0+0.1) 
                               ENDIF 
                          ELSE 
                          GO TO 10 
                          ENDIF 
                     ENDIF 
C======================================================================= 
C     Read rainfall and station number > 0 for a 
C       user-defined time series. 
C======================================================================= 
           IF(F1.GT.0.AND.F7.EQ.1) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
                READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) 
     1              REIN,(FF(I),I=1,6) 
                IF(REIN.NE.0.0) THEN 
C#### WCH, 8/1/95.  CONVERT STATION ID TO CHARACTER. 
C####                      STA   = FF(F1) 
                          WRITE(STA,'(I8)') FF(F1) 
C 
                          YEAR  = FF(F2) 
C#### WCH, 10/25/94. 
c                         IF(YEAR.GT.1900) YEAR = YEAR - 1900 
                          IF(YEAR.LT.100)  YEAR = YEAR + 1900 
                          MONTH = FF(F3) 
                          DAY   = FF(F4) 
                          REIN  = REIN*CONV 
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR 
                          IHR   = FF(F5) 
                          MINU  = FF(F6) 
                          IF(METRIC.EQ.1) THEN 
                               IRAIN = IFIX(REIN*1000.0+0.1) 
                               ELSE 
                               IRAIN = IFIX(REIN*100.0+0.1) 
                               ENDIF 
                          ELSE 
                          GO TO 10 
                          ENDIF 
                     ENDIF 
C======================================================================= 
C     Read rainfall and station number = 0 for a 
C             user-defined time series. 
C======================================================================= 
           IF(F1.EQ.0.AND.F7.GE.6) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
                READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) 
     1              (FF(I),I=1,5),REIN 
                IF(REIN.NE.0.0) THEN 
                     STA   = ISTA 
                     YEAR  = FF(F2) 
C#### WCH, 10/25/94. 
c                    IF(YEAR.GT.1900) YEAR = YEAR - 1900 
                     IF(YEAR.LT.100)  YEAR = YEAR + 1900 
                     MONTH = FF(F3) 
                     DAY   = FF(F4) 
                     REIN  = REIN*CONV 
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR 
                     IHR   = FF(F5) 
                     MINU  = FF(F6) 
                     IF(METRIC.EQ.1) THEN 
                               IRAIN = IFIX(REIN*1000.0+0.1) 
                               ELSE 
                               IRAIN = IFIX(REIN*100.0+0.1) 
                               ENDIF 
                     ELSE 
                     GO TO 10 
                     ENDIF 
                ENDIF 
C======================================================================= 
C     Read rainfall and station number = 0 for a 
C             user-defined time series. 
C======================================================================= 
           IF(F1.EQ.0.AND.F7.EQ.1) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
                READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) 
     1              REIN,(FF(I),I=1,5) 
                IF(REIN.NE.0.0) THEN 
                     STA   = ISTA 
                     YEAR  = FF(F2) 
C#### WCH, 10/25/94. 
c                    IF(YEAR.GT.1900) YEAR = YEAR - 1900 
                     IF(YEAR.LT.100)  YEAR = YEAR + 1900 
                     MONTH = FF(F3) 
                     DAY   = FF(F4) 
                     REIN  = REIN*CONV 
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR 
                     IHR   = FF(F5) 
                     MINU  = FF(F6) 
                     IF(METRIC.EQ.1) THEN 
                               IRAIN = IFIX(REIN*1000.0+0.1) 
                               ELSE 
                               IRAIN = IFIX(REIN*100.0+0.1) 
                               ENDIF 
                     ELSE 
                     GO TO 10 
                     ENDIF 
                ENDIF 
C======================================================================= 
           ENDIF 
C======================================================================= 
C     Read rainfall and station number for a user-defined time series. 
C======================================================================= 
      IF(NUVAL.GT.1) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
                     READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) 
     1                   (FF(I),I=1,3),(XRAIN(K),K=1,NUVAL) 
                     STA   = ISTA 
                     YEAR  = FF(F2) 
C#### WCH, 10/25/94. 
c                    IF(YEAR.GT.1900) YEAR = YEAR - 1900 
                     IF(YEAR.LT.100)  YEAR = YEAR + 1900 
                     MONTH = FF(F3) 
                     DAY   = FF(F4) 
                     ENDIF 
C======================================================================= 
C     Check for same station.     Check for same year. 
C     Add to this year's matrix.  Find the day number and indicate 
C                                 unusual conditions. 
C     Hour =  -2 means meter stuck. 
C     Hour =  -1 means missing data. 
C======================================================================= 
C#### WCH, 8/1/95.  DON'T MAKE THIS CHECK ANYMORE. 
C####      IF(STA.NE.ISTA) GO TO 40 
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GE.IYEND(2) 
     *                   .AND.DAY.GT.IYEND(3))   GO TO 40 
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GT.IYEND(2)) 
     *                                           GO TO 40 
      IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))     GO TO 40 
C======================================================================= 
C#### WCH, 12/3/96. NEED TO BACKSPACE IO, OTHERWISE MISS FIRST RECORD 
C     OF NEXT YEAR. 
C======================================================================= 
C####      IF(YEAR.GT.NEWYR)                          RETURN 
      IF(YEAR.GT.NEWYR) THEN 
           BACKSPACE IO 
           RETURN 
           ENDIF 
      IDAY = KDATE(DAY,MONTH,YEAR) - IDAST 
C======================================================================= 
C     User defined format for one value per line. 
C======================================================================= 
      IF(NUVAL.EQ.1) THEN 
                     NSTORM         = NSTORM     + 1 
C####################################################################### 
C  WCH 2/9/93  CAUTION. IHR USED AS SUBSCRIPT.  USER INPUTS 
C    FROM 0 TO 23, THUS ADD 1 FOR SUBSCRIPT FOR HOURS OF DAY. 
C####################################################################### 
C  WCH, 11/12/93.  ADD OPTION FOR IHR TO VARY FROM 1 - 24. 
C####################################################################### 
                     IF(IHH.EQ.0.AND.IHR.GE.24) THEN 
                        WRITE(N6,9050) IHR,YEAR,MONTH,DAY 
                        IHR = 23 
                        ENDIF 
                     IF(IHH.EQ.1) THEN 
                        IHR = IHR - 1 
                        IF(IHR.LT.0) THEN 
                           WRITE(N6,9060) IHR+1,YEAR,MONTH,DAY 
                           IHR = 1 
                           ENDIF 
                        ENDIF 
                     HOUR(IDAY,IHR+1) = IRAIN      + HOUR(IDAY,IHR+1) 
                     RTIME(NSTORM)  = FLOAT(IHR) + FLOAT(MINU)/60.0 
                     RRAIN(NSTORM)  = IRAIN 
                     RDAY(NSTORM)   = IDAY 
c                    write(*,*) nstorm,rday(nstorm),rtime(nstorm) 
cim change from EQ to GE 11/97 
                     IF(NSTORM.GE.LIMRN) THEN 
                                         WRITE(N6,9000) LIMRN 
                                         GO TO 40 
                                         ENDIF 
                     ENDIF 
C======================================================================= 
C     User defined format for multiple values per line. 
C======================================================================= 
      IF(NUVAL.GT.1) THEN 
                     DO 7000     J  = 1,24 
                     IF(XRAIN(J).EQ.0.0) GO TO 7000 
                     IF(METRIC.EQ.1) THEN 
                               IRAIN = 10 * XRAIN(J) 
                               ELSE 
                               IRAIN =      XRAIN(J) 
                               ENDIF 
                     HOUR(IDAY,J)   = IRAIN 
                     NSTORM         = NSTORM     + 1 
                     RTIME(NSTORM)  = J 
                     RRAIN(NSTORM)  = IRAIN 
                     RDAY(NSTORM)   = IDAY 
cim include check and write for nstorm here also 
                     IF(NSTORM.GE.LIMRN) THEN 
                                         WRITE(N6,9000) LIMRN 
                                         GO TO 40 
                                         ENDIF 
 7000                CONTINUE 
                     ENDIF 
C======================================================================= 
C#### WCH, 12/3/96.  REMOVE UNUSED STATEMENT NUMBER 777. 
Cwch 2/3/03 error print 
      if(iday.lt.1.or.iday.gt.366) then  
	     write(n6,9876) iday,idast,year, 
     1     month,day,ihr,minu,rein 
Cwch, 8/27/03 
                		backspace io 
	                read(io,9123) text 
 9123 format(80a1) 
	                write(n6,9123) text 
	                endif 
 9876 format(/,' iday,idast,year,month,day,ihr,minu,rein ',7i8,f7.2) 
      HOUR(IDAY,25) = MONTH 
      HOUR(IDAY,26) =   DAY 
      HOUR(IDAY,27) =  YEAR 
      GO TO 10 
C======================================================================= 
C     End of loop for IF(IDO.EQ.1) 
C======================================================================= 
      ENDIF 
C======================================================================= 
C     Skip if the new station is not the station selected. 
C     Return if the new year is less than the selected ending year. 
C======================================================================= 
49    RETURN 
C======================================================================= 
C     Here if reach end of file or passed designated ending date. 
C================================================================= 
40    IGO = 1 
c  do this to ensure that all rainfall on interface is written 
      IF (NSTORM.LT.LIMRN) NSTORM = NSTORM + 1 
      RDAY(NSTORM) = 999999 
c 
      RETURN 
C======================================================================= 
C#### WCH, 10/2/96.  NEW ERROR MESSAGE FOR READ(IO) ERRORS. 
C======================================================================= 
  970 WRITE(N6,9700) IO,MOD(IOS,256),FF 
      WRITE(*,9700) IO,MOD(IOS,256),FF 
      STOP 'Run stopped from Sub. G3RAIN.' 
C======================================================================= 
C#### WCH, 8/1/95.  NEW FORMAT STATEMENT 990. 
  990 FORMAT(/,' STATION ID ON PRECIP. DATA INPUT FILE = ',A8,/, 
     1' REQUESTED STATION ID = ',A8,' CHECK TO BE SURE THEY MATCH.',/) 
 9000 FORMAT(/,' Error ==> Limit of ',I6, 
     +         ' precipitation values exceeded for this year.') 
C#### WCH, 11/12/93 
 9050 FORMAT(' WARNING VALUE OF IHOUR =',I3,' AND IS .GE. 24.', 
     1 ' HOURS SHOULD RUN FROM 0 (MIDNIGHT) TO 23.',/, 
     2' VALUE RESET TO 23, YEAR = ',I4,', MONTH =',I3,', DAY =',I3) 
 9060 FORMAT(' WARNING$$ VALUE OF IHOUR =',I3,' AND SHOULD NOT BE LESS T 
     1HAN 1 FOR HOUR-OPTION YOU HAVE CHOSEN.',/,' (HOURS GO FROM 1-24)', 
     2'  VALUE RESET TO 1.  YEAR = ',I4,', MONTH =',I3,', DAY =',I3) 
C#### WCH, 10/2/96. 
 9700 FORMAT(/,' ERROR DURING READ OF UNIT',I3,/, 
     1 ' COMPAQ DIGITAL FORTRAN ERROR NUMBER =',I5,/, 
     2 ' CURRENT VALUES OF ARRAY FF(1-6): ',6I8) 
C======================================================================= 
      END 
 
REM File: GAMP.FOR 
 
      SUBROUTINE GAMP(SUCT,SMD,SMDMAX,IFLAG,FU,F,HYDCON,WDEPTH, 
     1           TR,DELT,TIME,RI,RLOSS,UL,SVAP,KAMEW,NAMEW,FLOW2P) 
C     RUNOFF BLOCK 
C     CALLED BY WSHED NEAR LINE 300 
C======================================================================= 
C     Green-Ampt infiltration routine,  written FEB 1979 by R.G.MEIN. 
C 
C     Theory as given in Mein & Larson, Water Resources Research, 
C                                       Vol. 9, NO. 2, 384-394, 1973 
C======================================================================= 
C     Redistribution rate depends on soil hydraulic conductivity 
C     and is considered only for the surface region. 
C####################################################################### 
C     WCH (CDM), 10/5/93.  CHANGE EVAP TO SVAP FOR CONSISTENCY, 5  
C       LOCATIONS. 
C     WCH, 4/5/00. Declare TIME as double precision to match delcarion  
C       in TIMER.INC.. 
C     WCH, 12/20/00.  Add rerouted overland flow to rain-evap calc.  
C     WCH, 4/11/02. Correct use of RI to R1 in several places, to  
C       account for rerouted overland flow.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      DOUBLE PRECISION RI,RLOSS,SVAP,TIME 
      CHARACTER KAMEW*10 
C======================================================================= 
C     Statement function for Green-Ampt equation. 
C======================================================================= 
      F22(X) = X-(X-F-C1*ALOG(X+C1)+C2)/(1.0-C1/(X+C1)) 
C======================================================================= 
      C1    = SUCT*SMD 
      TBS   = 6.0 
Cwch, 12/20/00. Add rerouted water from impervious areas. 
Cwch, 4/11/02.  Add standing water to potential infiltration,  
C     as in HORTON. 
      R1    = RI - SVAP + FLOW2P + WDEPTH/DELT 
      FUMAX = UL*SMDMAX 
      RVOL  = R1*DELT  
C======================================================================= 
C     Check for surface saturation. 
C======================================================================= 
      IF(IFLAG.EQ.1)   GO TO 200 
C======================================================================= 
C     Surface unsaturated at the beginning of the time step. 
C======================================================================= 
      TR = TR - DELT 
C======================================================================= 
C     Evaporation depletes any rainfall or standing water. 
Cwch, 4/11/02. Set RLOSS = total water available for loss. 
C======================================================================= 
      IF(R1.LE.0.0) THEN 
                    RLOSS = RI + FLOW2P + WDEPTH/DELT 
                    IF(FU.LE.0.0) RETURN 
C======================================================================= 
C                   Deplete soil moisture during dry period. 
C======================================================================= 
                    DF  = UL*DELT/90000. 
                    DEP = DF*FUMAX 
                    F   = F  - DEP 
                    FU  = FU - DEP 
                    IF(FU.LE.0.0) THEN 
                                  FU  = 0.0 
                                  F   = 0.0 
                                  SMD = SMDMAX 
                                  RETURN 
                                  ENDIF 
C======================================================================= 
C                   If sufficient time elapsed since rain, redistribute. 
C======================================================================= 
                    IF(TR.LE.0.0) THEN 
                                  SMD = (FUMAX-FU)/UL 
                                  F   = 0.0 
                                  ENDIF 
                    RETURN 
                    ENDIF 
C======================================================================= 
C     Low intensity, all infiltrates.  Rain intensity > 0.0 
C======================================================================= 
      IF(R1.LE.HYDCON) THEN 
                       FU = FU + RVOL 
                       IF(FU.GT.FUMAX) FU = FUMAX 
                       F                  = F + RVOL 
Cwch, 4/11/02. Loss should be R1 plus evap, not RI.  
                       RLOSS              = R1 + SVAP 
                       IF(TR.LE.0.0) THEN 
                                     SMD = (FUMAX-FU)/UL 
                                     F   = 0.0 
                                     ENDIF 
                       RETURN 
                       ENDIF 
C======================================================================= 
C     Rain (minus evap) intensity > Hyd. conductivity. 
C======================================================================= 
      TR = 900.0*TBS/UL 
      FS = HYDCON*C1/(R1-HYDCON)-F 
C======================================================================= 
C     Soil still wet from last rain, surface saturates. 
C======================================================================= 
      IF(FS.LE.0.0) THEN 
                    IFLAG = 1 
                    GO TO 200 
                    ENDIF 
C======================================================================= 
C     All water infiltrates. 
C======================================================================= 
      IF(FS.GE.RVOL) THEN 
Cwch, 4/11/02. Loss should be R1 plus evap, not RI.  
                     RLOSS = R1 + SVAP 
                     F     = F  + RVOL 
                     FU    = FU + RVOL 
                     IF(FU.GT.FUMAX) FU = FUMAX 
                     RETURN 
                     ENDIF 
C======================================================================= 
C     Surface saturates during interval. 
C======================================================================= 
      F  = F + FS 
      TS = FS/R1 
      C2 = C1*ALOG(F+C1)-HYDCON*(DELT-TS) 
      GO TO 300 
C======================================================================= 
C     Surface is saturated, so compute vol of potential infiltration. 
C======================================================================= 
  200 TR = 900.0*TBS/UL 
      TS = 0.0 
      IF(C1.LE.0.0) THEN 
                    F2 = HYDCON*DELT+F 
                    ELSE 
                    C2 = C1*ALOG(F+C1) - HYDCON*DELT 
                    GO TO 300 
                    ENDIF 
C======================================================================= 
C     Excess water at surface.  Corrected December, 1990. 
Cwch 4/11/02. RVOL includes WDEPTH.  Should not add here. 
C======================================================================= 
C  210 IF((F2-F).LE.(WDEPTH+RVOL)) THEN 
  210 IF((F2-F).LE.RVOL) THEN 
                                  RLOSS = (F2-F)/DELT + SVAP 
                                  FU    = F2 - F      + FU 
                                  F     = F2 
C---- old code                    FU    = F2 
                                  IF(FU.GT.FUMAX) FU = FUMAX 
                                  RETURN 
C======================================================================= 
C     Rain+surface water infiltrates.  Corrected December, 1990. 
C======================================================================= 
                                  ELSE 
Cwch, 4/11/02. Loss should be R1 + evap. R1 includes all available water.  
C                                  RLOSS = WDEPTH/DELT + RI 
                                  RLOSS = R1 + SVAP 
                                  F     = F  + AMAX1(WDEPTH+RVOL,0.0) 
                                  IFLAG = 0 
                                  FU    = FU + AMAX1(WDEPTH+RVOL,0.0) 
C--- old code                     FU    = F 
                                  IF(FU.GT.FUMAX) FU = FUMAX 
                                  RETURN 
                                  ENDIF 
C======================================================================= 
C     Newton-Raphson iteration to solve for infiltration volume. 
C======================================================================= 
  300 F21      = F 
      DO 310 I = 1,11 
      F2       = F22(F21) 
      IF(ABS(F2-F21).LT.0.0001)   GO TO 320 
      F21      = F2 
  310 CONTINUE 
C======================================================================= 
C     No convergence. 
C======================================================================= 
      F2 = F + (DELT-TS)*R1/2.0 
      IF(JCE.EQ.0) WRITE(N6,315) NAMEW,TIME,IFLAG,SMD,F,R1 
      IF(JCE.EQ.1) WRITE(N6,316) KAMEW,TIME,IFLAG,SMD,F,R1 
C======================================================================= 
C     Convergence, return to call point. 
C======================================================================= 
  320 IF(IFLAG.EQ.0) THEN 
                     RLOSS = (F2 - F + FS)/DELT + SVAP 
                     FU    = F2 - F  + FU 
                     F     = F2 
                     IFLAG = 1 
C--- old code        FU    = F2 
                     IF(FU.GT.FUMAX) FU = FUMAX 
                     RETURN 
                     ENDIF 
      GO TO 210 
C======================================================================= 
315   FORMAT(' ===>  Warning, No convergence of Green-Ampt equation. F 
     1or subcat. input # ',I10,' Time =',F9.0,' seconds',/, 
     2 ' IFLAG =',I2,' SMD =',F6.4,' F(ft) =',F7.4,' Rain-Evap(ft/s) =', 
     3 E12.5,' ===>  Assume infil. vol. = half of rain-evap.') 
316   FORMAT(' ===>  Warning, No convergence of Green-Ampt equation. F 
     1or subcat. input name  ',A10,' Time =',F9.0,' seconds',/, 
     2 ' IFLAG =',I2,' SMD =',F6.4,' F(ft) =',F7.4,' Rain-Evap(ft/s) =', 
     3 E12.5,' ===>  Assume infil. vol. = half of rain-evap.') 
C======================================================================= 
      END 
 
 
REM File: GETCUR.FOR 
 
      SUBROUTINE GETCUR(JNO,XFROM,SLOPE,METRIC,KNORM,KCOND, 
cim 3/99 use length on C1 line. 
c     +      AFULL,DEEP,TWFULL,XLEN,RN0,RFULL,NSTOP,IDNUM,KDNUM,KSTOP) 
     +      AFULL,DEEP,TWFULL,XLENIN,RN0,RFULL,NSTOP,IDNUM,KDNUM,KSTOP) 
C     TRANSPORT AND EXTRAN BLOCK 
C======================================================================= 
C     THIS ROUTINE READS THE INPUT FILE AND FINDS 
C     FLOW/COEF CURVES FOR SECTIONS SPECIFIED IN EXTRAN OR TRANSPORT. 
C     A.C. ROWNEY JUNE 1986, UPDATED J. E. SWANSON MARCH 1987 
C     MODIFIED BY R. E. DICKINSON JANUARY, 1988, MAY, 1989. 
C     MODIFIED BY WAYNE C. HUBER, HALLOWEEN, 1991 and August 1992. 
C     MODIFIED BY WCH, 2/24/93 TO CORRECT HYDRAULIC RADIUS CALCULATION 
C      FOR VERTICAL CROSS SECTIONS, AS PER HINTS FROM CHUCK MOORE AT CDM. 
C     MODIFIED BY RED, 6/2/93 FOR USE WITH TRANSPORT BLOCK. 
C     MODIFIED BY WCH (RED), 9/23/93 TO MULTIPLY STCHL ETC. BY PXSECR. 
C     MODIFIED BY WCH, 11/30/93.  IF ROUGHNESS TRANSITION OCCURS EXACTLY 
C      AT VERTICAL SECTION, ASSUME VERTICAL WALL SHOULD HAVE MAIN 
C      CHANNEL ROUGHNESS.  CHANGE IF STATEMENT TO STRICTLY LT AND GT. 
C     MODIFIED BY WCH, 8/25/94.  ANOTHER CORRECTION FOR CASE WHEN 
C      VERTICAL WALL OCCURS AT ROUGHNESS TRANSITION. 
C     RED, 12/16/94.  CORRECTION FOR POWER FUNCTION CHANNELS FOR 
C      INTERMEDIATE SLICE (2-26) AREA CALCULATIONS. 
C     WCH, 2/7/95.  OPTION TO INCREASE NUMBER OF ALLOWABLE CROSS SECTION 
c      POINTS WITH PARAMETER STATEMENT.  LEAVE AT 100 FOR NOW. 
C     CIM, 9/8/00.  Major changes for option of adding additional 
C                   detail for irregular sections in TRANSPORT. 
C                   Move some of calculations to new subroutine IRRSECT. 
C                   Modified check for STCHL and STCHR. 
C     WCH, 7/6/01.  Need top width for new Transport quality calcs. 
C                   Create new QCURVE(NATUR,4,I) array to store 
C                   normalized flows for Transport and use same 
C                   QCURVE(NATUR,3,I) array for top width for both 
C                   Extran and Transport.   
C     WCH, 3/14/02. Add metric fixes for calling from Transport.   
C     WCH, 3/15/02. Check for zero value of XFROM. 
C     WCH, 4/16/02. Allow default for zero SLOPE. 
C     WCH (CIM), 7/20/04. Fix format variable KK for Transport  
C                   output table.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'FLODAT.INC' 
      INCLUDE 'BALINES.INC' 
CIM### 9/9/00 New common block 
      INCLUDE 'NEWTR.INC' 
      CHARACTER KDNUM*10 
C#### WCH, 2/7/95.  INCREASE DIMENSION FROM 100 TO 300. 
C  IF CHANGED, CHANGE IN CHECKSTCH AND IRRSECT ALSO 
      PARAMETER (NXSPTS=100) 
      DIMENSION ELSTA(2,NXSPTS) 
      LOGICAL GOTOO,FAILED,OKL,OKR 
C======================================================================= 
C     JNO      = CONDUIT INPUT ORDER NUMBER FROM EXTRAN OR TRANSPORT 
C     XFROM    = CROSS SECTION IDENTIFICATION NUMBER,OR 
C                POWER FUNCTION EXPONENT 
C     SLOPE    = AVERAGE CHANNEL SLOPE 
C     METRIC   = US CUSTOMARY OR METRIC UNITS 
C     KNORM    = IF 0 - CALLED FROM EXTRAN, IF 1 - CALLED FROM TRANSPORT 
C     KCOND    = IF 0 - READ NATURAL CROSS SECTIONS 
C     KCOND    = IF 1 - CREATE POWER FUNCTION CHANNELS 
C     AFULL    = AREA WHEN CONDUIT IS FULL 
C     DEEP     = MAXIMUM DEPTH 
C     TWFULL   = TOP WIDTH WHEN CONDUIT IS FULL 
C     XLEN     = CONDUIT LENGTH 
C     RN0      = CHANNEL MANNING'S N 
C     RFULL    = HYDRAULIC RADIUS WHEN CONDUIT IS FULL 
C     NSTOP    = NUMBER OF ERRORS 
C     IDNUM    = CONDUIT NUMBER 
C     KDNUM    = CONDUIT NAME 
C     KSTOP    = 0.... PRINT NORMALIZED CURVES 
C     KSTOP    = 1.... DO NOT PRINT NORMALIZED CURVES 
C     NATUR    = NUMBER (SEQUENCE NO.) OF NATURAL CHANNEL AND/OR OF 
C                POWER FUNCTION CHANNEL. PASSED IN FLODAT.INC.  
C======================================================================= 
C     EXTRAN USES EITHER U.S. CUSTOMARY OR METRIC UNITS INTERNALLY. 
C     TRANSPORT USES U.S. CUSTOMARY UNITS INTERNALLY.  BUT TRANSPORT 
C     USES METRIC UNITS WITHIN GETCUR FOR NATURAL SECTIONS, IF METRIC=2. 
C======================================================================= 
      IF(KNORM.EQ.0) KMET = METRIC 
      IF(KNORM.EQ.1) KMET = 1 
C======================================================================= 
C     INITIALIZE AS REQUIRED 
C======================================================================= 
      NQC(JNO)            = NATUR 
      GOTOO               = .FALSE. 
      FAILED              = .FALSE. 
      NUMST               = 0 
      NUMQ(NATUR)         = 26 
      PXSECR              = 1.0 
      POW                 = XFROM 
      QCURVE(NATUR,1,1)   = 0.0 
      QCURVE(NATUR,2,1)   = 0.0 
      QCURVE(NATUR,3,1)   = 0.0 
Cwch, 7/6/01 
      QCURVE(NATUR,4,1)   = 0.0 
      IF(KCOND.EQ.0) XLEN = 0.0 
Cwch, 4/16/02. Does it matter if slope is zero since it's only used 
C     to develop a rating curve?  Try allowing a default of 0.01. 
      IF(KCOND.EQ.0.AND.SLOPE.LE.0.0) THEN 
                                      IF(JCE.EQ.0) WRITE(N6,9600) IDNUM 
                                      IF(JCE.EQ.1) WRITE(N6,9601) KDNUM 
	                                SLOPE = 0.01 
C                                      STOP 
                                      ENDIF 
      RTSLOP              = SQRT(SLOPE) 
      IF(KNORM.EQ.1.AND.KCOND.EQ.0) TWFULL = 0.0 
C======================================================================= 
C FOR POWER FUNCTION CHANNELS, GO RIGHT TO CALCULATIONS. 
C======================================================================= 
      IF(KCOND.EQ.1) GO TO 6666 
C======================================================================= 
C READ CARDS. WHEN NC OR GR CARD IS ENCOUNTERED, INCORPORATE VALUES. 
C             WHEN X1 CARD IS ENCOUNTERED, CHECK IF NAME IS RIGHT. 
C             IF X1 CARD IS OKAY, USE IT. IF NOT, FORGET IT. 
C======================================================================= 
C     READ THE CROSS-SECTION DATA 
C======================================================================= 
C REDUCE LENGTH OF DO LOOP FROM 100000 TO 2200, WCH, 8/28/92 
C####################################################################### 
Cwch, 3/115/02 Follow CIM suggestion re. checking for zero XFROM. 
	IF(XFROM.EQ.0) THEN 
	     WRITE (N6,9005) JNO 
	     WRITE(*,9005)   JNO 
	     NSTOP = NSTOP + 1 
	     ENDIF 
      DO 300 KREAD = 1,2200 
      READ(N5,*,ERR=888,END=9000) CC 
cimbridges 
      IF(CC.EQ.'D1') then 
cimbridges   additional time saving error check 
      write(n6,*) 'ERROR - Cross-section ',XFROM,' was not found' 
      write(n6,*) '        Input data may be missing from', 
     a' cross-section data.' 
      write(n6,*) '        More likely cause is the order of sections', 
     a'        in cross-section cards is not the same as they appear ', 
     b'in the C1 cards.' 
      stop 'Cross-section card not found' 
      endif 
      IF(CC.EQ.'NC'.OR.CC.EQ.'C2'.OR.CC.EQ.'E2') THEN 
           BACKSPACE N5 
           READ(N5,*,ERR=888) CC,XNL,XNR,XNCH 
           IF(XNCH.LE.0.0) WRITE(N6,201) 
           ENDIF 
      RN0 = XNCH 
      IF(XNCH.LE.0.0) WRITE(N6,201) 
      IF(CC.EQ.'X1'.OR.CC.EQ.'C3'.OR.CC.EQ.'E3') THEN 
           BACKSPACE N5 
           READ(N5,*,ERR=888) CC,SECNO,NUMST,STCHL,STCHR, 
     +                                 XLOBL,XLOBR,XLEN,PX,PSXECE 
           IF(SECNO.EQ.XFROM) THEN 
                              GOTOO                = .TRUE. 
                              IF(PX.NE.0.0) PXSECR =  PX 
                              ENDIF 
           ENDIF 
C 
      IF(CC.EQ.'GR'.OR.CC.EQ.'C4'.OR.CC.EQ.'E4'.AND.NUMST.NE.0) THEN 
           BACKSPACE N5 
           DO 210 II = 1,NUMST,5 
           IEND = II + 4 
           IF(IEND.GT.NUMST) IEND = NUMST 
           READ(N5,*,ERR=888) CC,((ELSTA(K,I),K=1,2),I=II,IEND) 
  210      CONTINUE 
cim 9/8/00  check that at least one station matches STCHL and STCHR 
      CALL CHECKSTCH(ELSTA,STCHL,NUMST,'STCHL') 
      CALL CHECKSTCH(ELSTA,STCHR,NUMST,'STCHR') 
C======================================================================= 
C WCH MODIFICATION 
C ALLOW ONLY ONE SET OF C3-C4 LINES, IF DESIRED. 
C BACKSPACE THE NUMBER OF LINES REQUIRED. 
C NREQ = NUMBER OF C4 LINES PLUS ONE C3 LINE. 
C======================================================================= 
C NEW CORRECTION, 8/92, WCH.  BACKSPACE ONLY IF USING 
C  DESIRED C3-C4 LINES. 
C======================================================================= 
          IF(GOTOO) THEN 
                    NREQ = NUMST/5 
                    IF(NREQ*5.LT.NUMST) NREQ = NREQ + 1 
                    NREQ = NREQ + 1 
                    DO 240 J = 1,NREQ 
  240               BACKSPACE N5 
                    ENDIF 
          IF(GOTOO) GO TO 1200 
          ENDIF 
  300 CONTINUE 
C####################################################################### 
C IF ARRIVE HERE, HAVEN'T BEEN ABLE TO FIND MATCH FOR NATURAL CHANNEL. 
C WRITE ERROR MESSAGE.  WCH, 8/28/92 
C####################################################################### 
      WRITE(N6,9040) XFROM, SECNO 
      NSTOP = NSTOP+1 
      RETURN 
C======================================================================= 
C     IRREGULAR CHANNEL CALCS FOR EXTRAN OR TRANSPORT CHANNEL ROUTING. 
C                       TRANSPORT IS NORMALIZED BY AREA. 
C                       EXTRAN IS NORMALIZED BY DEPTH. 
C======================================================================= 
C     MODIFY BY FACTORS ON X1 LINE 
C======================================================================= 
 1200 CONTINUE 
      IF(PXSECR.NE.1.0.OR.PSXECE.NE.0.0) THEN 
                                         DO 1300 I  = 1,NUMST 
                                         ELSTA(2,I) = PXSECR*ELSTA(2,I) 
 1300                                    ELSTA(1,I) = PSXECE+ELSTA(1,I) 
C#### WCH (RED), 9/93. 
C#### RED (WCH), 12/31/93.  SHOULD BE PXSECR, NOT PSXECR 
                                         STCHL      = PXSECR*STCHL 
                                         STCHR      = PXSECR*STCHR 
                                         ENDIF 
C======================================================================= 
C     ALL REQUIRED DATA IN PLACE. CREATE CURVES AS REQUIRED. 
C     DUMMY OUT OVERBANK ROUGHNESS IF IT WAS NOT SPECIFIED. 
C======================================================================= 
      IF(XNR.EQ.0.0) XNR = XNCH 
      IF(XNL.EQ.0.0) XNL = XNCH 
C======================================================================= 
C     FIND MIN AND MAX STAGE POINTS. 
C     CHECK IF STATIONS ARE IN THE WRONG ORDER. 
C======================================================================= 
      ELMIN =  99999.0 
      ELMAX = -99999.0 
      DO 1400 I = 1,NUMST 
      IF(ELSTA(1,I).GT.ELMAX) ELMAX = ELSTA(1,I) 
      IF(ELSTA(1,I).LT.ELMIN) ELMIN = ELSTA(1,I) 
      IF(I.GT.1) THEN 
C#### WCH, 2/24/93.  MAKE ERROR CHECK SLIGHTLY MORE LIBERAL. 
              IF(ELSTA(2,I)-ELSTA(2,I-1).LT.-0.001) FAILED=.TRUE. 
              IF(FAILED) GO TO 9020 
              ENDIF 
 1400 CONTINUE 
C======================================================================= 
C     ESTABLISH RANGE ON CURVES. 
C======================================================================= 
      IF(DEEP.LE.0.0)         DEEP = ELMAX - ELMIN 
      IF(DEEP.GT.ELMAX-ELMIN) DEEP = ELMAX - ELMIN 
      WIDE        = ELSTA(2,NUMST)-ELSTA(2,1) 
      ELDEL       = DEEP/25.0 
cim### 9/8/00 change for transport  detailed output 
      ELEVN        = ELMAX 
C======================================================================= 
C     DO A FEW BASIC CHECKS. 
C======================================================================= 
      IF(XNCH.EQ.0.0) THEN 
                      WRITE(N6,1405) 
                      NSTOP = NSTOP + 1 
                      RETURN 
                      ENDIF 
CIM Change code here to check length against 
CIM length on C1 lines.  Adopt convention that 
CIM length on C1 line should be used.  For now 
CIM stop program run if it doesn't 
c      IF(XLEN.EQ.0.0) THEN 
c                      WRITE(N6,1406) 
c                      NSTOP = NSTOP + 1 
c                      RETURN 
c                      ENDIF 
C======================================================================= 
Cwch 3/14/02.Must worry about metric or not when calling from Transport. 
C     Error found by Sandy Elliot.  
C======================================================================= 
      CMETGET = 1.0 
	IF(KNORM.EQ.1.) CMETGET = CMET(1,METRIC) 
      IF(ABS((XLEN-XLENIN/CMETGET)/XLEN).GT.0.01) THEN 
          IF (KNORM.EQ.0) THEN 
C This is EXTRAN 
             SELECT CASE (IWLEN) 
               CASE (0) 
                 WRITE(N6,7020) XLENIN, XLEN 
                 nstop = nstop + 1 
               CASE (1) 
                 WRITE(N6,7040) XLENIN, XLEN 
                 XLENIN = XLEN 
               CASE (2) 
                 WRITE(N6,7050) XLENIN, XLEN 
             END SELECT 
             ELSE 
C This is TRANSPORT 
Cwch, 3/14/02 
             WRITE(N6,7030) XLENIN/CMETGET, XLEN 
             nstop = nstop + 1 
             ENDIF 
          endif 
      IF(WIDE.EQ.0.0) THEN 
                      WRITE(N6,1407) 
                      NSTOP = NSTOP + 1 
                      RETURN 
                      ENDIF 
      IF(DEEP.EQ.0.0) THEN 
                      WRITE(N6,1408) 
                      NSTOP = NSTOP + 1 
                      RETURN 
                      ENDIF 
      IF(NUMST.LE.1)  THEN 
                      WRITE(N6,1409) 
                      NSTOP = NSTOP + 1 
                      RETURN 
                      ENDIF 
C======================================================================= 
C     FIND STAGES, TOTAL AREAS, FLOWS AND TOP WIDTHS FOR EACH STAGE. 
CIM### 9/8/00  MOVE MUCH OF CALCULATIONS TO SUBROUTINE IRRSECT 
C======================================================================= 
CIM  FIRST CALL FOR FULL CROSS SECTION 
Cwch, 3/14/02. No metric conversions have occured for Transport.  Hence, 
C     use full metric units in IRRSECT.  Use METRIC, not KMET as param.  
      CALL IRRSECT(0,ELDEL,ELMIN,KNORM,TWFULL, 
     .STCHL,STCHR,XNL,XNCH,XNR,NUMST,RTSLOP,METRIC,elsta) 
CIM DO BELOW ONLY IF IDETAIL equals 1 
      IF(IDETAIL.EQ.1) THEN 
CIM  SECOND CALL FOR SECTION BELOW 1/25 AFULL 
cim  linearly interpolate to find first guess for depth 
cim  corresponding to 1/25 afull 
           I = 1 
           AREAT = QCURVE(NATUR,2,26)/25.0 
1500       I = I + 1 
           IF (QCURVE(NATUR,2,I).LE.AREAT) GO TO 1500 
C      WRITE(N6,*) I,AREAT,QCURVE(NATUR,2,I),QCURVE(NATUR,2,I-1) 
           RATIO = (AREAT-QCURVE(NATUR,2,I-1))/ 
     .                    (QCURVE(NATUR,2,I)-QCURVE(NATUR,2,I-1)) 
           DEEP2 = ((I-2)+RATIO)*0.04*DEEP 
cim below iterate to find DEEP2 that matches target area within 0.05% 
           ERRMAX = 0.0005*AREAT 
           ERRMIN = AREAT 
           CLOSEST = 0.0 
           ICOUNT=0 
1505       CONTINUE 
           ELDEL = DEEP2/25.0 
C      WRITE(N6,*) RATIO,DEEP2,ELDEL 
           CALL IRRSECT(1,ELDEL,ELMIN,KNORM,TWFULL2, 
     .       STCHL,STCHR,XNL,XNCH,XNR,NUMST,RTSLOP,METRIC,ELSTA) 
CIM   may need to iterate until qcurv2(natur,2,26) = 1/25 afull 
           EDELTA = AREAT - QCURV2(NATUR,2,26) 
cim      write(n6,*) icount,DEEP2,areat,qcurv2(natur,2,26),edelta 
           IF ((ABS(EDELTA).GT.ERRMAX).AND.(ICOUNT.LT.100)) THEN 
              IF (ABS(EDELTA).LT.ERRMIN) THEN 
                 ERRMIN = ABS(EDELTA) 
                 CLOSEST = DEEP2 
                 ENDIF 
CIM   NEW GUESS FOR DEEP2 
              ICOUNT = ICOUNT + 1 
              IF (ICOUNT.GE.100) THEN 
                 DEEP2 = CLOSEST 
                 GO TO 1505 
                 ENDIF 
              IF (ICOUNT.EQ.1) THEN 
                 SLIPE = 0.0016/(QCURV2(NATUR,2,26)-QCURV2(NATUR,2,25)) 
                 DEEP2OLD = DEEP2 
                 AREAOLD = QCURV2(NATUR,2,26) 
                 DEEP2 = DEEP2 + EDELTA*SLIPE 
                ELSE 
                 IF (QCURV2(NATUR,2,26).NE.AREAOLD) 
     .           SLIPE = (DEEP2-DEEP2OLD)/(qcurv2(natur,2,26)-AREAOLD) 
                 DEEP2OLD = DEEP2 
                 AREAOLD = QCURV2(NATUR,2,26) 
                  ENDIF 
              DEEP2 = DEEP2 + EDELTA*SLIPE 
              GO TO 1505 
              ENDIF 
           ENDIF 
CIM### 9/8/00 End of major changes. 
C======================================================================= 
C======================================================================= 
C     CALCULATE AREA, HYDRAULIC RADIUS, AND TOP WIDTH FOR 
C               POWER FUNCTION CROSS SECTIONS 
C======================================================================= 
C     POWER FUNCTION CHANNELS WILL HAVE SKIPPED NATURAL CROSS SECTION 
C       INPUT AND CALCS. 
C======================================================================= 
 6666 CONTINUE 
C======================================================================= 
C	When called from Transport, metric conversions have already  
C     occured.  Hence, even if METRIC = 2, internal calcs for power- 
C     function channels from Transport are in U.S. units.  
C======================================================================= 
      IF(KCOND.EQ.1) THEN 
           PEW        = 1.0/POW 
           DEPTH      = 0.0 
           DINC       = DEEP/25.0 
           WETPER     = 0.0 
           DO 2500 I  = 2,26 
           DEPTH      = DEPTH + DINC 
           CALL POWER(DEPTH,DEEP,TWFULL,WP,POW,DINC) 
           WETPER = WETPER + WP 
C#### WCH (RED), 12/16/94.  FIX INTERMEDIATE SLICE (2-26) CALCS FOR 
C     POWER FUNCTION CHANNELS. 
C     REMOVE TWFULL FROM AREA CALCULATIONS. 
C####           AREA   = TWFULL*DEPTH*(1.0 - 1.0/(1.0 + POW)) 
           TWIDTH = TWFULL*DEPTH**PEW/DEEP**PEW 
C#### WCH (RED), 12/16/94.  ADD TWIDTH TO AREA CALCULATIONS. 
           AREA   = TWIDTH*DEPTH*(1.0 - 1.0/(1.0 + POW)) 
CIM### 9/8/00 MOVE RADIUS CALC BELOW AREA CALC ??? 
           RADIUS = AREA/WETPER 
           FLOW   = CMET(9,KMET)/RN0*RADIUS**0.666667*RTSLOP*AREA 
           QCURVE(NATUR,1,I) = RADIUS 
           QCURVE(NATUR,2,I) = AREA 
Cwch, 7/6/01. Use same array for top width and new array 4 for flow. 
Cwch           IF(KNORM.EQ.0) QCURVE(NATUR,3,I) = TWIDTH 
Cwch           IF(KNORM.EQ.1) QCURVE(NATUR,3,I) = FLOW 
           QCURVE(NATUR,3,I) = TWIDTH 
           IF(KNORM.EQ.1) QCURVE(NATUR,4,I) = FLOW 
 2500      CONTINUE 
CIM ### 9/8/00 
           IF(KNORM.EQ.1.AND.IDETAIL.EQ.1) THEN 
CIM  This is for added detail below 1/25 of full area 
cim  First find depth that corresponds to 1/25 afull 
              AREAT = QCURVE(NATUR,2,26)/25.0 
cim   solve directly for deep2 that corresponds to Areat 
              PEW        = 1.0/POW 
              DEEP2=((DEEP**PEW*AREAT)/(TWFULL*(1.0 - 1.0/(1.0 + POW)))) 
     1          **(1.0/(1.0+PEW)) 
              DINC2       = DEEP2/25.0 
              TWFULL2= TWFULL*DEEP2**PEW/DEEP**PEW 
cim           AREA   = TWFULL2*DEEP2*(1.0 - 1.0/(1.0 + POW)) 
cim      WRITE(N6,*) deep2,areat,area 
              DEPTH      = 0.0 
              WETPER     = 0.0 
              DO 2550 I  = 2,26 
              DEPTH      = DEPTH + DINC2 
              CALL POWER(DEPTH,DEEP2,TWFULL2,WP,POW,DINC2) 
              WETPER = WETPER + WP 
C#### WCH (RED), 12/16/94.  FIX INTERMEDIATE SLICE (2-26) CALCS FOR 
C     POWER FUNCTION CHANNELS. 
C     REMOVE TWFULL FROM AREA CALCULATIONS. 
C####           AREA   = TWFULL*DEPTH*(1.0 - 1.0/(1.0 + POW)) 
              TWIDTH = TWFULL2*DEPTH**PEW/DEEP2**PEW 
C#### WCH (RED), 12/16/94.  ADD TWIDTH TO AREA CALCULATIONS. 
              AREA   = TWIDTH*DEPTH*(1.0 - 1.0/(1.0 + POW)) 
CIM MOVE RADIUS CALC BELOW AREA CALC. 
              RADIUS = AREA/WETPER 
C 
              FLOW   = CMET(9,KMET)/RN0*RADIUS**0.666667*RTSLOP*AREA 
              QCURV2(NATUR,1,I) = RADIUS 
              QCURV2(NATUR,2,I) = AREA 
              QCURV2(NATUR,3,I) = FLOW 
 2550         CONTINUE 
              ENDIF 
           ENDIF 
CIM### 9/8/00 End of changes for power function. 
C======================================================================= 
C     CALCULATE EQUIVALENT HYDRAULIC RADIUS, 
C     NORMALIZE CURVES, AND FIND MAX VALUES OF AREA AND EQUIV. HYD. RAD. 
C======================================================================= 
Cwch 4/14/02. For natural channels, Transport is working here in  
C     metric.  For power functions, Transport is working here in  
C     U.S. units.  
C======================================================================= 
      IF(KCOND.EQ.0) CONST  =  CMET(9,METRIC)/RN0*RTSLOP 
      IF(KCOND.EQ.1) CONST  =  CMET(9,KMET)/RN0*RTSLOP 
C======================================================================= 
C     Normalization process is independent of U.S. or metric units.  
C     QFULL, AFULL, RFULL etc. are passed to Transport in argument list 
C     of call statement.  For natural channels, convert from metric  
C     to U.S. customary units in Sub. INTRAN, right after call  
C     statement.  For power function channels, no conversion is needed 
C     in Sub. INTRAN.   
C======================================================================= 
      AFULL  =  QCURVE(NATUR,2,26) 
      IF(KNORM.EQ.0) QMAX   =  QCURVE(NATUR,1,26) 
Cwch, 7/6/01. Use new array 4, not 3, for Transport flow.  
      IF(KNORM.EQ.1) QMAX   =  QCURVE(NATUR,4,26) 
      IF(KCOND.EQ.0) RFULL  =  (QMAX/(AFULL*CONST))**1.5 
      IF(KCOND.EQ.1) RFULL  =  QCURVE(NATUR,1,26) 
Cwch, 7/6/01. Save TWFULL for Transport also. 
Cwch      IF(KNORM.EQ.0) TWFULL =  QCURVE(NATUR,3,26) 
      TWFULL =  QCURVE(NATUR,3,26) 
C 
      DO 1600 I = 2,26 
      IF(KCOND.EQ.1) QCURVE(NATUR,1,I) = QCURVE(NATUR,1,I)/RFULL 
      IF(KCOND.EQ.0) THEN 
C======================================================================= 
C NOTE THAT HERE FOR EXTRAN, QCURVE-1 IS CONVERTED FROM FLOW TO HYD RAD. 
Cwch, 7/6/01. For Transport, use QCURVE4 instead of 3.  
C======================================================================= 
           IF(KNORM.EQ.0) QCURVE(NATUR,1,I) = 
     +  ((QCURVE(NATUR,1,I)/(CONST*QCURVE(NATUR,2,I)))**1.5)/RFULL 
           IF(KNORM.EQ.1) QCURVE(NATUR,1,I) = 
     +  ((QCURVE(NATUR,4,I)/(CONST*QCURVE(NATUR,2,I)))**1.5)/RFULL 
           ENDIF 
      QCURVE(NATUR,2,I) = QCURVE(NATUR,2,I)/AFULL 
Cwch      IF(KNORM.EQ.0) QCURVE(NATUR,3,I) = QCURVE(NATUR,3,I)/TWFULL 
Cwch      IF(KNORM.EQ.1) QCURVE(NATUR,3,I) = QCURVE(NATUR,3,I)/QMAX 
      QCURVE(NATUR,3,I) = QCURVE(NATUR,3,I)/TWFULL 
      IF(KNORM.EQ.1) QCURVE(NATUR,4,I) = QCURVE(NATUR,4,I)/QMAX 
 1600 CONTINUE 
CIM### 9/8/00 
CIM   FOR ADDED DETAIL BELOW 1/25 AREA 
cim   NOTE THAT THIS IS NORMALIZED TO AFULL, QMAX, RFULL 
      IF (KNORM.EQ.1.AND.IDETAIL.EQ.1) THEN 
C 
         DO 1650 I = 2,26 
         IF(KCOND.EQ.1) QCURV2(NATUR,1,I) = QCURV2(NATUR,1,I)/RFULL 
         IF(KCOND.EQ.0) THEN 
C======================================================================= 
C NOTE THAT HERE FOR EXTRAN, QCURVE-1 IS CONVERTED FROM FLOW TO HYD RAD. 
C======================================================================= 
            QCURV2(NATUR,1,I) = 
     +  ((QCURV2(NATUR,3,I)/(CONST*QCURV2(NATUR,2,I)))**1.5)/RFULL 
            ENDIF 
         QCURV2(NATUR,2,I) = QCURV2(NATUR,2,I)/AFULL 
         QCURV2(NATUR,3,I) = QCURV2(NATUR,3,I)/QMAX 
 1650    CONTINUE 
         ENDIF 
C====================================================================== 
C     CONVERT TO NORMALIZED AREA IF CALLED BY TRANSPORT 
CIM### 9/8/00   CALCULATIONS MOVED TO SUBROUTINE TRANNORM 
C====================================================================== 
      IF(KNORM.EQ.1) THEN 
CIM  FIRST CALL FOR FULL SECTION 
           CALL TRANNORM(0,DEEP2,DEEP) 
CIM  SECOND CALL FOR SECTION BELOW 1/25 OF AFULL 
           IF (IDETAIL.EQ.1) THEN 
              CALL TRANNORM(1,DEEP2,DEEP) 
cim correct radius, depth, and q for qcurve(natur,*,2) for true, 
cim not interpolate, values at 0.04 afull. 
              QCURVE(NATUR,1,2) = QCURV2(NATUR,1,26) 
              QCURVE(NATUR,2,2) = QCURV2(NATUR,2,26) 
Cwch, 7/6/01              QCURVE(NATUR,3,2) = QCURV2(NATUR,3,26) 
              QCURVE(NATUR,4,2) = QCURV2(NATUR,3,26) 
              ENDIF 
           END IF 
C====================================================================== 
C     PRINT CROSS SECTION OR CONDUIT INFORMATION FOR NATURAL CHANNELS. 
C     THE 100th IRREGULAR STATION POINT IS SET = 0 TO GIVE 
C     CORRECT OUTPUT IN PRINTING ROUTINE. 
C     These prints should be OK for both Extran and Transport since 
C     metric units have not been converted for Transport.   
C====================================================================== 
      IF(KCOND.EQ.0) THEN 
           IF(JCE.EQ.0) WRITE(N6,1690) IDNUM 
           IF(JCE.EQ.1) WRITE(N6,1691) KDNUM 
           WRITE(N6,1696)  XFROM,NATUR 
           IF(METRIC.EQ.1) THEN 
                WRITE(N6,1700) XLEN,ELEVN,SLOPE,DEEP, 
     +                               XNL,STCHL,AFULL,XNCH,RFULL 
                WRITE(N6,1701) XNR,STCHR,TWFULL,QMAX 
                IF(KSTOP.EQ.0) WRITE(N6,1710) NUMST,PSXECE,PXSECR 
                ELSE 
                WRITE(N6,2700) XLEN,ELEVN,SLOPE,DEEP, 
     +                               XNL,STCHL,AFULL,XNCH,RFULL 
                WRITE(N6,2701) XNR,STCHR,TWFULL,QMAX 
                IF(KSTOP.EQ.0) WRITE(N6,2710) NUMST,PSXECE,PXSECR 
                ENDIF 
C 
C CIM HERE CHECK THAT STCHL AND STCHR ARE ELSTA STATIONS 
      OKL = .FALSE. 
	OKR = .FALSE. 
	DO I = 1,NUMST 
	IF (ELSTA(2,I).EQ.STCHL) OKL = .TRUE. 
	IF (ELSTA(2,I).EQ.STCHR) OKR = .TRUE. 
	IF (OKL.AND.OKR) EXIT 
	ENDDO 
	IF (.NOT.OKL) THEN 
	  WRITE(N6,7000) 'LEFT ','STCHL' 
	  NSTOP = NSTOP + 1 
	ENDIF 
	IF (.NOT.OKR) THEN 
	  WRITE(N6,7000) 'RIGHT','STCHR' 
	  NSTOP = NSTOP + 1 
	ENDIF 
C#### WCH, 2/7/95.  CHANGE ELSTA TO VARIABLE DIMENSION. 
C#### REPLACE 100 IN STATEMENTS BELOW BY NXSPTS. 
C#### MAX. TIMES THROUGH LOOP = NXSPTS/5 = ILOPPX 
           ELSTA(1,NXSPTS) = 0.0 
           ELSTA(2,NXSPTS) = 0.0 
           ILOPPX          = NXSPTS/5 
           DO 1303 I    = 1,ILOPPX 
           II           = 5*(I-1)+1 
           III          = 5*(I-1)+2 
           IF(III.GT.NUMST)   III = NXSPTS 
                               IV = 5*(I-1)+3 
           IF(IV.GT.NUMST)     IV = NXSPTS 
                              IIV = 5*(I-1)+4 
           IF(IIV.GT.NUMST)   IIV = NXSPTS 
                             IIIV = 5*(I-1)+5 
           IF(IIIV.GT.NUMST) IIIV = NXSPTS 
           IF(KSTOP.EQ.0) WRITE(N6,1302) (ELSTA(K,II),K=1,2), 
     +                (ELSTA(K,III),K=1,2),(ELSTA(K,IV),K=1,2), 
     +                (ELSTA(K,IIV),K=1,2),(ELSTA(K,IIIV),K=1,2) 
           IF(IIIV.GE.NUMST) GO TO 1304 
 1303      CONTINUE 
 1304      CONTINUE 
           ENDIF 
C====================================================================== 
C     PRINT CONDUIT INFORMATION FOR POWER FUNCTION CHANNELS 
Cwch 3/14/02.  Here, need to back convert to metric for printout when 
C     calling from Transport.  
C====================================================================== 
      IF(KCOND.EQ.1) THEN 
                     CMETGET = 1.0 
	IF(KNORM.EQ.1) CMETGET = CMET(1,METRIC) 
	     IF(JCE.EQ.0) WRITE(N6,2690) IDNUM 
           IF(JCE.EQ.1) WRITE(N6,2691) KDNUM 
           IF(METRIC.EQ.1) THEN 
                WRITE(N6,3700) XLEN,POW,DEEP, 
     +                               RN0,AFULL,RFULL,TWFULL,NATUR 
                ELSE 
                WRITE(N6,3710) XLEN/CMETGET,POW,DEEP/CMETGET, 
     +       RN0,AFULL/CMETGET**2,RFULL/CMETGET,TWFULL/CMETGET,NATUR 
                ENDIF 
           ENDIF 
C======================================================================= 
C     WRITE CROSS SECTION DIMENSIONLESS CURVES 
C======================================================================= 
Cwch, 7/6/01      IF(KNORM.EQ.0.AND.QCURVE(NATUR,3,1).EQ.0.0) 
      IF(QCURVE(NATUR,3,1).EQ.0.0) 
     +                  QCURVE(NATUR,3,1) = QCURVE(NATUR,3,2) 
      IF(KSTOP.EQ.0) THEN 
           IF(KNORM.EQ.0) WRITE(N6,1702) 
           IF(KNORM.EQ.1) WRITE(N6,1703) 
	     KK = 3 
	     IF(KNORM.EQ.1) KK = 4 
           DO 1900 I = 1,8 
           II        = I + 9 
           III       = I + 18 
           WRITE(N6,3333) I,(QCURVE(NATUR,K,I),K=1,KK),II, 
                         (QCURVE(NATUR,K,II),K=1,KK),III, 
                         (QCURVE(NATUR,K,III),K=1,KK) 
 1900      CONTINUE 
           WRITE(N6,3333) 9,(QCURVE(NATUR,K,9),K=1,KK),18, 
                         (QCURVE(NATUR,K,18),K=1,KK) 
CIM### 9/8/00 
C  WRITE ADDITIONAL TABLE FOR DETAILED PART OF CURVE 
           IF(KNORM.EQ.1.AND.IDETAIL.EQ.1) THEN 
CIM 2004 set KK to 3 for this write so correct format 3333 is used.  
Cwch 7/20/04. 
              KK = 3  
              WRITE(N6,1704) 
              WRITE(N6,1705) 
              DO 1920 I = 1,8 
              II        = I + 9 
              III       = I + 18 
              WRITE(N6,3333) I,(QCURV2(NATUR,K,I),K=1,3),II, 
                         (QCURV2(NATUR,K,II),K=1,3),III, 
                         (QCURV2(NATUR,K,III),K=1,3) 
 1920         CONTINUE 
              WRITE(N6,3333) 9,(QCURV2(NATUR,K,9),K=1,3),18, 
                         (QCURV2(NATUR,K,18),K=1,3) 
              ENDIF 
           ENDIF 
CIM### 9/8/00 
C======================================================================= 
      RETURN 
C======================================================================= 
C======================================================================= 
C     PRINT POSSIBLE INPUT ERRORS 
C======================================================================= 
C     DATA COULD NOT BE FOUND 
C======================================================================= 
 9000 CONTINUE 
      WRITE(N6,9010) XFROM 
      NSTOP = NSTOP+1 
      RETURN 
C======================================================================= 
C     DATA INPUT IN WRONG ORDER 
C======================================================================= 
 9020 CONTINUE 
      WRITE(N6,9030) XFROM 
      NSTOP = NSTOP+1 
      RETURN 
  888 CALL IERROR 
C======================================================================= 
  201 FORMAT(/,' ===> WARNING   XNCH LE 0.0.') 
 1302 FORMAT(5(F10.2,2X,F10.2,4X)) 
 1405 FORMAT(/,' ===> ERROR  MANNINGS "N" OF CENTER CHANNEL IS 0.0. 
     +JOB STOPPED.') 
 1406 FORMAT(/,' ===> ERROR  CHANNEL LENGTH IS 0.0.  JOB STOPPED.') 
 1407 FORMAT(/,' ===> ERROR  WIDTH OF CHANNEL IS 0.0.  JOB STOPPED.') 
 1408 FORMAT(/,' ===> ERROR  DEPTH OF CHANNEL IS 0.0.  JOB STOPPED.') 
 1409 FORMAT(/,' ===> ERROR  NUMBER OF DATA POINTS LE 1.  JOB STOPPED 
     +.') 
 1410 FORMAT(/,' ===> ERROR  NATURAL CHANNEL LIMITED TO MAXIMUM OF 
     *50 INTERIOR DEPRESSIONS.  JOB STOPPED.') 
 1690 FORMAT(/,9X,'NATURAL CROSS-SECTION INFORMATION FOR CHANNEL ', 
     +       I10,/,9X,53('=')) 
 1691 FORMAT(/,9X,'NATURAL CROSS-SECTION INFORMATION FOR CHANNEL ', 
     +       A10,/,9X,53('=')) 
 1696 FORMAT(9X,' CROSS-SECTION ID (FROM X1 CARD) : ',F15.2, 
     +          ' CHANNEL SEQUENCE NUMBER :',I6,/) 
 1700 FORMAT(3X,'LENGTH    :',F12.2,' FT ',T55, 
     +          ' MAXIMUM ELEVATION        : ',F10.2,'     FT.',/, 
     +3X,       'SLOPE     :',F12.4,' FT/FT',T55, 
     +          ' MAXIMUM DEPTH            : ',F10.2,'     FT.',/, 
     +3X,       'MANNING N :',F12.3,' TO STATION  ',F10.1,T55, 
     +          ' MAXIMUM SECTION AREA     : ',1PG10.2,' SQ. FT.', 
     +/,3X,'  "    "  :',0PF12.3,' IN MAIN CHANNEL',T55, 
     +' MAXIMUM HYDRAULIC RADIUS : ',F10.2,'     FT.') 
 1701  FORMAT(3X,'  "    "  :',F12.3,' BEYOND STATION',F8.1,T55, 
     +' MAX TOPWIDTH             : ',F10.2,'     FT.',/,T55, 
     +' MAXIMUM UNIFORM FLOW     : ',1PE10.2,' CFS.   ') 
 1702 FORMAT(///,26X,' CROSS-SECTION DIMENSIONLESS CURVES ',/, 
     +           26X,'       NORMALIZED BY DEPTH',/, 
     +      24X,42('-')/ 
     +      3(' POINT  HYDRAULIC                           '),/, 
     +      3('  NO.    RADIUS       AREA     TOPWIDTH     '),/, 
     +      3(' -----  ---------    -----     --------     ')) 
Cwch, 7/6/01 
 1703 FORMAT(//,26X,' CROSS-SECTION DIMENSIONLESS CURVES ',/, 
     +           26X,'       NORMALIZED BY AREA',/, 
     +      24X,42('-')/ 
     +      3(' POINT  HYDRAULIC                                       ' 
     +),/, 
     +      3('  NO.    RADIUS      DEPTH    TOP WIDTH        FLOW     ' 
     +),/, 
     +      3(' -----  ---------     ----     --------     -------     ' 
     +)) 
CIM### 9/8/00 
 1704 FORMAT(//,26x,' DETAILED NORMALIZED CURVE FOR PORTION OF SECTION', 
     +' BELOW 0.04 AFULL',//) 
 1705 FORMAT(//, 
     +      24X,42('-')/ 
     +      3(' POINT  HYDRAULIC                           '),/, 
     +      3('  NO.    RADIUS      DEPTH         FLOW     '),/, 
     +      3(' -----  ---------     ----     --------     ')) 
 1710 FORMAT(//,52X,'CROSS-SECTION POINTS',/, 
     +          51X,'--------------------',/,10X, 
     +'THE FOLLOWING ',I2,' STATIONS WERE READ AND ADJUSTED', 
     +F9.3,' FT VERTICALLY AND HORIZONTALLY BY A RATIO OF ',F6.3,//, 
     +5('   ELEVATION   STATION    '),/, 
     +5('      FT         FT       '),/, 
     +5('   ---------   -------    ')) 
 2690 FORMAT(/,9X,'POWER FUNCTION CROSS-SECTION INFORMATION', 
     +       ' FOR CHANNEL ',I10,/,9X,53('=')) 
 2691 FORMAT(/,9X,'POWER FUNCTION CROSS-SECTION INFORMATION', 
     +       ' FOR CHANNEL ',A10,/,9X,53('=')) 
 2700 FORMAT(3X,'LENGTH    :',F12.1,' METERS.',T55, 
     +' MAXIMUM ELEVATION        : ',F10.2,' METERS.',/, 
     +3X,'SLOPE     :',F12.4,'  M/M ',T55, 
     +' MAXIMUM DEPTH            : ',F10.2,' METERS.',/, 
     +3X,'MANNING N :',F12.3,' TO STATION  ',F10.1,T55, 
     +' MAXIMUM SECTION AREA     : ',1PG10.2,' SQ.MET.', 
     +/,3X,'  "    "  :',0PF12.3,' IN MAIN CHANNEL',T55, 
     +' MAXIMUM HYDRAULIC RADIUS : ',F10.2,' METERS.') 
 2701  FORMAT(3X,'  "    "  :',F12.3,' BEYOND STATION',F8.1,T55, 
     +' MAX TOPWIDTH             : ',F10.2,' METERS.',/,T55, 
     +' MAXIMUM UNIFORM FLOW     : ',1PE10.2,' CMS.   ') 
 2710 FORMAT(//,52X,'CROSS-SECTION POINTS',/, 
     +          51X,'--------------------',/,10X, 
     +'THE FOLLOWING ',I2,' STATIONS WERE READ AND ADJUSTED', 
     +F9.3,'  M VERTICALLY AND HORIZONTALLY BY A RATIO OF ',F6.3,//, 
     +5('   ELEVATION   STATION    '),/, 
     +5('    METERS     METERS     '),/, 
     +5('   ---------   -------    ')) 
Cwch, 7/6/01 3333 FORMAT(3(I3,3F12.4,5X)) 
Cwch  Try CVF "variable format expression" option. Lang.Ref.Manual 11-44. 
 3333 FORMAT(3(I3,<KK>F12.4,5X)) 
 3700 FORMAT(9X,'LENGTH                   :',F12.1,' FEET.',/, 
     +       9X,'EXPONENT OF CHANNEL      :',F12.3,/, 
     +       9X,'MAXIMUM DEPTH            :',F12.2,' FEET.',/, 
     +       9X,'MANNING N                :',F12.3,/, 
     +       9X,'MAXIMUM SECTION AREA     :',F12.2,' SQ. FT.',/, 
     +       9X,'MAXIMUM HYDRAULIC RADIUS :',F12.3,' FEET.',/, 
     +       9X,'MAXIMUM TOP WIDTH        :',F12.2,' FEET.',/, 
     +       9X,'CHANNEL SEQUENCE NUMBER  :',I12) 
 3710 FORMAT(9X,'LENGTH                   :',F12.1,' METERS.',/, 
     +       9X,'EXPONENT OF CHANNEL      :',F12.3,/, 
     +       9X,'MAXIMUM DEPTH            :',F12.2,' METERS.',/, 
     +       9X,'MANNING N                :',F12.3,/, 
     +       9X,'MAXIMUM SECTION AREA     :',F12.2,' SQ.MET.',/, 
     +       9X,'MAXIMUM HYDRAULIC RADIUS :',F12.3,' METERS.',/, 
     +       9X,'MAXIMUM TOP WIDTH        :',F12.2,' METERS.',/, 
     +       9X,'CHANNEL SEQUENCE NUMBER  :',I12) 
Cwch, 3/15/02. 
 9005 FORMAT(/,' ERROR. Value of cross-section ID on Transport E1 line ( 
     1BARREL)',/,' or Extran C1 line (STHETA) is zero for input line:', 
	2I3,/,' Value on E1 or C1 line must be >>numeric<<, not alphanumeri 
	3c',/,' to correspond to SECNO on E3 or C3 or X1 line.',/, 
	4' This is most likely cause of error.') 
 9010 FORMAT(/,' ===> ERROR  FAILURE TO FIND DATA FOR SECTION', 
     +' (',F10.3,')',/,'               JOB ENDED') 
 9011  FORMAT(/,'  ===> ERROR, END OF DATA SET FOUND WHILE READING', 
      'AREA/STAGE DATA AT JUNCTION # ',I10) 
 9012  FORMAT(/,'  ===> ERROR , END OF DATA SET FOUND WHILE READING', 
      'VOLUME/STAGE DATA AT JUNCTION # ',I10) 
 9030 FORMAT(/,' ===> ERROR  STATIONS NOT IN CORRECT SEQUENCE', 
     +' FOR SECTION (',F10.3,')',/,'                JOB ENDED') 
 9040 FORMAT(/,' ===> ERROR  UNABLE TO MATCH NATURAL CHANNEL CROSS SEC 
     *TION DATA FOR CHANNEL',F10.1,/, 
     *'        LAST SECNO (LINE C3) READ WAS',F10.1,' $$ JOB ENDED.') 
Cwch, 4/16/02. 
 9600 FORMAT(/,' ===> ERROR  . CONDUIT SLOPE WAS ZERO', 
     +         ' FOR CONDUIT ',I10,' Assign default of 0.01.') 
 9601 FORMAT(/,' ===> ERROR  . CONDUIT SLOPE WAS ZERO', 
     +         ' FOR CONDUIT ',A10,' Assign default of 0.01.') 
C 9600 FORMAT(/,' ===> FATAL ERROR  . CONDUIT SLOPE WAS ZERO', 
C     +         ' FOR CONDUIT ',I10) 
C 9601 FORMAT(/,' ===> FATAL ERROR  . CONDUIT SLOPE WAS ZERO', 
C     +         ' FOR CONDUIT ',A10) 
 7000 FORMAT(' ERROR - THE STATION OF THE ',A5,' BANK OF THE CHANNEL (', 
     1A5,') DOES NOT CORRESPOND TO A STATION IN THE CROSS SECTION DATA') 
 7020 FORMAT(/,' ===> ERROR  CHANNEL LENGTH ON C1 LINE DOES NOT', 
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/, 
     a         '      LENGTH ON C1 LINE EQUALS      ',F10.3,/, 
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3) 
 7030 FORMAT(/,' ===> ERROR  CHANNEL LENGTH ON E1 LINE DOES NOT', 
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/, 
     a         '      LENGTH ON E1 LINE EQUALS      ',F10.3,/, 
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3) 
 7040 FORMAT(/,' ===> WARNING  CHANNEL LENGTH ON C1 LINE DOES NOT', 
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/, 
     a' LENGTH ON C3/E1 LINE IS USED (IWLEN = 1)',/, 
     a         '      LENGTH ON C1 LINE EQUALS      ',F10.3,/, 
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3) 
 7050 FORMAT(/,' ===> WARNING  CHANNEL LENGTH ON C1 LINE DOES NOT', 
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/, 
     a' LENGTH ON C1 LINE IS USED (IWLEN = 2)',/, 
     a         '      LENGTH ON C1 LINE EQUALS      ',F10.3,/, 
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3) 
C======================================================================= 
      END 
 
REM File: GTCOLD.FOR 
 
      SUBROUTINE GTCOLD(IDO,IGO) 
C	TEMP BLOCK 
C     CALLED BY TEMP NEAR 110 and 112 
C      
C======================================================================= 
C     UPDATED 11/92 BY WCH TO CORRECT TYPO AT APPROX. LINE 91 
C       AND TO ALLOW NO STATION NUMBER FOR USER-DEFINED INPUT 
C     UPDATED 12/92 TO CORRECT DATE PROBLEMS. 
C     UPDATED 9/30/93 TO ALLOW ZERO STATION NUMBER AND BETTER END-OF- 
C       FILE MESSAGE.  WCH. 
C     ENHANCE ERROR MESSAGE FOR READING OF DATA, WCH, 4/18/94. 
C     ALTER IOSTAT NUMBER FOR LAHEY, WCH, 8/5/95. 
C     READ YEARS AS 4-DIGITS, WCH, 3/28/00. 
C     FIX MAJOR UNITS PROBLEM HERE AND IN SUB. TEMP. WCH, 7/27/04. 
C     ADD OPTION TO USE ALL KTYPE VALUES FOR USER INPUT. ALLOWS USER 
C       TO PROVIDE ANY OR ALL THREE OF TEMP, EVAP, OR WIND. WCH, 7/28/04. 
C======================================================================= 
C     THIS PROGRAM READS TWO FORMATS 
C     IFORM = 0 MEANS POST 1980 FORMAT 
C     IFORM = 2 MEANS USER DEFINED FORMAT 
C     IDO   = 0 SEARCH FOR STATION NUMBER 
C     IDO   = 1 READ STATION DATA 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'TEW.INC' 
      INTEGER  DAY,YEAR,STA,FF(8),IVALUE(31) 
      CHARACTER ELMTYP*4,LERR*30 
C======================================================================= 
      IF(IDO.EQ.0)   THEN 
      IF(IFORM.EQ.0) THEN 
C#### WCH, 4/18/94.  ADD IOSTAT 
2              READ(IO,1000,ERR=60,END=440,IOSTAT=IOS) IBUF,ELMTYP, 
     +              NEWYR,NEWMON 
               IF(NEWYR.LT.100) NEWYR = NEWYR + 1900 
C#### WCH, 9/30/93.  ALLOW ZERO STATION NUMBER OPTION HERE TOO. 
               IF(ISTA.GT.0.AND.IBUF.NE.ISTA) GO TO 2 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 2 
               IF(IYBEG(2).NE.0.AND.NEWMON.LT.IYBEG(2)) GO TO 2 
               BACKSPACE IO 
               ISTA = IBUF 
               ENDIF 
C 
      IF(IFORM.EQ.2) THEN 
C####################################################################### 
C WCH, 11/92  CORRECT TO ALLOW NO STATION NO. ENTERED IF F1=0, 
C               AS IN DOCUMENTATION 
C####################################################################### 
               NUMPAR = 6 
               IF(KTYPE.EQ.1.OR.KTYPE.EQ.2) NUMPAR = NUMPAR - 1 
	         IF(KTYPE.EQ.3.OR.KTYPE.EQ.4) NUMPAR = NUMPAR + 1 
	         IF(KTYPE.EQ.6)               NUMPAR = NUMPAR + 2 
               IF(F1.EQ.0)                  NUMPAR = NUMPAR - 1 
C#### WCH, 4/18/94.  ADD IOSTAT 
4              READ(IO,FIRMAT,ERR=60,END=440,IOSTAT=IOS)  
     +             (FF(I),I=1,NUMPAR) 
               IF(F1.NE.0) IBUF = FF(F1) 
               NEWYR  = FF(F2) 
C#### WCH, 12/92.  NEED 2-DIGIT YEAR. 
c              IF(NEWYR.GT.1900) NEWYR = NEWYR - 1900 
               IF(NEWYR.LT.100)  NEWYR = NEWYR + 1900 
               NEWMON = FF(F3) 
               NEWDAY = FF(F4) 
               IF(F1.NE.0.AND.IBUF.NE.ISTA) GO TO 4 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 4 
               IF(IYBEG(2).NE.0.AND.NEWMON.LT.IYBEG(2)) GO TO 4 
               IF(IYBEG(3).NE.0.AND.NEWDAY.LT.IYBEG(3)) GO TO 4 
               BACKSPACE IO 
               ENDIF 
      RETURN 
C#### WCH, 9/30/93.  ADD ALTERNATE END OF FILE MESSAGE. 
  440 WRITE(N6,9440) IO,ISTA,IBUF 
      STOP 
C======================================================================= 
C  ENDIF FOR IDO = 0 
C======================================================================= 
      ENDIF 
C 
      IF(IDO.EQ.1) THEN 
 7    BACKSPACE IO 
      CALL SETZER(BARAY,12,31,-99.0) 
      CALL SETZER(SARAY,12,31,-99.0) 
      CALL SETZER(EARAY,12,31,-99.0) 
      CALL SETZER(WARAY,12,31,-99.0) 
C 
10    CONTINUE 
      IF(IFORM.EQ.0) THEN 
C#### WCH, 4/18/94.  ADD IOSTAT 
         READ(IO,1000,END=40,ERR=60,IOSTAT=IOS) STA,ELMTYP, 
     +             YEAR,MONTH,(IDUM,IDUM,IVALUE(J),J=1,31) 
         IF (YEAR.LT.100) YEAR = YEAR + 1900 
C 
         IF(KTYPE.EQ.0.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX')) 
     +              GO TO 15 
      IF(KTYPE.EQ.1.AND.ELMTYP.EQ.'EVAP') GO TO 15 
      IF(KTYPE.EQ.2.AND.ELMTYP.EQ.'WDMV') GO TO 15 
      IF(KTYPE.EQ.3.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'. 
     +                          OR.ELMTYP.EQ.'EVAP')) GO TO 15 
      IF(KTYPE.EQ.4.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'. 
     +                          OR.ELMTYP.EQ.'WDMV')) GO TO 15 
      IF(KTYPE.EQ.5.AND.(ELMTYP.NE.'EVAP'.OR.ELMTYP.EQ.'WDMV'))GO TO 15 
      IF(KTYPE.EQ.6.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'. 
     +              OR.ELMTYP.EQ.'EVAP'.OR.ELMTYP.EQ.'WDMV')) GO TO 15 
         GO TO 30 
C 
  15     CONTINUE 
         DO 200 K = 1,31 
         IF(IVALUE(K).EQ.-9999) GO TO 200 
         IF(ELMTYP.EQ.'EVAP') EARAY(MONTH,K) = FLOAT(IVALUE(K)) 
         IF(ELMTYP.EQ.'WDMV') WARAY(MONTH,K) = FLOAT(IVALUE(K)) 
         IF(ELMTYP.EQ.'TMIN') SARAY(MONTH,K) = FLOAT(IVALUE(K)) 
         IF(ELMTYP.EQ.'TMAX') BARAY(MONTH,K) = FLOAT(IVALUE(K)) 
  200    CONTINUE 
         ENDIF 
C 
      IF(IFORM.EQ.2) THEN 
C#### WCH 11/92 
C#### WCH, 4/18/94.  ADD IOSTAT 
Cwch, 7/28/04. Allow reading of temperature and/or evap and/or wind. 
         READ(IO,FIRMAT,END=40,ERR=60,IOSTAT=IOS) (FF(I),I=1,NUMPAR) 
         IF(F1.NE.0) STA = FF(F1) 
         YEAR  = FF(F2) 
C#### WCH, 12/92.  NEED 2-DIGIT YEAR. 
c         IF(YEAR.GT.1900) YEAR = YEAR - 1900 
          IF(YEAR.LT.100) YEAR = YEAR + 1900 
         MONTH = FF(F3) 
         DAY   = FF(F4) 
Cwch, 7/28/04         MAXU  = FF(F5) 
         IF(MONTH.LE.0.OR.MONTH.GT.12) GO TO 30 
         IF(DAY.LE.0.OR.DAY.GT.31)     GO TO 30 
Cwch, 7/28/04. More complicated IF statements for multiple input options. 
Cwch	   MINU  = FF(F6) 
C         IF(KTYPE.EQ.0) BARAY(MONTH,DAY) = FLOAT(MAXU) 
C         IF(KTYPE.EQ.0) SARAY(MONTH,DAY) = FLOAT(MINU) 
C         IF(KTYPE.EQ.1) EARAY(MONTH,DAY) = FLOAT(MAXU)*CONV 
C         IF(KTYPE.EQ.2) WARAY(MONTH,DAY) = FLOAT(MAXU)*CONV 
         IF(KTYPE.EQ.0.OR.KTYPE.EQ.3.OR.KTYPE.EQ.4.OR.KTYPE.EQ.6) THEN 
              BARAY(MONTH,DAY) = FLOAT(FF(F5)) 
	        SARAY(MONTH,DAY) = FLOAT(FF(F6)) 
	        ENDIF 
	   IF(KTYPE.EQ.1.OR.KTYPE.EQ.3.OR.KTYPE.EQ.5.OR.KTYPE.EQ.6) 
     1        EARAY(MONTH,DAY) = FLOAT(FF(F7))*CONV 
	   IF(KTYPE.EQ.2.OR.KTYPE.GE.4) 
     1        WARAY(MONTH,DAY) = FLOAT(FF(F8))*CONV 
Cwch, 7/2704. Save units conversion for after print-out.  
C     Convert in Sub. TEMP while placing on interface file. 
C         IF(KUNIT.EQ.1.AND.KTYPE.EQ.0) THEN 
C                   BARAY(MONTH,DAY) = 1.8*BARAY(MONTH,DAY) + 32.0 
C##### 
C WCH, 11/92 CHANGE BARAY TO SARAY 
C##### 
C                   SARAY(MONTH,DAY) = 1.8*SARAY(MONTH,DAY) + 32.0 
C                   ENDIF 
         ENDIF 
C======================================================================= 
C     SKIP IF THE NEW STATION IS NOT THE STATION SELECTED 
C     RETURN IF THE NEW YEAR IS LESS THAN THE SELECTED ENDING YEAR 
C======================================================================= 
30    CONTINUE 
C####################################################################### 
C  WCH, 12/92  RETURN IF LAST DAY OF YEAR. 
C  ALSO CHECK FOR NO ADDITIONAL RECORDS. 
C  END = 40 IN READ MEANS THIS IS LAST YEAR IF REACH END OF FILE. 
C####################################################################### 
      IF(IFORM.EQ.0) DAY = 31 
      IF(MONTH.EQ.12.AND.DAY.EQ.31)  THEN 
C#### WCH, 4/18/94.  ADD IOSTAT 
             IF(IFORM.EQ.0) READ(IO,1000,END=40,ERR=60,IOSTAT=IOS)  
     +             STA,ELMTYP,YEAR,MONTH,(IDUM,IDUM,IVALUE(J),J=1,31) 
             IF (YEAR.LT.100) YEAR = YEAR + 1900 
C#### WCH, 4/18/94.  ADD IOSTAT 
             IF(IFORM.EQ.2) READ(IO,FIRMAT,END=40,ERR=60,IOSTAT=IOS)  
     +             (FF(I),I=1,NUMPAR) 
             IF (FF(F2).LT.100) FF(F2) = FF(F2) + 1900 
C  NOTE, IO BACKSPACED AT BEGINNING OF LOOP FOR IDO = 1 (STATEMENT 7). 
             RETURN 
             ENDIF            
C#### WCH, 11/92 
      IF(IFORM.EQ.2.AND.F1.EQ.0) GO TO 33 
      IF(STA.NE.ISTA)                            GO TO 40 
C####################################################################### 
C  WCH, 12/92 CORRECT WRONG SUBSCRIPTS FOR YEAR AND MONTH 
C  (3) = DAY, (2) = MONTH, (1) = YEAR 
C  ALSO, ALTER THE CHECK FOR ENDING DATE TO CHECK FOR EXACT  
C    DATE FOR IFORM = 2. 
C####################################################################### 
33    IF(IFORM.EQ.2) THEN 
        IF(YEAR.EQ.IYEND(1).AND.MONTH.EQ.IYEND(2).AND.DAY.EQ.IYEND(3))  
     *                                           GO TO 40 
        ENDIF 
      IF(IFORM.EQ.0) THEN 
        IF(YEAR.EQ.IYEND(1).AND.MONTH.GE.IYEND(2)) GO TO 40 
        ENDIF 
      IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))     GO TO 40 
      IF(YEAR.GT.NEWYR)                          RETURN 
      GO TO 10 
C======================================================================= 
C     ENDIF FOR IDO = 1 
C======================================================================= 
      ENDIF 
C======================================================================= 
40    IGO = 1 
      RETURN 
C======================================================================= 
C     ERROR MESSAGE FOR READING INPUT FILE. 
C======================================================================= 
C#### WCH, 4/18/94.  ADD IOSTAT 
C#### WCH, 8/5/95.  ALTER IOS FOR LAHEY. 
60    WRITE(N6,2000) IO,MOD(IOS,256) 
      WRITE(*,2000)  IO,MOD(IOS,256) 
      WRITE(*,2001) 
      BACKSPACE IO 
      READ(IO,3000)  LERR 
      WRITE(N6,3001) LERR 
      STOP 
C======================================================================= 
Cwch, 3/28/00.  Read year as 4 digits. 
C1000 FORMAT(3X,I6,2X,A4,4X,I2,I2,7X,31(2I2,I6,2X)) 
 1000 FORMAT(3X,I6,2X,A4,2X,I4,I2,7X,31(2I2,I6,2X)) 
C#### WCH, 4/18/94.  ADD IOSTAT 
C#### WCH, 8/5/95.  ALTER IOSTAT NUMBER FOR LAHEY. 
 2000 FORMAT(/,' ===> ERROR   READING THE INPUT FILE, UNIT',I3,/, 
     1        '  LAHEY ERROR NUMBER =',I5,/, 
     2        '  EXECUTION STOPS FROM TEMP BLOCK.') 
C#### WCH, 4/18/94 
 2001 FORMAT ('  SEE OUTPUT FILE FOR MORE INFORMATION.') 
 3000 FORMAT(A30) 
 3001 FORMAT(/,' FIRST 30 CHARACTERS OF THE LAST LINE READ ARE: ',/, 
     +         3X,A30 ) 
C#### WCH, 9/30/93. 
 9440 FORMAT (' ERROR FROM TEMP BLOCK.  END OF FILE REACHED ON UNIT', 
     1I3,/,' EITHER ISTA > 0 AND CAN''T FIND MATCHING STATION NUMBER ON  
     2DATA FILE OR ELSE CAN''T FIND CORRECT DATES.',/,' ISTA =',I8, 
     3 ' STA. NO. ON DATA FILE =',I8,/,' RUN STOPPED FROM TEMP BLOCK.') 
C======================================================================= 
      END 
 
 
REM File: GTRAIN.FOR 
 
      SUBROUTINE GTRAIN(IDO,IGO,ILOST,M4) 
C     RAIN BLOCK 
C     CALLED BY RAIN BLOCK AT NUMEROUS LOCATIONS 
C####################################################################### 
C     This program reads 15 versions of precipitation files. 
C     WCH, 3/2/93.  Precautionary IF statement if IHR = 25. 
C     WCH, 8/93.  Add option for recent EarthInfo ASCII files in 
C       Subroutine G9RAIN and misc. corrections. 
C     WCH, 8/93. Add code to ensure 15-min. data are properly placed 
C       on interface file. 
C     WCH, 10/11/93.  Revise input format for IFORM = 4 or 6 for 15-min. 
C       rainfall.  Include calc. of JULDAY when necessary. 
C     WCH, 4/25/94.  Correct computation of Julian date for 15-min. 
C       data for IFORM = 0 and 1. 
C     WCH, 4/26/94.  Major code modifications to permit averaging of 
C       NCDC accumulated rainfall and to list special codes in data. 
C     WCH, 5/24/94.  Fix subscript for FLAG1 for IFORM=1 and remove 
C       ILOOP (no discernable purpose). 
C     WCH, 8/1/95.  Change all station IDs to character from integer. 
C       Also, add new AES format.  No longer compare requested ID with 
C       ID read on data lines to avoid character comparison 
C       complications. 
C     WCH, 8/4/95. Alter IOSTAT number for Lahey. 
C     WCH, 10/2/96.  Add better error path for initial reads of files. 
C     WCH, 12/5/96.  Correct the logic for starting at indicated 
C       beginning year when IFORM = 4 or 6. 
C     WCH, 12/6/96.  Fix averaging process for 15-min. rainfall 
C       for special combinations of hour/minute. 
C     WCH, 11/9/99.  Read year as 4 digits to fix Y2K in several spots.  
C     WCH, 11/22/99. Add Y2K compatibility for AES data.   
C     WCH, 2/9/01.  Reset value of NEND every call to GTRAIN. 
C        Suggested by Nerkez Gavranovic, Sydney, Australia 
C     WCH, 7/28/04. Add option for unformatted read for IFORM=1. 
C####################################################################### 
C     IFORM = 0 NWS POST 1980 TD-3240 FIXED LENGTH FORMAT 
C     IFORM = 1 NWS POST 1980 TD-3240/3260 VARIABLE LENGTH FORMAT 
C     IFORM = 2 NWS PRE-1980 FORMAT 
C			  Note, IFORM = 2 is CANNOT be Y2K compatible.   
C     IFORM = 3 USER-SPECIFIED INPUT FORMAT AND FILE (SUB. G3RAIN) 
C     IFORM = 4 NWS MICROCOMPUTER FORMAT WITH QUOTATION MARKS (RELEASE 
C               B, CONDENSED) 
C               Note, IFORM = 4 CANNOT be Y2K compatible.  
C     IFORM = 5 HOURLY AES PRECIPITATION DATA (OLDER COMPRESSED FORMAT) 
C               Note, IFORM = 5 CANNOT be Y2K compatible. 
C     IFORM = 6 NWS MICROCOMPUTER FORMAT (IFORM=4) WITH APOSTROPHES 
C     IFORM = 7 EARTH INFO NCDC  DISPLAY COMPUTER FORMAT. 
C     IFORM = 8 EARTH INFO ASCII DISPLAY COMPUTER FORMAT. 
C         THE FOLLOWING FOUR OPTIONS ARE IN SUBROUTINE G9RAIN: 
C     IFORM = 9 EARTH INFO UNPROCESSED ASCII OUTPUT FILE - 1993, 15-MIN. 
C     IFORM =10 EARTH INFO UNPROCESSED ASCII OUTPUT FILE - 1993, HOURLY. 
C     IFORM =11 EARTH INFO PROCESSED ASCII FILE - 1993, 15-MIN. 
C     IFORM =12 EARTH INFO PROCESSED ASCII FILE - 1993, HOURLY. 
C 
C     IFORM =13 AES PRECIPITATION DATA (NEWER FORMAT, WITH FLAGS). 
C               Note, IFORM = 13 CANNOT be Y2K compatible. 
C     IFORM =14 HOURLY AES PRECIP. DATA, NEWER FORMAT WITH 4-DIGIT YR. 
C     IFORM =15 15-MIN. AES PRECIP. DATA, NEWER FORMAT WITH 4-DIGIT YR. 
C======================================================================= 
C     IDO   = 0 SEARCH FOR STATION NUMBER 
C     IDO   = 1 READ STATION RAINFALL 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'PRECIP.INC' 
C#### WCH, 8/1/95.  CHANGE STA TO CHARACTER. 
CWCH, 11/22/99. CHANGE XRAIN TO 96 
C####      INTEGER DAY,YEAR,STA,XRAIN(24),IHOUR(100),VALUE(100) 
      INTEGER DAY,YEAR,XRAIN(96),IHOUR(100),VALUE(100) 
      REAL    YRAIN(24) 
      CHARACTER*3 XRA(12),ZIM,BIB,BLK 
      CHARACTER STNAME*20,UNITS*2,CH(50)*1,FLAG1(100)*1,FLAG2(100)*1 
C#### WCH, 8/1/95.  ADD IBUF AND STA. 7/28/04 +ABUF 
      CHARACTER IA*1,IM*1,ICODE*1,ELMTYP*4,SQUOTE*1,IBUF*8,STA*8,ABUF*6, 
     1 ABUF2*2,ABUF3,IBUF2*6,STA6*6 
C#### WCH, 10/11/93 AND 4/26/94 
      CHARACTER*1 M3LINE(50),BLANK,IKODE 
      DATA IM/'M'/,IA/'A'/,ZIM/'0- '/,BIB/'   '/,BLK/'-  '/ 
      DATA SQUOTE/''''/,BLANK/' '/ 
C======================================================================= 
C     First find the correct Rainfall station (IDO = 0) 
C======================================================================= 
      IF(IFORM.EQ.4) THEN 
                     M3 = NSCRAT(3) 
                     IF(M3.EQ.0) CALL ERROR(104) 
                     ENDIF 
      IF(IDO.EQ.0)   THEN 
C#### WCH, 8/1/95. 
      IPRINT = 0 
C======================================================================= 
      IF(IFORM.EQ.0) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
C#### 2              READ(IO,1000,ERR=2,END=40) IBUF,ELMTYP, 
2              READ(IO,1000,ERR=970,END=40,IOSTAT=IOS) IBUF,ELMTYP, 
     +                                    NEWYR,NEWMON,NEWDAY 
                    IF (NEWYR.LT.100) NEWYR = NEWYR + 1900 
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY. 
C####               IF(IBUF.NE.ISTA) GO TO 2 
               IF(IPRINT.EQ.0) THEN 
                    WRITE(N6,990) IBUF,ISTA 
                    WRITE(*,990) IBUF,ISTA 
                    IPRINT = 1 
                    ENDIF 
C 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 2 
               IF(NEWMON.LT.IYBEG(2).AND. 
     +                            NEWYR.EQ.IYBEG(1))    GO TO 2 
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3) 
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 2 
               IF(ELMTYP.EQ.'QPCP') THISTO = 900.0 
               IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0 
               ENDIF 
C======================================================================= 
      IF(IFORM.EQ.1) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
Cwch, 7/28/04. Add option for unformatted file for IFORM=1 
C 3              READ(IO,1060,ERR=970,END=40,IOSTAT=IOS) IBUF,ELMTYP, 
3     IF(IFORM1.EQ.0) READ(IO,1060,ERR=970,END=40,IOSTAT=IOS) IBUF, 
     +                                 ELMTYP,NEWYR,NEWMON,NEWDAY 
	IF(IFORM1.EQ.1) THEN 
C 3123      READ(IO,*,ERR=970,END=3124,IOSTAT=IOS) ABUF 
C     Check first for two extraneous lines at top of file. 
C	     IF(ABUF.EQ.'COOPID'.OR.ABUF.EQ.'------') THEN 
C			  GOTO 3123 
C	          ELSE 
C	          REWIND IO 
C	          ENDIF 
           READ(IO,*,ERR=970,END=3124,IOSTAT=IOS) IBUF2,ABUF2, 
     +                   ELMTYP,ABUF2,NEWYR,NEWMON,NEWDAY 
	     IBUF = IBUF2 
	     ENDIF 
C 
                    IF (NEWYR.LT.100) NEWYR = NEWYR + 1900 
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY. 
C####               IF(IBUF.NE.ISTA) GO TO 3 
               IF(IPRINT.EQ.0) THEN 
                    WRITE(N6,990) IBUF,ISTA 
                    WRITE(*,990) IBUF,ISTA 
                    IPRINT = 1 
                    ENDIF 
C 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 3 
               IF(NEWMON.LT.IYBEG(2).AND. 
     +                            NEWYR.EQ.IYBEG(1))    GO TO 3 
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3) 
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 3 
Cwch, 7/28/04. Can't do 15-min yet with IFORM1=1 
               IF(ELMTYP.EQ.'QPCP'.AND.IFORM.EQ.1) THEN 
	              WRITE(N6,9123) 
	              WRITE(*,9123) 
 9123 FORMAT(/,' ERROR. Sorry, cannot yet read 15-min. unformatted data  
     1with IFORM=-1. Run will have to stop.') 
	               STOP 
	               ENDIF 
               IF(ELMTYP.EQ.'QPCP') THISTO = 900.0 
               IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0 
               ENDIF 
C======================================================================= 
      IF(IFORM.EQ.2) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
4              READ(IO,1040,ERR=970,END=40,IOSTAT=IOS) IBUF,NEWYR, 
     1              NEWMON,NEWDAY 
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900 
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY. 
C####               IF(IBUF.NE.ISTA) GO TO 4 
               IF(IPRINT.EQ.0) THEN 
                    WRITE(N6,990) IBUF,ISTA 
                    WRITE(*,990) IBUF,ISTA 
                    IPRINT = 1 
                    ENDIF 
C 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 4 
               IF(NEWMON.LT.IYBEG(2).AND. 
     +                            NEWYR.EQ.IYBEG(1))    GO TO 4 
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3) 
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 4 
C#### WCH, 8/93. 
               THISTO = 3600.0 
               ENDIF 
C======================================================================= 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. ADD 4-DIGIT YEAR AND 15-MIN. DATA OPTION FOR AES. 
      IF(IFORM.EQ.5.OR.IFORM.GE.13) THEN 
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT. 
7              IF(IFORM.LE.13) READ(IO,1045,ERR=970,END=40,IOSTAT=IOS)  
     1             IBUF,NEWYR,NEWMON,NEWDAY 
	         IF(IFORM.GE.14) READ(IO,1047,ERR=970,END=40,IOSTAT=IOS) 
     1             IBUF,NEWYR,NEWMON,NEWDAY 
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900 
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY. 
C####               IF(IBUF.NE.ISTA) GO TO 7 
               IF(IPRINT.EQ.0) THEN 
                    WRITE(N6,990) IBUF,ISTA 
                    WRITE(*,990) IBUF,ISTA 
                    IPRINT = 1 
                    ENDIF 
C 
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 7 
               IF(NEWMON.LT.IYBEG(2).AND. 
     +                            NEWYR.EQ.IYBEG(1))    GO TO 7 
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3) 
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 7 
C#### WCH, 8/93. 
               THISTO = 3600.0 
CWCH, 11/22/99. ADD 15-MIN OPTION. 
			 IF(IFORM.EQ.15) THISTO = 900.0 
               ENDIF 
C======================================================================= 
      IF(IFORM.EQ.7) THEN 
                     READ(IO,1050,END=40) YEAR 
                     IF(YEAR.GT.1900) THEN 
c                                      YEAR = YEAR - 1900 
                                      ELSE 
                                      BACKSPACE IO 
                                      READ(IO,1051,ERR=40,END=40) YEAR 
c                                      YEAR = YEAR - 1900 
                                      ENDIF 
                    IF (YEAR.LT.100) YEAR = YEAR + 1900 
                     BACKSPACE IO 
                     IBUF   = ISTA 
                     THISTO = 3600.0 
                     NEWYR  = YEAR 
                     ENDIF 
C======================================================================= 
      IF(IFORM.EQ.8) THEN 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1150,ERR=40,END=40) YEAR 
                     BACKSPACE IO 
                     IBUF   = ISTA 
                     IF (YEAR.LT.100) YEAR = YEAR + 1900 
                     NEWYR  = YEAR 
                     THISTO = 3600.0 
                     ENDIF 
C======================================================================= 
C     Read Rainfall lines 1 to 5 for IFORM = 4 and IFORM = 6. 
C======================================================================= 
      IF(IFORM.EQ.4) THEN 
C======================================================================= 
C                    Open rainfall file 
C====================================================================== 
C#### WCH, 8/93.  PERMIT PROCESSED NSCRAT(3) FILE TO BE SAVED. 
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).NE.'SCRT3.UF') 
     +      OPEN(M3,FILE=FFNAME(53),FORM='FORMATTED',STATUS='UNKNOWN') 
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).EQ.'SCRT3.UF') 
     +      OPEN(M3,FORM='FORMATTED',STATUS='SCRATCH') 
                     REWIND M3 
                     WRITE(*,1090) 
                     DO 2000 J = 1,1000000 
                     READ(IO,1080,END=2001) CH 
C======================================================================= 
C                    Change double quotes " in record to single ' 
C                    so that character strings can be read by 
C                    List-Directed I/O 
C======================================================================= 
                     DO 30 I = 1,50 
                     IF(CH(I).EQ.'"') CH(I) = SQUOTE 
   30                CONTINUE 
                     WRITE(M3,1080) CH 
 2000                CONTINUE 
 2001                CONTINUE 
                     REWIND M3 
                     READ(M3,*,ERR=888) LN 
                     READ(M3,*,ERR=888) LN,STNAME 
C#### WCH, 8/1/95.  READ STATION AS INTEGER AND CONVERT. 
                     READ(M3,*,ERR=888) LN,IISTA 
                     WRITE(ISTA,'(I8)') IISTA 
C 
                     READ(M3,*,ERR=888) LN,NEWYR,NEWMON,IEY,IEM 
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900 
                     READ(M3,*,ERR=888) LN,ELMTYP 
c                     NEWYR = NEWYR - 1900 
                     IF(ELMTYP.EQ.'QPCP') THISTO = 900.0 
                     IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0 
                     ENDIF 
      IF(IFORM.EQ.6) THEN 
                     M3 = IO 
                     REWIND M3 
                     READ(M3,*,ERR=888) LN 
                     READ(M3,*,ERR=888) LN,STNAME 
C#### WCH, 8/1/95.  READ STATION AS INTEGER AND CONVERT. 
                     READ(M3,*,ERR=888) LN,IISTA 
                     WRITE(ISTA,'(I8)') IISTA 
C 
                     READ(M3,*,ERR=888) LN,NEWYR,NEWMON,IEY,IEM 
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900 
                     READ(M3,*,ERR=888) LN,ELMTYP 
c                     NEWYR = NEWYR - 1900 
                     IF(ELMTYP.EQ.'QPCP') THISTO = 900.0 
                     IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0 
                     ENDIF 
C======================================================================= 
      ENDIF 
C======================================================================= 
C====> End of IDO = 0 (Executed only once). 
C======================================================================= 
Cwch, 2/9/01  Apparently it is possible to lose value of NEND between  
C     calls to GTRAIN.  So reset value of NEND every call.  Move to 
C     this location between IDO = 0 and IDO = 1. 
C     Suggested by Nerkez Gavranovic, Sydney, Australia 
C####################################################################### 
C    WCH, 8/93.  CHECK FOR COMPATIBILITY OF HYETOGRAPH TIME INTERVALS. 
C####################################################################### 
      IF(HIST.GT.0.0) THEN 
           IF(ABS(HIST-THISTO).GT.0.1) THEN 
                WRITE(N6,9110) THISTO,HIST 
                WRITE(*,9110)  THISTO,HIST 
                STOP 
                ENDIF 
           ELSE 
           HIST = THISTO 
           ENDIF 
C#### WCH, 4/26/94. 
      NEND = 24 
      IF(ABS(HIST-900.0).LE.0.1) NEND = 96 
C======================================================================= 
C     Read the rainfall values (IDO = 1) 
C======================================================================= 
C     CLEAR THIS YEAR'S MATRIX 
C     BACKSPACE FOR A NEW YEAR OR NEW STATION 
C     COMPUTE STARTING DAY NUMBER FOR THIS YEAR 
C======================================================================= 
      IF(IDO.EQ.1) THEN 
C======================================================================= 
C     IF 8 < IFORM < 13, DO ALL CALCULATIONS IN SUB. G9RAIN 
C======================================================================= 
CWCH, 11/22/99. ADD OPTION FOR IFORM .GE.13 
      IF(IFORM.LT.4.OR.IFORM.EQ.5.OR.IFORM.GE.13) BACKSPACE IO 
      CALL SETIA(HOUR,366,27,0) 
cim fix set LIMRN values 11/97 
C     CALL SETIA(RDAY,3000,1,0) 
      CALL SETIA(RDAY,LIMRN,1,0) 
C#### WCH, 4/26/94.  INITIALIZE NEW VARIABLE ACODE. 
      DO 8 I = 1,366 
      DO 8 J = 1,4 
    8 ACODE(I,J) = BLANK 
      IOK    = 0 
C#### WCH, 5/24/94.  DON'T SEE A REASON FOR ILOOP??? 
C####      ILOOP  = 0 
      ILOST  = 1 
      NSTORM = 0 
      IDAST  = KDATE(0,1,NEWYR) 
      IF(NEND.EQ.96) REWIND M4 
C======================================================================= 
C     Read this year's rainfall. 
C======================================================================= 
      IF(IFORM.EQ.7) THEN 
                     READ(IO,1050,ERR=40,END=40) YEAR 
                     IF(YEAR.GT.1900) THEN 
c                                      YEAR = YEAR - 1900 
                                      ELSE 
                                      BACKSPACE IO 
                                      READ(IO,1051,ERR=40,END=40) YEAR 
c                                      YEAR = YEAR - 1900 
                                      ENDIF 
                     IF (YEAR.LT.100) YEAR = YEAR + 1900 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     IBUF  = ISTA 
                     NEWYR = YEAR 
                     IDAST = KDATE(0,1,NEWYR) 
                     ENDIF 
      IF(IFORM.EQ.8) THEN 
                     READ(IO,1150,ERR=40,END=40) YEAR 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     READ(IO,1080,ERR=40,END=40) CH(1) 
                     IBUF  = ISTA 
                     IF (YEAR.LT.100) YEAR = YEAR + 1900 
                     NEWYR = YEAR 
                     IDAST = KDATE(0,1,NEWYR) 
                     ENDIF 
C#### WCH, 4/26/94.  INITIALIZE VARIABLE FOR NEW KODEA OPTION. 
      JDOLD = 0 
C======================================================================= 
10    IF(IFORM.EQ.0) READ(IO,1000,ERR=10,END=40) STA,ELMTYP,YEAR, 
     *               MONTH,DAY,IHR,IRAIN,ICODE 
C#### WCH, 8/93.  ZERO OUT ALL 100 CELLS OF ARRAY 'VALUE'. 
      IF(IFORM.EQ.1) CALL SETIA(VALUE,100,1,0) 
Cwch, 7/28/04 
C      IF(IFORM.EQ.1) READ(IO,1060,ERR=10,END=40) STA,ELMTYP,YEAR, 
      IF(IFORM.EQ.1.AND.IFORM1.EQ.0) READ(IO,1060,ERR=10,END=40)  
     *               STA,ELMTYP,YEAR,MONTH,DAY,NUM,(IHOUR(I), 
     *               VALUE(I),FLAG1(I),FLAG2(I),I=1,NUM) 
      IF(IFORM.EQ.1.AND.IFORM1.EQ.1) THEN 
	     NUM = 24 
	     READ(IO,*,ERR=10,END=40)  
     *     STA6,ABUF2,ELMTYP,ABUF2,YEAR,MONTH,DAY,ABUF3,(IHOUR(I), 
     *               VALUE(I),FLAG1(I),FLAG2(I),I=1,NUM) 
	write(n6,*) STA6,ABUF2,ELMTYP,ABUF2,YEAR,MONTH,DAY,ABUF3, 
     *               (IHOUR(I),VALUE(I),FLAG1(I),FLAG2(I),I=1,NUM) 
	     ENDIF 
      IF(IFORM.EQ.2) READ(IO,1040,ERR=10,END=40) STA,YEAR,MONTH, 
     *               DAY,ICARD,XRA 
      IF(IFORM.EQ.5) READ(IO,1045,ERR=10,END=40) STA,YEAR,MONTH, 
     *               DAY,(XRAIN(I),I=1,24) 
C#### WCH, 8/1/95.  ADD NEW AES FORMAT OPTION. 
      IF(IFORM.EQ.13) READ(IO,1046,ERR=10,END=40) STA,YEAR,MONTH, 
     *               DAY,(XRAIN(I),FLAG1(I),I=1,24) 
CWCH, 11/22/99. ADD TWO NEW AES FORMATS. 
      IF(IFORM.EQ.14) READ(IO,1047,ERR=10,END=40) STA,YEAR,MONTH, 
     *               DAY,(XRAIN(I),FLAG1(I),I=1,24) 
      IF(IFORM.EQ.15) READ(IO,1048,ERR=10,END=40) STA,YEAR,MONTH, 
     *               DAY,(XRAIN(I),FLAG1(I),I=1,96) 
                     IF (YEAR.LT.100) YEAR = YEAR + 1900 
      IF(IFORM.EQ.7) THEN 
                     READ(IO,1085,ERR=49,END=40) MONTH,DAY, 
     +                                           (YRAIN(I),I=1,12) 
                     READ(IO,1095,ERR=10,END=40) (YRAIN(I),I=13,24) 
                     ILOST = 0 
                     IF(IYBEG(1).NE.0.AND.YEAR.LT.IYBEG(1))  GO TO 10 
                     IF(MONTH.LT.IYBEG(2).AND. 
     +                                     YEAR.EQ.IYBEG(1)) GO TO 10 
                     IF(MONTH.LE.IYBEG(2).AND.DAY.LT.IYBEG(3) 
     +                                .AND.YEAR.EQ.IYBEG(1)) GO TO 10 
                     STA   = ISTA 
                     ILOST = 1 
                     ENDIF 
      IF(IFORM.EQ.8) THEN 
                     READ(IO,1155,ERR=40,END=40) MONTH,DAY,XRAIN 
                     STA   = ISTA 
                     ILOST = 0 
                     IF(MONTH.EQ.0) GO TO 10 
                     IF(IYBEG(1).NE.0.AND.YEAR.LT.IYBEG(1))  GO TO 10 
                     IF(MONTH.LT.IYBEG(2).AND. 
     +                                     YEAR.EQ.IYBEG(1)) GO TO 10 
                     IF(MONTH.LE.IYBEG(2).AND.DAY.LT.IYBEG(3) 
     +                                .AND.YEAR.EQ.IYBEG(1)) GO TO 10 
                     ILOST = 1 
                     ENDIF 
C======================================================================= 
C#### 8/1/95.  ADD CHECK FOR ZERO YEAR/MONTH/DAY.  LIKELY CAUSED BY 
C     EXTRA CARRIAGE RETURN AT END OF INPUT ASCII DATA FILE. 
C======================================================================= 
      IF(IFORM.NE.4.AND.IFORM.NE.6) THEN 
           IF(YEAR.LE.0.OR.MONTH.LE.0.OR.DAY.LE.0) THEN 
                WRITE(N6,9655) IO 
                GO TO 40 
                ENDIF 
           ENDIF 
C======================================================================= 
C     NCDC Release B Condensed data. 
C     IFORM = 4 or 6.  Read Rainfall lines 8 and 9 (first column) 
C       for microcomputer format. 
C======================================================================= 
      IF(IFORM.EQ.4.OR.IFORM.EQ.6) THEN 
                     READ(M3,*,END=940,ERR=950,IOSTAT=IOS) LN 
                     IF(LN.EQ.10) GO TO 40 
                     BACKSPACE M3 
C======================================================================= 
C     Here, should be reading data line LN = 8. 
C======================================================================= 
                     READ(M3,*,ERR=950,IOSTAT=IOS) LN,YEAR,MONTH,DAY, 
     1                     UNITS,NR 
                     IF (YEAR.LT.100) YEAR = YEAR + 1900 
CIM    here year 1948 comes over as 948  
CIM    I guess that 2000 will be 000 
                     IF (YEAR.LT.1000) THEN 
	                     IF (YEAR.GT.500) THEN 
	                     YEAR = YEAR + 1000 
	                     ELSE 
	                     YEAR = YEAR + 2000 
	                     ENDIF 
	                 ENDIF 
c                     YEAR    = YEAR - 900 
                     IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND. 
     +               MONTH.GE.IYEND(2).AND.DAY.GT.IYEND(3))  GO TO 40 
                     IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND. 
     +               MONTH.GT.IYEND(2))                      GO TO 40 
                     IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))  GO TO 40 
C======================================================================= 
C      BACKSPACE AND RETURN FOR FIRST ENTRY OF NEXT YEAR IN ORDER 
C      RECORD/ANALYZE DATA FOR PRIOR YEAR AND INCREMENT NEWYR. 
C      BUT ONLY DO IT IF DATA HAVE BEEN FOUND, IOK=1. 
C======================================================================= 
                     IF(YEAR.GT.NEWYR.AND.IOK.EQ.1) THEN 
                                                    BACKSPACE M3 
                                                    RETURN 
                                                    ENDIF 
                     IF(IYBEG(1).NE.0.AND.YEAR.LT.IYBEG(1))  GO TO 55 
                     IF(MONTH.LT.IYBEG(2).AND. 
     +                                     YEAR.EQ.IYBEG(1)) GO TO 55 
                     IF(MONTH.LE.IYBEG(2).AND.DAY.LT.IYBEG(3) 
     +                                .AND.YEAR.EQ.IYBEG(1)) GO TO 55 
C======================================================================= 
C      ALSO BACKSPACE AND RETURN IF THIS IS FIRST DAY OF STARTING YEAR. 
C      IN THIS CASE, NO RAIN WOULD HAVE BEEN READ, IOK=0. 
C      DO THIS IN ORDER TO INCREMENT NEWYR AND GET CORRECT IDAST. 
C======================================================================= 
                     IF(IYBEG(1).NE.0.AND.YEAR.EQ.IYBEG(1) 
     1                  .AND.YEAR.GT.NEWYR.AND.IOK.EQ.0) THEN 
                          IF(MONTH.EQ.IYBEG(2).AND.DAY.EQ.IYBEG(3)) THEN 
                               NEWYR = YEAR 
                               ILOST = 0 
                               BACKSPACE M3 
                               RETURN 
                               ENDIF 
                          ENDIF 
C#### WCH, 5/24/94.  DON'T SEE A REASON FOR ILOOP??? 
C####                     ILOOP   = ILOOP + 1 
C####                     IF(ILOOP.EQ.1)                          GO TO 55 
C======================================================================= 
C     HERE, FINALLY, READ THE ACTUAL PRECIP. VALUES. (DATA LINE LN = 9) 
C     NEED SEPARATE READS FOR HOURLY AND 15-MIN. DATA. 
C======================================================================= 
C#### WCH, 4/26/94. 
C     ALLOW FOR AVERAGING OF NCDC VALUES WITH "A" (ACCUMULATED TOTALS), 
C     OR ELSE THE OPTION FOR USING THAT RAINFALL VALUE LUMPED AT THE 
C     TIME INDICATED FOR THE "A". 
C 
C     KODEA = 0, OLD PROCEDURE.  DON'T INCLUDE ACCUMULATED TOTALS, BUT 
C                DO KEEP A TOTAL AT END OF EVENT SUMMARY. 
C     KODEA = 1, AVERAGE ACCUMULATED TOTAL OVER PRECEDING HOURS SINCE 
C                LAST "A", "I", OR "M" VALUE OR FROM BEGINNING OF DAY. 
C     KODEA = 2, USE ACCUMULATED TOTAL AS RAINFALL AT TIME OF "A". 
C======================================================================= 
C     SAVE OLD TIME FOR KODEA = 1 OPTION. 
C======================================================================= 
                     JD1    = JDATE(DAY,MONTH,YEAR) 
                     JULDAY = JD1 + YEAR*1000 
                     IHROLD = 1 
                     MINOLD = 0 
                     RHOURO = 0.0 
                     MIN    = 0 
                     DO 50 J = 1,NR 
                     IF(NEND.LT.96) READ(M3,*,ERR=960,IOSTAT=IOS) 
     1                       LN,IHR,IRAIN,ICODE 
                     IF(NEND.EQ.96) READ(M3,*,ERR=960,IOSTAT=IOS) 
     1                       LN,IHR,MIN,IRAIN,ICODE 
C####################################################################### 
C  WCH, 3/2/93 AND 10/8/93. 
C  LAST ENTRY IS TOTAL FOR DAY.  SKIP CALCULATIONS FOR THIS CASE. 
C####################################################################### 
                     IF(ICODE.EQ.'0') ICODE = BLANK 
                     IF(J.EQ.NR) THEN 
                          CALL RAINCD(ICODE,JD1) 
                          GO TO 50 
                          ENDIF 
                     IF(IRAIN.GE.99999) THEN 
                                        IRAIN = 0 
                                        ICODE = IM 
                                        IF(KODEA.EQ.1) THEN 
C======================================================================= 
C    HERE, SAVE ENDING TIME OF MISSING RAINFALL VALUE, FOR HOURLY DATA 
C======================================================================= 
C#### WCH, 12/6/96. SEVERAL REPLACED STATEMENTS UP TO COMMENT OF 4/26/94 
                                           IF(NEND.EQ.24) THEN 
                                               IHROLD = IHR 
                                               MINOLD = 0 
                                               RHOURO = FLOAT(IHR)*3600. 
                                               ELSE 
C======================================================================= 
C    HERE, SAVE STARTING TIME OF MISSING RAINFALL VALUE, FOR 15-MIN DATA 
C======================================================================= 
                                               IHRSO  = IHR 
                                               MINOLD = MIN - 15 
                                               IF(MINOLD.EQ.-15) THEN 
                                                  MINOLD = 45 
                                                  IHRSO  = IHRSO - 1 
                                                  ENDIF 
                                               IHROLD = IHRSO + 1 
                                               RHOURO = FLOAT(IHRSO)* 
     1                                          3600.+FLOAT(MINOLD)*60. 
                                               ENDIF 
                                           ENDIF 
                                        ENDIF 
C####################################################################### 
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT. 
C======================================================================= 
                     CALL RAINCD(ICODE,JD1) 
                     IOK   = 1 
                     ILOST = 1 
                     IDAY  = KDATE(DAY,MONTH,YEAR) - IDAST 
C#### WCH, 8/93 
C======================================================================= 
C#### WCH, 12/6/96.  NEED TO COMPUTE IHRS AND RECOMPUTE MIN EVEN IF 
C     THERE IS NO RAIN, IN EVENT THEY ARE NEEDED FOR AVERAGING OF 
C     ACCUMULATED DATA.  SO, PUT IRAIN GT OR EQ 0 CHECKS INSIDE LOOP 
C     FOR NEND.EQ.96 (15 MIN DATA). 
C======================================================================= 
C####                     IF(NEND.EQ.96.AND.IRAIN.GT.0) THEN 
                     IF(NEND.EQ.96) THEN 
C======================================================================= 
C  FOR 15-MIN. DATA, COMPUTE STARTING HOUR AND MINUTE (IHRS, 0-23 AND 
C    MIN, 0-45) AND ENDING HOUR (IHR, 1-24). 
C    RELEASE-B CONDENSED HAS HOURS GOING FROM 0-24 AND MINUTES 
C    FROM 0 - 45.  SMALLEST TIME SHOULD BE HR=0 AND 
C    MIN=15 AND LARGEST TIME SHOULD BE HR = 24 AND MIN = 0.  HOWEVER 
C    PROTECT AGAINST POSSIBILITY OF HR = 0 AND MIN = 0 IN CODE AND 
C    AGAINST POSSIBILITY OF HR = 24 AND MIN > 0. 
C    NOTE THAT TIMES IN DATA (IHR,MIN) ARE ENDING TIMES OF RAINFALL. 
C======================================================================= 
                        IHRS = IHR 
                        MIN = MIN - 15 
                        IF(MIN.EQ.-15) THEN 
                             MIN = 45 
                             IHRS = IHRS - 1 
                             ENDIF 
                        IHR  = IHRS + 1 
                        JPJDAY = JULDAY 
C#### WCH, 10/8/93.  WORRY ABOUT RAIN ENDING EXACTLY AT MIDNITE AND IHR=0. 
C#### JUST IN CASE HR=0 AND MIN=0 START SHOWING UP ON INPUT DATA: 
                        IF(IHRS.EQ.-1.AND.MIN.EQ.45) THEN 
                           IHR  = 1 
                           IHRS = 23 
                           IF(JULDAY-(JULDAY/1000)*1000.GT.1) THEN 
                               JPJDAY = JPJDAY - 1 
                               ELSE 
                               JPJDAY = JDATE(31,12,YEAR-1) + 
     1                                   (YEAR-1)*1000 
                               ENDIF 
                           ENDIF 
                        RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0 
C======================================================================= 
C#### WCH, 12/6/96.  HERE, PUT IN CHECK FOR RAIN OR NO RAIN. 
C======================================================================= 
                        IF(IRAIN.GT.0) THEN 
C======================================================================= 
C  IF KODEA = 1, PLACE AVERAGE ON FILE DURING INTERVENING HOURS. 
C  NOTE, EXTRA AVERAGING INTERVAL IS ADDED IN SUB. RAINAVG TO ACCOUNT 
C  FOR GETTING TO END OF CURRENT INTERVAL THAT CONTAINS "A" CODE. 
C======================================================================= 
                             IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN 
                                CALL RAINAVG(RHOUR,RHOURO,JPJDAY, 
     1                            IDAY,IHROLD,MINOLD,NEND,IRAIN,M4) 
                                ICODE = ' ' 
C======================================================================= 
C  PLACE 15-MIN. PRECIP. VALUE ON SCRATCH FILE IN UNITS OF INCHES/HOUR. 
C======================================================================= 
                                ELSE 
                                REIN  = FLOAT(IRAIN)/100.0/0.25 
                                WRITE(M4) JPJDAY,RHOUR,THISTO,REIN 
                                HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN 
                                ENDIF 
C 
C#### WCH, 12/6/96. 
C####                    ELSE IF(NEND.EQ.96) THEN 
C####                    IHR = IHR + 1 
                             ELSE IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN 
C####                    RHOURO = FLOAT(IHR-1)*3600.+FLOAT(MIN)*60. 
C======================================================================= 
C     HERE HAVE ACCUMULATION CODE ("A") BUT NO RAIN.  UNLIKELY, BUT 
C     POSSIBLE. 
C======================================================================= 
                                  RHOURO = RHOUR 
                                  IHROLD = IHR 
                                  MINOLD = MIN 
                                  ENDIF 
                        ENDIF 
C======================================================================= 
C#### WCH, 10/8/93.  RECOGNIZE POSSIBLE ERROR WHEN 15-MIN RAINFALL ENDS 
C       AT MIDNIGHT.  PREVIOUS 15-MIN INCREMENT COUNTED IN FIRST HOUR 
C       OF NEXT DAY FOR PRINT-OUT OF HOURLY TOTALS, ONLY.  SHOULD BE 
C       CORRECT ON PRECIPITATION INTERFACE FILE. 
C======================================================================= 
                     IF(IHR.GT.24) IHR = 24 
                     IF(NEND.EQ.24) THEN 
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA 
     1                              .AND.IRAIN.GT.0) THEN 
C======================================================================= 
C     SUBTRACT HOUR FROM END HOUR BECAUSE EXTRA INTERVAL IS ADDED IN 
C     SUB. RAINAVG. 
C======================================================================= 
                           RHOUR = FLOAT(IHR-1)*3600. 
                           CALL RAINAVG(RHOUR,RHOURO,JPJDAY, 
     1                       IDAY,IHROLD,MINOLD,NEND,IRAIN,M4) 
                           ICODE = ' ' 
                           ELSE 
                           HOUR(IDAY,IHR) = IRAIN + HOUR(IDAY,IHR) 
                           ENDIF 
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA.AND. 
     1                                          IRAIN.EQ.0) THEN 
                           RHOURO = FLOAT(IHR)*3600. 
                           IHROLD = IHR 
                           ENDIF 
                        ENDIF 
C======================================================================= 
C                    Special codes for missing rainfall. 
C======================================================================= 
                     IF(ICODE.EQ.IA.AND.KODEA.EQ.0) THEN 
                                     HOUR(IDAY,IHR) = -2 
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV 
                                     ENDIF 
C#### WCH, 12/6/96.  DON'T DO THIS FOR 15-MIN DATA. 
                     IF(NEND.EQ.24.AND.ICODE.EQ.IM) HOUR(IDAY,IHR) = -1 
   50                CONTINUE 
                     GO TO 52 
C======================================================================= 
C     Here if need to read data to advance file before arriving at 
C     desired start time. 
C======================================================================= 
   55                CONTINUE 
                     ILOST = 0 
                     IF(YEAR.GT.NEWYR) THEN 
                                       NEWYR = YEAR 
                                       BACKSPACE M3 
                                       RETURN 
                                       ENDIF 
                     DO 51 J = 1,NR 
C#### WCH, 10/8/93.  NEED SEPARATE READS FOR HOURLY AND 15-MIN. 
                     IF(NEND.LT.96) READ(M3,*,ERR=950,IOSTAT=IOS) 
     1                    LN,IHR,IRAIN,ICODE 
                     IF(NEND.EQ.96) READ(M3,*,ERR=950,IOSTAT=IOS) 
     1                    LN,IHR,MIN,IRAIN,ICODE 
   51                CONTINUE 
                     NEWYR = YEAR 
                     IDAST = KDATE(0,1,NEWYR) 
   52                CONTINUE 
                     ENDIF 
C======================================================================= 
C     Check for same station.     Check for same year. 
C     Add to this year's matrix.  Find the day number and indicate 
C                                 unusual conditions. 
C     Hour =  -2 means meter stuck. 
C     Hour =  -1 means missing data. 
C======================================================================= 
      IF((IFORM.EQ.4.OR.IFORM.EQ.6).AND.IOK.EQ.0)  GO TO 10 
      IF((IFORM.EQ.4.OR.IFORM.EQ.6).AND.IOK.EQ.1)  GO TO 777 
C#### WCH, 8/1/95.  ELIMINATE THIS CHECK. 
C####      IF(STA.NE.ISTA) GO TO 40 
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GE.IYEND(2) 
     *                   .AND.DAY.GT.IYEND(3))   GO TO 40 
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GT.IYEND(2)) 
     *                                           GO TO 40 
      IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))     GO TO 40 
      IF(YEAR.GT.NEWYR)                          RETURN 
      IDAY = KDATE(DAY,MONTH,YEAR) - IDAST 
C======================================================================= 
C#### WCH, 8/1/95.  ADD CHECK FOR SUBSCRIPT. 
      IF(IDAY.LE.0.OR.IDAY.GT.366) THEN 
           WRITE(N6,9660) IDAY,YEAR,MONTH,DAY,NEWYR 
           WRITE (*,9660) IDAY,YEAR,MONTH,DAY,NEWYR 
           GO TO 40 
           ENDIF 
C======================================================================= 
C     Special codes for new format of rainfall. 
C======================================================================= 
C     NCDC, TD-3240, fixed length records (one rainfall value per line). 
C======================================================================= 
      IF(IFORM.EQ.0) THEN 
C======================================================================= 
C     SAVE OLD TIME FOR KODEA = 1 OPTION. 
C======================================================================= 
                     JD1   = JDATE(DAY,MONTH,YEAR) 
                     JDNEW = JD1 + YEAR*1000 
                     IF(KODEA.EQ.1) THEN 
                        IF(JDNEW.GT.JDOLD.OR.JD1.EQ.1) THEN 
                           IHROLD = 1 
                           MINOLD = 0 
                           RHOURO = 0.0 
                           JDOLD  = JDNEW 
                           ENDIF 
                        ENDIF 
C 
                     IF(IRAIN.GE.99999) THEN 
                              IRAIN = 0 
                              ICODE = IM 
                              IF(KODEA.EQ.1) THEN 
C======================================================================= 
C    HERE, SAVE ENDING TIME OF MISSING RAINFALL VALUE, FOR HOURLY DATA 
C======================================================================= 
C#### WCH, 12/6/96. SEVERAL REPLACED STATEMENTS UP TO COMMENT OF 4/26/94 
                                   IF(NEND.EQ.24) THEN 
                                       IHROLD = IHR 
                                       MINOLD = 0 
                                       RHOURO = FLOAT(IHR)*3600. 
                                       ELSE 
C======================================================================= 
C    HERE, SAVE STARTING TIME OF MISSING RAINFALL VALUE, FOR 15-MIN DATA 
C======================================================================= 
                                       IHRSO  = IHR/100 
                                       MINOLD = IHR - (IHR/100)*100 - 15 
                                       IF(MINOLD.EQ.-15) THEN 
                                            MINOLD = 45 
                                            IHRSO  = IHRSO - 1 
                                            ENDIF 
                                       IHROLD = IHRSO + 1 
                                       RHOURO = FLOAT(IHRSO)* 
     1                                     3600.+FLOAT(MINOLD)*60. 
                                       ENDIF 
                                   ENDIF 
                              ENDIF 
C####################################################################### 
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT. 
C======================================================================= 
                     CALL RAINCD(ICODE,JD1) 
C#### WCH, 8/93 
C#### WCH, 12/6/96.  CHECK FOR IRAIN.GT.0 LATER. 
C####                     IF(NEND.EQ.96.AND.IRAIN.GT.0) THEN 
                     IF(NEND.EQ.96) THEN 
C======================================================================= 
C  FOR 15-MIN. DATA, COMPUTE STARTING HOUR AND MINUTE (IHRS, 0-23 AND 
C    MIN, 0-45) AND ENDING HOUR (IHR, 1-24) 
C  FORM OF IHR IS HRMN WHERE HR = HOUR, FROM 0 - 24, AND MN = MIN, E.G., 
C    0045, 1530, 2300.  THIS IS END TIME OF RAINFALL VALUE. 
C======================================================================= 
                        MIN  = IHR - (IHR/100)*100 - 15 
                        IHRS = IHR/100 
                        IF(MIN.LT.0) THEN 
                           MIN  = 45 
                           IHRS = IHRS - 1 
                           ENDIF 
                        IHR  = IHRS + 1 
C#### WCH, 12/6/96.  NEED TO COMPUTE RHOUR HERE. 
                        RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0 
                        IF(IRAIN.GT.0) THEN 
C#### WCH, 4/25/94.  DON'T SUBTRACT 1900 FROM YEAR.  ALREADY 2-DIGIT. 
                           JULDAY = JDATE(DAY,MONTH,YEAR) 
     1                                 + YEAR*1000 
C####                RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0 
C======================================================================= 
C  IF KODEA = 1, PLACE AVERAGE ON FILE DURING INTERVENING HOURS. 
C======================================================================= 
                           IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN 
                                CALL RAINAVG(RHOUR,RHOURO,JULDAY, 
     1                           IDAY,IHROLD,MINOLD,NEND,IRAIN,M4) 
                                ICODE = ' ' 
                                JDOLD = JULDAY 
C======================================================================= 
C  PLACE 15-MIN. PRECIP. VALUE ON SCRATCH FILE IN UNITS OF INCHES/HOUR. 
C======================================================================= 
                                ELSE 
                                REIN  = FLOAT(IRAIN)/100.0/0.25 
                                WRITE(M4) JULDAY,RHOUR,THISTO,REIN 
                                HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN 
                                ENDIF 
C#### WCH, 12/6/96 
C####                           ENDIF 
C####                        ELSE IF(NEND.EQ.96.AND.KODEA.EQ.1.AND. 
C####     1                            ICODE.EQ.IA) THEN 
                           ELSE IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN 
                                   IHROLD = IHR 
                                   MINOLD = MIN 
C####                   RHOURO = FLOAT(IHRS)*3600.+FLOAT(MIN)*60. 
                                   RHOURO = RHOUR 
                                   ENDIF 
                           ENDIF 
C======================================================================= 
C  ALLOW AVERAGING OF HOURLY RAINFALL ALSO. 
C======================================================================= 
                     IF(NEND.EQ.24) THEN 
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA 
     1                             .AND.IRAIN.GT.0) THEN 
                           RHOUR = FLOAT(IHR-1)*3600. 
                           CALL RAINAVG(RHOUR,RHOURO,JDNEW, 
     2                          IDAY,IHROLD,MINOLD,NEND,IRAIN,M4) 
                           ICODE = ' ' 
                           JDOLD = JDNEW 
                           ELSE 
                           HOUR(IDAY,IHR) = IRAIN + HOUR(IDAY,IHR) 
                           ENDIF 
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN 
                           RHOURO = FLOAT(IHR)*3600. 
                           IHROLD = IHR 
                           JDOLD = JDNEW 
                           ENDIF 
                        ENDIF 
C 
                     IF(ICODE.EQ.IA.AND.KODEA.EQ.0) THEN 
                                     HOUR(IDAY,IHR) = -2 
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV 
                                     ENDIF 
C#### WCH, 12/6/96.  DON'T DO THIS FOR 15-MIN DATA. 
                     IF(NEND.EQ.24.AND.ICODE.EQ.IM) HOUR(IDAY,IHR) = -1 
                     ENDIF 
C======================================================================= 
C     NCDC TD-3240/3260, variable length records (data for all hours on 
C     one line).  This format is also for "NCDC format" for exporting 
C     of data from EarthInfo and Hydrosphere CD-ROMs. 
C======================================================================= 
      IF(IFORM.EQ.1) THEN 
                     IF(KODEA.EQ.1) THEN 
                        IHROLD = 1 
                        MINOLD = 0 
                        RHOURO = 0.0 
                        ENDIF 
                     ICODE = ' ' 
C#### WCH, 12/6/96.  PLACE THIS DATE CALCULATION OUTSIDE LOOP. 
                     JD1 = JDATE(DAY,MONTH,YEAR) 
                     JULDAY = JD1 + YEAR*1000 
C 
                     DO 8000 I = 1,NUM 
                     IRAIN     = VALUE(I) 
                     IF(IRAIN.GE.99999) THEN 
                              IRAIN = 0 
                              ICODE = IM 
                              IF(KODEA.EQ.1) THEN 
C======================================================================= 
C    HERE, SAVE ENDING TIME OF MISSING RAINFALL VALUE, FOR HOURLY DATA 
C======================================================================= 
C#### WCH, 12/6/96. SEVERAL REPLACED STATEMENTS UP TO COMMENT OF 4/26/94 
                                   IF(NEND.EQ.24) THEN 
                                       IHR    = IHOUR(I)/100 
                                       IHROLD = IHR 
                                       MINOLD = 0 
                                       RHOURO = FLOAT(IHR)*3600. 
                                       ELSE 
C======================================================================= 
C    HERE, SAVE STARTING TIME OF MISSING RAINFALL VALUE, FOR 15-MIN DATA 
C======================================================================= 
                                       IHR   = IHOUR(I) 
                                       IHRSO = IHR/100 
                                       MINOLD = IHR - (IHR/100)*100 - 15 
                                       IF(MINOLD.EQ.-15) THEN 
                                            MINOLD = 45 
                                            IHRSO  = IHRSO - 1 
                                            ENDIF 
                                       IHROLD = IHRSO + 1 
                                       RHOURO = FLOAT(IHRSO)* 
     1                                     3600.+FLOAT(MINOLD)*60. 
                                       ENDIF 
                                   ENDIF 
                              ENDIF 
C####################################################################### 
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT. 
C======================================================================= 
                     IKODE = BLANK 
                     IF(ICODE.NE.BLANK)    IKODE = ICODE 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
                     IF(FLAG1(I).NE.BLANK) IKODE = FLAG1(I) 
                     CALL RAINCD(IKODE,JD1) 
                     IF(I.EQ.NUM) GO TO 8000 
C####################################################################### 
C  WCH, 8/93,  Need to perform this time calculation for both 15-min. 
C    and hourly data because IHOUR is of form HRMN, e.g., 
C    2330, 0015, etc. 
C####################################################################### 
                     IHR  = IHOUR(I) 
                     MIN  = IHR - (IHR/100)*100 - 15 
                     IHRS = IHR/100 
                     IF(MIN.LT.0) THEN 
                        MIN  = 45 
                        IHRS = IHRS - 1 
                        ENDIF 
                     IHR  = IHRS + 1 
C#### WCH, 12/6/96.  CHECK FOR ZERO RAIN LATER. 
                     IF(NEND.EQ.96) THEN 
C####                     IF(NEND.EQ.96.AND.IRAIN.GT.0) THEN 
C#### WCH, 4/25/94.  DON'T SUBTRACT 1900 FROM YEAR.  ALREADY 2-DIGIT. 
                          RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0 
C======================================================================= 
C  IF KODEA = 1, PLACE AVERAGE ON FILE DURING INTERVENING HOURS. 
C======================================================================= 
C#### WCH, 12/6/96 
                          IF(IRAIN.GT.0) THEN 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
                             IF(KODEA.EQ.1.AND.FLAG1(I).EQ.IA) THEN 
                                 CALL RAINAVG(RHOUR,RHOURO,JULDAY, 
     1                             IDAY,IHROLD,MINOLD,NEND,IRAIN,M4) 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
                                 FLAG1(I) = ' ' 
                                 JDOLD = JULDAY 
C======================================================================= 
C  PLACE 15-MIN. PRECIP. VALUE ON SCRATCH FILE IN UNITS OF INCHES/HOUR. 
C======================================================================= 
                                 ELSE 
                                 REIN  = FLOAT(IRAIN)/100.0/0.25 
                                 WRITE(M4) JULDAY,RHOUR,THISTO,REIN 
                                 HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN 
                                 ENDIF 
C 
C#### WCH, 12/6/96 
                             ELSE IF(FLAG1(I).EQ.IA.AND.KODEA.EQ.1) THEN 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
C####                        ELSE IF(NEND.EQ.96.AND.FLAG1(I).EQ.IA.AND. 
C####     1                      KODEA.EQ.1) THEN 
                                 IHROLD = IHR 
                                 MINOLD = MIN 
C####                   RHOURO = FLOAT(IHRS)*3600.+FLOAT(MIN)*60. 
                                 RHOURO = RHOUR 
                                 ENDIF 
                          ENDIF 
C======================================================================= 
C  ALLOW AVERAGING OF HOURLY RAINFALL ALSO. 
C======================================================================= 
                     IF(NEND.EQ.24) THEN 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
                        IF(KODEA.EQ.1.AND.FLAG1(I).EQ.IA 
     1                                 .AND.IRAIN.GT.0) THEN 
                           RHOUR = FLOAT(IHR-1)*3600. 
                           CALL RAINAVG(RHOUR,RHOURO,JDNEW, 
     1                          IDAY,IHROLD,MINOLD,NEND,IRAIN,M4) 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
                           FLAG1(I) = ' ' 
                           ELSE 
                           HOUR(IDAY,IHR) = IRAIN + HOUR(IDAY,IHR) 
                           ENDIF 
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1(). 
                        IF(KODEA.EQ.1.AND.FLAG1(I).EQ.IA) THEN 
                           RHOURO = FLOAT(IHR)*3600. 
                           IHROLD = IHR 
                           ENDIF 
                        ENDIF 
C 
                     IF(FLAG1(I).EQ.IA.AND.KODEA.EQ.0) THEN 
                                     HOUR(IDAY,IHR) = -2 
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV 
                                     ENDIF 
C#### WCH, 12/6/96.  DON'T DO THIS FOR 15-MIN DATA. 
                     IF(NEND.EQ.24.AND.ICODE.EQ.IM) HOUR(IDAY,IHR) = -1 
 8000                CONTINUE 
                     ENDIF 
C======================================================================= 
C     NWS Card Deck 488 format. 
C     Special codes for old format of rainfall. 
C======================================================================= 
      IF(IFORM.EQ.2) THEN 
                     IF(ICARD.EQ.1) J1 =  0 
                     IF(ICARD.EQ.2) J1 = 12 
                     DO 35 J = 1,12 
                     IF(XRA(J).EQ.ZIM) THEN 
                                       HOUR(IDAY,J+J1) = -2 
C#### WCH, 4/26/94. 
                             CALL RAINCD(IA,IDAY) 
                                       GO TO 35 
                                       ENDIF 
                     IF(XRA(J).EQ.BIB) THEN 
                                       HOUR(IDAY,J+J1) = -1 
C#### WCH, 4/26/94. 
                             CALL RAINCD(IM,IDAY) 
                                       GO TO 35 
                                       ENDIF 
                     IF(XRA(J).EQ.BLK) THEN 
                                       HOUR(IDAY,J+J1) = 0 
                                       GO TO 35 
                                       ENDIF 
                     HOUR(IDAY,J+J1) = INTCHR(XRA(J)) 
35                   CONTINUE 
                     ENDIF 
C======================================================================= 
C     Special codes for AES Canadian data. 
C======================================================================= 
C#### WCH, 8/1/95.  ADD NEW FORMAT OPTION, IFORM = 13. 
CWCH, 11/22/99. ADD FORMAT FOR 4-DIGIT YEAR (IFORM = 14). 
      IF(IFORM.EQ.5.OR.IFORM.EQ.13.OR.IFORM.EQ.14) THEN 
                     DO 45 J = 1,24 
                     IF(XRAIN(J).GE.9999) THEN 
                             SUM(1)       = SUM(1)+FLOAT(XRAIN(J))*CONV 
                             HOUR(IDAY,J) = -2 
C#### WCH, 4/26/94. 
                             CALL RAINCD(IA,IDAY) 
C#### WCH, 8/1/95.  IF THERE IS A FLAG, PRINT IT. 
CWCH, 11/22/99. CHANGE TO .GE.13 
                             IF(IFORM.GE.13) CALL RAINCD(FLAG1(J),IDAY) 
                             GO TO 45 
                             ENDIF 
C     Code for missing data is -1. (AES value = -99999) 
                     IF(XRAIN(J).LE.-999) THEN 
                             HOUR(IDAY,J) = -1 
C#### WCH, 4/26/94. 
                             CALL RAINCD(IM,IDAY) 
C#### WCH, 8/1/95.  IF THERE IS A FLAG, PRINT IT. 
CWCH, 11/22/99. CHANGE TO .GE.13 
                             IF(IFORM.GE.13) CALL RAINCD(FLAG1(J),IDAY) 
                             GO TO 45 
                             ENDIF 
C#### WCH, 8/1/95.  IF THERE IS A FLAG, PRINT IT. 
CWCH, 11/22/99. MAKE .GE.13 
                     IF(IFORM.GE.13) CALL RAINCD(FLAG1(J),IDAY) 
                     HOUR(IDAY,J)         = XRAIN(J) 
45                   CONTINUE 
                     ENDIF 
C======================================================================= 
CWCH, 11/22/99.  AES 15-min precip. data. 
C	Now more properly called CMC or NCDA format? 
C     AES "ELEM" code = 159 for FIF21 (15-min precip). 
C     Take format from Web page at: 
C     http://www.cmc.ec.gc.ca/climate/document.htm 
C======================================================================= 
      IF(IFORM.EQ.15) THEN 
                     JD1 = JDATE(DAY,MONTH,YEAR) 
                     JULDAY = JD1 + YEAR*1000 
	               NUM = 96 
C 
                     DO 808 I = 1,NUM 
                     IRAIN     = XRAIN(I) 
C     Don't fully understand AES format, so don't allow for special 
C     computations for missing or accumulated data.   
                     IF(IRAIN.LE.-999) THEN 
                              IRAIN = 0 
                              ICODE = IM 
                              ENDIF 
C####################################################################### 
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT. 
C======================================================================= 
                     IKODE = BLANK 
                     IF(FLAG1(I).NE.BLANK) IKODE = FLAG1(I) 
                     CALL RAINCD(IKODE,JD1) 
C======================================================================= 
C     Compute hour and minute of start of interval. 
C     IHR  = 1-24 = subscript. 
C     IHRS = 0-23 = starting hour. 
C======================================================================= 
                     IHR  = (I-1)/4 + 1 
	               IHRS = IHR - 1 
                     MIN  = (I - 1 - IHRS*4)*15 
                     RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0 
                     IF(IRAIN.GT.0) THEN 
C======================================================================= 
C     Intensity is 15-min. depth/.25 hr and divided by conversion factor 
C     of 0.1 to get mm/hr.  
C======================================================================= 
                                 REIN  = FLOAT(IRAIN)/0.1/0.25 
                                 WRITE(M4) JULDAY,RHOUR,THISTO,REIN 
                                 HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN 
                                 ENDIF 
                     IF(FLAG1(I).EQ.IA.AND.KODEA.EQ.0) THEN 
                                     HOUR(IDAY,IHR) = -2 
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV 
                                     ENDIF 
  808                CONTINUE 
                     ENDIF 
C======================================================================= 
C     Earth Info precipitation data. 
C     Old format, data retrieved from display.  For new ASCII files, 
C       use Subroutine G9RAIN (IFORM = 9-12). 
C======================================================================= 
      IF(IFORM.EQ.7) THEN 
                     DO 60 J       = 1,24 
                     HOUR(IDAY,J)  = IFIX(YRAIN(J)*100.0+0.1) 
60                   CONTINUE 
                     ENDIF 
C======================================================================= 
C     Earth Info Precipitation data. 
C======================================================================= 
      IF(IFORM.EQ.8) THEN 
                     DO 65 J       = 1,24 
                     HOUR(IDAY,J)  = XRAIN(J) 
65                   CONTINUE 
                     ENDIF 
C======================================================================= 
 777  HOUR(IDAY,25) = MONTH 
      HOUR(IDAY,26) =   DAY 
      HOUR(IDAY,27) =  YEAR 
      GO TO 10 
      ENDIF 
C======================================================================= 
C     Skip if the new station is not the station selected. 
C     Return if the new year is less than the selected ending year. 
C======================================================================= 
   49 RETURN 
C======================================================================= 
  940 WRITE(N6,9400) M3 
   40 IGO = 1 
      RETURN 
  888 WRITE(N6,1070) 
      STOP 
C####################################################################### 
C     WCH, 10/11/93.  Additional error messages while reading precip. 
C     file. 
C======================================================================= 
C#### WCH, 8/4/95.  ALTER IOSTAT NUMBER FOR LAHEY, FOR FOUR WRITES. 
  950 WRITE(N6,9500) M3,LN,YEAR,MONTH,DAY,NR,MOD(IOS,256) 
      WRITE(*,9501)  M3,MOD(IOS,256) 
      GO TO 965 
  960 WRITE(N6,9600) M3,LN,YEAR,MONTH,DAY,NR,J,IHR,MIN,IRAIN, 
     1  MOD(IOS,256) 
      WRITE(N6,9601) M3,MOD(IOS,256) 
  965 BACKSPACE M3 
      READ(M3,9650,END=966) M3LINE 
  966 WRITE(N6,9651) M3,M3LINE 
3124	write(N6,*) IBUF2,ABUF2, 
     +                   ELMTYP,ABUF2,NEWYR,NEWMON,NEWDAY 
      STOP 
C#### WCH, 10/2/96.  ADD NEW ERROR ROUTINE FOR INITIAL READS. 
Cwch, 7/28/04 Just print IOSTAT 
C  970 WRITE(N6,9700) IO,MOD(IOS,256),IBUF 
C      WRITE(*,9700) IO,MOD(IOS,256),IBUF 
  970 WRITE(N6,9700) IO,IOS,IBUF 
      WRITE(*,9700) IO,IOS,IBUF 
      STOP 'Run stopped from Sub. GTRAIN.' 
C======================================================================= 
C#### WCH, 8/1/95.  NEW FORMAT STATEMENT 990. 
  990 FORMAT(/,' STATION ID ON PRECIP. DATA INPUT FILE = ',A8,/, 
     1' REQUESTED STATION ID = ',A8,'  CHECK TO BE SURE THEY MATCH.',/) 
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I6 TO A6. 
CWCH, 11/9/99. READ YEAR (3RD PARAMETER) AS 4 DIGITS, NOT 2.   
 1000 FORMAT(3X,A6,2X,A4,2X,I4,I2,I4,3X,I2,3X,I5,A1) 
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I6 TO A6. 
 1040 FORMAT(A6,3I2,I1,12A3) 
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I8 TO A7 AND ALTER NEXT 
C     FIELD ALSO. ADD NEW 1046 FOR NEW AES FORMAT. 
 1045 FORMAT(A7,1X,3I2,3X,24I4) 
 1046 FORMAT(A7,1X,3I2,3X,24(I6,A1)) 
CWCH, 11/22/99. ADD OPTION FOR 4-DIGIT YEAR AES DATA. 
 1047 FORMAT(A7,I4,2I2,3X,24(I6,A1)) 
 1048 FORMAT(A7,I4,2I2,3X,96(I6,A1)) 
 1050 FORMAT(72X,I4) 
 1051 FORMAT(73X,I4) 
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I6 TO A6. 
CWCH, 11/9/99. READ YEAR (3RD PARAMETER) AS 4 DIGITS, NOT 2.   
 1060 FORMAT(3X,A6,2X,A4,2X,I4,I2,I4,I3,100(I4,I6,2A1)) 
 1070 FORMAT(/,' ===> Error  in your rainfall file input.',/) 
 1080 FORMAT(50A1) 
 1085 FORMAT(25X,I2,1X,I2,4X,4(F6.0,F7.0,F7.0,1X)) 
 1095 FORMAT(25X,9X,4(F6.0,F7.0,F7.0,1X)) 
 1090 FORMAT(/,' Changing double quotation marks to single quotation', 
     +         ' marks in input file.',/) 
 1150 FORMAT(66X,I2) 
 1155 FORMAT(I2,1X,I2,24I5) 
 9000 FORMAT(/,' Error ==> Limit of ',I6, 
     +         ' Precipitation values exceeded for this year.') 
C#### WCH, 8/93. 
 9110 FORMAT(/,' ===> ERROR. Time interval for new data,',F7.1, 
     1 ' sec. does not',/,'     agree with time interval,',F7.1, 
     2 ' sec. of data on unit JOUT with which',/, 
     3 '     new data are to be combined.  Run stopped.') 
C#### WCH, 10/11/93. 
 9400 FORMAT(/,' WARNING END-OF-FILE REACHED ON UNIT',I3,' WHILE READIN 
     1G PRECIPITATION DATA',/,' FOR IFORM = 4 OR 6.  SHOULD HAVE A NUMBE 
     2R 10 IN FIRST TWO COLUMNS',/,' TO CONCLUDE THIS FILE.  POSSIBLE ER 
     3ROR.  PROCESSING CONTINUES.') 
C#### WCH, 8/4/95. CHANGE RMFORT TO LAHEY. 
 9500 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S 
     1HOULD BE A',/,' LINE 8 INPUT STRING. CURRENT PARAMETER VALUES ARE: 
     2',/,' LINE ID =',I3,/,' YEAR =',I5,/,' MONTH =',I3 
     3,/,' DAY =',I3,/,' NO. LINES =',I3,/,' LAHEY ERROR NO. =',I5 
     4,/,' RUN STOPPED FROM RAIN BLOCK.') 
C#### WCH, 10/2/96.  CHANGE 'RMFORT' TO 'LAHEY'. 
 9501 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S 
     1HOULD BE A',/,' LINE 8 INPUT STRING.  LAHEY ERROR NO. =',I5,/,' SE 
     2E OUTPUT FILE FOR COMPLETE MESSAGE.',/, 
     3' RUN STOPPED FROM RAIN BLOCK.') 
C#### WCH, 8/4/95.  CHANGE RMFOR TO LAHEY. 
 9600 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S 
     1HOULD BE A',/,' LINE 9 INPUT STRING. CURRENT PARAMETER VALUES ARE: 
     2',/,' LINE ID =',I3,/,' YEAR =',I5,/,' MONTH =',I3 
     3,/,' DAY =',I3,/,' NO. LINES =',I3,/,' LINE NO. =',I3 
     4,/,' HOUR =',I4,/,' MIN =',I4,/,' RAIN =',I5 
     5,/,' LAHEY ERROR NO. =',I5 
     6,/,' RUN STOPPED FROM RAIN BLOCK.') 
C#### WCH, 10/2/96.  CHANGE 'RMFORT' TO 'LAHEY'. 
 9601 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S 
     1HOULD BE A',/,' LINE 9 INPUT STRING.  LAHEY ERROR NO. =',I5,/,' SE 
     2E OUTPUT FILE FOR COMPLETE MESSAGE.',/, 
     3' RUN STOPPED FROM RAIN BLOCK.') 
 9650 FORMAT(50A1) 
 9651 FORMAT(' OFFENDING LINE FROM UNIT',I3,' MAY BE:',/,1X,50A1) 
C#### WCH, 8/1/95.  TWO NEW WARNING MESSAGES. 
 9655 FORMAT (/, ' $$$$ CAUTION.  AT LEAST ONE OF YEAR/MONTH/DAY IS .LE. 
     1 ZERO ON UNIT',I3,/,' LIKELY HAVE EXTRA CARRIAGE RETURN AT END OF 
     2INPUT PRECIPITATION DATA FILE.',/,' ASSUME END-OF-FILE AND CEASE D 
     3ATA INPUT.') 
 9660 FORMAT (/,' ERROR.  INCORRECT DAY OF YEAR COMPUTED IN SUB. GTRAI 
     1N: IDAY =',I8,/,' HAS TO BE CAUSED BY WRONG YEAR/MONTH/DAY = ', 
     2 3I5,/,' CURRENT YEAR SHOULD BE: NEWYR =',I5,/, 
     3' CEASE DATA INPUT.  PERFORM FINAL RAIN ANALYSIS.') 
C#### WCH, 10/2/96. 
Cwch, 7/28/04 
 9700 FORMAT(/,' ERROR DURING INITIAL READ OF UNIT',I3,/, 
     1 ' Visual Fortran IOSTAT =',I5,/, 
     2 ' CURRENT STATION ID VALUE =',A10) 
C======================================================================= 
      END 
 
REM File: GUTNR.FOR 
 
      SUBROUTINE GUTNR(J,GLEN,GD,RDELT,NPG,WTYPE,WELEV,WDIS,SPILL, 
     +           GS1,GS2,GWIDTH,GCON,DFULL,QIN,QSUR,GFLOW,OUTFLW, 
     +           AXZERO,AX,FLZERO) 
C     RUNOFF BLOCK 
C     CALLED BY GUTTER NEAR LINE 26 
C=======================================================================                
C     NEWTON-RAPHSON SOLUTION OF GUTTER OR PIPE DEPTH 
C     LAST UPDATED 4/22/92 BY RED AND WCH. 
C     UPDATED 9/23/93 BY WCH (RED) TO FIX IF-STMT NEAR END. 
C     WCH (CDM), 8/13/96.  REMOVE ERRANT CONVERGENCE CHECK FOR CHANNELS 
C       WITH WEIRS/ORIFICES.   
C======================================================================= 
      INCLUDE  'TAPES.INC' 
      INCLUDE  'NEW88.INC' 
      DIMENSION NSEQ(4),YZ(4),DZ(4),DY(4) 
      INTEGER   WTYPE 
      DATA NSEQ/1,2,4,8/ 
C======================================================================= 
      NUSE     = 4 
      KCHAN(J) = KCHAN(J) + 1 
C======================================================================= 
C     MAIN LOOP 
C======================================================================= 
      DO 400 JJ= 1,NUSE 
      GDEPTH   = GD 
      DELT     = RDELT/FLOAT(NSEQ(JJ)) 
      DELD     = 0.0 
      DO 250 K = 1,NSEQ(JJ) 
      GDEPTH   = GDEPTH + DELD 
      IFLG     = 0 
      IFLAG2   = 0 
      DELD     = 0.0 
      D0       = GDEPTH 
      AX0      = 0.0 
      WP0      = 0.001 
C======================================================================= 
C     TRAPEZOIDAL PARAMETERS 
C======================================================================= 
      IF(NPG.EQ.1) THEN 
         AX0 = 0.5*(GS1+GS2)*D0**2.0 + GWIDTH*D0 
         WP0 = SQRT(GS1**2.0+1.0)*D0 + SQRT(GS2**2.0+1.0)*D0 + GWIDTH 
         ENDIF 
C======================================================================= 
C     CIRCULAR PARAMETERS 
C======================================================================= 
      IF(NPG.EQ.2) THEN 
                   SIN2D0  = 0.5*SIN(2.0*D0) 
                   AX0     = GWIDTH**2*(D0-SIN2D0)/4.0 
                   WP0     = GWIDTH*D0 
                   D1      = 1.5707963 
                   DELD    = D1 - GDEPTH 
                   ENDIF 
C======================================================================= 
C     PARABOLIC PARAMETERS 
C======================================================================= 
      IF(NPG.EQ.4.AND.GDEPTH.GT.0.0) THEN 
                      WIDTH = GWIDTH*SQRT(D0/DFULL) 
                      X     = WIDTH/2.0 
                      A2    = GWIDTH**4.0/(64.0*DFULL**2.0) 
                      WP0   = 8.0*DFULL/GWIDTH**2.0*(X*SQRT(A2+X**2.0) +  
     +                                       A2*LOG(X+SQRT(A2+X**2.0)) -  
     +                                       A2*LOG(SQRT(A2)))        
                      AX0   = 0.66666667*WIDTH*D0 
                      ENDIF 
C======================================================================= 
      IF(AX0.LT.0.001) AX0 = 0.0 
      IF(WP0.LE.0.001) WP0 = 0.001 
      RAD                  = AX0/WP0 
C======================================================================= 
      FLOW0 = 0.0 
      IF(WTYPE.EQ.-1.AND.RAD.GT.0.0) FLOW0 = GCON*AX0*RAD**0.666666667 
      IF(WTYPE.EQ.0.AND.D0.GT.WELEV) FLOW0 = WDIS*SPILL*(D0-WELEV)**1.5 
      IF(WTYPE.EQ.1.AND.D0.GT.WELEV) FLOW0 = WDIS*SPILL*(D0-WELEV)**2.5 
      IF(WTYPE.EQ.2.AND.D0.GT.WELEV) FLOW0 = WDIS*SPILL* 
     +                                       (2.0*32.2*(D0-WELEV))**0.5 
      IF(JJ.EQ.1) THEN 
                  FLZERO = FLOW0 
                  AXZERO = AX0 
                  ENDIF 
C======================================================================= 
C     COMPUTE CHANGE IN DEPTH (NEWTON-RAPHSON) 
C 
C     D1 = ESTIMATED FINAL DEPTH. 
C          FOR PIPES, 'DEPTH' IS HALF OF ANGLE SUBTENDED BY 
C          WETTED PERIMETER, IN RADIANS. 
C======================================================================= 
                        KSOL = 0 
      IF(DELT.GE.900.0) KSOL = 1 
      DO 210 I = 1,20 
      D1       = GDEPTH+DELD 
C======================================================================= 
C     TRAPEZOIDAL CHANNEL 
C======================================================================= 
      IF(NPG.EQ.1) THEN 
             IF(D1.LE.0.0) THEN 
                           IFLAG2 = IFLAG2 + 1 
                           D1     = 0.0 
                           DELD   =  -GDEPTH 
                           ENDIF 
             DELV = GLEN*DELD * ((GS1+GS2)*(D0 + 0.5 * DELD) 
     +                                         + GWIDTH)/DELT 
             DDELV = GLEN*((GS1+GS2)*D1  + GWIDTH)/DELT 
             AX    = 0.5*(GS1+GS2)*D1**2 + GWIDTH*D1 
             DAX   = (GS1+GS2)*D1+GWIDTH 
             WP    = SQRT(GS1**2+1.0)*D1+SQRT(GS2**2+1.0)*D1+GWIDTH 
             DWP   = SQRT(GS1**2+1.0)+SQRT(GS2**2+1.0) 
             ENDIF 
C======================================================================= 
C     CIRCULAR PIPE 
C======================================================================= 
      IF(NPG.EQ.2) THEN 
                   IF(I.EQ.1) THEN 
                              D1   = 1.5707963 
                              DELD = D1 - GDEPTH 
                              ENDIF 
                   IF(D1.LE.0.0) THEN 
                                 IFLAG2 = IFLAG2 + 1 
                                 D1     = 0.0 
                                 DELD   = -GDEPTH 
                                 ENDIF 
                   IF(D1.GT.DFULL) THEN 
                                   D1   = DFULL 
                                   DELD = D1 - GDEPTH 
                                   ENDIF 
                   SIN2D1 = 0.5*SIN(2.0*D1) 
                   COS2D1 = COS(2.0*D1) 
                   DELV   = .25*GLEN*GWIDTH**2*(DELD-SIN2D1+SIN2D0)/DELT 
                   DDELV  = .25*GLEN*GWIDTH**2*(1.0-COS2D1)/DELT 
                   AX     = GWIDTH**2*(D1-SIN2D1)/4.0 
                   DAX    = GWIDTH**2*(1.0-COS2D1)/4.0 
                   WP     = GWIDTH*D1 
                   DWP    = GWIDTH 
                   ENDIF 
C======================================================================= 
C     PARABOLIC CHANNEL 
C======================================================================= 
      IF(NPG.EQ.4) THEN 
             IF(D1.LE.0.0) THEN 
                           IFLAG2 = IFLAG2 + 1 
                           D1     = 0.001 
                           DELD   =  -GDEPTH + 0.001 
                           ENDIF 
             WID0  = GWIDTH*SQRT(D0/DFULL) 
             WID1  = GWIDTH*SQRT(D1/DFULL) 
             DELV  = 0.66666667*GLEN/DELT*(D1*WID1 - D0*WID0) 
             DDELV = 0.66666667*GLEN/DELT*1.50*WID1 
             AX    = 0.66666667*WID1*D1 
             DAX   = 0.66666667*WID1*1.50 
             X     = WID1/2.0 
             A2    = GWIDTH**4.0/(64.0*DFULL**2.0) 
             WP    = 8.0*DFULL/GWIDTH**2.0*(X*SQRT(A2+X**2.0) +  
     +                              A2*LOG(X+SQRT(A2+X**2.0)) -  
     +                              A2*LOG(SQRT(A2)))        
                           DX  = 0.0 
             IF(D1.GT.0.0) DX  = 0.25*GWIDTH/SQRT(D1*DFULL) 
             DXX   = 0.25*GWIDTH**2.0/DFULL 
             DWP   = 8.0*DFULL/GWIDTH**2.0*(DX*SQRT(A2+X**2.0) + 
     +               0.5*X*DXX/SQRT(A2+X**2.0) +  
     +         (DX+0.5*DXX/SQRT(A2+X**2.0))/(LOG(X+SQRT(A2+X**2.0)))) 
             ENDIF 
C======================================================================= 
C     HYDRAULIC RADIUS (ALL CROSS-SECTIONS) 
C======================================================================= 
      IF(AX.LE.0.001) AX = 0.000 
      IF(WP.LE.0.001) WP = 0.001 
      RAD                = AX/WP 
C======================================================================= 
C     FLOW1 = INSTANTANEOUS FLOW AT END OF TIME STEP. 
C======================================================================= 
                      FLOW1 = 0.0 
      IF(WTYPE.EQ.-1) FLOW1 = GCON*AX*RAD**0.666666667                         
      IF(WTYPE.EQ.0.AND.D1.GT.WELEV) FLOW1 = WDIS*SPILL*(D1-WELEV)**1.5 
      IF(WTYPE.EQ.1.AND.D1.GT.WELEV) FLOW1 = WDIS*SPILL*(D1-WELEV)**2.5 
      IF(WTYPE.EQ.2.AND.D1.GT.WELEV) FLOW1 = WDIS*SPILL* 
     +                                       (2.0*32.2*(D1-WELEV))**0.5 
      FLOW   = 0.5*(FLOW1+FLOW0) 
      DFLOW  = 0.0 
      IF(WTYPE.EQ.-1) DFLOW =  0.5*GCON*(1.6666667*(RAD**0.66666667) 
     +                         *DAX - 0.66666667*(RAD**1.6666667)*DWP) 
      IF(WTYPE.EQ.0.AND.D1.GT.WELEV) DFLOW = 1.5*WDIS*SPILL* 
     +                                       (D1-WELEV)**0.5 
      IF(WTYPE.EQ.1.AND.D1.GT.WELEV) DFLOW = 2.5*WDIS*SPILL* 
     +                                       (D1-WELEV)**1.5 
      IF(WTYPE.EQ.2.AND.D1.GT.WELEV) DFLOW = 32.2*WDIS*SPILL/ 
     +                                       (64.4*(D1-WELEV))**0.5 
C======================================================================= 
C     NEWTON-RAPHSON CORRECTION (ALL CROSS-SECTIONS) 
C======================================================================= 
      IF(KSOL.EQ.0) THEN 
C$$$  WCH THINKS SHOULD DIVIDE BY RDELT (CONST DT), NOT DELT (VARIABLE DT) 
C$$$  TRY CORRECTION 4/20/92 
                    F     = DELV  + FLOW  - QIN - QSUR/RDELT 
                    DF    = DDELV + DFLOW 
                    ELSE 
                    DFLOW = 2.0*DFLOW 
                    F     = DELV  + FLOW1 - QIN - QSUR/RDELT 
                    DF    = DDELV + DFLOW 
                    ENDIF 
C======================================================================= 
C     ZERO SLOPE 
C======================================================================= 
      IF(ABS(DF).LE.1.0E-10) THEN 
                        DEL = 0.001 
                        ELSE 
                        DEL = DELD - F/DF 
                        ENDIF 
C======================================================================= 
C     CONVERGENCE CHECK (INDIVIDUAL GUTTER) 
C======================================================================= 
C#### WCH (CDM=C.I.M.), 8/13/96 
C     THIS IF-LOOP SEEMS TO CAUSE PREMATURE END TO CONVERGENCE 
C     ITERATIONS FOR CHANNELS WITH WEIRS/ORIFICES WHEN GUESS CAUSES 
C     LEVEL BELOW OUTLET LEVEL (WELEV).  THIS MAKES IT HARD FOR CHANNEL  
C     TO "FILL UP" TO OUTLET LEVEL, ESPECIALLY AT START OF STORM WHEN  
C     CHANNEL IS DRY.  ELIMINATING THIS IF-LOOP SEEMS TO WORK, BASED 
C     ON CDM EXPERIENCE. 
C 
C####      IF(WTYPE.GE.0.AND.GDEPTH+DEL.LT.WELEV) THEN 
C####                                          GD       = GDEPTH+DEL 
C####                                          LCHAN(J) = LCHAN(J) + 1 
C####                                          GO TO 402 
C####                                          ENDIF                     
      IF(GDEPTH+DEL.GE.DFULL) THEN 
                       IF(IFLG.EQ.1) THEN 
                                     GD       = DFULL 
                                     LCHAN(J) = LCHAN(J) + 1 
                                     GO TO 402 
                                     ENDIF 
                       DEL  = DFULL-GDEPTH 
                       IFLG = 1 
                       ELSE 
                       IFLG = 0 
                       IF(ABS(DEL-DELD).LE.0.001) GO TO 250 
                       IF(IFLAG2.GE.2) KSOL = 1 
                       ENDIF 
  210 DELD = DEL 
C======================================================================= 
C     NO CONVERGENCE. 
C 
C     NEW DEPTH AT END OF TIME INTERVAL 
C======================================================================= 
  250 DELD   = DEL 
      GDEPTH = GDEPTH + DELD 
C======================================================================= 
C     CHECK FOR ALLOWABLE CONDUIT DEPTHS.  4/22/92 
C======================================================================= 
      IF(GDEPTH.GT.DFULL) GDEPTH = DFULL 
      IF(GDEPTH.LT.0.0)   GDEPTH = 0.0 
      QSUR   = 0.0 
      YZ(JJ) = GDEPTH 
      IF(JJ.EQ.1) DY(1) = YZ(1) 
      IF(JJ.EQ.2) THEN 
                  DY(2) = (4.0*YZ(2) - YZ(1))/3.0 
                  IF(ABS(DY(2)-DY(1)).LE.0.001*ABS(DY(1))) THEN 
                                      LCHAN(J) = LCHAN(J) + 3 
                                      GD       = DY(2) 
                                      GO TO 402 
                                      ENDIF 
                  ENDIF 
      IF(JJ.EQ.3) THEN 
                  DY(3) = (4.0*YZ(3)  - YZ(2))/3.0 
                  DZ(3) = (16.0*DY(3) - DY(2))/15.0 
                  IF(ABS(DZ(3)-DY(3)).LE.0.001*ABS(DZ(3))) THEN 
                                      LCHAN(J) = LCHAN(J) + 7 
                                      GD       = DZ(3) 
                                      GO TO 402 
                                      ENDIF 
                 ENDIF 
      IF(JJ.EQ.4)THEN 
                 DY(4)    = (4.0*YZ(4)  - YZ(3))/3.0 
                 DZ(4)    = (16.0*DY(4) - DY(3))/15.0 
                 DZ(4)    = (64.0*DZ(4) - DZ(3))/63.0 
                 GD       = DZ(4) 
                 LCHAN(J) = LCHAN(J) + 15 
                 ENDIF 
 400  CONTINUE 
 402  CONTINUE 
C======================================================================= 
C     CHECK FOR ALLOWABLE CONDIUT DEPTHS.  4/22/92 
C======================================================================= 
      IF(GD.GT.DFULL) GD = DFULL 
      IF(GD.LT.0.0)   GD = 0.0 
      IF(WTYPE.EQ.-1) THEN 
      IF(NPG.EQ.1)    THEN 
             AX = 0.5*(GS1+GS2)*GD**2.0 + GWIDTH*GD 
             WP = SQRT(GS1**2.0+1.0)*GD + SQRT(GS2**2.0+1.0)*GD+GWIDTH 
             ENDIF 
      IF(NPG.EQ.2)  THEN 
                    SIN2D0  = 0.5*SIN(2.0*GD) 
                    AX      = GWIDTH**2*(GD-SIN2D0)/4.0 
                    WP      = GWIDTH*GD 
                    ENDIF 
      IF(NPG.EQ.4)  THEN 
           IF(GD.GT.0.0) THEN 
                    WIDTH = GWIDTH*SQRT(GD/DFULL) 
                    AX    = 0.66666667*WIDTH*GD 
                    X     = WIDTH/2.0 
                    A2    = GWIDTH**4.0/(64.0*DFULL**2.0) 
                    WP    = 8.0*DFULL/GWIDTH**2.0*(X*SQRT(A2+X**2.0) +  
     +                                     A2*LOG(X+SQRT(A2+X**2.0)) -  
     +                                     A2*LOG(SQRT(A2)))        
                    ELSE 
                    AX    = 0.0 
                    WP    = 0.001 
                    ENDIF 
           ENDIF 
      IF(AX.LT.0.001) AX = 0.0 
      IF(WP.LE.0.001) WP = 0.001 
      RAD                = AX/WP 
      ENDIF 
                                     FLOW1 = 0.0 
      IF(WTYPE.EQ.-1.AND.RAD.GT.0.0) FLOW1 = GCON*AX*RAD**0.666666667                         
      IF(WTYPE.EQ.0.AND.GD.GT.WELEV) FLOW1 = WDIS*SPILL*(GD-WELEV)**1.5 
      IF(WTYPE.EQ.1.AND.GD.GT.WELEV) FLOW1 = WDIS*SPILL*(GD-WELEV)**2.5 
      IF(WTYPE.EQ.2.AND.GD.GT.WELEV) FLOW1 = WDIS*SPILL* 
     +                                       (2.0*32.2*(GD-WELEV))**0.5 
      OUTFLW = FLOW1                         
      FLOW   = (OUTFLW + FLZERO)/2.0 
      IF(FLOW.LT.1.0E-10.AND.WTYPE.EQ.-1) THEN 
                                          FLOW   = 0.0 
                                          GD     = 0.0 
                                          ENDIF 
      IF(FLOW.LT.0.0.AND.WTYPE.GE.0) THEN 
                                     FLOW   = 0.0 
                                     GD     = 0.0 
                                     ENDIF 
      GFLOW  = FLOW 
C#### WCH (RED), 9/93.  ADD QSUR > 0.0 TO IF STMT. 
      IF(IFLG.EQ.1.OR.QSUR.GT.0.0) THEN 
                    QSUR   = QSUR + (QIN-FLOW)*RDELT 
                    IF(QSUR.LT.0.0) QSUR = 0.0 
                    ENDIF 
      RETURN 
      END 
 
 
REM File: HCURVE.FOR 
 
      SUBROUTINE HCURVE(NTYPE) 
C     GRAPH RUNOFF BLOCK 
C     CALLED FROM RUNOFF NEAR LINES 265 through 269 
C======================================================================= 
C     HCURVE WAS LAST UPDATED BY THE UNIVERSITY OF FLORIDA JANUARY, 1989 
C     DIMENSION MODIFICATION, DELETED LOOP, AND NEW PRINT, 12/92 BY WCH 
C     WCH, 11/10/99. FIX RAINFALL GRAPHS THAT EXTEND BEYOND ONE PLOT.  
C     WCH, 7/1/03. Fix GW output loop.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'GRWTR.INC' 
      INCLUDE 'LAB.INC' 
C======================================================================= 
C#### WCH, 12/92.  DIMENSION TO NGW. 
CIM INCREASE HYETOGRAPHS  ~~~~~~~~~~~~~~~~~~~~~~~~~ 
      DIMENSION GWFLWB(NGW),STPOLL(2,NGW),JSTA(MAXRG) 
      DIMENSION X(201,2),Y(201,2),Y1(201,2),NPT(2),REIN(maxrg) 
cim      DIMENSION GWFLWB(NGW),STPOLL(2,NGW),JSTA(10) 
cim      DIMENSION X(201,2),Y(201,2),Y1(201,2),NPT(2),REIN(10) 
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~ 
      INTEGER MPGRW(NGW) 
      CHARACTER*30 TITL(6),ORIZ,TSEC,TFIR 
      CHARACTER*10 VER1(5),VER2(5),VER3(10),ALPLOT,KPGRW(NGW) 
C======================================================================= 
      DATA TITL/'RAINFALL HYETOGRAPH           ', 
     1 'SURFACE INLET HYDROGRAPH FLOW ','PLOT OF INFILTRATION RATE    ', 
     2 'SUBSURFACE OUTLET HYDROGRAPH  ', 
     3 'SUBSURFACE STAGE GRAPH        ','SUBSURFACE MOISTURE FRACTION '/ 
      DATA TFIR/'SUMMATION OVER PERVIOUS AREA '/ 
      DATA TSEC/'SUMMATION FOR ALL INLETS'/ 
      DATA ORIZ /'         TIME IN HOURS        '/ 
      DATA VER1/' RAINFALL ','  RUNOFF  ','   FLOW  ','  STAGE   ', 
     +          ' MOISTURE '/ 
      DATA VER2/'    IN    ','    IN    ','    IN   ','    IN    ', 
     +          '    IN    '/ 
      DATA VER3/'  IN/HR   ','   MM/HR  ','    CFS   ',' CUB M/S  ', 
     +          '   CFS    ',' CUB M/S  ','   FEET   ','  METERS  ', 
     +          ' FRACTION ',' FRACTION '/ 
C======================================================================= 
      NREIN    = NSCRAT(1) 
      NFLOW    = NSCRAT(4) 
      ALPLOT   = ' ' 
C======================================================================= 
C      PLOT RAINFALL HYETOGRAPH OR INLET HYDROGRAPH 
C======================================================================= 
      X(1,1)   = TZERO/3600.0 
      Y(1,1)   = 0.0 
      HORIZ(1) = ORIZ 
      HTITLE(1)= TITL(NTYPE) 
      HTITLE(2)= '       ' 
      MTYPE    = NTYPE 
      IF(NTYPE.EQ.3) MTYPE = 1 
      IF(NTYPE.EQ.4) MTYPE = 3 
      VERT1    = VER1(MTYPE) 
      VERT2    = VER2(MTYPE) 
      VERT3    = VER3(2*MTYPE-2+METRIC) 
      IF(NTYPE.EQ.3) THEN 
                     VERT1     = 'INFILTRATN' 
                     HTITLE(2) = TFIR 
                     ENDIF 
C======================================================================= 
C     FIND THE STARTING POSITION ON THE RAINFALL INTERFACE FILE 
C======================================================================= 
      IF(NTYPE.EQ.1) THEN 
      I        = 0 
      DO 110 J = 1,NRGAG 
      REWIND NREIN 
      READ(NREIN) NSTA,MRAIN,(JSTA(K),K=1,NSTA) 
      I        = I+1 
      TNEXT    = TZERO 
      JULDAY   = IDATEZ 
      TIME     = TZERO 
      TIMDAY   = TZERO 
      DO 65 L  = 1,MRAIN 
      READ(NREIN,END=71) JDAY,TMDAY,THISTO,(REIN(K),K=1,NSTA) 
      IF(JDAY.GE.JULDAY.AND.TMDAY.GE.TIMDAY) THEN 
                        BACKSPACE NREIN 
                        GO TO 66 
                        ENDIF 
  65  CONTINUE 
  66  CONTINUE 
C======================================================================= 
C     READ RAINFALL FILE 
C======================================================================= 
      N        = 1 
      X(N,1)   = TZERO/3600.0 
      Y(N,1)   = 0.0 
      DO 70 L  = 1,NRAIN 
      READ(NREIN,END=71) JDAY,TMDAY,THISTO,(REIN(K),K=1,NSTA) 
      CALL NTIME(JDAY,TMDAY,TRN) 
      CALL STIME(TRN) 
      TIME     = TIME + TRN 
	      IF(TIME.GT.TNEXT) THEN 
                        N      = N + 1 
                        X(N,1) = TNEXT/3600.0 
                        Y(N,1) = 0.0 
                        N      = N + 1 
                        X(N,1) = TIME/3600.0 
                        Y(N,1) = 0.0 
                        ENDIF 
      N        = N+1 
      X(N,1) = TIME/3600.0 
      Y(N,1) = REIN(J) 
      N      = N+1 
      TNEXT  = TIME + THISTO 
      X(N,1) = TNEXT/3600.0 
      Y(N,1) = REIN(J) 
      IF(N.GE.199) THEN 
                   N      = N+1 
CWCH, 11/10/99. CAN SOMEHOW GET N > 201 AND EXCEED DIMENSION.  
C     MAX N ENCOUNTERED AT THIS POINT IS 202,  
C     SO ASSUME N = 202 IS TRUE HERE FOR FIX. 
C     MOVE LAST TWO X AND Y VALUES TO 199 AND 200. 
                   IF(N.GT.201) THEN 
	                  X(199,1) = X(200,1) 
				      X(200,1) = X(201,1) 
	                  Y(199,1) = Y(200,1) 
	                  Y(200,1) = Y(201,1) 
	                  N = 200 
	                  ENDIF 
                   X(N,1) = X(N-1,1) 
CWCH, 11/10/99.  BE SURE THAT MAX VALUE OF X IS NOT CHANGED. 
			     XXX    = X(N,1)	 
                   Y(N,1) = 0.0 
                   NPT(1) = N 
                   KSTAT = JSTA(J) 
                   CALL CURVE(X,Y,NPT,1,KSTAT,ALPLOT) 
C                   X(1,1) = X(N,1) 
                   X(1,1) = XXX 
                   Y(1,1) = 0.0 
                   N = 1 
                   ENDIF 
   70 CONTINUE 
   71 N      = N+1 
      X(N,1) = X(N-1,1) 
      Y(N,1) = 0.0 
      NPT(1) = N 
      KSTAT = JSTA(J) 
      CALL CURVE(X,Y,NPT,1,KSTAT,ALPLOT) 
  110 CONTINUE 
      RETURN 
      ENDIF 
C======================================================================= 
C     PLOT THE INLET HYDROGRAPH 
C     MAKE THE CONVERSION FROM CFS TO CUBIC METERS PER SECOND (METRIC=2) 
C======================================================================= 
      IF(NTYPE.EQ.2) THEN 
      REWIND NFLOW 
      HTITLE(2)= TSEC 
      N        = 1 
      X(N,1)   = TZERO/3600.0 
      Y(N,1)   = 0.0 
      KINC     = (MTIME+199)/200 + 1 
      NPLOT    = 1 
C====================================================================== 
      DO 130 J = 1,MTIME,KINC 
      DO 140 K = 1,KINC 
 140  READ(NFLOW,END=135) TIME,FLWOFF,FINF 
      N        = N + 1 
      X(N,1)   = TIME/3600.0 
      Y(N,1)   = FLWOFF 
      IF(METRIC.EQ.2) Y(N,1) = Y(N,1) * 0.028316847 
  130 CONTINUE 
C======================================================================= 
  135 NPT(1) = N 
      KCE    = JCE 
      JCE    = 1 
      ALPLOT = 'FLOW SUM' 
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT) 
      JCE    = KCE 
      RETURN 
      ENDIF 
C======================================================================= 
C     PLOT THE IFILTRATION RATE PLOT 
C======================================================================= 
      IF(NTYPE.EQ.3.AND.PRCIMP.LT.1.0) THEN 
      REWIND NFLOW 
      TY       = TRIBA*3630.0*(1.0-PRCIMP) 
      IF (TY.NE.0.0) THEN  
      TY       = 3600.0/TY 
      ELSE  
      TY       = 0.0 
      END IF 
      HTITLE(1)= TITL(3) 
      HTITLE(2)= '                  ' 
      N        = 1 
      X(N,1)   = TZERO/3600.0 
      Y(N,1)   = 0.0 
      KINC     = (MTIME+199)/200 + 1 
      NPLOT    = 1 
C====================================================================== 
      DO 230 J = 1,MTIME,KINC 
      DO 240 K = 1,KINC 
 240  READ(NFLOW,END=235) TIME,FLWOFF,FINF 
      N        = N + 1 
      X(N,1)   = TIME/3600.0 
      Y(N,1)   = FINF*TY 
      IF(METRIC.EQ.2) Y(N,1) = Y(N,1) * 25.4 
 230  CONTINUE 
C======================================================================= 
  235 NPT(1) = N 
      KCE    = JCE 
      JCE    = 1 
      ALPLOT = 'INFILTRA' 
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT) 
      JCE    = KCE 
      RETURN 
      ENDIF 
C======================================================================= 
C     PLOT SUBSURFACE FLOWS, SOIL MOISTURE, AND STAGE 
C======================================================================= 
      IF(NTYPE.EQ.4) THEN 
             NGRND = NSCRAT(6) 
C      MCOUN        = 0 
C#### WCH, 12/92  NOTE, FORMER DO 395 LOOP 1,NSVGW DELTED AT THIS POINT. 
C 
Cwch, 7/1/03. Here *any* subcat can have GW, not just first NOGWSC. 
C     Have saved subcat ID in Sub. CATCH.  Don't need initial loop.  
C 
C      DO 405 JH    = 1,NOGWSC 
C	      IF(NSCSFG(JH).GT.0) THEN 
C                          MCOUN        = MCOUN + 1 
C                          MPGRW(MCOUN) = NMSUB(JH) 
C                          IF(JCE.EQ.1) KPGRW(MCOUN) = KMSUB(JH) 
C                          ENDIF 
C 405  CONTINUE 
C##### WCH, 12/92 
      WRITE (*,8990) 
      DO 400 JJ    = 1,NSVGW 
C##### WCH, 12/92.  PLOTS CAN BE TIME CONSUMING.  PRINT REASSURANCE. 
      WRITE (*,9000) JJ,NSVGW 
      REWIND NGRND 
      N        = 1 
      X(N,1)   = TZERO/3600.0 
      Y(N,1)   = 0.0 
      KINC     = (MTIME+199)/200 + 1 
      DO 330 J = 1,MTIME,KINC 
      DO 340 K = 1,KINC 
C======================================================================= 
C     READ SUBSURFACE PLOT INFORMATION 
C======================================================================= 
 340  READ(NGRND,END=335) JULDAY,TIMDAY,TIME,(GWFLWB(JI), 
     .            (STPOLL(JV,JI),JV=1,2),JI=1,NSVGW) 
      N        = N + 1 
      X(N,1)   = TIME/3600.0 
      Y(N,1)   = GWFLWB(JJ) 
      Y1(N,1)  = STPOLL(1,JJ) 
      Y1(N,2)  = STPOLL(2,JJ) 
 330  CONTINUE 
 335  CONTINUE 
      NPT(1) = N 
C======================================================================= 
Cwch, 7/1/03. Use names saved in Sub. CATCH. 
C                    NPLOT = MPGRW(JJ) 
C      IF(JCE.EQ.1) ALPLOT = KPGRW(JJ) 
      IF(JCE.EQ.0)  NPLOT = NAMWPL(JJ) 
	IF(JCE.EQ.1) ALPLOT = KMSUPL(JJ) 
      HTITLE(1) = TITL(4) 
      HTITLE(2) = '      ' 
      VERT1     = VER1(3) 
      VERT2     = VER2(3) 
      VERT3     = VER3(5+METRIC-1) 
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT) 
      DO 300 J  = 1,N 
 300  Y(J,1)    = Y1(J,1) 
      HTITLE(1) = TITL(5) 
      VERT1     = VER1(4) 
      VERT2     = VER2(4) 
      VERT3     = VER3(7+METRIC-1) 
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT) 
      DO 350 J  = 1,N 
 350  Y(J,1)    = Y1(J,2) 
      HTITLE(1) = TITL(6) 
      VERT1     = VER1(5) 
      VERT2     = VER2(5) 
      VERT3     = VER3(9+METRIC-1) 
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT) 
 400  CONTINUE 
C#### WCH, 12/92 
      RETURN 
      ENDIF 
C####################################################################### 
 8990 FORMAT (//) 
 9000 FORMAT ('+ Constructing no.',I3,' of',I4,' requested groundwater p 
     *lots.') 
      END 
 
 
REM File: HYDRO.FOR 
 
      SUBROUTINE HYDRO 
C	RUNOFF BLOCK 
C	CALLED BY SUBROUTINE RUNOFF NEAR LINE 262 
C======================================================================= 
C     Hydro was last updated May 1993 by R.E.D. 
C     Updated 8/93 by Chuck Moore, CDM to include infiltration/inflow 
C     and new statistical summaries. 
C     Correct rainfall total for situation in which THISTO < WET, RED, 
C       12/31/93. 
C     Cosmetic changes to continuity check printouts, WCH, 1/4/94. 
C     Add check for snow on surface and channel/pipe flow in order to 
C       use WETDRY time step during continuous simulations, WCH, 4/7/94. 
C     Change precip. station ID (JSTA) to character to be compatible 
C       with changes in Rain Block, WCH, 8/1/95. 
C     Alter IOSTAT for Lahey, WCH, 8/4/95. 
C     Metric unit correction for RDII CIM 9/8/00 
C     Correction for rainfall summer. WCH, 4/15/02. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
      INCLUDE 'QUALTY.INC' 
      INCLUDE 'GRWTR.INC' 
      INCLUDE 'NEW88.INC' 
C#### C. MOORE, CDM, 8/93. 
      INCLUDE 'RDII.INC' 
      INCLUDE 'RUNSTAT.INC' 
Cwch, 12/20/00 
      INCLUDE 'OVERLAND.INC' 
CIM INCREASE HYETOGRAPHS  ~~~~~~ 
      DIMENSION ZUM(30),REIN(MAXRG),BANE(MAXRG),JSTA(MAXRG) 
CIM  ~~~~~~~ 
C======================================================================= 
CIM      DIMENSION ZUM(30),REIN(10),BANE(10),JSTA(10) 
C======================================================================= 
C     DECLARE THESE VARIABLES.  WCH, 11/1/91 
C======================================================================= 
      REAL   TRN 
      DOUBLE PRECISION DTRN 
      LOGICAL DELUGE,DESERT 
C#### WCH, 8/1/95.  CHANGE PRECIP STATION TO CHARACTER. 
      CHARACTER*8 JSTA 
C======================================================================= 
C     Compute the initial water stored in channels. 
C======================================================================= 
      CNT(20)    = 0.0 
      IF(NOG.NE.999) THEN 
             DO 100 J = 1,NOG 
             IF(NPG(J).EQ.1) AX = 0.5*(GS1(J)+GS2(J))*GDEPTH(J)**2 + 
     +                                 GWIDTH(J)*GDEPTH(J) 
             IF(NPG(J).EQ.2) AX = GWIDTH(J)**2/4.0*(GDEPTH(J) - 
     +                                0.5*SIN(2.0*GDEPTH(J))) 
             IF(NPG(J).EQ.4) THEN 
                       WIDTH = GWIDTH(J)*SQRT(GDEPTH(J)/DFULL(J)) 
                       AX    = 0.66666667*WIDTH*GDEPTH(J) 
                       ENDIF 
             IF(NPG(J).NE.3) THEN 
                             VOL    = AX*GLEN(J) 
                             CNT(20)  = CNT(20) + VOL + QSUR(J) 
                             ENDIF 
  100        CONTINUE 
             ENDIF 
C======================================================================= 
      DELUGE  = .FALSE. 
      DESERT  = .TRUE. 
C####################################################################### 
C     C. Moore, CDM, 8/93.  Option to pre-process rainfall to compute 
C       infiltration/inflow for inlet at each subcatchment. 
C####################################################################### 
      CALL RDIIRES 
Cwch, 1/7/03. Add write statement as help in error checking. 
	WRITE (N6,2110) 
C 
      NREIN   = NSCRAT(1) 
      REWIND NREIN 
      IF(IPRN(2).EQ.0) THEN 
                       NFLOW   = NSCRAT(4) 
                       IF(NFLOW.EQ.0) CALL ERROR(20) 
                       REWIND NFLOW 
                       ENDIF 
      READ(NREIN,END=777,ERR=777) NSTA,MRAIN,(JSTA(I),I=1,NSTA) 
      WRITE(N6,2115)  NSTA 
      WRITE(N6,2120) (I,JSTA(I),I=1,NSTA) 
      IF(NRGAG.GT.NSTA) CALL ERROR(115) 
C======================================================================= 
C     The next DO loop is the driver of the Runoff Block. 
C     It will call subroutines Wshed, Qshed amd Gutter. 
C======================================================================= 
      TRAIN  = TZERO 
      TIME   = TZERO 
      KWIK   = 0 
C#### WCH, 4/7/94.  Initialize KWIKSN and KWIKGT. 
                     KWIKSN = 0 
      IF(ISNOW.EQ.2) KWIKSN = 1 
      KWIKGT = 0 
      LWEAT  = 0 
      KRAIN  = 0 
      NRAIN  = 0 
      JWET   = 1 
      JDRY   = 0 
      MTIME  = 0 
C#### WCH, 4/7/94.  ADD PARAMETER KWIKGT 
      CALL GUTTER(REIGN,KWIKGT) 
C======================================================================= 
C     Calculate ending Julian day. 
C======================================================================= 
      CALL NDATE(LONG,JDAY,TMDAY) 
      LONG   = LONG + TZERO 
      WRITE(*,23) (LONG/3600.0),JDAY 
      DELT   = 0.0 
      DLAST  = 0.0 
      JDAY   = JULDAY 
      TMDAY  = TIMDAY 
C======================================================================= 
C     Recapture starting date/time. 
C======================================================================= 
      DO 2000 MBIG = 1,1000000 
C======================================================================= 
      IF(KRAIN.LE.MRAIN) THEN 
C======================================================================= 
C     If current time >= rainfall time, need to read new rainfall. 
C======================================================================= 
         IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN 
                   DELUGE = .FALSE. 
                   DESERT = .TRUE. 
 200               READ(NREIN,END=800,ERR=777,IOSTAT=IOS) JDAY,TMDAY, 
     +                                THISTO, (BANE(J),J=1,NSTA) 
Cwch, 4/15/02. Move rainfall summer from here. 
                   CALL NTIME(JDAY,TMDAY,TRN) 
                   DTRN = DBLE(TRN) 
                   DTRN  = TRN 
                   IF(DABS(DTRN).LT.WET*0.001) TRN = 0.0 
                   TRAIN = TRN 
                   KRAIN = KRAIN + 1 
                   NRAIN = NRAIN + 1 
C======================================================================= 
C#### WCH (CDM, C. MOORE), 10/93 
Cwch, 4/15/02. Start to sum rain *after* start of simulation. 
C     Otherwise, may get rainfall total in subcatchment summaries 
C     that includes extensive rain prior to start of simulation.  
C======================================================================= 
                   IF(.NOT.(MBIG.EQ.1.AND.TRN.LT.0.0)) THEN 
                        DO 201 J=1,NSTA 
 201                    RTOT(J)=RTOT(J)+BANE(J)*THISTO 
                        ENDIF 
C####################################################################### 
C#### WCH, 4/7/94.  If no precipitation  .AND.  snow on ground (KWIKSN 
C     = 1) or if overland flow is occuring (KWIK = 1) or channel/pipe 
C     flow is occuring (KWIKGT = 1), use WETDRY time step.  For better 
C     accuracy, user must set WETDRY closer to WET, at expense of 
C     computation time.  Check for none of the above (dry conditions 
C     and DRY time step) is made later. 
C======================================================================= 
                   IF(TRAIN.EQ.0.0)  THEN 
C======================================================================= 
C     Here, have rain value at this time.  Will assign WET time step 
C     later. 
C======================================================================= 
                                TRAIN  = THISTO + TRAIN 
                                JDRY   = 0 
                                JWET   = 1 
                                ELSE IF(TRAIN.GT.0.0) THEN 
C======================================================================= 
C     Here, have rain value at future time.  Will use WETDRY time step 
C     unless DRY is determined later. 
C======================================================================= 
                                JDRY   = IFIX(TRAIN/WETDRY) 
                                IF(JDRY.EQ.0) THEN 
                                              JDRY  = 1 
                                              XDELT = TRAIN 
                                              ELSE 
                                              XDELT = TRAIN/FLOAT(JDRY) 
                                              ENDIF 
                                TRAIN  = THISTO + TRAIN 
                                ELSE 
C======================================================================= 
C     TRAIN < 0, current time > rainfall time.  
C     Here, still need to read rainfall value at time >= current time. 
C======================================================================= 
                                GO TO 200 
                                ENDIF 
                   IF(THISTO.LT.WET) THEN 
C####################################################################### 
C RED (WCH), 12/31/93. If THISTO < WET, change the time step to THISTO 
C                      to ensure calculation of correct rainfall amount. 
C                      Change the time step, not the rainfall. 
C                      Add new variable IMSHORT. 
C####################################################################### 
C#### Old code: 
C####                           DO 300 J = 1,NRGAG 
C#### 300                       BANE(J)  = BANE(J)*THISTO/WET 
C####                           JWET     = 1 
C####                           ELSE 
C####                           JWET     = IFIX(THISTO/WET) 
C####                           ENDIF 
C#### New code: 
                                JWET     = 1 
                                IMSHORT  = 1 
                                ELSE 
                                JWET     = IFIX(THISTO/WET) 
                                IMSHORT  = 0 
C#### Check for some slop. 
                                IF(FLOAT(JWET)*WET.LT.THISTO-0.01) THEN 
                                     JWET    = JWET + 1 
                                     IMSHORT = 2 
                                     ENDIF 
                                ENDIF 
C 
                   GO TO 801 
C======================================================================= 
C     Here if reach end-of-file on precipitation input file. 
C======================================================================= 
  800              CALL NDATE (LONG,JDAY,TMDAY) 
C#### 5/28/93, RED.  REMOVE TRN=TRAIN AND ADD TRAIN=TRN AFTER CALL STMT. 
C####             TRN = TRAIN 
                   CALL NTIME (JDAY,TMDAY,TRN) 
                   TRAIN = TRN 
                   JDRY   = IFIX(TRAIN/WETDRY) 
                   IF(JDRY.EQ.0) THEN 
                            JDRY  = 1 
                            XDELT = TRAIN 
                            ELSE 
                            XDELT = TRAIN/FLOAT(JDRY) 
                            ENDIF 
                   JWET   = 0 
                   DO 810 J = 1,NRGAG 
  810              BANE(J)  = 0.0 
  801              CONTINUE 
                   ENDIF 
         ELSE 
C======================================================================= 
C     Here, have read future rainfall value.  Use zero until reach 
C     that time. 
C======================================================================= 
         DO 820 J = 1,NRGAG 
  820    BANE(J)  = 0.0 
         ENDIF 
C======================================================================= 
C     Wet, Wet/Dry or Dry Time Step. 
C======================================================================= 
      NSTEP  = 1 
 2050 MTIME  = MTIME + 1 
C======================================================================= 
C     DELUGE = .TRUE.   ==> Wet time step. 
C     DELUGE = .FALSE.  ==> Dry or wet/dry time step. 
C 
C     KWIK   =    0     ==> No overland flow. 
C     KWIK   =    1     ==> Some overland flow occuring. 
C#### WCH, 4/7/94. 
C     KWIKSN =    0     ==> No snow on catchment surface. 
C     KWIKSN =    1     ==> Snow somewhere in catchment. 
C 
C     KWIKGT =    0     ==> No channel/pipe routing occuring. 
C     KWIKGT =    1     ==> Some channel/pipe routing occuring. 
C 
C     Set DELUGE = TRUE if reach a time with precipitation. 
C======================================================================= 
      IF(NSTEP.GT.JDRY) DELUGE = .TRUE. 
      IF(DELUGE) THEN 
C#### RED (WCH), 12/31/93.  Calculate DELT based on IMSHORT. 
                 IF(IMSHORT.EQ.0) DELT   = WET 
                 IF(IMSHORT.EQ.1) DELT   = THISTO 
                 IF(IMSHORT.EQ.2) DELT   = THISTO/FLOAT(JWET) 
C####                 DELT   = WET 
                 DO 305 J = 1,NRGAG 
  305            REIN(J)  = BANE(J) 
C======================================================================= 
C     Here if DELUGE is false (not a time step with precipitation). 
C 
C     Use WETDRY time step for: 
C     - remaining overland flow 
C     - snow on surface 
C     - remaining channel/pipe flow 
C     - groundwater flow to channel/pipes. 
C 
C     Use DRY time step if none of the above.  Thus, DRY applies to 
C     lingering evaporation, infiltration and groundwater ET/seepage. 
C 
C     NOTE: Time steps are only approximately equal to DRY or WETDRY. 
C     Divide interval between end of precip (or snow) and next precip 
C     into intervals nearest to DRY or WETDRY.  This means that 
C     calculations and time step print-outs do not necessarily come at 
C     even time intervals corresponding to DRY or WETDRY entered by the 
C     user. 
C======================================================================= 
                 ELSE 
                 DO 310 J = 1,NRGAG 
  310            REIN(J)  = 0.0 
C======================================================================= 
C#### WCH, 4/7/94.  Change code to add check for snow on surface or 
C     overland flow or channel/pipe flow.  Need to use WETDRY time step 
C     if there is snow because don't know when it will melt. 
C 
C     For snow, variable KWIKSN is initialized in WSHED and changed 
C     (if snow is present) in SNOW. 
C 
C     Check for presence of channel/pipe routing in GUTTER. 
C======================================================================= 
                 IF((ISNOW.GT.0.AND.KWIKSN.EQ.1).OR.KWIKGT.EQ.1) KWIK=1 
C======================================================================= 
C     Purpose of logical variable DESERT is to ensure that only pass 
C     through following IF-THEN loop once, to set time step at beginning 
C     of a dry or wet/dry period. 
C     This is the only place where DRY time step is established. 
C======================================================================= 
                 IF(KWIK.EQ.0.AND.DESERT) THEN 
                               TMREM = FLOAT(JDRY-NSTEP+1)*XDELT 
                               JDRY  = IFIX(TMREM/DRY) 
                               IF(JDRY.EQ.0) THEN 
                                             JDRY  = 1 
                                             DELT  = TMREM 
                                             ELSE 
                                             DELT = TMREM/FLOAT(JDRY) 
                                             ENDIF 
                               DESERT = .FALSE. 
                               NSTEP  = 1 
                               ENDIF 
C======================================================================= 
C     Similarly, if water is on surface (or KWIK is otherwise set to 1), 
C     then only pass through following IF-THEN once, to set up time 
C     intervals. 
C======================================================================= 
                 IF(KWIK.GT.0.AND. .NOT.DESERT) THEN 
                               TMREM = FLOAT(JDRY-NSTEP+1)*DELT 
                               JDRY  = IFIX(TMREM/WETDRY) 
                               IF(JDRY.EQ.0) THEN 
                                             JDRY  = 1 
C#### WCH, 4/7/94.  CHANGE DELT TO XDELT IN ORDER TO USE THESE CALCS. 
                                             XDELT  = TMREM 
                                             ELSE 
C#### WCH, 4/7/94.  CHANGE DELT TO XDELT IN ORDER TO USE THESE CALCS. 
                                             XDELT = TMREM/FLOAT(JDRY) 
                                             ENDIF 
                               DESERT = .TRUE. 
                               NSTEP  = 1 
                               ENDIF 
                 IF(KWIK.GT.0) DELT = XDELT 
                 ENDIF 
      REIGN  = REIN(1) 
      TIME   = TIME + DELT 
      FINF   = CNT(4) 
      IF(TIME.GT.LONG) THEN 
                       DELT = LONG - TIME + DELT 
                       TIME = LONG 
                       IF(NRAIN.GT.0) NRAIN = NRAIN - 1 
                       ENDIF 
C======================================================================= 
C#### WCH, 11/30/93.  TRY DEFINITION OF DLAST AND DMEAN CONSISTENT WITH 
C                     OTHER BLOCKS AND COMPUTATIONS.  USE NEW DELT FOR 
C                     DMEAN IF PAST TIME STEP WAS DRY (NO RUNOFF TO 
C                     INLETS, LWEAT = 0). 
C======================================================================= 
                     DMEAN = 0.5 * (DLAST + DELT) 
      IF(LWEAT.EQ.0) DMEAN = DELT 
C 
      CALL STIME(DELT) 
cim   need to write to 6 not * to get carriage control on writes to console 
      WRITE(6,22) MTIME,TIME/3600.0,JULDAY 
C======================================================================= 
C     Watershed Elements (Overland Flow). 
C======================================================================= 
      CALL WSHED(REIN,KWIK) 
C####################################################################### 
C     C. Moore, CDM, 8/93.  I/I timestep calculations. 
C======================================================================= 
      IF (RRMAX.GT.0.0) CALL RDIISHED 
C======================================================================= 
C     Watershed Quality contributions. 
C======================================================================= 
      IF(KWALTY.EQ.1) CALL QSHED 
C======================================================================= 
C#### WCH, 9/93.  Add infiltration/inflow to subcatchment flows after 
C       performing quality calculations. 
C======================================================================= 
      IF(RRMAX.GT.0.0) THEN 
           DO 220 JK = 1,NOW 
  220      WFLOW(JK) = WFLOW(JK) + FLOWII(JK) 
           ENDIF 
C======================================================================= 
C     Channel/Pipe Elements. 
C======================================================================= 
C#### WCH, 4/7/94.  ADD PARAMETER KWIKGT 
      CALL GUTTER(REIGN,KWIKGT) 
C======================================================================= 
C     Sum inlet flows over the basin. 
C======================================================================= 
      FLWOFF    = 0.0 
cim   next should be NSAVE  NOT   NOW 
      DO 250 JK = 1,NSAVE 
      IF(NGTOI(JK).EQ.0) GO TO 255 
      NX        = NGTOI(JK) 
  250 FLWOFF    = FLWOFF  + OUTFLW(NX) 
  255 CNT(5)    = CNT(5)  + FLWOFF*DMEAN 
      FINF      = (CNT(4) - FINF)/DELT 
      DLAST = DELT 
C======================================================================= 
C#### WCH, 11/30/93.  TRY DEFINITION OF DLAST/DMEAN CONSISTENT WITH 
C                     BLOCKS. 
C####      IF(LWEAT.EQ.0) DLAST = WET 
C####                     LWEAT = KWIK 
C======================================================================= 
      LWEAT = 1 
      IF(FLWOFF.LE.0.0) LWEAT = 0 
C 
      IF(IPRN(2).EQ.0) WRITE(NFLOW,ERR=778,IOSTAT=IOS) TIME,FLWOFF,FINF 
C======================================================================= 
      IF(TIME.EQ.LONG) GO TO 2100 
      NSTEP = NSTEP + 1 
      IF(NSTEP.LE.JDRY+JWET) GO TO 2050 
 2000 CONTINUE 
 2100 CONTINUE 
      CALL DATED 
      WRITE(N6,272) MONTH,NDAY,NYEAR,MTIME,JULDAY,TIMDAY,TIMDAY/3600.0, 
     +              TIME/3600.0,TIME/86400.0 
C======================================================================= 
C     Write the extrapolation summary. 
C======================================================================= 
      WRITE(N6,8000) 
      DO 8100 J = 1,NOW,3 
      JJ        = J + 2 
      IF(JJ.GT.NOW) JJ = NOW 
      IF(JCE.EQ.0) WRITE(N6,8020) (NAMEW(K),LND(K),KLND(K),K=J,JJ) 
      IF(JCE.EQ.1) WRITE(N6,8021) (KAMEW(K),LND(K),KLND(K),K=J,JJ) 
 8100 CONTINUE 
C======================================================================= 
      IF(NOG.GT.0.AND.NOG.NE.999) THEN 
             WRITE(N6,8010) 
             DO 8200 J = 1,NOG,3 
             JJ        = J + 2 
             IF(JJ.GT.NOG) JJ = NOG 
             IF(JCE.EQ.0) WRITE(N6,8020) (NAMEG(K), 
     +                                    LCHAN(K),KCHAN(K),K=J,JJ) 
             IF(JCE.EQ.1) WRITE(N6,8021) (KAMEG(K), 
     +                                    LCHAN(K),KCHAN(K),K=J,JJ) 
 8200        CONTINUE 
             ENDIF 
C======================================================================= 
C     Calculate final subsurface storage. 
C======================================================================= 
      GRAREA     = 0.0 
      IF(NOGWSC.GT.0) THEN 
      DO 286 JE1 = 1,NOGWSC 
      GRAREA     = GRAREA + WAREA(JE1) 
 286  CNT(16)    = CNT(16)+TH1(JE1)*(GRELEV(JE1)-STG(JE1))*WAREA(JE1) + 
     +             POR(JE1)*(STG(JE1)-BELEV(JE1))*WAREA(JE1) 
      ELSE 
      GRAREA     = TRIBA 
      ENDIF 
C======================================================================= 
C     Compute water volume on subcatchments. 
C======================================================================= 
                     KKK = 3 
      IF(ISNOW.GT.0) KKK = 4 
      CNT(10)  = 0.0 
      DO 288 K = 1,KKK 
      DO 288 J = 1,NOW 
  288 CNT(10)  = CNT(10) + WDEPTH(K,J)*WAR(K,J) 
C======================================================================= 
C     Compute snow volume on subcatchments. 
C======================================================================= 
      IF(ISNOW.GT.0) THEN 
            DO 290 J = 1,NOW 
            CNT(8) = CNT(8)+(WSNOW(2,J)+FW(2,J))*WAR(2,J) 
            CNT(8) = CNT(8)+(WSNOW(1,J)+FW(1,J))*WAR(4,J) 
  290       CNT(8) = CNT(8)+(WSNOW(3,J)+FW(3,J))*(WAR(1,J)+WAR(3,J)) 
            END IF 
      DO 295 K  = 1,MQUAL 
  295 REFF(1,K) = 0.0 
      IF(NOG.EQ.0.OR.NOG.EQ.999) GO TO 350 
C======================================================================= 
C     Compute water stored in channels. 
C======================================================================= 
      DO 340 J = 1,NOG 
      IF(NPG(J).EQ.3) GO TO 340 
C======================================================================= 
C     Volume in TRAPEZOIDAL SECTIONS. 
C======================================================================= 
      IF(NPG(J).EQ.1) AX = 0.5*(GS1(J)+GS2(J))*GDEPTH(J)**2 + 
     +                     GWIDTH(J)*GDEPTH(J) 
C======================================================================= 
C     Volume in circular sections. Compute area of segment of a circle. 
C======================================================================= 
      IF(NPG(J).EQ.2) AX = GWIDTH(J)**2/4.0*(GDEPTH(J) - 
     +                     0.5*SIN(2.0*GDEPTH(J))) 
      IF(NPG(J).EQ.4) THEN 
                      WIDTH = GWIDTH(J)*SQRT(GDEPTH(J)/DFULL(J)) 
                      AX    = 0.66666667*WIDTH*GDEPTH(J) 
                      ENDIF 
      VOL    = AX*GLEN(J) 
      CNT(7) = CNT(7) + VOL + QSUR(J) 
C======================================================================= 
C     Calculate remaining channel pollutant loads. 
C     Store the sums in array REFF until reaching print routines. 
C======================================================================= 
      IF(NQS.NE.0) THEN 
                   DO 335 K  = 1,NQS 
                   RNEW      = VOL*C(K,J) + CVSUR(K,J) 
  335              REFF(1,K) = REFF(1,K)  + RNEW 
                   ENDIF 
  340 CONTINUE 
C======================================================================= 
C     Compute continuity error due to computations. 
C======================================================================= 
  350 SUMALL  = CNT(4) + CNT(6) + CNT(19) + CNT(21) + 
     +          CNT(8) + CNT(9) + CNT(10) 
C======================================================================= 
C     Print values in inches or millimeters over the basin. 
C     The number 3630 converts cubic feet per acre to inches. 
C======================================================================= 
      TY       =  TRIBA*3630.0 
      GY       = GRAREA*3630.0/43560.0 
      DO 351 J = 1,30 
      IF(J.LE.10.OR.J.GE.20) THEN 
                             IF (TY.NE.0.0) THEN 
                             ZUM(J)   = CNT(J)/TY 
                             ELSE 
                             ZUM(J)   = 0.0 
                             END IF 
                             ELSE 
                             IF (GY.NE.0.0) THEN 
                             ZUM(J)   = CNT(J)/GY 
                             ELSE 
                             ZUM(J) = 0.0 
                             END IF 
                             ENDIF 
  351 CONTINUE 
      IF (TY.NE.0.0) THEN 
                        ZALL    = SUMALL/TY 
      ELSE 
                        ZALL    = 0.0 
      END IF 
      IF(PRCIMP.LT.1.0) ZUM(18) = ZUM(11)/(1.0-PRCIMP) 
      IF(PRCIMP.LT.1.0) ZUM(19) = ZUM(12)/(1.0-PRCIMP) 
C======================================================================= 
C     IF METRIC = 2 ALL SUMMERS WILL HAVE TO BE CONVERTED TO CUBIC 
C                   METERS AND MILLIMETERS FROM CUBIC FEET AND 
C                   AND INCHES RESPECTIVELY. 
C======================================================================= 
      DO 355 J = 1,30 
      ZUM(J)   = ZUM(J) * CMET(5,METRIC) 
 355  CNT(J)   = CNT(J) / CMET(8,METRIC) 
      SUMALL   = SUMALL / CMET(8,METRIC) 
      ZALL     = ZALL   * CMET(5,METRIC) 
C======================================================================= 
C     Write the title for the continuity page depending on metric. 
C     CNT(21) = surface runoff from subcatchments 
C======================================================================= 
      IF(METRIC.EQ.1) WRITE (N6,360) CNT(1),ZUM(1) 
      IF(METRIC.EQ.2) WRITE (N6,361) CNT(1),ZUM(1) 
      IF(ISNOW.GT.0)  WRITE(N6,370)  CNT(2),ZUM(2),CNT(3),ZUM(3) 
                      WRITE(N6,380)  CNT(4),ZUM(4),CNT(6),ZUM(6), 
     1                               CNT(21),ZUM(21),CNT(10),ZUM(10) 
      IF(ISNOW.GT.0)  WRITE(N6,390)  CNT(8),ZUM(8),CNT(9),ZUM(9) 
C======================================================================= 
C     Calculate the infiltration in inches over the pervious area only. 
C======================================================================= 
      IF(PRCIMP.LT.1.0)    ZUM4 = ZUM(4) / ( 1.0 - PRCIMP ) 
      Z1    = CNT(1) + CNT(3) 
      Z2    = ZUM(1) + ZUM(3) 
                    ERRER = 0.0 
      IF(Z2.NE.0.0) ERRER = 100.0*(Z2 - ZALL)/Z2 
      WRITE(N6,395) CNT(4),ZUM4,SUMALL,ZALL,Z1,Z2 
      WRITE(N6,400) ERRER 
C#### C. MOORE, CDM, 8/93. 
      WRITE(*,401) ERRER 
C####################################################################### 
C     C. Moore, CDM, 8/93.  Write the I/I continuity check. 
C####################################################################### 
      IF (RRMAX.GT.0.0) THEN 
cim           SUMOFRS = 0.0 
cim           DO 3340 J=1,NOW 
cim           DO 3340 I=1,3 
cim           DO 3340 JJ=1,12 
cim 3340      SUMOFRS = SUMOFRS + RDIIR(J,I,JJ)*SEWAREA(J) 
           SUMOFRS = SUMOFRS/RDIIAREA 
           SUMRII  = 0.0 
           DO 3350 I=1,3 
 3350      SUMRII = SUMRII + CNTRDII(I) 
CIM### 9/8/00 corrections for metric units 
	  IF(METRIC.EQ.2) THEN 
           IF(CNEXCESS.NE.0.0) THEN 
                ERRER = (SUMRII/35.315/RDIIAREA/10.0 - 
     +                  SUMOFRS*CNEXCESS)*100.0/(SUMOFRS*CNEXCESS) 
                ELSE 
                ERRER = 999.0 
                IF(SUMRII.EQ.0.0) ERRER = 0.0 
                ENDIF 
	   ELSE 
           IF(CNEXCESS.NE.0.0) THEN 
                ERRER = ((SUMRII/(RDIIAREA*3630.0)) - 
     +                  SUMOFRS*CNEXCESS)*100.0/(SUMOFRS*CNEXCESS) 
                ELSE 
                ERRER = 999.0 
                IF(SUMRII.EQ.0.0) ERRER = 0.0 
                ENDIF 
	   ENDIF 
CIM### 9/8/00 
C======================================================================= 
C     Include metric options. 
C======================================================================= 
           IF(METRIC.EQ.1) WRITE(N6,3358) 
           IF(METRIC.EQ.2) WRITE(N6,3359) 
           IF(METRIC.EQ.1) 
     1       WRITE(N6,3360) CNRAIN*RDIIAREA*43560.0/12.0,CNRAIN, 
     2       CNEXCESS*RDIIAREA*43560.0/12.0,CNEXCESS,SUMOFRS, 
     3       SUMOFRS*CNEXCESS*RDIIAREA*43560.0/12.0,SUMOFRS*CNEXCESS, 
     4       CNTRDII(1),(CNTRDII(1)/(RDIIAREA*3630.0)), 
     5       CNTRDII(2),(CNTRDII(2)/(RDIIAREA*3630.0)), 
     6       CNTRDII(3),(CNTRDII(3)/(RDIIAREA*3630.0)), 
     7       SUMRII,(SUMRII/(RDIIAREA*3630.0)) 
           IF(METRIC.EQ.2) 
CIM### 9/8/00 Correction for metric units 
c     1       WRITE(N6,3360) CNRAIN*RDIIAREA*43560.0/12.0/35.3133, 
c     2       CNRAIN*25.4,CNEXCESS*RDIIAREA*43560.0/12.0/35.315, 
c     3       CNEXCESS*25.4,SUMOFRS, 
c     4       SUMOFRS*CNEXCESS*RDIIAREA*43560.0/12.0/35.315, 
c     5       SUMOFRS*CNEXCESS*25.4, 
c     6       CNTRDII(1)/35.315,CNTRDII(1)/(RDIIAREA*3630.0)*25.4, 
c     7       CNTRDII(2)/35.315,CNTRDII(2)/(RDIIAREA*3630.0)*25.4, 
c     8       CNTRDII(3)/35.315,CNTRDII(3)/(RDIIAREA*3630.0)*25.4, 
c     9       SUMRII/35.315,SUMRII/(RDIIAREA*3630.0)*25.4 
CIM   CNRAIN, CNEXCESS IS MM  RDIIAREA IS HECTARES 
     1       WRITE(N6,3360) CNRAIN/1000.0*RDIIAREA*10000.0,CNRAIN, 
     1       CNEXCESS/1000.0*RDIIAREA*10000.0,CNEXCESS, 
     2       SUMOFRS, 
     4       SUMOFRS*CNEXCESS/1000.0*RDIIAREA*10000.0, 
     5       SUMOFRS*CNEXCESS, 
     6       CNTRDII(1)/35.315,CNTRDII(1)/35.315/RDIIAREA/10.0, 
     7       CNTRDII(2)/35.315,CNTRDII(2)/35.315/RDIIAREA/10.0, 
     8       CNTRDII(3)/35.315,CNTRDII(3)/35.315/RDIIAREA/10.0, 
     9       SUMRII/35.315,SUMRII/35.315/RDIIAREA/10.0 
CIM### 9/8/00 
           IF(IIRDII.EQ.0) THEN 
                WRITE(N6,3361) ERRER 
                WRITE(*,3362) ERRER 
                ELSE 
                WRITE(N6,3363) 
                ENDIF 
           ENDIF 
C======================================================================= 
C     Write the channel/pipe continuity check. 
C======================================================================= 
      IF(TY.NE.0.0) THEN 
Cwch, 2/10/01.  Metric correction from Sandy Elliot, NIWA, New Zealand. 
C           ZUM13   = CNT(13)/TY 
           ZUM13   = CNT(13)*CMET(8,METRIC)/TY*CMET(5,METRIC) 
           ELSE 
           ZUM13   = 0.0 
           ENDIF 
      C1      = CNT(5)  + CNT(7)  + CNT(22) 
      C2      = CNT(20) + CNT(21) + CNT(13) 
      Z1      = ZUM(5)  + ZUM(7)  + ZUM(22) 
C#### C. MOORE, CDM, 8/93 
      ZZ1     = CNT(5)  + CNT(7)  + CNT(22) 
      Z2      = ZUM(20) + ZUM(21) + ZUM13 
                    ERRER = 0.0 
C#### C. MOORE, CDM, 8/93 
CCC   IF(Z1.NE.0.0) ERRER = 100.0*(Z1 - ZUM(20) - ZUM13 - ZUM(21))/Z1 
      IF(ZZ1.NE.0.0) ERRER = 100.0*(ZZ1-CNT(20)-CNT(13)-CNT(21))/ZZ1 
      IF(METRIC.EQ.1) WRITE(N6,365) CNT(20),ZUM(20),CNT(7),ZUM(7), 
     +                CNT(21),ZUM(21) 
      IF(METRIC.EQ.2) WRITE(N6,366) CNT(20),ZUM(20),CNT(7),ZUM(7), 
     +                CNT(21),ZUM(21) 
C#### C. MOORE, CDM, 8/93 
      IF(RRMAX.NE.0.0) THEN 
           IF(METRIC.EQ.1) WRITE(N6,369) SUMRII,SUMRII/TY 
           IF(METRIC.EQ.2) WRITE(N6,369) SUMRII/35.315, 
     +                     SUMRII/TY*25.4 
           ERRER = 0.0 
CIM### 9/8/00 Metric correction 
      IF (METRIC.EQ.1) THEN 
           IF(ZZ1.NE.0.0) ERRER = 100.0*(ZZ1-CNT(20)-CNT(13)-CNT(21)- 
     +                            SUMRII)/ZZ1 
      ELSE 
           IF(ZZ1.NE.0.0) ERRER = 100.0*(ZZ1-CNT(20)-CNT(13)-CNT(21)- 
     +                            SUMRII/35.315)/ZZ1 
      endif 
CIM### 
           ENDIF 
      WRITE(N6,367)   CNT(13),ZUM13,CNT(22), 
     +                ZUM(22),CNT(5),ZUM(5),C2,Z2,C1,Z1,ERRER 
C#### C. MOORE, CDM, 8/93 
      WRITE(*,368) ERRER 
C======================================================================= 
C     Write the groundwater continuity check. 
C======================================================================= 
      IF(NOGWSC.GT.0) THEN 
           SUMSBS = ZUM(11)+ZUM(12)+ZUM(13)+ZUM(14)+ZUM(16) 
           IF((ZUM(17)+ZUM(15)).NE.0.0) THEN 
                      SUBERR = (ZUM(17)+ZUM(15)-SUMSBS)/ 
     +                         (ZUM(17)+ZUM(15))*100.0 
                      ELSE 
                      SUBERR = 0.0 
                      ENDIF 
            WRITE(N6,356) 
            IF(METRIC.EQ.1) WRITE(N6,358) 
            IF(METRIC.EQ.2) WRITE(N6,357) 
            WRITE(N6,870) CNT(17),ZUM(17), 
     1                CNT(11),ZUM(11),CNT(12),ZUM(12),CNT(13),ZUM(13), 
     2                CNT(14),ZUM(14),CNT(15),ZUM(15),CNT(16),ZUM(16), 
     3                CNT(11),ZUM(18),CNT(12),ZUM(19) 
            ENDIF 
      IF(NOGWSC.NE.0) WRITE(N6,871) SUBERR 
C####################################################################### 
C     Chuck Moore, CDM, 8/93.  Call routine to print summary statistics 
C       for channel/pipes. 
C####################################################################### 
      CALL SMSTAT 
C======================================================================= 
C     CALCULATE THE QUALITY LOAD REMAINING ON THE SURFACE 
C     AND IN THE CATCHBASINS AT THE END OF THE SIMULATION 
C     THE SUMS WILL BE STORED IN ARRAYS PSHED AND PBASIN 
C     FOR EVENTUAL PRINTOUT IN SUBROUTINE PRPOLL. 
Cwch, 1/4/01. Initialize summers inside loop on quality.  
C     Initialize SUMWAT in RUNOFF.    
C======================================================================= 
      IF(NQS.GE.1) THEN 
                   DO 500 I = 1,NQS 
                   SUMSRF   = 0.0 
                   SUMCAT   = 0.0 
                   DO 600 K = 1,NOW 
                   SUMCAT   = SUMCAT + PBASIN(I,K) 
C======================================================================= 
Cwch, 1/4/01 Here need to fix summer, using correct land use value. 
Cwch, 12/20/00. Use SUMNL(J,I,10) to store remaining loads by land use. 
C     And it gets more complicated.  If subcatchment to subcatchmnet or 
C     internal subcatchment overland flow routing occurs, must include 
C     remaining concentration in summation.   
C======================================================================= 
                   IKALC = 0 
                   IF(NWTOW(1,K).NE.0.OR.IFLOWP(K).EQ.1.OR.IFLOWP(K) 
     1  .EQ.2.OR.IFLOWP(K).EQ.4.OR.IFLOWP(K).EQ.5) IKALC = 1 
	             IF(IKALC.EQ.1) THEN 
	                  IJK = 3 
					  IF(ISNOW.GT.0) IJK = 4 
	                  VOL4Q = 0.0 
	                  DO IK=1,IJK 
	                     VOL4Q = VOL4Q + WDEPTH(IK,K)*WAR(IK,K) 
	                     ENDDO 
	                  ENDIF 
				 DO 600 JJ = 1,N1 
	             IF(N1.EQ.1) J = KLAND(K) 
	             IF(N1.GT.1) J = JJ 
	             SUMNL(J,I,10) = SUMNL(J,I,10) + PSHED(J,I,K) 
                   SUMSRF        = SUMSRF        + PSHED(J,I,K) 
C======================================================================= 
Cwch, 12/20/00. Note that land uses are NOT associated with the four 
C     subcatchment flow subareas.  Hence, distribute volume over each 
C     subarea strictly on the basis of the land use fraction. 
C======================================================================= 
	             IF(IKALC.EQ.1) THEN 
	                  SUMWAT(I) = SUMWAT(I) + 
     1                    VOL4Q*PLAND(J,K)*COFF(J,I,K) 
                        SUMNL(J,I,11) = SUMNL(J,I,11) +  
     1                    VOL4Q*PLAND(J,K)*COFF(J,I,K)					   
                        ENDIF 
 600               CONTINUE 
C======================================================================= 
C     Change the units from milligrams to kilograms. 
C     Careful. Here we use PSHED(1,poll#,1) to store remaining 
C     surface load. Can do this because run through land use subscripts  
C     (first subscript) first, in loop just above, and use subscript 1 
C     from first subcatchment.  Hence, we read data before writing 
C     over them.  
C======================================================================= 
                   SUMSRF       = SUMSRF / 1.0E06 
                   SUMCAT       = SUMCAT / 1.0E06 
                   PSHED(1,I,1) = SUMSRF 
                   PBASIN(I,1)  = SUMCAT 
 500               CONTINUE 
C======================================================================= 
C     Calculate the remaining pollutant loads in the channel system. 
C     Change the units of REFF from NDIM units * flow to units of KG. 
C======================================================================= 
                   DO 850  K = 1,NQS 
                   ND        = NDIM(K)   + 1 
 850               REFF(1,K) = REFF(1,K) * FACT3(ND) / 1.0E06 
                   ENDIF 
      RETURN 
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY. 
 777  WRITE(N6,9777) MOD(IOS,256) 
      STOP 
 778  WRITE(N6,9778) MOD(IOS,256) 
      STOP 
C======================================================================= 
   22 FORMAT('+',20X,'Step=',I10,F10.2,' hours. Julian Date = ',I7) 
   23 FORMAT(/,' Beginning time step loop.  End at time ', 
     1           F11.2,' hours. Final date is ',I7,/, 
     2 ' Current step/time = ',/) 
  272 FORMAT(/, 
     1' ************************************************',/, 
     2' *      End of time step DO-loop in Runoff      *',/, 
     3' ************************************************',//, 
     4' Final Date (Mo/Day/Year)   = ',T48,I2,'/',I2,'/',I4,/, 
     5' Total number of time steps = ',T50,I8,/, 
     6' Final Julian Date  =',T45,5X,I8,/, 
     7' Final time of day  =',T45,F13.0,' seconds.',/, 
     8' Final time of day  =',T45,F13.2,'   hours.',/, 
     9' Final running time =',T45,F13.4,'   hours.',/, 
     9' Final running time =',T45,F13.4,'    days.') 
Cwch, 1/7/03  
 2110 FORMAT (/,' End of preliminary input data and data echo.') 
 2115 FORMAT(//, 
     +' ***************************************************',/, 
     +' *  Precipitation Interface File Summary           *',/, 
     +' *  Number of precipitation station....',I9,'   *',/, 
     +' ***************************************************',/) 
C#### WCH, 8/1/95.  CHANGE I13 TO A13. 
 2120 FORMAT(' Location Station Number',/, 
     +       ' -------- --------------',/, 
     +       10(I9,'. ',A13,/)) 
 356  FORMAT(/,1H1,/, 
     +' ***************************************************',/, 
     +' *     Continuity Check for Subsurface Water       *',/, 
     +' ***************************************************',/) 
 357  FORMAT(70X,'Millimeters over',/,51X,'cubic meters',7X, 
     .      'Subsurface Basin') 
 358  FORMAT(70X,'Inches over',/,54X,'cubic feet',6X, 
     .       'Subsurface Basin') 
 360  FORMAT(1H1,/, 
     +' **********************************************',/, 
     +' *       Continuity Check for Surface Water   *',/, 
     +' **********************************************',/, 
     1 69X,'Inches over',/, 55X,'cubic feet    Total Basin',/, 
     2 ' Total Precipitation (Rain plus Snow)',16X,1PE13.6,0PF11.3) 
 361  FORMAT(1H1,/, 
     +' **********************************************',/, 
     +' *       Continuity Check for Surface Water   *',/, 
     +' **********************************************',/, 
     1 69X,'Millimeters over',/,55X,'cubic meters  Total Basin',/, 
     2 ' Total Precipitation (Rain plus Snow)',16X,1PE13.6,0PF11.3) 
 365  FORMAT(//, 
     +' **********************************************',/, 
     +' *       Continuity Check for Channel/Pipes   *',/, 
     +' **********************************************',/, 
     1 69X,'Inches over',/,55X,'cubic feet    Total Basin',/, 
     2' Initial Channel/Pipe Storage................', 
     2  8X,1PE13.6,0PF11.3,/, 
     3' Final Channel/Pipe Storage..................', 
     2  8X,1PE13.6,0PF11.3,/, 
     4' Surface Runoff from Watersheds..............', 
     2  8X,1PE13.6,0PF11.3) 
 366  FORMAT(//, 
     +' **********************************************',/, 
     +' *       Continuity Check for Channel/Pipes   *',/, 
     +' **********************************************',/, 
     1 69X,'Millimeters over',/,55X,'cubic meters  Total Basin',/, 
     2' Initial Channel/Pipe Storage................', 
     2  8X,1PE13.6,0PF11.3,/, 
     3' Final Channel/Pipe Storage..................', 
     2  8X,1PE13.6,0PF11.3,/, 
     4' Surface Runoff from Watersheds..............', 
     2  8X,1PE13.6,0PF11.3) 
  368 FORMAT(' Continuity Check for Channel/Pipes =      ',F10.2, 
     1 ' Percent') 
C#### C. MOORE, CDM, 8/93 
  369 FORMAT( 
     1' Total I/I Volume ...........................', 
     2  8X,1PE13.6,0PF11.3) 
  367 FORMAT( 
     5' Groundwater Subsurface Inflow...............', 
     2  8X,1PE13.6,0PF11.3,/, 
     6' Evaporation Loss from Channels..............', 
     2  8X,1PE13.6,0PF11.3,/, 
     7' Channel/Pipe/Inlet Outflow..................', 
     2  8X,1PE13.6,0PF11.3,/, 
     7' Initial Storage + Inflow....................', 
     2  8X,1PE13.6,0PF11.3,/, 
     7' Final Storage + Outflow.....................', 
     2  8X,1PE13.6,0PF11.3,/, 
     8' ********************************************',/, 
     9' * Final Storage + Outflow + Evaporation  - *',/, 
     9' * Watershed Runoff - Groundwater Inflow  - *',/, 
     9' *     Initial Channel/Pipe Storage         *',/, 
     9' *     ----------------------------------   *',/, 
     9' *  Final Storage + Outflow  + Evaporation  *',/, 
     9' ********************************************',/, 
     9' Error.......................................',F11.3, 
     9' Percent') 
 370  FORMAT (' Total Rain only',37X,1PE13.6,0PF11.3,/, 
     1 ' Total Initial Snow Cover (Water equiv.)',13X,1PE13.6,0PF11.3) 
 380  FORMAT (' Total Infiltration',34X,1PE13.6,0PF11.3,/, 
     1 ' Total Evaporation                  ',17X,1PE13.6,0PF11.3,/, 
     2 ' Surface Runoff from Watersheds     ',17X,1PE13.6,0PF11.3,/, 
     4 ' Total Water remaining in Surface Storage',12X,1PE13.6,0PF11.3) 
 390  FORMAT(' Total Water remaining in Snow Cover',17X,1PE13.6, 
     .        0PF11.3,/,' Total Snow removed from Basin (Water equiv.)', 
     .        8X,1PE13.6,0PF11.3) 
 395  FORMAT(' Infiltration over the Pervious Area...',14X,1PE13.6, 
     . 0PF11.3,/,'                       --------        ',/, 
     .         ' Infiltration + Evaporation + ',/, 
     .         ' Surface Runoff + Snow removal +',/, 
     .         ' Water remaining in Surface Storage +',/, 
     .         ' Water remaining in Snow Cover.........', 
     .           14X,1PE13.6,0PF11.3,/, 
     .         ' Total Precipitation + Initial Storage.', 
     .           14X,1PE13.6,0PF11.3) 
  400 FORMAT(//,' The error in continuity is calculated as',/, 
     .      ' ***************************************',/, 
     .      ' * Precipitation + Initial Snow Cover  *',/, 
     .      ' *      - Infiltration -               *'/, 
     .      ' *Evaporation - Snow removal -         *',/, 
     .      ' *Surface Runoff from Watersheds -     *',/, 
     .      ' *Water in Surface Storage -           *',/, 
     .      ' *Water remaining in Snow Cover        *',/, 
     .      ' *-------------------------------------*',/, 
     .      ' * Precipitation + Initial Snow Cover  *',/, 
     .      ' ***************************************',/, 
     .      ' Error..................................', 
     .       3X,F10.3,' Percent') 
  401 FORMAT(/,' Continuity Check for Surface Water =      ',F10.2, 
     1 ' Percent') 
 870  FORMAT(/,' Total Infiltration',34X,1PE13.6,0PF11.3,/, 
     .       ' Total Upper Zone ET',33X,1PE13.6,0PF11.3,/, 
     .       ' Total Lower Zone ET',33X,1PE13.6,0PF11.3,/, 
     .       ' Total Groundwater flow',30X,1PE13.6,0PF11.3,/, 
     .       ' Total Deep percolation',30X,1PE13.6,0PF11.3,/, 
     .       ' Initial Subsurface Storage',26X,1PE13.6,0PF11.3,/, 
     .       ' Final Subsurface Storage',28X,1PE13.6,0PF11.3,/, 
     .       ' Upper Zone ET over Pervious Area', 
     .         20X,1PE13.6,0PF11.3,/, 
     .       ' Lower Zone ET over Pervious Area', 
     .         20X,1PE13.6,0PF11.3) 
 871  FORMAT(//,' ******************************************',/, 
     .          ' * Infiltration + Initial Storage - Final *',/, 
     .          ' * Storage - Upper and Lower Zone ET -    *',/, 
     .          ' * Groundwater Flow - Deep Percolation    *',/, 
     .          ' * -------------------------------------- *',/, 
     .          ' *     Infiltration + Initial Storage     *',/, 
     .          ' ******************************************',/, 
     .          ' Error ....................................', 
     .            F10.3,1X,'Percent',//) 
C#### C. MOORE, CDM, 8/93 
 3358 FORMAT(1H1,/, 
     +' *****************************************************',/, 
     +' *       Continuity Check for Infiltration/Inflow    *',/, 
     +' *****************************************************',/, 
     1 68X,'Inches over',/, 54X,'cubic feet    Sewered Area') 
 3359 FORMAT(1H1,/, 
     +' *****************************************************',/, 
     +' *       Continuity Check for Infiltration/Inflow    *',/, 
     +' *****************************************************',/, 
     1 68X,'mm over',/, 54X,'cubic meters  Sewered Area') 
 3360 FORMAT( 
     2 ' Approx. Total Rain for I/I (Avg. of hyetographs)....', 
     3 1PE13.6,0PF11.3,/, 
     4 ' Total I/I Excess (Rain minus storage losses)........', 
     5 1PE13.6,0PF11.3,/, 
     6 ' Area Weighted Average Total Ratio......',0PF13.6,/, 
     7 ' Approx. Total Infiltration (Ratio*I/I Excess).......', 
     8 1PE13.6,0PF11.3,/, 
     9 ' Total Curve 1 Outflow Volume........................', 
     1 1PE13.6,0PF11.3,/, 
     2 ' Total Curve 2 Outflow Volume........................', 
     3 1PE13.6,0PF11.3,/, 
     4 ' Total Curve 3 Outflow Volume........................', 
     5 1PE13.6,0PF11.3,/, 
     6 ' Total I/I Outflow Volume............................', 
     7 1PE13.6,0PF11.3,//) 
 3361 FORMAT(' Approximate Continuity Error .................', 
     9 0PF10.3,' Percent',//, 
     1 ' Error computed as (Total I/I Outflow Volume - Approx. Total Inf 
     2iltration)  /',/,19X,' (Approx. Total Infiltration)') 
 3362 FORMAT(' Approximate Continuity Check for I/I     =',F10.2, 
     1 ' Percent') 
 3363 FORMAT(' Cannot compute I/I continuity error when using existing I 
     1/I',/,' NSCRAT(8) rainfall file (IIRDII=1).') 
 8000 FORMAT(/, 
     +' **************************************************',/, 
     +' *     Extrapolation Summary for Watersheds       *',/, 
     +' * # Steps ==> Total Number of Extrapolated Steps *',/, 
     +' * # Calls ==> Total Number of OVERLND Calls      *',/, 
     +' **************************************************',//, 
     +'  Subcatch   # Steps   # Calls  Subcatch   # Steps   # Calls  Sub 
     +catch   # Steps   # Calls',/, 
     +'  --------   -------   -------  --------   -------   -------  --- 
     +-----   -------   -------') 
8010  FORMAT(/, 
     +' **************************************************',/, 
     +' *     Extrapolation Summary for Channel/Pipes    *',/, 
     +' * # Steps ==> Total Number of Extrapolated Steps *',/, 
     +' * # Calls ==> Total Number of GUTNR Calls        *',/, 
     +' **************************************************',//, 
     +' Chan/Pipe   # Steps   # Calls Chan/Pipe   # Steps   # Calls Chan 
     +/Pipe   # Steps   # Calls',/, 
     +'  --------   -------   -------  --------   -------   -------  --- 
     +-----   -------   -------') 
8020  FORMAT(9I10) 
8021  FORMAT(3(A10,2I10)) 
9777  FORMAT(/,' ===> Error   Reading precipitation time history', 
     1         ' on the NSCRAT(1) file.',/, 
     2' Fortran error number =',I5,'. Run stopped from Sub. HYDRO.') 
9778  FORMAT(/,' ===> Error   Writing inlet hydrograph time history', 
     1         ' on the NSCRAT(4) file.',/, 
     2' Fortran error number =',I5,'. Run stopped from Sub. HYDRO.') 
C======================================================================= 
      END 
 
REM File: INDAT1.FOR 
 
      SUBROUTINE INDAT1 
C	EXTRAN BLOCK 
C	CALLED BY EXTRAN NEAR LINE 198 
C======================================================================= 
C     This Subroutine reads and prints control, 
C     Conduit and Junction data. 
C======================================================================= 
C     THIS PROGRAM LAST MODIFIED BY R.E.D., 4/92. 
C     MODIFICATION IS TO ALLOW ONLY ONE SET OF C3,34 LINES TO BE 
C       USED FOR IRREGULAR CHANNELS IF DESIRED. 
C     ADD INITIAL DATE ON LINE B1, WCH, 4/11/94. 
C     MODIFY FOR CORRECT START TIME USING HOT START, WCH, 7/25/96. 
C       ALSO, MINOR CORRECTION OF PRINTING 'JREDO' INSTEAD OF 'REDO'. 
CIM START  <><><><><><><><><><><><> 
CIM  CHANGE MADE 1/96 BY CDM TO CHANGE INTERNAL NUMBERING OF PIPE 
CIM  TYPES TO ALLOW OTHER TYPES TO BE INCORPORATED 
CIM END  <><><><><><><><><><><> 
CIM  10/98  modifified to remove multiple reads.  Lines are 
CIM  now padded with zeros in STRIP.FOR 
CWCH, 11/12/99, allow for negative IDATZ to force its use with interface 
C    file. 
CWCH, 3/27/00.  Change default date to 19410802 to correspond to other 
C    blocks. 
CWCH, 3/28/00. Fix remarkable typo in computation of equivalent 
C    roughness. 
CIM,  9/8/00.  Open interface after it knows starting date from interface 
C    file. 
CIM,  9/8/00.  Read optional D2 lines for threshold elevations against 
C    which elevations will be compared and reported. 
CWCH 9/8/00.  Trivial change for printout of INTER. 
CWCH 9/9/00.  Metricate ASCII output header and add column headings. 
Cred 2/4/01.  Correction for IDATZ. 
Cwch, 2/10/01.  Add metric conversions for conduits 9,10,11. 
Cwch, 10/30/01. Increase integer field with for conduits at junctions. 
Cwch, 7/20/04. Initialize variables for steady-state check.  
Cwch, 7/20/04. Fix area calc for arch pipes (case 11) and depth-width 
C       table values for vertical ellipse (case 10). From Mike Gregory, 
C       RED, and CIM.  
Cwch, 7/23/04. Provide option for choice of NHEAD spatial weighting.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'WEIR.INC' 
      INCLUDE 'BND.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'TIDE.INC' 
      INCLUDE 'HYFLOW.INC' 
      INCLUDE 'FLODAT.INC' 
cim TRANAID START 
CIM include common blocks for tranaid interface file 
      INCLUDE 'TRANAID.INC' 
cim TRANAID END 
CIM  NEW COMMON FOR WRITING OF RESULTS TO ASCII FILE 
      INCLUDE 'CWRITE.INC' 
CIM 
CIM  NEW COMMON FOR SAVING AND WRITING INTERMEDIATE CONTINUITY OUTPUT 
      INCLUDE 'INTCON.INC' 
c common for writing detailed EXTRAN ASCII output file. 
      INCLUDE 'ASCOUT1.INC' 
CIM  CHANGE FOR VARIABLE BASE FLOW 
      INCLUDE 'MOBFF.INC' 
CIM  CHANGE FOR BE LINES FOR MULTIPLE OUTPUT PERIODS 
      INCLUDE 'BE.INC' 
CIM  CHANGE FOR BB AND C1 INPUT OF PIPE SEDIMENT DEPTHS 
      INCLUDE 'PIPESED.INC' 
CIM 1/99 CHANGE FOR BA OUTPUT CONTROLS    - OUTPUT CONTROLS 
      INCLUDE 'BALINES.INC' 
	INCLUDE 'WASP.INC' 
cim  <><><><> increase dimensions of CTYPE from 8 to 12 and add types 
cim  to data statement 
cim change dimensions of kdum to NCHN  10/98 
      CHARACTER GTYPE(2)*20,CTYPE(12)*10,KDUM(NCHN)*10,IREAD*4 
	LOGICAL BFFACT,TABLE2 
	LOGICAL GRNDERROR 
      DATA GTYPE/'  POSITIVE FLAP GATE','  NEGATIVE FLAP GATE'/ 
      DATA CTYPE/' CIRCULAR ',' RECTANGLE',' HORSESHOE', 
     +           ' EGG-SHAPE',' BASKET   ',' TRAPEZOID', 
     +           ' POWER FNC',' NATURAL  ' 
CIM START  <><><><><><><><> 
     +          ,' H ELLIPSE',' V ELLIPSE',' ARCH     ', 
     +           ' BRIDGE   '/ 
CIM END   <><><><><><><> 
      DATA IREAD/'CARD'/ 
CIM  START  <><><><><><> 
CIM            closed is logical that flags closed conduits for equivalent 
CIM            PIPE CALCS,  NEWKLASS CONTAINS THE MAPPING FROM OLD TO NEW 
CIM            CLASS ID'S 
      LOGICAL CLOSED(NEE) 
      DIMENSION NEWKLASS(12) 
CIM  THESE NEXT ARRAYS CONTAIN DATA FOR STANDARD ELLIPTICAL AND 
CIM  ARCH PIPE TYPES: MAJOR AXIS LENGTH, MINOR AXIS LENGTH, 
CIM  FULL FLOW AREA, FULL FLOW HYDRAULIC RADIUS, INITIALIZED IN 
      INCLUDE 'SHAPE.INC' 
CIM  END     <><><><><><><><>< 
C======================================================================= 
C                  E X E C U T I O N 
C======================================================================= 
      NSTOP  = 0 
      ISOL   = 0 
      JSLOT  = 0 
      KSUPER = 0 
      NCSAVE = NSCRAT(4) 
      IF(NCSAVE.GT.0) REWIND NCSAVE 
C======================================================================= 
C     READ THE TWO A1 TITLE LINES 
C======================================================================= 
      READ(N5,*,ERR=888) CC,ALPHA1 
      READ(N5,*,ERR=888) CC,ALPHA2 
      WRITE(N6,2999) 
      WRITE(N6,5060) ALPHA1,ALPHA2 
C======================================================================= 
Cwch, 7/23/04  HERE, OPTION(S) FOR VERSION COMPATIBILITY. 
C======================================================================= 
Cwch, 7/23/04. Initialize NHEAD weighting parameters. 
C     Subscript NAVER = 1 > SWMM3x. 
C     Subscript NAVER = 2 > SWMM4x (default) 
C     Subscript NAVER = 3 > SWMM5 
C======================================================================= 
      WUP(1) = 1./4. 
	WDN(1) = 1./4. 
	WMD(1) = 1./2. 
	WUP(2) = 0. 
	WDN(2) = 0. 
      WMD(2) = 1.0 
      WUP(3) = 1./6. 
      WDN(3) = 1./6. 
      WMD(3) = 2./3. 
      NAVER  = 2 
	NFASNH = 0 
C======================================================================= 
C     READ OPTIONAL LINE AA FOR VERSION COMPATIBILITY VARIABLES. 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'AA') THEN 
                     READ(N5,*,ERR=888) CC,NAVER,NFASNH 
                     IF(NAVER.GE.1.AND.NAVER.LE.3) THEN 
	                    WRITE (N6,5050) 
				        IF(NAVER.EQ.1) WRITE (N6,5051)  
	                    IF(NAVER.EQ.2) WRITE (N6,5052) 
	                    IF(NAVER.EQ.3) WRITE (N6,5053) 
	                    ELSE 
	                    WRITE (N6,5054) NAVER 
	                    NAVER = 2 
	                    ENDIF 
	               IF(NFASNH.EQ.0.OR.NFASNH.EQ.1) THEN 
				        WRITE(N6,5055) NFASNH 
	                    ELSE 
	                    WRITE(N6,5056) NFASNH 
	                    NFASNH = 0 
	                    ENDIF 
	               ENDIF 
C======================================================================= 
C     READ SOLUTION PARAMETERS ON OPTIONAL DATA GROUP B0 
C======================================================================= 
      ISOLSKIP = 0 
Cwch, 7/20/04. Initialize variables for steady-state check.  
      TOLCS1   = 0. 
      QLOWCS   = 0. 
      TOLCS2   = 0. 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'B0') THEN 
                     BACKSPACE N5 
cim ### RHF 8/30/96 CS           READ(N5,*,ERR=888) CC,ISOL,KSUPER 
                     READ(N5,*,ERR=888) CC,ISOL,KSUPER,KREDO, 
     &                                  TOLCS1,QLOWCS,TOLCS2 
                     IF (ISOL.EQ.3) THEN 
                     ISOL = 0 
                     ISOLSKIP = 1 
                     ENDIF 
                     IF (ISOL.EQ.4) THEN 
                     ISOL = 1 
                     ISOLSKIP = 1 
                     ENDIF 
C --- 
                     ELSE 
                     BACKSPACE N5 
                     ENDIF 
CIM   BA THROUGH BE LINES ARE DUPLICATED BELOW.  AS DOCUMENTED IN 
CIM   EXTRAN44.DOC, B LINES SHOULD BE INPUT IN ALPHANUMERIC ORDER 
CIM   (E.G., B0, B1,...B9, BB, BC, BD.  HOWEVER NEED TO KEEP HERE 
CIM   TO MAINTAIN BACKWARD COMPTATIBILITY. 
CIM END 
C======================================================================= 
C     READ OUTPUT CONTROL PARAMETERS ON OPTIONAL DATA GROUP BA 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BA') THEN 
         BACKSPACE N5 
         READ(N5,*,ERR=888) CC,JHEAD,JP10,IWLEN 
         IF (JHEAD.LT.0.OR.JHEAD.GT.1) JHEAD = 0 
         IF (JP10.LT.0.OR.JP10.GT.1) JP10 = 0 
      ELSE 
         JHEAD = 0 
         JP10 = 0 
	   IWLEN = 0 
         BACKSPACE N5 
      ENDIF 
C  these lines are commented to avoid writing stuff 
C  twice when program trys to read lines again below. 
c         IF (JHEAD.EQ.0) WRITE(N6,8020) 
c         IF (JHEAD.EQ.1) WRITE(N6,8022) 
c         IF (JP10.EQ.0) WRITE(N6,8024) 
c         IF (JP10.EQ.1) WRITE(N6,8026) 
c	IF (IWLEN.EQ.0) WRITE(N6,7010) 
c	IF (IWLEN.EQ.1) WRITE(N6,7020) 
c	IF (IWLEN.EQ.2) WRITE(N6,7030) 
C======================================================================= 
C     READ SOLUTION PARAMETERS ON OPTIONAL DATA GROUP BB 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BB') THEN 
                     BACKSPACE N5 
cim SEDEPTH  Add IPIPESED to BB line 
CIM PP 4/1/97  add IPRATE to BB lines 
cim    9/22/97  add IM2 to BB line 
cim 
                     READ(N5,*,ERR=888) CC,JELEV,JDOWN,IPRATE,IM2, 
     a                                 IPIPESED 
                     IF(JELEV.LT.0) JELEV = 0 
                     IF(JDOWN.LT.0.OR.JDOWN.GT.2) JDOWN = 0 
                     ELSE 
                     JELEV = 0 
                     JDOWN = 0 
                     IPRATE = 0 
                     IM2 = 0 
                     IPIPESED = 0 
                     BACKSPACE N5 
                     ENDIF 
C======================================================================= 
C     READ INTERMEDIATE CONTINUITY OUTPUT DATA ON OPTIONAL DATA GROUP BC 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BC') THEN 
                     BACKSPACE N5 
                     READ(N5,*,ERR=888) CC,ICONTER 
                     ELSE 
                     ICONTER = 0 
                     BACKSPACE N5 
                     ENDIF 
c      IF (ICONTER.LE.0) then 
c      write(n6,8005) 
c      ICONTER = 2147483647 
c      else 
c      write(n6,8010) ICONTER 
c      endif 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP BD <<<<<<<<<<<< 
C    OPTIONAL INPUT OF BASE FLOW FACTORS 
C    CIM   10/97 
C======================================================================= 
C  INITIALIZE STUFF 
      NUMSETS = 0 
	BFFACT = .FALSE. 
      MONTHOLD = 0 
      DO 19947 I=1,MAXSETS 
      NUMBFF(I) = 0 
      INBFF(I) = 0 
      IBFF(I) = 0 
      DO 19947 J=1,MAXBFF 
19947 BFFMO(I,J) = 1.0 
      do 19349 i=1,nee 
19349 iwhich(i)=1 
19948 READ (N5,*,ERR=888) CC 
      IF (CC.EQ.'BD') THEN 
	BFFACT = .TRUE. 
      NUMSETS = NUMSETS+1 
      IF (NUMSETS.GT.MAXSETS) THEN 
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SETS SPECIFIED ON BD LINES', 
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXSETS 
      STOP 'TOO MANY BD LINES' 
      ENDIF 
      BACKSPACE N5 
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS) 
      IF (NUMBFF(NUMSETS).GT.MAXBFF) THEN 
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SPECIFIED ON BD LINE', 
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBFF,' FOR SET ', 
     .'NUMBER ',NUMSETS 
      STOP 'TOO MANY BASE BASE FLOW VALUES SPECIFED ON BD LINE' 
      ENDIF 
      BACKSPACE N5 
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS), 
     .              (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS)) 
      WRITE(N6,*) 
      WRITE(N6,*) ' MONTHLY BASE FLOW FACTOR SET NUMBER ',NUMSETS 
      WRITE(N6,949) (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS)) 
C GO BACK TO TRY TO READ NEXT BD LINE 
      GOTO 19948 
      ELSE 
C NO BD LINES READ, OR NO ADDITIONAL BD LINES FOUND 
C  THEN BACKSPACE AND CONTININUE 
      BACKSPACE N5 
      END IF 
c  initialize following below if needed 
c      IF (NUMSETS.LE.0) NUMSETS = 1 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP BE <<<<<<<<<<<< 
C    OPTIONAL INPUT OF DETAILED SUMMARY OUTPUT PERIODS 
C    CIM   5/98 
C======================================================================= 
C  INITIALIZE STUFF 
      DO NUMBE = 0,MAXBE 
      IBESTART(NUMBE) = 0 
      IBEEND(NUMBE) = 0 
      ENDDO 
      NUMBE = 0 
      IBE = 0 
19950 READ (N5,*,ERR=888) CC 
      IF (CC.EQ.'BE') THEN 
      NUMBE = NUMBE + 1 
      IBE = 1 
C  NOTE MAXBE IS RESERVED FOR PERIOD AFTER LAST PERIOD 
      IF (NUMBE.GT.MAXBE-1) THEN 
      WRITE(N6,*) ' NUMBER OF BE LINES', 
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBE-1 
      STOP 'TOO MANY BE LINES' 
      ENDIF 
      BACKSPACE N5 
      READ(N5,*,ERR=888) CC, IBESTART(NUMBE), IBEEND(NUMBE) 
      IF (NUMBE.EQ.1) WRITE(N6,951) 
      WRITE(N6,952) IBESTART(NUMBE),IBEEND(NUMBE) 
C  TRY TO READ NEXT BE LINE 
      GO TO 19950 
      ELSE 
C  NO BE LINE FOUND.  BACKSPACE AND CONTINUE 
CIM SET IBESTART(0) AND IBEEND(0) 
CIM FOR USE IN CASE NO BE LINES ARE INPUT 
c      IBESTART(0) = NSTART 
c      IBEEND(0) = 999999999 
      BACKSPACE N5 
	ENDIF 
C  Check on inputs 
	IF (NUMBE.GT.0) THEN 
CIM SET IBESTART(NUMBE+1) AND IBBEND(NUMBE+1) HERE 
      IBESTART(NUMBE+1) = 999999999 
      IBEEND(NUMBE+1) = 999999999 
      DO I = 1, NUMBE 
      IF (IBEEND(NUMBE).LE.IBESTART(NUMBE)) THEN 
      WRITE(N6,*) ' ERROR - ENDING CYCLE IS LESS THAN STARTING CYCLE ' 
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ', 
     *IBESTART(I),' END CYCLE = ',IBEEND(I) 
      STOP ' ERROR IN NE LINE INPUTS' 
      ENDIF 
      IF (I.GT.1.AND.IBESTART(I).LE.IBEEND(I-1)) THEN 
      WRITE(N6,*) ' ERROR - STARTING CYCLE IS LESS THAN ENDING CYCLE ', 
     A'OF PREVIOUS PRINTOUT PERIOD' 
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ', 
     AIBESTART(I),' END CYCLE OF PREVIOUS NE CARD = ',IBEEND(I-1) 
      STOP ' ERROR IN BE LINE INPUTS' 
      ENDIF 
      ENDDO 
      ENDIF 
C======================================================================= 
C     GENERAL CONTROL PARAMETERS ON DATA GROUPS B1, B2 AND B3 
C======================================================================= 
C#### WCH, 4/11/94.  ADD OPTIONAL INITIAL DATE TO LINE B1 INPUT. 
      IDATZ = 0 
      READ(N5,*,ERR=888) CC,NTCYC,DELT,TZERO,NSTART,INTER,JNTER,JREDO, 
     1 IDATZ 
C 
      READ(N5,*,ERR=888) CC,METRIC,NEQUAL,AMEN,ITMAX,SURTOL 
      READ(N5,*,ERR=888) CC,NHPRT,NQPRT,NPLT,LPLT,NJSW 
C======================================================================= 
C     METRIC = 0 --> U.S. CUSTOMARY UNITS 
C     METRIC = 1 --> METRIC UNITS 
C                    NOTE: METRIC = METRIC + 1  SOON IN FORTRAN CODE. 
C                    NOTE: EXTRAN USES CONSISTENT UNITS (U.S. OR METRIC) 
C                      INTERNALLY IN CODE DURING COMPUTATIONS. 
C     JSLOT  = 0 --> SUM OF JUNCTION FLOW IS ZERO 
C     JSLOT  = 1 --> PREISSMAN SLOT 
C======================================================================= 
      IF(SURTOL.LT.0.0) THEN 
                        ISOL   = 1 
                        SURTOL = ABS(SURTOL) 
                        ENDIF 
cim rhf change .GE. to .EQ. 
      IF(ISOL.EQ.2)  JSLOT = 1 
      METRIC               = METRIC + 1 
      RDELT                = DELT 
      DELT2                = DELT/2.0 
      GRVT                 = 32.2 
      IF(METRIC.EQ.2) GRVT = 9.806 
      IF(AMEN.EQ.0.0.AND.METRIC.EQ.1) AMEN = 12.566 
      IF(AMEN.EQ.0.0.AND.METRIC.EQ.2) AMEN =  1.22 
      WRITE(N6,5100)  NTCYC 
      WRITE(N6,5120)  DELT,DELT*FLOAT(NTCYC)/3600.0 
      IF(NEQUAL.EQ.0) WRITE(N6,5121) NEQUAL 
C BAC START   
C      IF(NEQUAL.GE.1) WRITE(N6,5122) NEQUAL 
      IF(NEQUAL.EQ.1) WRITE(N6,5122) NEQUAL 
      IF(NEQUAL.EQ.2) WRITE(N6,5921) NEQUAL 
      IF(NEQUAL.EQ.3) WRITE(N6,5922) NEQUAL 
      IF(NEQUAL.EQ.4) WRITE(N6,5923) NEQUAL 
      IF(NEQUAL.EQ.5) WRITE(N6,5924) NEQUAL 
cim   check to eliminate possibility of using nequal 4 or 5 with isol = 0 or 3 
cim 
      IF(NEQUAL.GE.4) THEN 
c      IF(ISOL.EQ.0.or.ISOL.EQ.3) THEN 
c      WRITE(N6,7920) 
c      WRITE(*,7920) 
c 7920 FORMAT(' WARNING : TESTING SHOWS THAT USING NEQUAL OF 4 OR 5 ',/, 
c     a' WITH ISOL EQUAL TO 0 OR 3 MAY PRODUCE ERRONEOUS RESULTS.  ',/, 
c     b' WE SUGGEST USING ISOL OF 1 OR 4.  IF YOU USE ISOL OF 0 OR 3, ' 
c     c,/,' WE RECOMMEND THAT YOU TEST THE PROGRAM RESULTS AGAINST',/, 
c     d' SIMULATIONS USING NEQUAL OF 3 OR 4.') 
c      WRITE(*,*) 'PRESS ENTER TO CONTINUE WITH SIMULATION' 
c      READ(*,*) KDUM(1) 
c      ENDIF 
      IF (ISOL.EQ.2) THEN 
      WRITE(N6,7930) 
      WRITE(*,7930) 
 7930 FORMAT(' WARNING : USE OF NEQUAL OF 4 OR 5 HAS NOT BEEN TESTED',/ 
     A,' WITH ISOL OF 2.  WE SUGGEST THAT YOU COMPARE RESULTS WITH',/, 
     B' NEQUAL OF 4 OR 5 WITH CORRESPONDING RESULTS FROM NEQUAL', 
     C' OF 3 OR 4.') 
      write(*,*) 'PRESS ENTER TO CONTINUE WITH SIMULATION' 
      read(*,*) KDUM(1) 
      ENDIF 
      ENDIF 
C BAC END   
      IF(METRIC.EQ.1) WRITE(N6,5123) METRIC-1 
      IF(METRIC.EQ.2) WRITE(N6,5124) METRIC-1 
      IF(NSTART.LE.0) NSTART   = 1 
CIM IF JNTER is ZERO SET TO BIG 
      IF (JNTER.EQ.0.0) JNTER = 999999999 
CIM CHANGES FOR INTER 
      SELECT CASE(INTER) 
      CASE (0) 
CIM FIRST IF INTER IS ZERO, THEN NO OUTPUT IS WRITTEN 
CIM SET INTER TO A BIG NUMBER 
      INTER = 999999999 
      IASCII = 0 
      CASE (:-1) 
cim less than zero, modify JOUT file to create 
cim detailed ascii results output file 
      INTER = -INTER 
      WRITE(N6,5139) 
      IASCII = JOUT(IOUTCT) 
      NEXT = 0 
      IF (IASCII.EQ.0) THEN 
      WRITE(N6,5137) 
      STOP 
      ENDIF 
      IF (FFNAME(25+IOUTCT).EQ.'JOT.UF') THEN 
      WRITE(N6,5138) JOUT(IOUTCT) 
      stop 
      ELSE 
close file and open as formatted 
      CLOSE(UNIT=IASCII) 
      OPEN(UNIT=IASCII,FILE=FFNAME(25+IOUTCT),STATUS='UNKNOWN', 
     aFORM='FORMATTED') 
      ENDIF 
      CASE(1:) 
      IASCII = 0 
      END SELECT 
      WRITE(N6,5140)  NSTART,INTER,FLOAT(INTER)*DELT/60.0,JNTER, 
     +                FLOAT(JNTER)*DELT/60.0,JREDO 
C#### WCH, 7/25/96.  ADD DATE/TIME EXPLANATIONS WITH HOT START. 
c     IF(JREDO.EQ.0.OR.JREDO.EQ.2) THEN 
c          WRITE(N6,5160)  TZERO 
c          ELSEIF(NEXT.GT.0) THEN 
c               WRITE(N6,5161)  TZERO 
c          ENDIF 
cim  changed to write always, also changed format 11/97 
           WRITE(N6,5160)  TZERO 
           WRITE(N6,5161) 
C#### WCH, 4/11/94 AND 7/25/96 (ADD 5165). 
Cwch, 3/27/00.  Change default to 19410802 to correspond to other blocks. 
      IF(IDATZ.EQ.0) THEN 
           IDATZ = 19410802 
           WRITE(N6,5163) IDATZ 
Cwch, 2/4/01.  Also check for IDATZ with too few digits. 
           ELSEIF(IABS(IDATZ).LE.9999) THEN 
	       WRITE(N6,5162) IDATZ 
	       IDATZ = 19410802 
           ELSE 
CWCH, 11/21/99.  ADD OPTION FOR NEGATIVE IDATZ TO FORCE USE EVEN 
C     FOR INTERFACE FILE INPUT. 
		 IISIGN = ISIGN(1,IDATZ) 
	     IDATZ  = IABS(IDATZ) 
           IYRZ   = IDATZ/10000 
cred            odd logic - 2/04/01 
           IDATZ = IDATZ - IYRZ*10000 
Cwch, 2/4/01.  Check for zero month and day. 
           IMOZ  = IDATZ/100 
	     IDAYZ = IDATZ - IMOZ*100 
cred 2/4/01  add 1 to the default date so there will be days in extran 
	     IF(IDAYZ.EQ.0) IDAYZ = 1 
	     IF(IMOZ.EQ.0)  IMOZ  = 1 
	     IF(IYRZ.LT.100) IYRZ = IYRZ + 1900 
           IDATZ = IYRZ*10000 + IMOZ*100 + IDAYZ 
	     IDATZ = IISIGN*IDATZ 
           WRITE(N6,5164) IDATZ 
           ENDIF 
c next line should have been last not next 
c change to write always 11/97 
c      IF(NEXT.GT.0) WRITE(N6,5165) 
      WRITE(N6,5165) 
C 
      WRITE(N6,5170)  ITMAX,SURTOL 
      IF(METRIC.EQ.1) WRITE(N6,5175) AMEN 
      IF(METRIC.EQ.2) WRITE(N6,5176) AMEN 
      IF(ISOL.EQ.0)   WRITE(N6,5177) 
      IF(ISOL.EQ.1)   WRITE(N6,5178) 
      IF(ISOL.EQ.2)   WRITE(N6,5179) 
C ### RHF 8/30/96 CS 
      if (metric.eq.1) then 
      IF(ISOLSKIP.EQ.1)   WRITE(N6,9050) QLOWCS,TOLCS1,TOLCS2 
      else 
      IF(ISOLSKIP.EQ.1)   WRITE(N6,9051) QLOWCS,TOLCS1,TOLCS2 
      endif 
      IF(JSLOT.EQ.1)  WRITE(N6,9060) 
C --- 
      IF(KSUPER.EQ.0) WRITE(N6,5183) 
      IF(KSUPER.EQ.1) WRITE(N6,5184) 
      TZERO  =  3600.0*TZERO 
      ITMAX  = IABS(ITMAX) 
C BAC START    comment out nequal 
CIM NOTE THAT THIS MODIFICATION CHANGES DEFINITION OF NEQUAL FROM HERE ON. 
C      IF(NEQUAL.EQ.1) NEQUAL = IFIX(DELT) 
C BAC END   
      WRITE(N6,5180) NJSW 
C======================================================================= 
C     Read Junction numbers for print and plot data. 
C======================================================================= 
      IF(NHPRT.GT.0) THEN 
         IF (JCE.EQ.0) THEN 
                     READ(N5,*,ERR=888) CC,(JPRT(I),I=1,NHPRT) 
                     WRITE(N6,5200)  NHPRT,(JPRT(I),I=1,NHPRT) 
         ELSE 
                     READ(N5,*,ERR=888) CC,(AOUT(I,1),I=1,NHPRT) 
                     WRITE(N6,5201)  NHPRT,(AOUT(I,1),I=1,NHPRT) 
         ENDIF 
      ENDIF 
C======================================================================= 
C     READ CONDUIT NUMBERS FOR DETAILED PRINTOUT 
C======================================================================= 
      IF(NQPRT.GT.0) THEN 
         IF (JCE.EQ.0) THEN 
                     READ(N5,*,ERR=888) CC,(CPRT(I),I=1,NQPRT) 
                     WRITE(N6,5220)  NQPRT,(CPRT(I),I=1,NQPRT) 
         ELSE 
                     READ(N5,*,ERR=888) CC,(AOUT(I,2),I=1,NQPRT) 
                     WRITE(N6,5221)  NQPRT,(AOUT(I,2),I=1,NQPRT) 
         ENDIF 
      ENDIF 
C======================================================================= 
C     READ JUNCTION NUMBERS FOR PLOTTING 
C======================================================================= 
      IF(NPLT.GT.0) THEN 
         IF(JCE.EQ.0) THEN 
                    READ(N5,*,ERR=888) CC,(JPLT(N),N=1,NPLT) 
                    WRITE(N6,5240)     NPLT,(JPLT(N),N=1,NPLT) 
         ELSE 
                    READ(N5,*,ERR=888) CC,(AOUT(N,3),N=1,NPLT) 
                    WRITE(N6,5241)     NPLT,(AOUT(N,3),N=1,NPLT) 
         ENDIF 
      ENDIF 
C======================================================================= 
C     READ CONDUIT NUMBERS FOR PLOTTING 
C======================================================================= 
      IF(LPLT.GT.0) THEN 
         IF(JCE.EQ.0) THEN 
                    READ(N5,*,ERR=888) CC,(KPLT(N),N=1,LPLT) 
                    WRITE(N6,5260)     LPLT,(KPLT(N),N=1,LPLT) 
         ELSE 
                    READ(N5,*,ERR=888) CC,(AOUT(N,4),N=1,LPLT) 
                    WRITE(N6,5261)     LPLT,(AOUT(N,4),N=1,LPLT) 
         ENDIF 
      ENDIF 
C======================================================================= 
C     READ CONDUIT NUMBERS FOR PLOTTING WATER SURFACE SLOPE 
C     DATA WILL BE ON DATA GROUP B8 IF PRESENT. 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'B8') THEN 
                     BACKSPACE N5 
                     IF(JCE.EQ.0) THEN 
                      READ(N5,*,ERR=888) CC,NSURF,(JSURF(N),N=1,NSURF) 
                      WRITE(N6,5265)        NSURF,(JSURF(N),N=1,NSURF) 
                     ELSE 
                      READ(N5,*,ERR=888) CC,NSURF,(AOUT(N,5),N=1,NSURF) 
                      WRITE(N6,5266)        NSURF,(AOUT(N,5),N=1,NSURF) 
                     ENDIF 
                     ELSE 
                     NSURF = 0 
                     BACKSPACE N5 
                     ENDIF 
CIM  WRITING OF RESULTS TO ASCII FILE OR BINARY FILE 
C======================================================================= 
C     READ CONDUIT NUMBERS FOR WRITING FLOWS TO ASCII FILE 
C     DATA WILL BE ON DATA GROUP B9 IF PRESENT. 
C         NOFLOW  - Number of conduits for which flows are written. 
C                   Negative indicates that the flows will be written 
C                   to a unformatted sequential file compatible with STATS 
C                   block. 
C                   IF negative then write absolute value of flows 
C         NOFDUP  - Number of additional conduits to write 
C         IFINTER - Number of time steps between output time steps. 
C                   If negative write to a standard SWMM binary file. 
C         FLOWMIN - Minimum flow.  Flows will not be written when the flow 
C                   are less than this value. 
C         FLOWOUT - Conduits for which flows are written.  Repeat NOFLOW 
C                   times without B9 on overlap lines. 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'B9') THEN 
                     BACKSPACE N5 
                     IF(JCE.EQ.0) THEN 
                          READ(N5,*,ERR=888) CC,NOFLOW,NOFDUP,IFINTER, 
     &                              FLOWMIN,(FLOWOUT(N),N=1,ABS(NOFLOW)) 
                     DO N = 1, NOFDUP 
                        READ(N5,*,ERR=888) FLOWOUT(N+ABS(NOFLOW)), 
     +				                     FLOWREF(N) 
                     ENDDO 
                          writing = .false. 
                          dryflwstep = 0.0 
                          IF(IFINTER.LT.0) THEN 
                               IFLBIN = 1 
                               WRITE(N6,8260) 
                               IFINTER = -IFINTER 
                               ELSE 
                               IFLBIN = 0 
                               WRITE(N6,8261) 
                               ENDIF 
c 
                          IF(NOFLOW.LT.0) THEN 
                               B9ABS = .TRUE. 
                               NOFLOW = - NOFLOW 
                               WRITE(N6,8263) 
                          ELSE 
                               B9ABS = .FALSE. 
                          ENDIF 
c 
Cwch, 9/9/00, Metricate write statement. 
                       IF(METRIC.EQ.1) WRITE(N6,5267) NOFLOW, 
     1						IFINTER,FLOWMIN,(FLOWOUT(N),N=1,NOFLOW) 
                       IF(METRIC.EQ.2) WRITE(N6,5273) NOFLOW, 
     1						IFINTER,FLOWMIN,(FLOWOUT(N),N=1,NOFLOW) 
                          IF (NOFDUP.GT.0) THEN 
                          WRITE(N6,7268)    NOFDUP 
                          WRITE(N6,7269) 
     &                     (FLOWOUT(N+NOFLOW),FLOWREF(N),N=1,NOFDUP) 
                          ELSE 
                          WRITE(N6,7270) 
                          ENDIF 
C     Alphanumeric read/writes. 
                          ELSE 
                          READ(N5,*,ERR=888) CC,NOFLOW,NOFDUP,IFINTER, 
     &                              FLOWMIN,(AFLWOUT(N),N=1,ABS(NOFLOW)) 
                     DO N = 1, NOFDUP 
                       READ(N5,*,ERR=888) AFLWOUT(N+ABS(NOFLOW)), 
     1                                    AFLOWREF(N) 
                     ENDDO 
                          writing = .false. 
                          dryflwstep = 0.0 
                          IF(IFINTER.LT.0) THEN 
                               IFLBIN = 1 
                               WRITE(N6,8260) 
                               IFINTER = -IFINTER 
                               ELSE 
                               IFLBIN = 0 
                               WRITE(N6,8261) 
                               ENDIF 
c 
                          IF(NOFLOW.LT.0) THEN 
                               B9ABS = .TRUE. 
                               NOFLOW = - NOFLOW 
                               WRITE(N6,8263) 
                          ELSE 
                               B9ABS = .FALSE. 
                          ENDIF 
Cwch, 9/8/00. Metricate write statment. 
                       IF(METRIC.EQ.1) WRITE(N6,5268)    NOFLOW, 
     1      				 IFINTER,FLOWMIN,(AFLWOUT(N),N=1,NOFLOW) 
                       IF(METRIC.EQ.2) WRITE(N6,5274)    NOFLOW, 
     1      				 IFINTER,FLOWMIN,(AFLWOUT(N),N=1,NOFLOW) 
                          IF (NOFDUP.GT.0) THEN 
                          WRITE(N6,7268)    NOFDUP 
                          WRITE(N6,7271) 
     &                     (AFLWOUT(N+NOFLOW),AFLOWREF(N),N=1,NOFDUP) 
                          ELSE 
                          WRITE(N6,7270) 
                          ENDIF 
                          ENDIF 
                     DO 25 N=1,MXFLOW 
   25                SUMFLW(MXFLOW)=0.0 
                     ioflow = 0 
                     FLWSTEP = IFINTER * DELT 
                     IF(NSCRAT(3).EQ.0) THEN 
      WRITE(N6,*) 'ERROR - NSCRAT(3) MUST BE NON-ZERO TO USE OPTION', 
     +' TO WRITE RESULTS FOR SELECTED CONDUITS TO ASCII FILE' 
                          STOP 'NSCRAT(3) IS ZERO FOR B9-LINE OPTION' 
                          ELSE 
                          NFOUT = NSCRAT(3) 
                          ENDIF 
                     IF(FFNAME(53).EQ.'SCRT3.UF') THEN 
      WRITE(N6,*) 'ERROR - YOU MUST SPECIFY THE NAME FOR NSCRAT(3)', 
     +' TO WRITE RESULTS FOR SELECTED CONDUITS TO ASCII FILE' 
                          STOP 'NO DOS NAME GIVEN FOR NSCRAT(3)' 
                          ENDIF 
                     IF(IFLBIN.EQ.0) THEN 
Cwch, 9/8/00.  Put metric header on ascii file. 
                          IF(METRIC.EQ.1) WRITE(NFOUT,5269) 
						IF(METRIC.EQ.2) WRITE(NFOUT,5272) 
                          IF(JCE.EQ.0) THEN 
                               WRITE(NFOUT,5270)(FLOWOUT(N), 
     &                          N=1,NOFLOW+NOFDUP) 
                               ELSE 
                               WRITE(NFOUT,5271)(AFLWOUT(N), 
     &                          N=1,NOFLOW+NOFDUP) 
                               ENDIF 
CIM### 9/8/00 
CIM  6/2000 do not open file until after starting and 
cim  ending dates are known.  Move code in INDAT3 
c                          ELSE 
cim here if IFLBIN = 1 
c                          CLOSE(NFOUT,STATUS='DELETE') 
c                          OPEN(NFOUT,FILE=FFNAME(53),FORM='UNFORMATTED', 
c     +                        STATUS='UNKNOWN') 
C======================================================================= 
C     Write file headers for output hydrograph. 
C======================================================================= 
c                         REWIND NFOUT 
c                         NPOLL = 0 
c                         WRITE(NFOUT) NOFLOW+NOFDUP,NPOLL 
c                         IF(JCE.EQ.0) THEN 
c                           WRITE(NFOUT) (FLOWOUT(N),N=1,NOFLOW+NOFDUP) 
c                         ELSE 
c                           WRITE(NFOUT) (AFLWOUT(N),N=1,NOFLOW+NOFDUP) 
c                         ENDIF 
c                         SOURCE = 'EXTRAN BLOCK' 
c                         QQCONV = QCONV 
c                         QCONV  = CMET(8,METRIC) 
c                         TITLE(3) = ALPHA1 
c                         TITLE(4) = ALPHA2 
c                         CALL INFACE(2,NFOUT) 
c                         QCONV    = QQCONV 
                         ENDIF 
                     ELSE 
                     NOFLOW = 0 
                     BACKSPACE N5 
                     ENDIF 
CIM END 
C======================================================================= 
C     READ OUTPUT CONTROL PARAMETERS ON OPTIONAL DATA GROUP BA 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BA') THEN 
         BACKSPACE N5 
         READ(N5,*,ERR=888) CC,JHEAD,JP10,IWLEN 
         IF (JHEAD.LT.0.OR.JHEAD.GT.1) JHEAD = 0 
         IF (JP10.LT.0.OR.JP10.GT.1) JP10 = 0 
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ 
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN 
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE 
C  REMOVED. 
      ELSE 
c         JHEAD = 0 
c         JP10 = 0 
c         IWLEN = 0 
         BACKSPACE N5 
      ENDIF 
         IF (JHEAD.EQ.0) WRITE(N6,8020) 
         IF (JHEAD.EQ.1) WRITE(N6,8022) 
         IF (JP10.EQ.0) WRITE(N6,8024) 
         IF (JP10.EQ.1) WRITE(N6,8026) 
	IF (IWLEN.EQ.0) WRITE(N6,7010) 
	IF (IWLEN.EQ.1) WRITE(N6,7020) 
	IF (IWLEN.EQ.2) WRITE(N6,7030) 
C======================================================================= 
C     READ SOLUTION PARAMETERS ON OPTIONAL DATA GROUP BB 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BB') THEN 
                     BACKSPACE N5 
cim SEDEPTH  Add IPIPESED to BB line 
CIM PP 4/1/97  add IPRATE to BB lines 
cim    9/22/97  add IM2 to BB line 
cim 
                     READ(N5,*,ERR=888) CC,JELEV,JDOWN,IPRATE,IM2, 
     a                                 IPIPESED 
                     IF(JELEV.LT.0) JELEV = 0 
                     IF(JDOWN.LT.0.OR.JDOWN.GT.2) JDOWN = 0 
                     ELSE 
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ 
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN 
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE 
C  REMOVED. 
c                     JELEV = 0 
c                     JDOWN = 0 
c                     IPRATE = 0 
c                     IM2 = 0 
c                     IPIPESED = 0 
                     BACKSPACE N5 
                     ENDIF 
	IF(JELEV.EQ.0) WRITE(N6,8184) 
      IF(JELEV.EQ.1) WRITE(N6,8185) 
	IF(JELEV.EQ.2) WRITE(N6,8186) 
	IF(JELEV.EQ.3) WRITE(N6,8187) 
	IF(JELEV.EQ.4) WRITE(N6,8188) 
      IF(JDOWN.EQ.0) WRITE(N6,5186) 
      IF(JDOWN.EQ.1) WRITE(N6,5187) 
      IF(JDOWN.EQ.2) WRITE(N6,5188) 
      IF(IPRATE.NE.0) WRITE(N6,5189) 
change 
      IF(IM2.EQ.0) THEN 
      WRITE(N6,5190) 
      ELSE 
      IM2 = 1 
      WRITE(N6,5191) 
      ENDIF 
      IF(IPIPESED.NE.0) THEN 
      WRITE(N6,5192) 
      ELSE 
      WRITE(N6,5193) 
      ENDIF 
change 
C======================================================================= 
C     READ INTERMEDIATE CONTINUITY OUTPUT DATA ON OPTIONAL DATA GROUP BC 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BC') THEN 
                     BACKSPACE N5 
                     READ(N5,*,ERR=888) CC,ICONTER 
                     ELSE 
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ 
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN 
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE 
C  REMOVED. 
c                     ICONTER = 0 
                     BACKSPACE N5 
                     ENDIF 
      IF (ICONTER.LE.0) then 
      write(n6,8005) 
      ICONTER = 2147483647 
      else 
      write(n6,8010) 
      endif 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP BD <<<<<<<<<<<< 
C    OPTIONAL INPUT OF BASE FLOW FACTORS 
C    CIM   10/97 
C======================================================================= 
C  INITIALIZE STUFF 
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ 
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN 
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE 
C  REMOVED. 
c      NUMSETS = 0 
c	BFFACT = .FALSE. 
c      MONTHOLD = 0 
c      DO 947 I=1,MAXSETS 
c      NUMBFF(I) = 0 
c      INBFF(I) = 0 
c      IBFF(I) = 0 
c      DO 947 J=1,MAXBFF 
c  947 BFFMO(I,J) = 1.0 
c      do 349 i=1,nee 
c  349 iwhich(i)=1 
  948 READ (N5,*,ERR=888) CC 
      IF (CC.EQ.'BD') THEN 
	BFFACT = .TRUE. 
      NUMSETS = NUMSETS+1 
      IF (NUMSETS.GT.MAXSETS) THEN 
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SETS SPECIFIED ON BD LINES', 
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXSETS 
      STOP 'TOO MANY BD LINES' 
      ENDIF 
      BACKSPACE N5 
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS) 
      IF (NUMBFF(NUMSETS).GT.MAXBFF) THEN 
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SPECIFIED ON BD LINE', 
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBFF,' FOR SET ', 
     .'NUMBER ',NUMSETS 
      STOP 'TOO MANY BASE BASE FLOW VALUES SPECIFED ON BD LINE' 
      ENDIF 
      BACKSPACE N5 
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS), 
     .              (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS)) 
      WRITE(N6,*) 
      WRITE(N6,*) ' MONTHLY BASE FLOW FACTOR SET NUMBER ',NUMSETS 
      WRITE(N6,949) (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS)) 
C GO BACK TO TRY TO READ NEXT BD LINE 
      GOTO 948 
      ELSE 
C NO BD LINES READ, OR NO ADDITIONAL BD LINES FOUND 
C  THEN BACKSPACE AND CONTININUE 
      BACKSPACE N5 
      END IF 
      IF (NUMSETS.LE.0) NUMSETS = 1 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP BE <<<<<<<<<<<< 
C    OPTIONAL INPUT OF DETAILED SUMMARY OUTPUT PERIODS 
C    CIM   5/98 
C======================================================================= 
C  INITIALIZE STUFF 
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ 
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN 
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE REMOVED 
c     DO NUMBE = 0,MAXBE 
c     IBESTART(NUMBE) = 0 
c     IBEEND(NUMBE) = 0 
c     ENDDO 
c     NUMBE = 0 
c     IBE = 0 
  950 READ (N5,*,ERR=888) CC 
      IF (CC.EQ.'BE') THEN 
      NUMBE = NUMBE + 1 
      IBE = 1 
C  NOTE MAXBE IS RESERVED FOR PERIOD AFTER LAST PERIOD 
      IF (NUMBE.GT.MAXBE-1) THEN 
      WRITE(N6,*) ' NUMBER OF BE LINES', 
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBE-1 
      STOP 'TOO MANY BE LINES' 
      ENDIF 
      BACKSPACE N5 
      READ(N5,*,ERR=888) CC, IBESTART(NUMBE), IBEEND(NUMBE) 
      IF (NUMBE.EQ.1) WRITE(N6,951) 
      WRITE(N6,952) IBESTART(NUMBE),IBEEND(NUMBE) 
C  TRY TO READ NEXT BE LINE 
      GO TO 950 
      ELSE 
C  NO BE LINE FOUND.  BACKSPACE AND CONTINUE 
CIM SET IBESTART(0) AND IBEEND(0) 
CIM FOR USE IN CASE NO BE LINES ARE INPUT 
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ 
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN 
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE REMOVED 
      IBESTART(0) = NSTART 
      IBEEND(0) = 999999999 
      BACKSPACE N5 
	ENDIF 
C  Check on inputs 
	IF (NUMBE.GT.0) THEN 
CIM SET IBESTART(NUMBE+1) AND IBBEND(NUMBE+1) HERE 
      IBESTART(NUMBE+1) = 999999999 
      IBEEND(NUMBE+1) = 999999999 
      DO I = 1, NUMBE 
      IF (IBEEND(NUMBE).LE.IBESTART(NUMBE)) THEN 
      WRITE(N6,*) ' ERROR - ENDING CYCLE IS LESS THAN STARTING CYCLE ' 
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ', 
     *IBESTART(I),' END CYCLE = ',IBEEND(I) 
      STOP ' ERROR IN NE LINE INPUTS' 
      ENDIF 
      IF (I.GT.1.AND.IBESTART(I).LE.IBEEND(I-1)) THEN 
      WRITE(N6,*) ' ERROR - STARTING CYCLE IS LESS THAN ENDING CYCLE ', 
     A'OF PREVIOUS PRINTOUT PERIOD' 
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ', 
     AIBESTART(I),' END CYCLE OF PREVIOUS NE CARD = ',IBEEND(I-1) 
      STOP ' ERROR IN BE LINE INPUTS' 
      ENDIF 
      ENDDO 
      ENDIF 
C======================================================================= 
C     CALL TO WASPREAD TO TRY TO READ EXTRAN TO WASP LINKAGE 
C     LINES   BF, BG, BH LINES 
      CALL WASPREAD 
CIM TRANAID START 
C======================================================================= 
CIM   OPTIONAL READ OF BZ CARD FOR INFORMATION TO WRITE TRANAID 
CIM   INTERFACE FILE 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'BZ') THEN 
                     BACKSPACE N5 
                     READ(N5,*,ERR=888) CC,idump, dthyd, hydstr,IVCALC 
                     else 
                     idump = 0 
                     dthyd = 0.0 
                     hydstr = 0.0 
                     BACKSPACE N5 
                     end if 
        if (idump .gt. 0) then 
        write(n6,6666) hydstr, dthyd 
	IF (IVCALC.EQ.0) THEN 
	WRITE(N6,7022) 
	LVCALC = .TRUE. 
	ELSE 
	WRITE(N6,7024) 
	LVCALC = .FALSE. 
	ENDIF 
        end if 
CIM  TRANAID END 
C======================================================================= 
C     Read conduit data on data group C1. 
C======================================================================= 
      WRITE(*,6000) 
      NATUR    = 0 
      DO 260 N = 1,NEE 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'C1') GO TO 280 
      IF(JCE.EQ.0) THEN 
      IF (IPIPESED.EQ.0) THEN 
         READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N), 
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N), 
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N) 
                        ENTK(N) = 0.0 
                        EXITK(N) = 0.0 
                        OTHERK(N) = 0.0 
                        SEDEPTH(N) = 0.0 
      ELSE 
         READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N), 
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N), 
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N), 
     +                      SEDEPTH(N) 
                        ENTK(N) = 0.0 
                        EXITK(N) = 0.0 
                        OTHERK(N) = 0.0 
      ENDIF 
CIM START  <><><><><><><> 
C *** NOTE:  THE FOLLOWING IF STATEMENT WILL NEED TO BE MODIFIED IF A 
C            CLOSED CONDUIT WITH NKLASS > 5 IS ADDED. 
CIM  ADDED CLOSED ARRAY TO ID CLOSED CONDUITS 
         CLOSED(N) = (NKLASS(N).LE.5).OR. 
     .            (NKLASS(N).EQ.9).OR. 
     .            (NKLASS(N).EQ.10).OR. 
     .            (NKLASS(N).EQ.11).OR. 
     .            (NKLASS(N).EQ.12) 
CIM END     <><><><><><> 
C  BAC START   
C  read entrance exit and other loss coefficent if closed conduit type 
C 
Cwch, 3/12/01. May need to backspace twice if C1 data are on two lines 
C with a carriage return.  After backspacing once, check CC value.  If not 
C C1, then backspace twice and try agin. 
C$$$$$ Need to fix, 3/12/01.  Not yet done.  
        IF(NEQUAL.GE.2.AND.CLOSED(N)) THEN 
          BACKSPACE N5 
        IF(IPIPESED.EQ.0) THEN 
          READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N), 
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N), 
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N), 
     +                      ENTK(N),EXITK(N),OTHERK(N) 
          SEDEPTH(N) = 0.0 
        ELSE 
          READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N), 
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N), 
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N), 
     +                      ENTK(N),EXITK(N),OTHERK(N),SEDEPTH(N) 
        ENDIF 
        ENDIF 
C BAC END   
       ELSE 
      IF (IPIPESED.EQ.0) THEN 
      READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2), 
     +                  QO(N),NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N), 
     +                  ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N) 
                        ENTK(N) = 0.0 
                        EXITK(N) = 0.0 
                        OTHERK(N) = 0.0 
                        SEDEPTH(N) = 0.0 
      ELSE 
      READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2), 
     +                  QO(N),NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N), 
     +                  ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N), 
     +                  SEDEPTH(N) 
                        ENTK(N) = 0.0 
                        EXITK(N) = 0.0 
                        OTHERK(N) = 0.0 
      ENDIF 
CIM START  <><><><><><><> 
C *** NOTE:  THE FOLLOWING IF STATEMENT WILL NEED TO BE MODIFIED IF A 
C            CLOSED CONDUIT WITH NKLASS > 5 IS ADDED. 
CIM  ADDED CLOSED ARRAY TO ID CLOSED CONDUITS 
         CLOSED(N) = (NKLASS(N).LE.5).OR. 
     .            (NKLASS(N).EQ.9).OR. 
     .            (NKLASS(N).EQ.10).OR. 
     .            (NKLASS(N).EQ.11).OR. 
     .            (NKLASS(N).EQ.12) 
CIM END     <><><><><><> 
C BAC START  
C  read entrance exit and other loss coefficent if closed conduit type 
        IF(NEQUAL.GE.2.AND.CLOSED(N)) THEN 
          BACKSPACE N5 
        IF (IPIPESED.EQ.0) THEN 
          READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2),QO(N), 
     +         NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),ZU(N),ZD(N), 
     +         ROUGH(N),STHETA(N),SPHI(N),ENTK(N),EXITK(N),OTHERK(N) 
               SEDEPTH(N)=0.0 
        ELSE 
          READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2),QO(N), 
     +         NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),ZU(N),ZD(N), 
     +         ROUGH(N),STHETA(N),SPHI(N),ENTK(N),EXITK(N),OTHERK(N), 
     +         SEDEPTH(N) 
        ENDIF 
        ENDIF 
C  BAC END  
      ENDIF 
      IF(ROUGH(N).LE.0.0) ROUGH(N) = 0.014 
C======================================================================= 
C     IF LEN(N) IS NEGATIVE A FLAP GATE IS BEING MODELED 
C        THIS FLAP GATE ONLY ALLOWS FLOW IN THE POSITIVE DIRECTION 
C        INGATE = 1 
C        FLOW IS LIMITED TO BE GREATER THAN 0.0 
C======================================================================= 
      INGATE(N) = 0 
      IF(LEN(N).LT.0) THEN 
                      INGATE(N) = 1 
                      LEN(N)    = ABS(LEN(N)) 
                      ENDIF 
C======================================================================= 
C     IF NKLASS(N) IS NEGATIVE A FLAP GATE IS BEING MODELED 
C        THIS FLAP GATE ONLY ALLOWS FLOW IN THE NEGATIVE DIRECTION 
C        INGATE IS 2 
C        FLOW IS LIMITED TO BE LESS THAN 0.0 
C======================================================================= 
      IF(NKLASS(N).LT.0) THEN 
                         INGATE(N) = 2 
                         NKLASS(N) = IABS(NKLASS(N)) 
                         ENDIF 
C 
C     IF NKLASS is not 6 7 8 or 12 then SPHI is maximum flow 
C 
C======================================================================= 
CIM START  <><><><><><><><><> 
CIM    THE FOLLOWING HOLD TRUE FOR INPUT ONLY, ARE MODIFIED 
CIM    TO INTERNAL NUMBERING SCHEME AT END OF INDAT1 SUBROUTINE 
CIM    Note:  In revised internal numbering scheme, 
cim        o  Conduit types 1 through 20 are reserved 
cim           for closed conduit types that use TWNORM, ANORM, and 
cim           HRNORM ARRAYS 
cim        o  Conduit types 21 through 50 are special types including 
cim           rectangular pipes (22), and also includes parabolic and 
cim           irregular sections (24) that use QCURVE arrays. 
cimbridge     Now includes bridges type 25 
cim        o  Conduit types 51 through 60 are reserved for equivalent 
cim           orifice types. 
CIM 
CIM   NKLASS  TYPE                                NEWKLASS 
C        1    CIRCULAR PIPE 
                                          NEWKLASS(1)=1 
C        2    RECTANGULAR PIPE 
                                          NEWKLASS(2)=21 
C        3    HORSESHOE PIPE 
                                          NEWKLASS(3)=2 
C        4    EGGSHAPED PIPE 
                                          NEWKLASS(4)=3 
C        5    BASKETHANDLE PIPE 
                                          NEWKLASS(5)=4 
C        6    TRAPEZOIDAL CHANNEL 
                                          NEWKLASS(6)=22 
C        7    PARABOLIC CROSS-SECTION OR POWER 
C             FUNCTION CROSS SECTION 
                                          NEWKLASS(7)=23 
C        8    IRREGULAR CROSS-SECTION 
                                          NEWKLASS(8)=24 
C        9    HORIZONTAL ELLIPSE 
C             (LONG AXIS IS HORIZONTAL) 
                                          NEWKLASS(9)=5 
C       10    VERTICAL ELLIPSE 
                                          NEWKLASS(10)=6 
C       11    ARCH 
                                          NEWKLASS(11)=7 
C       12    BRIDGE (TO BE IMPLEMENTED) 
                                          NEWKLASS(12)=25 
CIM    OOOOOOOOO 
CIM  THESE ARE OLD ASSIGNMENTS AND NEW ASSIGNMENTS FOR ORIFICE 
CIM  EQUIVALENT PIPES 
C        9    SIDE OUTLET CIRCULAR ORIFICE          51 
C       10    BOTTOM OUTLET CIRCULAR ORIFICE        52 
C       11    SIDE OUTLET RECTANGULAR ORIFICE       53 
C       12    BOTTOM OUTLET RECTANGULAR ORIFICE     54 
CIM   OOOOOOOOOO 
CIM END <><><><><><><><><><><><> 
C======================================================================= 
      KLASS = NKLASS(N) 
CIM START   <><><><><><><><> 
CIM       IF(KLASS.EQ.1.OR.KLASS.GE.9) THEN 
CIM  9 WAS ORIFICE, DON'T KNOW DATA YET 
c change this to select case 
      SELECT CASE (KLASS) 
      CASE (1) 
CIM END   <><><><><><> 
               RFULL(N)  = DEEP(N)/4.0 
               AFULL(N)  = (3.1415926/4.0)*DEEP(N)**2 
               WIDE(N)   = DEEP(N) 
cim  CALL SEDEPTH1 to adjust pipe if IPIPESED=1 
               IF (SEDEPTH(N).NE.0.0) THEN 
                   CALL SEDEPTH1(N) 
               ELSE 
               SEDAREA(N) = 0.0 
               SEDPERI(N) = 0.0 
               SEDRAD(N) = 0.0 
               ENDIF 
      CASE (2) 
               RFULL(N) = (WIDE(N)*DEEP(N))/(2.*WIDE(N)+2.0*DEEP(N)) 
               AFULL(N) =  WIDE(N)*DEEP(N) 
      CASE (3) 
               RFULL(N) = 0.25381  * DEEP(N) 
      CASE (4) 
               RFULL(N) = 0.19311 * DEEP(N) 
      CASE (5) 
               RFULL(N) = 0.28800*DEEP(N) 
      CASE (6) 
               AFULL(N)=DEEP(N)*(WIDE(N)+DEEP(N)/2.*(STHETA(N)+SPHI(N))) 
               IF(WIDE(N).LE.0.0) WIDE(N) = 0.01 
               RFULL(N)=AFULL(N)/(WIDE(N)+DEEP(N)* 
     +                  (SQRT(1.0+STHETA(N)**2)+SQRT(1.0+SPHI(N)**2))) 
      CASE (7) 
      IF(STHETA(N).EQ.0.0) THEN 
               AFULL(N) = 0.666666667*WIDE(N)*DEEP(N) 
               X      = WIDE(N)/2.0 
               X1     = WIDE(N)**4/(64.0*DEEP(N)**2) 
               WETPER = 8.0*DEEP(N)/WIDE(N)**2*(X*SQRT(X1+X**2) 
     +                             +  X1*LOG(X+SQRT(X1+X**2)) - 
     +                                X1*LOG(SQRT(X1))) 
               RFULL(N) = AFULL(N)/WETPER 
               ELSE 
               AFULL(N) = WIDE(N)*DEEP(N)*(1.0 - 1.0/(STHETA(N)+1.0)) 
               X      = WIDE(N)/2.0 
               X1     = WIDE(N)**4/(64.0*DEEP(N)**2) 
               WETPER = 8.0*DEEP(N)/WIDE(N)**2*(X*SQRT(X1+X**2) 
     +                             +  X1*LOG(X+SQRT(X1+X**2)) - 
     +                                X1*LOG(SQRT(X1))) 
               RFULL(N) = AFULL(N)/WETPER 
               ENDIF 
CIM START <><><><><><><><> 
CIM      HORIZONTAL ELLIPSE 
      CASE (9) 
C======================================================================= 
C     Approximations for elliptical pipe based on Table 4 "Elliptical 
C     Concrete Pipe," page 90, in Concrete Pipe Design Manual, American  
C     Concrete Pipe Assn., First Edition, 1970. Because ratio of minor 
C     to major axes is ~ constant, area formula works using just one 
C     axis.  It works better than true area for ellipse (pi*a*b) since 
C     pipe is only approximately elliptical.  
C======================================================================= 
      IF ((DEEP(N).LT.0.0).AND.(WIDE(N).LT.0.0)) THEN 
        DEEP(N) = - DEEP(N) 
        WIDE(N) = - WIDE(N) 
        AFULL(N) = 1.2692 * DEEP(N) * DEEP(N) 
        RFULL(N) = 0.3061 * DEEP(N) 
        ELSE 
        ISIZE = DEEP(N) 
        IF ((ISIZE.LE.0).OR.(ISIZE.GT.NUMELL)) THEN 
             IF (JCE.EQ.0)  THEN 
               WRITE(N6,4070) NCOND(N) 
               ELSE 
               WRITE(N6,4071) ACOND(N) 
               ENDIF 
             ISTOP = ISTOP + 1 
             ISIZE = 1 
             END IF 
Cwch, 2/12/01.  Add metric conversions. 
        DEEP(N) = EMINOR(ISIZE)/CMET(12,METRIC) 
        WIDE(N) = EMAJOR(ISIZE)/CMET(12,METRIC) 
        AFULL(N) = EAREA(ISIZE)/CMET(13,METRIC) 
        RFULL(N) = ERADIUS(ISIZE)/CMET(1,METRIC) 
      END IF 
CIM         VERTICAL ELLIPSE 
      CASE (10) 
Cwch (CIM), 7/20/04. Should be .LT. for both.  
C      IF ((DEEP(N).GT.0.0).AND.(WIDE(N).LT.0.0)) THEN 
      IF ((DEEP(N).LT.0.0).AND.(WIDE(N).LT.0.0)) THEN 
        DEEP(N) = - DEEP(N) 
        WIDE(N) = - WIDE(N) 
        AFULL(N) = 1.2692 * WIDE(N) * WIDE(N) 
        RFULL(N) = 0.3061 * WIDE(N) 
        ELSE 
        ISIZE = DEEP(N) 
        IF ((ISIZE.LE.0).OR.(ISIZE.GT.NUMELL)) THEN 
            IF (JCE.EQ.0)  THEN 
            WRITE(N6,4070) NCOND(N) 
            ELSE 
            WRITE(N6,4071) ACOND(N) 
            ENDIF 
            ISTOP = ISTOP + 1 
            ISIZE = 1 
            END IF 
Cwch, 2/12/01.  Add metric conversions. 
Cwch, 7/20/04. Major and minor sizes inverted. 
C        DEEP(N) = EMINOR(ISIZE)/CMET(12,METRIC) 
C        WIDE(N) = EMAJOR(ISIZE)/CMET(12,METRIC) 
        DEEP(N) = EMAJOR(ISIZE)/CMET(12,METRIC) 
        WIDE(N) = EMINOR(ISIZE)/CMET(12,METRIC) 
        AFULL(N) = EAREA(ISIZE)/CMET(13,METRIC) 
        RFULL(N) = ERADIUS(ISIZE)/CMET(1,METRIC) 
        END IF 
CIM         ARCH 
      CASE (11) 
C======================================================================= 
C     Approximations for steel pipe based in part on tables from "Modern 
C     Sewer Design," by American Iron and Steel Institute, Fourth Ed., 
C     1999.  But see also two web sites: 
C     http://www.lane-enterprises.com/cspFullFlow.htm 
C     http://www.lane-enterprises.com/sppFullFlow_p2.htm 
C     with hydraulic properties. 
C======================================================================= 
      IF ((DEEP(N).LT.0.0).AND.(WIDE(N).LT.0.0)) THEN 
        DEEP(N) = - DEEP(N) 
        WIDE(N) = - WIDE(N) 
Cwch, 7/20/04. Fix error noted by Mike Gregory in swmm-users, from 
C     10/10/03. See his spreadsheet calcs.  
C        AFULL(N) = 0.7879 * DEEP(N) * DEEP(N) 
        AFULL(N) = 0.7879 * DEEP(N) * WIDE(N) 
C 
        RFULL(N) = 0.2991 * DEEP(N) 
        ELSE 
        ISIZE = DEEP(N) 
        IF ((ISIZE.LE.0).OR.(ISIZE.GT.NUMARCH)) THEN 
            IF (JCE.EQ.0) THEN 
               WRITE(N6,4072) NCOND(N) 
               ELSE 
               WRITE(N6,4073) ACOND(N) 
               ENDIF 
            ISTOP = ISTOP + 1 
            ISIZE = 1 
            END IF 
Cwch, 2/12/01.  Add metric conversions. 
        DEEP(N) = AMINOR(ISIZE)/CMET(12,METRIC) 
        WIDE(N) = AMAJOR(ISIZE)/CMET(12,METRIC) 
        AFULL(N) = AAREA(ISIZE)/CMET(13,METRIC) 
        RFULL(N) = ARADIUS(ISIZE)/CMET(1,METRIC) 
        END IF 
      END SELECT 
CIM         BRIDGE  (TO BE IMPLEMENTED) 
cim      IF(KLASS.EQ.12) THEN 
cim      END IF 
CIM END <><><><><><><><><><> 
  260 CONTINUE 
  280 NC  = N-1 
      NTC = NC 
C======================================================================= 
C     PRINT OUT INFORMATION ON FLAP GATES (IF ANY EXIST) 
C======================================================================= 
      NFLAP     = 0 
      DO 9000 N = 1,NC 
      IF(INGATE(N).GT.0) THEN 
                         NFLAP = NFLAP + 1 
                         IF(NFLAP.EQ.1) WRITE(N6,9010) 
                         ND = INGATE(N) 
                         IF(JCE.EQ.0) THEN 
                            WRITE(N6,9020) NCOND(N),GTYPE(ND) 
                            ELSE 
                            WRITE(N6,9021) ACOND(N),GTYPE(ND) 
                         ENDIF 
      IF (INGATE(N).EQ.1) WRITE(N6,4060) 
      IF (INGATE(N).EQ.2) WRITE(N6,4061) 
                         ENDIF 
 9000 CONTINUE 
c   printout data for pipes where maximum positive flow or the 
c   minimum negative flow is limited as identified by SPHI and 
c   or STHETA for all types but 6, 7, 8 and 12. 
      NMXFLW = 0 
      DO 9001 N=1,NC 
      SELECT CASE (NKLASS(N)) 
      CASE (6,7,8,12) 
      CASE DEFAULT 
      IF(SPHI(N).NE.0.0.OR.STHETA(N).NE.0.0) THEN 
      NMXFLW = NMXFLW + 1 
      IF (NMXFLW.EQ.1) WRITE(N6,9011) 
      IF (JCE.EQ.0) THEN 
      IF (SPHI(N).NE.0.0) WRITE(N6,4064) NCOND(N),SPHI(N) 
      IF (STHETA(N).NE.0.0) WRITE(N6,4065) NCOND(N),STHETA(N) 
      ELSE 
      IF (SPHI(N).NE.0.0) WRITE(N6,4074) ACOND(N),SPHI(N) 
      IF (STHETA(N).NE.0.0) WRITE(N6,4075) ACOND(N),STHETA(N) 
      END IF 
      IF (SPHI(N).LT.0.0) WRITE(N6,4062) 
      IF (STHETA(N).GT.0.0) WRITE(N6,4063) 
      ENDIF 
      END SELECT 
 9001 CONTINUE 
C======================================================================= 
C     READ THE CS DATA GROUP TO DETERMINE IF THE NATURAL CROSS 
C          SECTION INFORMATION WILL BE SAVED ON NSCRAT(4) OR 
C          READ FROM NSCRAT(4) BY THE PROGRAM 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'CS') THEN 
                     BACKSPACE N5 
                     READ(N5,*,ERR=888) CC,IREAD 
                     ELSE 
                     BACKSPACE N5 
                     ENDIF 
C======================================================================= 
C     NOW GET DATA FOR IRREGULAR CHANNELS FROM THE SCRATCH FILE. 
C======================================================================= 
      IF(IREAD.EQ.'READ') THEN 
               IF(NCSAVE.EQ.0) THEN 
                               WRITE(N6,8999) 
                               STOP 
                               ENDIF 
               READ(NCSAVE,ERR=8888) NATUR,NC 
               READ(NCSAVE,ERR=8888) (NQC(N),N=1,NC) 
               READ(NCSAVE,ERR=8888) (NUMQ(N),N=1,NC) 
               READ(NCSAVE,ERR=8888) ((QCURVE(N,1,J),J=1,26),N=1,NATUR) 
               READ(NCSAVE,ERR=8888) ((QCURVE(N,2,J),J=1,26),N=1,NATUR) 
               READ(NCSAVE,ERR=8888) ((QCURVE(N,3,J),J=1,26),N=1,NATUR) 
               DO 275 N = 1,NC 
CIM START   <><><><><><><><> 
CIM               IF(NKLASS(N).LT.7) GO TO 275 
               IF(NKLASS(N).NE.8.OR.NKLASS(N).NE.7) GO TO 275 
CIM END  <><><><><><><><> 
               READ(NCSAVE,ERR=8888) SLOPE,AFULL(N),DEEP(N),WIDE(N), 
     +                               LEN(N),ROUGH(N),RFULL(N),NKLASS(N) 
  275          CONTINUE 
               ENDIF 
C======================================================================= 
C     NOW GET DATA FOR IRREGULAR CHANNELS, IF ANY. 
C======================================================================= 
      IF(IREAD.EQ.'SAVE'.OR.IREAD.EQ.'CARD') THEN 
      IIPRNT = 0 
      DO 285 N = 1,NC 
      IF(NKLASS(N).EQ.8) THEN 
            IF(IIPRNT.EQ.0) WRITE(N6,5355) 
            IIPRNT = 1 
            SLOPE = SPHI(N) 
            NATUR = NATUR + 1 
            KCOND = 0 
            KSTOP = 0 
            IF(STHETA(N).LT.0.0) THEN 
                                 KSTOP     = 1 
                                 STHETA(N) = ABS(STHETA(N)) 
                                 ENDIF 
            CALL GETCUR(N,STHETA(N),SLOPE,METRIC,0,KCOND,AFULL(N), 
     +                  DEEP(N),WIDE(N),LEN(N),ROUGH(N),RFULL(N), 
     +                  NSTOP,NCOND(N),ACOND(N),KSTOP) 
            ENDIF 
C======================================================================= 
C     CALCULATE DATA FOR POWER FUNCTION CROSS SECTIONS 
C======================================================================= 
      IF(NKLASS(N).EQ.7) THEN 
            KCOND    = 1 
            NATUR    = NATUR + 1 
            SLOPE    = 0.0 
            KSTOP    = 0 
            IF(STHETA(N).EQ.0.0) STHETA(N) = 2.0 
            IF(STHETA(N).LT.0.0) THEN 
                                 KSTOP     = 1 
                                 STHETA(N) = ABS(STHETA(N)) 
                                 ENDIF 
            CALL GETCUR(N,STHETA(N),SLOPE,METRIC,0,KCOND,AFULL(N), 
     +                  DEEP(N),WIDE(N),LEN(N),ROUGH(N),RFULL(N), 
     +                  NSTOP,NCOND(N),ACOND(N),KSTOP) 
            NKLASS(N) = 8 
            ENDIF 
  285 CONTINUE 
      ENDIF 
C 
C======================================================================= 
C   Call to read data for bridge sections if any 
C======================================================================= 
      CALL GETBRDGE 
C======================================================================= 
C     NOW SAVE THE DATA FOR IRREGULAR CHANNELS ON THE SCRATCH FILE. 
C======================================================================= 
      IF(IREAD.EQ.'SAVE') THEN 
               IF(NCSAVE.EQ.0) THEN 
                               WRITE(N6,8999) 
                               STOP 
                               ENDIF 
               WRITE(NCSAVE,ERR=8888) NATUR,NC 
               WRITE(NCSAVE,ERR=8888) (NQC(N),N=1,NC) 
               WRITE(NCSAVE,ERR=8888) (NUMQ(N),N=1,NC) 
               WRITE(NCSAVE,ERR=8888) ((QCURVE(N,1,J),J=1,26),N=1,NATUR) 
               WRITE(NCSAVE,ERR=8888) ((QCURVE(N,2,J),J=1,26),N=1,NATUR) 
               WRITE(NCSAVE,ERR=8888) ((QCURVE(N,3,J),J=1,26),N=1,NATUR) 
               DO 295 N = 1,NC 
CIM START   <><><><><><><> 
CIM     note now both parabolic and irregular are nklass = 8 
CIM            IF(NKLASS(N).LT.7) GO TO 295 
               IF(NKLASS(N).NE.8) GO TO 295 
CIM END   <><><><><><><> 
               WRITE(NCSAVE,ERR=8888) SLOPE,AFULL(N),DEEP(N),WIDE(N), 
     +                                LEN(N),ROUGH(N),RFULL(N),NKLASS(N) 
  295          CONTINUE 
               ENDIF 
C======================================================================= 
C     PRINT CONDUIT DATA 
C======================================================================= 
cim 1/99 print first header line 
                             WRITE(N6,2999) 
                             WRITE(N6,5060) ALPHA1,ALPHA2 
                             IF(METRIC.EQ.1) WRITE(N6,5300) 
                             IF(METRIC.EQ.2) WRITE(N6,5301) 
      DO 300 N = 1,NC 
      KLASS    = NKLASS(N) 
CIM START      <><><><><><><> 
      IF (KLASS.LT.1.OR.KLASS.GT.12) THEN 
      IF (JCE.EQ.0) THEN 
         WRITE(N6,7000) NCOND(N),NKLASS(N) 
         ELSE 
         WRITE(N6,7001) ACOND(N),NKLASS(N) 
      END IF 
       STOP 'INVALID NKLASS FOR CONDUIT' 
      END IF 
CIM END <><><><><><><><><> 
CIM 1/99 Eliminate intermediate output headers JHEAD = 1 
      IF(JHEAD.EQ.0.AND.MOD(N,50).EQ.0) THEN 
                             WRITE(N6,2999) 
                             WRITE(N6,5060) ALPHA1,ALPHA2 
                             IF(METRIC.EQ.1) WRITE(N6,5300) 
                             IF(METRIC.EQ.2) WRITE(N6,5301) 
                             ENDIF 
CIM 1/99 
      IF(JCE.EQ.0) THEN 
      IF(ZU(N).EQ.0.0.AND.ZD(N).EQ.0.0) THEN 
        IF(NKLASS(N).EQ.6) WRITE(N6,5320) N,NCOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(NJUNC(N,K),K=1,2),STHETA(N),SPHI(N) 
        IF(NKLASS(N).NE.6) WRITE(N6,5321) N,NCOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(NJUNC(N,K),K=1,2) 
                 ELSE 
        IF(NKLASS(N).EQ.6) WRITE(N6,5322) N,NCOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(NJUNC(N,K),K=1,2),ZU(N),ZD(N), 
     +                     STHETA(N),SPHI(N) 
        IF(NKLASS(N).NE.6) WRITE(N6,5323) N,NCOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(NJUNC(N,K),K=1,2),ZU(N),ZD(N) 
                ENDIF 
      ELSE 
      IF(ZU(N).EQ.0.0.AND.ZD(N).EQ.0.0) THEN 
        IF(NKLASS(N).EQ.6) WRITE(N6,5420) N,ACOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(KJUNC(N,K),K=1,2),STHETA(N),SPHI(N) 
        IF(NKLASS(N).NE.6) WRITE(N6,5421) N,ACOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(KJUNC(N,K),K=1,2) 
                 ELSE 
        IF(NKLASS(N).EQ.6) WRITE(N6,5422) N,ACOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(KJUNC(N,K),K=1,2),ZU(N),ZD(N), 
     +                     STHETA(N),SPHI(N) 
        IF(NKLASS(N).NE.6) WRITE(N6,5423) N,ACOND(N),LEN(N), 
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N), 
     +                     DEEP(N),(KJUNC(N,K),K=1,2),ZU(N),ZD(N) 
                ENDIF 
      ENDIF 
  300 CONTINUE 
C  BAC START   
C======================================================================= 
C     LENGTHEN CONDUITS AND/OR INCORPORATE LOCAL LOSSES INTO MANNING'S N 
C     AS APPROPRIATE 
C======================================================================= 
C 
C  SIMPLY REPLACE EXISTING CODE WITH THIS NEW CODE 
      WRITE(N6,9030) 
      VOLOLD   = 0.0 
      VOLNEW   = 0.0 
        DO 320 N=1,NC 
            VOLOLD   = VOLOLD + AFULL(N)*LEN(N) 
            IF(.NOT.CLOSED(N)) THEN 
                NEWK = NEWKLASS(NKLASS(N)) 
                CALL HYDRAD(N,NEWK,DEEP(N),RMID,AMID,BMID) 
                AB = AMID/BMID 
                IF(AB.LE.0.0) AB = 0.01 
            ELSE 
               AB = DEEP(N) 
            ENDIF 
            RATIO = SQRT(AB*GRVT)*DELT/LEN(N) 
        SELECT CASE (NEQUAL) 
        CASE (1,5) 
C 
C     LENGTHEN SHORT PIPES WITHOUT INCORPORATING LOCAL LOSSES 
C 
            IF(RATIO.GT.1.0) THEN 
               CLEN     = DELT*SQRT(AB*GRVT) 
               ROUGH(N) = ROUGH(N)*SQRT(LEN(N)/CLEN) 
               LEN(N)   = CLEN 
               IF(JCE.EQ.0) THEN 
                WRITE(N6,5335) NCOND(N),RATIO 
                WRITE(N6,5337) NCOND(N),CLEN,ROUGH(N),RATIO 
               ELSE 
                WRITE(N6,5336) ACOND(N),RATIO 
                WRITE(N6,5338) ACOND(N),CLEN,ROUGH(N),RATIO 
               ENDIF 
              ENDIF 
         IF ((NEQUAL.EQ.5).AND.CLOSED(N)) THEN 
               IF (JCE.EQ.0) THEN 
                    WRITE(N6,6400) NCOND(N),ENTK(N),EXITK(N),OTHERK(N) 
               ELSE 
                    WRITE(N6,6401) ACOND(N),ENTK(N),EXITK(N),OTHERK(N) 
               ENDIF 
         ENDIF 
C 
C     INCORPORATE LOCAL LOSSES INTO MANNING'S N FOR CLOSED CONDUITS 
C     BUT DO NOT ADJUST FOR SHORT CONDUITS 
           CASE (2) 
             IF(CLOSED(N)) THEN 
               OLDROUGH = ROUGH(N) 
Cwch, Factor of 29 in eqn. is 2g/1.49^2.  Need to include these 
C     coefficients explicitly to allow for metric.  Eqn. factored 
C     a little differently in re-write. 
CCC               ROUGH(N) = ((ENTK(N)+EXITK(N)+OTHERK(N)+29.*ROUGH(N)* 
CCC     +                    ROUGH(N)*LEN(N)/RFULL(N)**(1.333333))* 
CCC     +                    RFULL(N)**(1.333333)/29./LEN(N))**0.5 
			 ROUGH(N) = SQRT(ROUGH(N)**2 + 
     1                   (ENTK(N)+EXITK(N)+OTHERK(N))* 
     2                   CMET(9,METRIC)**2*RFULL(N)**1.333333/ 
	3				   (2.0*GRVT*LEN(N))) 
C ****** BAC -- THIS IS A TEMPORARY WRITE TO SEE IF PROGRAM IN FUNCTIONING CORRECTLY 
               IF(JCE.EQ.0) THEN 
                            WRITE(N6,6335) NCOND(N),OLDROUGH,ENTK(N), 
     +                                     EXITK(N),OTHERK(N),ROUGH(N) 
               ELSE 
                            WRITE(N6,6336) ACOND(N),OLDROUGH,ENTK(N), 
     +                                     EXITK(N),OTHERK(N),ROUGH(N) 
               ENDIF 
             ENDIF 
c  set additional losses to zero to avoid using again in _ROUTE routines 
      ENTK(N)   = 0.0 
      EXITK(N)  = 0.0 
      OTHERK(N) = 0.0 
      IF(RATIO.GT.1.0) THEN 
        IF (JCE.EQ.0) THEN 
         WRITE(N6,5335) NCOND(N),RATIO 
        ELSE 
         WRITE(N6,5336) ACOND(N),RATIO 
        ENDIF 
      ENDIF 
C 
C     INCORPORATE LOCAL LOSSES AND LENGTHEN SHORT CONDUITS 
c 
      CASE (3) 
c    IF SHORT THEN DO THIS 
               IF(RATIO.GT.1.0) THEN 
                  CLEN     = DELT*SQRT(AB*GRVT) 
C    IF NOT CLOSED AND SHORT THEN DO THIS 
                 IF(.NOT.CLOSED(N)) THEN 
                    ROUGH(N) = ROUGH(N)*SQRT(LEN(N)/CLEN) 
               IF(JCE.EQ.0) THEN 
                WRITE(N6,5335) NCOND(N),RATIO 
                WRITE(N6,5337) NCOND(N),CLEN,ROUGH(N),RATIO 
                ELSE 
                WRITE(N6,5336) ACOND(N),RATIO 
                WRITE(N6,5338) ACOND(N),CLEN,ROUGH(N),RATIO 
               ENDIF 
C    IF IT IS CLOSED AND SHORT THEN DO THE FOLLOWING 
                  ELSE 
                    OLDROUGH = ROUGH(N) 
Cwch, 3/28/00.  Fix typo again, as above (old eqn. deleted). 
			 ROUGH(N) = SQRT(ROUGH(N)**2 + 
     1                   (ENTK(N)+EXITK(N)+OTHERK(N))* 
     2                   CMET(9,METRIC)**2*RFULL(N)**1.333333/ 
	3				   (2.0*GRVT*LEN(N))) 
               IF(JCE.EQ.0) THEN 
c                WRITE(N6,5335) NCOND(N),RATIO 
                WRITE(N6,6337) NCOND(N),OLDROUGH,CLEN,ENTK(N),EXITK(N), 
     +                         OTHERK(N),ROUGH(N) 
                ELSE 
c                WRITE(N6,5336) ACOND(N),RATIO 
                WRITE(N6,6338) ACOND(N),OLDROUGH,CLEN,ENTK(N),EXITK(N), 
     +                         OTHERK(N),ROUGH(N) 
                ENDIF 
              ENDIF 
                  LEN(N)   = CLEN 
              ELSE 
C    GO HERE IF NOT SHORT BUT CLOSED TO INCORPORATED ADDITIONAL LOSSES 
C    INCORPORATE LOCAL LOSSES INTO MANNING'S N FOR CLOSED CONDUITS 
C    BUT DO NOT ADJUST FOR SHORT CONDUITS 
             IF(CLOSED(N)) THEN 
               OLDROUGH = ROUGH(N) 
Cwch, 3/28/00. Fix typo again, as above (old eqn. deleted). 
			 ROUGH(N) = SQRT(ROUGH(N)**2 + 
     1                   (ENTK(N)+EXITK(N)+OTHERK(N))* 
     2                   CMET(9,METRIC)**2*RFULL(N)**1.333333/ 
	3				   (2.0*GRVT*LEN(N))) 
C ****** BAC -- THIS IS A TEMPORARY WRITE TO SEE IF PROGRAM IN FUNCTIONING CORRECTLY 
               IF(JCE.EQ.0) THEN 
                            WRITE(N6,6335) NCOND(N),OLDROUGH,ENTK(N), 
     +                                     EXITK(N),OTHERK(N),ROUGH(N) 
               ELSE 
                            WRITE(N6,6336) ACOND(N),OLDROUGH,ENTK(N), 
     +                                     EXITK(N),OTHERK(N),ROUGH(N) 
               ENDIF 
             ENDIF 
             ENDIF 
c  set additional losses to zero to avoid using again in _ROUTE routines 
      ENTK(N) = 0.0 
      EXITK(N) = 0.0 
      OTHERK(N) = 0.0 
C 
C      NEQUAL IS ZERO OR 4 
C      ONLY CHECK FOR SHORT PIPES 
C 
      CASE (0,4) 
      IF(RATIO.GT.1.0) THEN 
         IF(JCE.EQ.0) THEN 
           WRITE(N6,5335) NCOND(N),RATIO 
         ELSE 
           WRITE(N6,5336) ACOND(N),RATIO 
         ENDIF 
      ENDIF 
         IF ((NEQUAL.EQ.4).AND.CLOSED(N)) THEN 
               IF (JCE.EQ.0) THEN 
                    WRITE(N6,6400) NCOND(N),ENTK(N),EXITK(N),OTHERK(N) 
               ELSE 
                    WRITE(N6,6401) ACOND(N),ENTK(N),EXITK(N),OTHERK(N) 
               ENDIF 
         ENDIF 
      END SELECT 
          VOLNEW   = VOLNEW + AFULL(N)*LEN(N) 
  320   CONTINUE 
C 
      IF(NEQUAL.EQ.1.AND.METRIC.EQ.1) WRITE(N6,5339) 
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD 
      IF(NEQUAL.EQ.1.AND.METRIC.EQ.2) WRITE(N6,5340) 
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD 
      IF(NEQUAL.EQ.0.AND.METRIC.EQ.1) WRITE(N6,5341)  VOLOLD 
      IF(NEQUAL.EQ.0.AND.METRIC.EQ.2) WRITE(N6,5342)  VOLOLD 
      IF(NEQUAL.EQ.3.AND.METRIC.EQ.1) WRITE(N6,5339) 
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD 
      IF(NEQUAL.EQ.3.AND.METRIC.EQ.2) WRITE(N6,5340) 
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD 
      IF(NEQUAL.EQ.2.AND.METRIC.EQ.1) WRITE(N6,5341)  VOLOLD 
      IF(NEQUAL.EQ.2.AND.METRIC.EQ.2) WRITE(N6,5342)  VOLOLD 
      IF(NEQUAL.EQ.5.AND.METRIC.EQ.1) WRITE(N6,5339) 
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD 
      IF(NEQUAL.EQ.5.AND.METRIC.EQ.2) WRITE(N6,5340) 
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD 
C  BAC END  
C======================================================================= 
C     FIND JUNCTION DATA TO READ FROM GROUP D1. 
C     THE FOLLOWING SEQUENCE IS REQUIRED IF NATURAL CHANNEL INFORMATION 
C     WAS ENTERED IN THE DATA INPUT STREAM.  R.E.D., 4/92 
C     Modified by CIM to eliminate artificial loop which could potentially 
C     fail if may irregular sections. 
C======================================================================= 
C     DO 370 J=1,1000 
 370  CONTINUE 
      READ(N5,*,ERR=372) CC 
C  don't know what C6 was before bridges were invoked 
C     IF(CC.EQ.'D1'.OR.CC.EQ.'C6') THEN 
            IF(CC.EQ.'D1') THEN 
                                   BACKSPACE N5 
                                   GO TO 375 
                                   ENDIF 
      GO TO 370 
  372 WRITE(N6,*) 'D1 lines not found in input stream.' 
      STOP 'D1 lines not found' 
C 370 CONTINUE 
  375 CONTINUE 
C======================================================================= 
C     READ JUNCTION DATA ON DATA GROUP D1 
C======================================================================= 
      WRITE(*,6050) 
      DO 380 J = 1,NEE 
  340 READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'D1'.AND.J.GT.1) GO TO 400 
C These next lines should not be needed. cim 10/97 
C      IF(J.EQ.1. AND.(CC.EQ.'C3'.OR.CC.EQ.'X1'.OR. 
C     *                CC.EQ.'C4'.OR.CC.EQ.'GR')) THEN 
C                                READ(N5,*,ERR=888) CC 
C                                GO TO 340 
C                                ENDIF 
C modify to read optional xloc, yloc, and iwhich 
C 
C     READ IWHICH IF BFFACT IS TRUE INDICATING THAT BD LINES WERE READ 
      IF (BFFACT) THEN 
         IF(JCE.EQ.0) THEN 
           READ(N5,*,ERR=888) CC,JUN(J),GRELEV(J), 
     +                        Z(J),QINST(J),Y(J), 
     +                        XLOC(J),YLOC(J), 
     +                        IWHICH(J),SURELEV(J) 
         ELSE 
           READ(N5,*,ERR=888) CC,AJUN(J),GRELEV(J), 
     +                        Z(J),QINST(J),Y(J), 
     +                        XLOC(J),YLOC(J), 
     +                        IWHICH(J),SURELEV(J) 
         ENDIF 
	ELSE 
C     DONT READ IWHICH IF BFFACT IS FALSE 
         IF(JCE.EQ.0) THEN 
           READ(N5,*,ERR=888) CC,JUN(J),GRELEV(J), 
     +                        Z(J),QINST(J),Y(J), 
     +                        XLOC(J),YLOC(J), 
     +                        SURELEV(J) 
         ELSE 
           READ(N5,*,ERR=888) CC,AJUN(J),GRELEV(J), 
     +                        Z(J),QINST(J),Y(J), 
     +                        XLOC(J),YLOC(J), 
     +                        SURELEV(J) 
         ENDIF 
	ENDIF 
c  350 CONTINUE 
	IF (JELEV.GE.2) Y(J) = Y(J) - Z(J) 
      IF (IWHICH(J).EQ.0) IWHICH(J)=1 
      IF (IWHICH(J).GT.NUMSETS) THEN 
      WRITE(N6,*) 'ERROR - BASE FLOW FACTOR SET FOR JUNCTION (IWHICH)', 
     .' IS GREATER THAN NUMBER OF SETS READ ON B9 LINES' 
      IF (JCE.EQ.0) THEN 
         WRITE(N6,*) ' JUNCTION = ',JUN(J),IWHICH(J) 
      ELSE 
         WRITE(N6,*) ' JUNCTION = ',AJUN(J),IWHICH(J) 
      ENDIF 
      STOP 'INCORRECT BASE FLOW FACTOR SET' 
      ENDIF 
      IF ((NUMSETS.GT.1).AND.(QINST(J).NE.0.0)) THEN 
      IF (JCE.EQ.0) THEN 
         WRITE(N6,*) 'JUNCTION ',JUN(J), 
     .' USES BASE FLOW SET NUMBER ',IWHICH(J) 
      ELSE 
         WRITE(N6,*) 'JUNCTION ',AJUN(J), 
     .' USES BASE FLOW SET NUMBER ',IWHICH(J) 
      ENDIF 
      ENDIF 
      ZCROWN(J) = Z(J) 
C     Set up junction connectivity array from pipe data. 
C======================================================================= 
      LOC      = 0 
      IF(NC.GT.0) THEN 
      DO 360 N = 1,NC 
      DO 360 K = 1,2 
      IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J)) THEN 
                                            LOC          = LOC+1 
	IF (LOC.GT.NCHN) THEN 
	WRITE(N6,8040) J,JUN(J),NCHN 
	NSTOP = NSTOP + 1 
	LOC = NCHN 
	ENDIF 
                                            NCHAN(J,LOC) = N 
                                            ENDIF 
      IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J))THEN 
                                            LOC          = LOC+1 
	IF (LOC.GT.NCHN) THEN 
	WRITE(N6,8045) J,AJUN(J),NCHN 
	NSTOP = NSTOP +1 
	LOC = NCHN 
	ENDIF 
                                            NCHAN(J,LOC) = N 
                                            ENDIF 
  360 CONTINUE 
CIM   DO THIS CHECK AFTER PUMPS AND WEIRS... HAVE BEEN READ 
CIM 
CIM      IF(LOC.EQ.0) THEN 
CIM                   IF(JCE.EQ.0) THEN 
CIM                     WRITE(N6,5350) JUN(J) 
CIM                   ELSE 
CIM                     WRITE(N6,5351) AJUN(J) 
CIM                   ENDIF 
CIM                   JSKIP(J) = 1 
CIM                   ENDIF 
      ELSE 
C======================================================================= 
C     ZCROWN IS EQUAL TO THE GROUND ELEVATION FOR JUNCTIONS WITH 
C            NO CONNECTING CONDUITS. 
C======================================================================= 
      ZCROWN(J) = GRELEV(J) - Z(J) 
      IF(ZCROWN(J).LE.0.0) THEN 
                           IF(JCE.EQ.0) THEN 
                            WRITE(N6,8200)  JUN(J) 
                           ELSE 
                            WRITE(N6,8201) AJUN(J) 
                           ENDIF 
                           NSTOP = NSTOP + 1 
                           ENDIF 
      ENDIF 
  380 CONTINUE 
  400 NJ = J-1 
C======================================================================= 
C     CONVERT CONDUIT CONNECTIVITY NUMBERS TO INTERNAL SYSTEM 
C     ASSIGN POSITIVE DOWNSTREAM FLOW CONVENTION 
C======================================================================= 
      IMOVE    = 0 
      IF(NC.GT.0) THEN 
	GRNDERROR = .FALSE. 
      DO 600 N = 1,NC 
      DO 540 K = 1,2 
      DO 500 J = 1,NJ 
      IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J))  GO TO 520 
      IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J)) GO TO 520 
  500 CONTINUE 
      IF(JCE.EQ.0) THEN 
       WRITE(N6,5390) NJUNC(N,K),NCOND(N) 
      ELSE 
       WRITE(N6,5391) KJUNC(N,K),ACOND(N) 
      ENDIF 
      NSTOP      = NSTOP + 1 
  520 NJUNC(N,K) = J 
  540 CONTINUE 
      NL    = NJUNC(N,1) 
      NH    = NJUNC(N,2) 
      IF(JELEV.EQ.0) THEN 
                     ZU(N) = Z(NL) + ZU(N) 
                     ZD(N) = Z(NH) + ZD(N) 
                     ELSE 
Cim If elevation is zero, then set to invert of junction 
                     IF(ZU(N).EQ.0.0) ZU(N) = Z(NL) + ZU(N) 
                     IF(ZD(N).EQ.0.0) ZD(N) = Z(NH) + ZD(N) 
                     ENDIF 
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
cim bac added 11/97 
C PREVENT FLAT CONDUITS 
c      DO N = 1, NC 
      IF(ABS(ZU(N)-ZD(N)).LE.0.0001) THEN 
      ZU(N)=ZU(N)+.001 
      IF (JCE.EQ.0) THEN 
                        WRITE(N6,6207) NCOND(N) 
                    ELSE 
                        WRITE(N6,6208) ACOND(N) 
      END IF 
      END IF 
c      END DO 
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
      IF(ZU(N)-ZD(N).LT.0.0) THEN 
                             IMOVE      = IMOVE + 1 
                             IF(JCE.EQ.1) THEN 
                                          KDUM(1)    = KJUNC(N,1) 
                                          KJUNC(N,1) = KJUNC(N,2) 
                                          KJUNC(N,2) = KDUM(1) 
                                          ENDIF 
                             TEMP       = ZU(N) 
                             ZU(N)      = ZD(N) 
                             ZD(N)      = TEMP 
                             QO(N)      = -QO(N) 
                             NJUNC(N,1) = NH 
                             NJUNC(N,2) = NL 
                             NL         = NJUNC(N,1) 
                             NH         = NJUNC(N,2) 
                             IF(IMOVE.EQ.1) WRITE(N6,6200) 
                             IF(JCE.EQ.0) THEN 
                               WRITE(N6,6205) IMOVE,NCOND(N) 
                             ELSE 
                               WRITE(N6,6206) IMOVE,ACOND(N) 
                             ENDIF 
                             ENDIF 
      IF((ZU(N) + DEEP(N)).GT.ZCROWN(NL))  ZCROWN(NL) = ZU(N)+DEEP(N) 
      IF((ZD(N) + DEEP(N)).GT.ZCROWN(NH))  ZCROWN(NH) = ZD(N)+DEEP(N) 
      IF(ZCROWN(NL).GT.GRELEV(NL)+0.001) THEN 
	            GRNDERROR = .TRUE. 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5395) NCOND(N),JUN(NL) 
                    ELSE 
                      WRITE(N6,5396) ACOND(N),AJUN(NL) 
                    ENDIF 
c  update grelev to appropriate land elevation for printout in table below 
                    GRELEV(NL) = ZCROWN(NL) + 0.01 
                    NSTOP      = NSTOP + 1 
                    ENDIF 
      IF(ZCROWN(NH).GT.GRELEV(NH)+0.001) THEN 
	            GRNDERROR = .TRUE. 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5395) NCOND(N),JUN(NH) 
                    ELSE 
                      WRITE(N6,5396) ACOND(N),AJUN(NH) 
                    ENDIF 
c  update grelev to appropriate land elevation for printout in table below 
                    GRELEV(NH) = ZCROWN(NH) + 0.01 
                    NSTOP      = NSTOP + 1 
                    ENDIF 
  600 CONTINUE 
      IF (GRNDERROR) WRITE(N6,8000) 
      ENDIF 
C======================================================================= 
C     Print junction data. 
C======================================================================= 
CIM 1/99 print first header 
                                   WRITE(N6,2999) 
                                   WRITE(N6,5060) ALPHA1,ALPHA2 
                                   IF(METRIC.EQ.1) WRITE(N6,5360) 
                                   IF(METRIC.EQ.2) WRITE(N6,5361) 
      DO 460 J = 1,NJ 
      MPT      = 0 
      NZP      = 0 
      DO 420 I = 1,NCHN 
      K1       = NCHAN(J,I) 
      IF(K1.EQ.0)            GO TO 440 
      IF(JCE.EQ.0) THEN 
       IDUM(I) = NCOND(K1) 
      ELSE 
       KDUM(I) = ACOND(K1) 
      ENDIF 
      MPT                  = MPT + 1 
C======================================================================= 
C     Check for all conduits above the Junction invert. 
C======================================================================= 
                           JJ = 1 
      IF(NJUNC(K1,1).EQ.J) JJ = 1 
      IF(NJUNC(K1,2).EQ.J) JJ = 2 
      IF(JJ.EQ.1.AND.ZU(K1).GT.Z(J)) NZP = NZP + 1 
      IF(JJ.EQ.2.AND.ZD(K1).GT.Z(J)) NZP = NZP + 1 
      IF(JJ.EQ.1.AND.ZU(K1).LT.Z(J)) NZP = NZP + 1 
      IF(JJ.EQ.2.AND.ZD(K1).LT.Z(J)) NZP = NZP + 1 
  420 CONTINUE 
  440 CONTINUE 
CIM 1/99 eliminate intermediate headers if JHEAD = 1 
      IF (JHEAD.EQ.0.AND.MOD(J,50).EQ.0) THEN 
                                   WRITE(N6,2999) 
                                   WRITE(N6,5060) ALPHA1,ALPHA2 
                                   IF(METRIC.EQ.1) WRITE(N6,5360) 
                                   IF(METRIC.EQ.2) WRITE(N6,5361) 
                                   ENDIF 
      IF(MPT.GT.0) THEN 
      IF(JCE.EQ.0) THEN 
                   WRITE(N6,5380) J,JUN(J),GRELEV(J),ZCROWN(J), 
     +                            Z(J),QINST(J),Y(J),(IDUM(K),K=1,MPT) 
      ELSE 
                   WRITE(N6,5381) J,AJUN(J),GRELEV(J),ZCROWN(J), 
     +                            Z(J),QINST(J),Y(J),(KDUM(K),K=1,MPT) 
      ENDIF 
      IF(NZP.EQ.MPT) THEN 
         IF(JCE.EQ.0) THEN 
             WRITE(N6,5382)  JUN(J) 
         ELSE 
             WRITE(N6,5383) AJUN(J) 
         ENDIF 
      ENDIF 
      ELSE 
      IF(JCE.EQ.0) THEN 
                   WRITE(N6,5380) J,JUN(J),GRELEV(J), 
     +                            ZCROWN(J),Z(J),QINST(J),Y(J) 
      ELSE 
                   WRITE(N6,5381) J,AJUN(J),GRELEV(J), 
     +                            ZCROWN(J),Z(J),QINST(J),Y(J) 
      ENDIF 
      ENDIF 
	IF ((XLOC(J).NE.0.0).OR. 
     1    (YLOC(J).NE.0.0).OR. 
     2    (SURELEV(J).NE.0.0)) TABLE2 = .TRUE. 
  460 CONTINUE 
C     PRINT SECOND TABLE FOR ADDITIONAL JUNCTION DATA 
C      X,Y, IWHICH, SURELEV 
      IF (TABLE2.OR.BFFACT) THEN 
	IF (METRIC.EQ.1) THEN 
	                   IREAD = '(FT)' 
	ELSE 
	                   IREAD = ' (M)' 
	ENDIF 
	IF (BFFACT) THEN 
	    WRITE(N6,7360) IREAD 
	ELSE 
	    WRITE(N6,7365) IREAD 
	ENDIF 
      DO 480 J = 1,NJ 
	IF (BFFACT) THEN 
      IF(JCE.EQ.0) THEN 
                   WRITE(N6,7380) J,JUN(J),XLOC(J),YLOC(J), 
     +                            IWHICH(J),SURELEV(J) 
      ELSE 
                   WRITE(N6,7381) J,AJUN(J),XLOC(J),YLOC(J), 
     +                            IWHICH(J),SURELEV(J) 
      ENDIF 
	ELSE 
      IF(JCE.EQ.0) THEN 
                   WRITE(N6,7385) J,JUN(J),XLOC(J),YLOC(J), 
     +                            SURELEV(J) 
      ELSE 
                   WRITE(N6,7386) J,AJUN(J),XLOC(J),YLOC(J), 
     +                            SURELEV(J) 
      ENDIF 
	ENDIF 
	IF ((SURELEV(J).NE.0.0).AND.(SURELEV(J).LT.GRELEV(J))) 
     1         WRITE(N6,7387) 
  480 CONTINUE 
      ENDIF 
	DO J=1,NJ 
	IF(SURELEV(J).EQ.0.0) SURELEV(J) = GRELEV(J) 
	IF(SURELEV(J).LT.GRELEV(J)) SURELEV(J) = GRELEV(J) 
	ENDDO 
C======================================================================= 
C     Check for high pipe and print a warning at the upstream end. 
C======================================================================= 
      DO 495 N = 1,NC 
      J        = NJUNC(N,1) 
      IF(ZU(N).EQ.Z(J)) GO TO 495 
C add a test for ZU lt z 
      IF(ZU(N).LT.Z(J)) THEN 
	IF (JCE.EQ.0) THEN 
	WRITE(N6,8050) 'UPSTREAM  ',NCOND(N),JUN(J),ZU(N),Z(J) 
	ELSE 
	WRITE(N6,8055) 'UPSTREAM  ',ACOND(N),AJUN(J),ZU(N),Z(J) 
      ENDIF 
	NSTOP = NSTOP + 1 
	ENDIF 
      ITEST     = 0 
      JTEST     = 0 
      DO 490 KK = 1,NCHN 
      NKK       = NCHAN(J,KK) 
      IF(NKK.EQ.N) GO TO 490 
      IF(NKK.EQ.0.OR.NKK.GT.NC) GO TO 494 
                            JJ = 1 
      IF(NJUNC(NKK,1).EQ.J) JJ = 1 
      IF(NJUNC(NKK,2).EQ.J) JJ = 2 
      JTEST = JTEST + 1 
      IF(JJ.EQ.1.AND.ZU(N).LE.ZU(NKK) + DEEP(NKK)) GO TO 490 
      IF(JJ.EQ.2.AND.ZU(N).LE.ZD(NKK) + DEEP(NKK)) GO TO 490 
      ITEST = ITEST + 1 
  490 CONTINUE 
  494 CONTINUE 
      IF(ITEST.EQ.JTEST) THEN 
          IF(JCE.EQ.0) THEN 
             WRITE(N6,5392) NCOND(N),JUN(J) 
          ELSE 
             WRITE(N6,5393) ACOND(N),AJUN(J) 
          ENDIF 
      ENDIF 
  495 CONTINUE 
C======================================================================= 
C     Check for high pipe and print a warning at the downstream end. 
C======================================================================= 
      DO 595 N = 1,NC 
      J        = NJUNC(N,2) 
      IF(ZD(N).EQ.Z(J)) GO TO 595 
C add a test for ZU lt z 
      IF(ZD(N).LT.Z(J)) THEN 
	IF (JCE.EQ.0) THEN 
	WRITE(N6,8050) 'DOWNSTREAM',NCOND(N),JUN(J),ZD(N),Z(J) 
	ELSE 
	WRITE(N6,8055) 'DOWNSTREAM',ACOND(N),AJUN(J),ZD(N),Z(J) 
      ENDIF 
	NSTOP = NSTOP + 1 
	ENDIF 
      ITEST     = 0 
      JTEST     = 0 
      DO 590 KK = 1,NCHN 
      NKK       = NCHAN(J,KK) 
      IF(NKK.EQ.N) GO TO 590 
      IF(NKK.EQ.0.OR.NKK.GT.NC) GO TO 594 
                            JJ = 1 
      IF(NJUNC(NKK,1).EQ.J) JJ = 1 
      IF(NJUNC(NKK,2).EQ.J) JJ = 2 
      JTEST = JTEST + 1 
      IF(JJ.EQ.1.AND.ZD(N).LE.ZU(NKK) + DEEP(NKK)) GO TO 590 
      IF(JJ.EQ.2.AND.ZD(N).LE.ZD(NKK) + DEEP(NKK)) GO TO 590 
      ITEST = ITEST + 1 
  590 CONTINUE 
  594 CONTINUE 
      IF(ITEST.EQ.JTEST) THEN 
        IF(JCE.EQ.0) THEN 
          WRITE(N6,5392) NCOND(N),JUN(J) 
        ELSE 
          WRITE(N6,5393) ACOND(N),AJUN(J) 
        ENDIF 
      ENDIF 
  595 CONTINUE 
CIM START   <><><><><><><><> 
CIM     CONVERT NKLASS FROM INPUT VALUES TO INTERNAL VALUES FOR LATER 
CIM     COMPUTATIONS STORED IN NEWKLASS ARRAY 
c 
      BIG = 3.4E+38 
      DO 650  N = 1,NC 
      NKLASS(N) = NEWKLASS(NKLASS(N)) 
      IF (NKLASS(N).LE.21) THEN 
      IF (STHETA(N).EQ.0.0) STHETA(N) = -BIG 
      IF (SPHI(N).EQ.0.0)   SPHI(N) = BIG 
      ENDIF 
  650 CONTINUE 
CIM END   <><><><><><> 
C======================================================================= 
CIM### 9/9/00 
C	CALL READTHRESH TO READ D2 AND D3 LINES 
      CALL READTHRESH 
C======================================================================= 
      WRITE(*,6100) 
      RETURN 
 888  CALL IERROR 
 8888 WRITE(N6,8887) 
      STOP 
C======================================================================= 
  949 FORMAT(12F10.3) 
  951 FORMAT(//,5X,'INTERMEDIATE OUTPUT WILL BE WRITTEN FOR THE', 
     A' FOLLOWING PERIODS',/, 
     B10X,' STARTING CYCLE   ENDING CYCLE') 
  952 FORMAT(10X,2I15) 
 2999 FORMAT(/, 
     1       '1',40(2H--)/' ','ENVIRONMENTAL PROTECTION AGENCY',13X,40H* 
     2***   EXTENDED TRANSPORT PROGRAM   ****,8X,'WATER RESOURCES DIVISI 
     3ON',/,' ','WASHINGTON, D.C.            ',16X,4H****,32X,4H****,8X, 
     4'CAMP DRESSER & MCKEE INC.',/,' ','                ',28X,4H****, 
     56X,'   ANALYSIS MODULE  ',6X,4H****,8X,'ANNANDALE, VIRGINIA') 
Cwch, 7/23/04. 
 5050 FORMAT(/,' Version compatibility options from Line AA.',/, 
     1         ' -------------------------------------------') 
 5051 FORMAT(  ' NAVER = 1, Use SWMM3x geometric parameter weighting.')  
 5052 FORMAT(  ' NAVER = 2, Use SWMM4x geometric parameter weighting.')  
 5053 FORMAT(  ' NAVER = 3, Use SWMM5 geometric parameter weighting.')  
 5054 FORMAT(/,' WARNING Parameter NAVER =',I3,' on AA line not 1,2 or 
     13.',/,   ' Use NAVER = 2 (SWMM4x weighting) as default.') 
 5055 FORMAT(  ' NFASNH =',I2,' on AA line re. surface area weighting. S 
     1ee documentation.') 
 5056 FORMAT(  ' NFASNH =',I3,' on AA line re. surface area weighting. O 
     1ut of range Use NFASNH = 0 as default. See documentation.')  
 5060 FORMAT(/,5X,A80,/,5X,A80,/) 
 5100 FORMAT(/,' Control information for simulation',/, 
     +       ' ----------------------------------',//, 
     +       ' Integration cycles.................',I8,/) 
 5120 FORMAT(' Length of integration step is......',F8.2, 
     +       ' seconds',/, 
     +       ' Simulation length..................',F8.2,' hours',/) 
 5121 FORMAT(' Do not create equiv. pipes(NEQUAL).',I8,/) 
C  BAC START 
C5122 FORMAT(' Create equivalent conduits based ',/, 
C    +       ' on the COURANT condition..........',I8,/) 
 5122 FORMAT(' Create equivalent conduits based ',/, 
     +       ' on the COURANT condition (no local',/, 
     +       ' losses)............................',I8,/) 
 5921 FORMAT(' Create equivalent conduits based ',/, 
     +       ' on incorporating local losses (no',/, 
     +       ' lengthening).......................',I8,/) 
 5922 FORMAT(' Create equivalent conduits based ',/, 
     +       ' on incorporating local losses and',/, 
     +       ' on the COURANT condition...........',I8,/) 
 5923 FORMAT(' Local losses read from C1 lines are ',/, 
     +       ' factored into momentum equation (no',/, 
     +       ' lengthening).......................',I8,/) 
 5924 FORMAT(' Local losses read from C1 lines are ',/, 
     +       ' factored into momentum equation and ',/, 
     +       ' conduits are lengthened based on COURANT',/, 
     +       ' condition..........................',I8,/) 
C  BAC END 
 5123 FORMAT(' Use U.S. customary units for I/O...',I8,/) 
 5124 FORMAT(' Use metric units for I/O...........',I8,/) 
C#### WCH, 7/25/96.  JREDO INSTEAD OF REDO. 
Cwch, 9/8/00. Use I9 for INTER. 
 5140 FORMAT(' Printing starts in cycle...........',I8,//, 
     +       ' Intermediate printout intervals of', I9,' cycles',/, 
     +       ' Intermediate printout intervals of.',F8.2,' minutes',//, 
     +       ' Summary printout intervals of......',I8,' cycles',/, 
     +       ' Summary printout time interval of..',F8.2,' minutes',//, 
     +       ' Hot start file parameter (JREDO)...',I8,/) 
 5160 FORMAT(' Initial time (TZERO)...............',F8.2,' hours') 
C#### WCH, 7/25/96. 
c 5161 FORMAT(' Time displacement from interface file starting date/time' 
c     1,/,    ' when hot start is used (TZERO).....',F8.2,' hours') 
 5161 FORMAT(' This is time displacement from JIN interface file ', 
     1'starting date/time when',/,' interface file is used.',/, 
     1' This also describes starting hour in K3 line hydrograph', 
     1' input when K3',/,' lines are used.') 
Cwch, 2/4/01 
 5162 FORMAT(/,' ERROR. IDATZ MUST BE AT LEAST 5 DIGITS TO PROVIDE YR/MO 
     1/DAY. CHANGE ENTERED IDATZ =',I8,' TO DEFAULT = 19410802.') 
C#### WCH, 4/11/94. 
 5163 FORMAT(' Initial date (default).............',I8,' (yr/mo/day)') 
CWCH, 11/12/99. ADD FIELD WIDTH TO ALLOW FOR NEGATIVE SIGN 
 5164 FORMAT(' Initial date (IDATZ).............', I10,' (yr/mo/day)') 
C#### WCH, 7/25/96. 
 5165 FORMAT(' NOTE: Initial date from JIN interface file will be', 
     +' used, if accessed,',/,' unless IDATZ is negative.') 
 5170 FORMAT(/,' Iteration variables: ITMAX.........',I8,/, 
     1         '                      SURTOL........',F8.4,/) 
 5175 FORMAT(' Default surface area of junctions....',F8.2, 
     +       ' square feet.',/) 
 5176 FORMAT(' Default surface area of junctions..',F6.2, 
     +       ' square meters.',/) 
 5177 FORMAT(' EXTRAN VERSION 3.3 SOLUTION. (ISOL = 0).',/, 
     +       ' Sum of junction flow is zero during surcharge.',/) 
 5178 FORMAT(' SEMI-IMPLICIT EXTRAN SOLUTION. (ISOL = 1).',/, 
     +       ' NEWTON-RAPHSON SURCHARGE ITERATION.',/) 
 5179 FORMAT(' ITERATIVE EXTRAN SOLUTION. (ISOL = 2).',/, 
     +       ' NEWTON-RAPHSON SURCHARGE ITERATION.',/) 
 5180 FORMAT(' NJSW INPUT HYDROGRAPH JUNCTIONS....',I6) 
 5183 FORMAT(' NORMAL FLOW OPTION WHEN THE WATER  ',/, 
     +       ' SURFACE SLOPE IS LESS THAN THE     ',/, 
     +       ' GROUND SURFACE SLOPE (KSUPER=0)....',/) 
 5184 FORMAT(' NORMAL FLOW OPTION WHEN THE FROUDE ',/, 
     +       ' # IS GREATER THAN 1.0 (KSUPER=1)...',/) 
CIM 1/99 CLEAN UP FOLLOWING TO PROVIDE BLANKS IF 10 CHARACTERS OR DIGITS 
CIM ARE USED 
 5200 FORMAT(/,' Printed output for the following',I3, 
     +         ' Junctions',//,(5X,10(I10,1X))) 
 5201 FORMAT(/,' Printed output for the following',I3, 
     +         ' Junctions',//,(5X,10(A10,1X))) 
 5220 FORMAT(/,' Printed output for the following',I3, 
     +         ' Conduits',//,(5X,10(I10,1X))) 
 5221 FORMAT(/,' Printed output for the following',I3, 
     +         ' Conduits',//,(5X,10(A10,1X))) 
 5240 FORMAT (/,' Water surface elevations will be plotted', 
     +    ' for the following ',I3,' Junctions',//,(5X,10(I10,1X))) 
 5241 FORMAT (/,' Water surface elevations will be plotted', 
     +    ' for the following ',I3,' Junctions',//,(5X,10(A10,1X))) 
 5260 FORMAT(/,' Flow rate will be plotted for the following ', 
     +             I3,' Conduits',//,(5X,10(I10,1X))) 
 5261 FORMAT(/,' Flow rate will be plotted for the following ', 
     +             I3,' Conduits',//,(5X,10(A10,1X))) 
 5265 FORMAT(/,' THE WATER SURFACE SLOPE WILL BE PLOTTED FOR THE ', 
     +         'FOLLOWING ',I3,' CONDUITS',//,(5X,10(I10,1X))) 
 5266 FORMAT(/,' THE WATER SURFACE SLOPE WILL BE PLOTTED FOR THE ', 
     +         'FOLLOWING ',I3,' CONDUITS',//,(5X,10(A10,1X))) 
CIM  WRITING OF RESULTS TO ASCII FILE 
 5267 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ', 
     +         'FOLLOWING ',I5,' CONDUITS',/, 
     +         ' FLOWS WILL BE WRITTEN EVERY ',i5,' TIME STEPS',/, 
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CFS', 
     +          /,(5X,10(I10,1X))) 
Cwch, 9/9/00. 
 5273 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ', 
     +         'FOLLOWING ',I5,' CONDUITS',/, 
     +         ' FLOWS WILL BE WRITTEN EVERY ',i5,' TIME STEPS',/, 
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CMS', 
     +          /,(5X,10(I10,1X))) 
 5268 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ', 
     +         'FOLLOWING ',I5,' CONDUITS',/, 
     +         ' FLOWS WILL BE WRITTEN EVERY ',I5,' TIME STEPS',/, 
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CFS', 
     +         //,(5X,10(A10,1X))) 
 5274 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ', 
     +         'FOLLOWING ',I5,' CONDUITS',/, 
     +         ' FLOWS WILL BE WRITTEN EVERY ',I5,' TIME STEPS',/, 
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CMS', 
     +         //,(5X,10(A10,1X))) 
 8260 FORMAT(/,' FLOWS ARE WRITTEN TO STANDARD SWMM BINARY ', 
     +'SEQUENTIAL UNFORMATTED FILE FOR INPUT TO STATS OR OTHER ', 
     +'SWMM BLOCK') 
 8261 FORMAT(/,' FLOWS ARE WRITTEN TO ASCII FORMATTED FILE') 
 8263 FORMAT(/,' ABSOLUTE VALUE OF FLOWS ARE WRITTEN TO OUTPUT FILE') 
 5269 FORMAT(' FLOWS IN CFS',/, 
     1' MO DY YEAR  HOUR  DT(SEC)   FLOWS IN CHANNEL NOS.:') 
Cwch, 9/8/00. 
 5272 FORMAT(' FLOWS IN CMS',/, 
     1' MO DY YEAR  HOUR  DT(SEC)   FLOWS IN CHANNEL NOS.:') 
 7268 FORMAT(' FLOWS AT FOLLOWING ',I10,' CONDUITS WILL BE WRITTEN', 
     &' WHEN FLOWS IN SECOND PIPE ARE GREATER THAN FLOWMIN',//, 
     &10X,'FIRST PIPE',10X,'SECOND PIPE ') 
 7269 FORMAT(10X,I10,10X,I10) 
 7270 FORMAT('NOFDUP EQUALS ZERO') 
 7271 FORMAT(10X,A10,10X,A10) 
 5270 FORMAT(25X,400I14) 
 5271 FORMAT(25X,400(4X,A10)) 
 5300 FORMAT(/,1H1,/, 
     +' *****************************************************',/, 
     +' *                     Conduit Data                  *',/, 
     +' *****************************************************',//, 
     1'  INP  CONDUIT    LENGTH   CONDUIT     AREA    MANNING MAX WIDTH' 
     1,'     DEPTH       JUNCTIONS          INVERT HEIGHT     TRAPEZOID' 
     1,/, 
     2'  NUM   NUMBER     (FT)      CLASS   (SQ FT)     COEF.   (FT)   ' 
     2,'      (FT)      AT THE ENDS        ABOVE JUNCTIONS   ', 
     2'SIDE SLOPES',/, 
     3' ----   ------   -------  --------   -------   ------- ---------' 
     3,'     -----   -------   -------     ---------------   ', 
     3'----- -----') 
 5301 FORMAT(/,1H1,/, 
     +' *****************************************************',/, 
     +' *                     Conduit Data                  *',/, 
     +' *****************************************************',//, 
     1'  INP  CONDUIT    LENGTH   CONDUIT     AREA    MANNING MAX WIDTH' 
     1,'     DEPTH       JUNCTIONS          INVERT HEIGHT     TRAPEZOID' 
     1,/, 
     2'  NUM   NUMBER     (M)       CLASS    (SQ M)     COEF.   (M)    ' 
     2,'      (M)       AT THE ENDS        ABOVE JUNCTIONS   ', 
     2'SIDE SLOPES',/, 
     3' ----   ------   -------  --------   -------   ------- ---------' 
     3,'     -----   -------   -------     ---------------   ', 
     2'----- -----') 
 5320 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X), 
     a16X,2F7.2) 
 5321 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X)) 
 5322 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X) 
     a,2F8.2,2F7.2) 
 5323 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X) 
     a,2F8.2) 
 5335 FORMAT(' ===> WARNING  (C*DELT/LEN) IN CONDUIT', 
     .       I10,' IS',F5.1,' AT FULL DEPTH.') 
 5336 FORMAT(' ===> WARNING  (C*DELT/LEN) IN CONDUIT ', 
     .       A10,' IS',F5.1,' AT FULL DEPTH.') 
 5337 FORMAT(' ===> THE NEW EQUIVALENT LENGTH/ROUGHNESS/RATIO FOR COND', 
     +'UIT ',I10,' IS ',F10.1,' / ',F10.7,' / ',F5.1) 
 5338 FORMAT(' ===> THE NEW EQUIVALENT LENGTH/ROUGHNESS/RATIO FOR COND', 
     +'UIT ',A10,' IS ',F10.1,' / ',F10.7,' / ',F5.1) 
 5339 FORMAT(/, 
     +' ****************************************',/, 
     +' *  Equivalent Conduit Volume Analysis  *',/, 
     +' ****************************************',//, 
     +' Input full depth volume............',1PE14.4,' cubic feet',/, 
     +' New full depth volume..............',1PE14.4,' cubic feet',/, 
     +' New volume / Old volume ratio......',0PF14.4) 
 5340 FORMAT(/, 
     +' ****************************************',/, 
     +' *  Equivalent Conduit Volume Analysis  *',/, 
     +' ****************************************',//, 
     +' Input full depth volume............',1PE14.4,' cubic meters',/, 
     +' New full depth volume..............',1PE14.4,' cubic meters',/, 
     +' New volume / Old volume ratio......',0PF14.4) 
 5341 FORMAT(/, 
     +' ********************',/, 
     +' *  Conduit Volume  *',/, 
     +' ********************',//, 
     +' Input full depth volume............',1PE14.4,' cubic feet') 
 5342 FORMAT(/, 
     +' ********************',/, 
     +' *  Conduit Volume  *',/, 
     +' ********************',//, 
     +' Input full depth volume............',1PE14.4,' cubic meters') 
C 5350 FORMAT(/,'===> WARNING  JUNCTION',I10, 
C     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT.') 
C 5351 FORMAT(/,'===> WARNING  JUNCTION',A10, 
C     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT.') 
 5355 FORMAT(//,'$$$ FOR NATURAL CHANNELS WITH MULTIPLE DEPRESSIONS OR V 
     *ARIABLE MANNINGS N,',/,'    FLOW IS SUM OF FLOWS IN DEPRESSIONS AN 
     *D/OR VARIABLE-N SEGMENTS.',/,'    THIS IS EQUIVALENT TO SUMMING CO 
     *NVEYANCES ACROSS THE CHANNEL. $$$'//) 
 5360 FORMAT(/,1H1,/, 
     +' *****************************************************',/, 
     +' *                  Junction Data                    *',/, 
     +' *****************************************************',//, 
     1' INP  JUNCTION    GROUND    CROWN     INVERT     QINST   INITIAL' 
     +,'     CONNECTING CONDUITS',/, 
     3' NUM    NUMBER     ELEV.     ELEV.     ELEV.       CFS DEPTH(FT)' 
     3,/,' ---    ------   -------   -------    ------   ------- ------' 
     3,'---     -------------------') 
 5361 FORMAT(/,1H1,/, 
     +' *****************************************************',/, 
     +' *                  Junction Data                    *',/, 
     +' *****************************************************',//, 
     1' INP  JUNCTION    GROUND    CROWN     INVERT     QINST   INITIAL' 
     +,'     CONNECTING CONDUITS',/, 
     3' NUM    NUMBER     ELEV.     ELEV.     ELEV.       CMS  DEPTH(M)' 
     3,/,' ---    ------   -------   -------    ------   ------- ------' 
     3,'---   -------------------') 
Cwch, 10/30/01. Change integer field for conduits to I10 from I7 
 5380 FORMAT(I4,I10,F10.2,4F10.2,3X,8(I10,1X)) 
 5381 FORMAT(I4,1X,A10,F9.2,4F10.2,3X,5(A10,1X),/,67X,3(A10,1X)) 
 5382 FORMAT(' ===> Warning all conduits connecting to Junction ',I10, 
     +       ' lie above the Junction invert.') 
 5383 FORMAT(' ===> Warning all conduits connecting to Junction ',A10, 
     +       ' lie above the Junction invert.') 
 5390 FORMAT(/,' ===> ERROR  JUNCTION',I10,' ON CONDUIT',I10, 
     1       ' IS NOT CONTAINED IN JUNCTION DATA') 
 5391 FORMAT(/,' ===> ERROR  JUNCTION',A10,' ON CONDUIT ',A10, 
     1       ' IS NOT CONTAINED IN JUNCTION DATA') 
 5392 FORMAT(' ===> WARNING   THE INVERT OF ', 
     *'CONDUIT ',I10,' LIES ABOVE THE CROWN OF ALL CONDUITS', 
     *' AT JUNCTION ',I10) 
 5393 FORMAT(' ===> WARNING   THE INVERT OF ', 
     *'CONDUIT ',A10,' LIES ABOVE THE CROWN OF ALL CONDUITS', 
     *' AT JUNCTION ',A10) 
 5395 FORMAT(/,' ===> ERROR   CONDUIT',I10,' HAS CAUSED ZCROWN OF', 
     1       ' JUNCTION',I10,' TO LIE ABOVE THE SPECIFIED GROUND ELEV.') 
 5396 FORMAT(/,' ===> ERROR   CONDUIT ',A10,' HAS CAUSED ZCROWN ', 
     1   'OF JUNCTION ',A10,' TO LIE ABOVE THE SPECIFIED GROUND ELEV.') 
 5420 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2, 
     +                                 2X,2(A10,1X),16X,2F7.2) 
 5421 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,2X,2(A10,1X)) 
 5422 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,2X,2(A10,1X), 
     +                                           2F8.2,2F7.2) 
 5423 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,2X, 
     +2(A10,1X),2F8.2) 
 6000 FORMAT(/,' Reading conduit data.') 
 6050 FORMAT(/,' Reading junction data.') 
 6100 FORMAT(/,' Reading remaining simulation data.') 
 6200 FORMAT(/,' ===> Warning  The upstream and downstream junctions', 
     +' for the following conduits',/, 
     +'                 have been reversed to correspond to the', 
     +' positive flow and decreasing',/ 
     +,'                 slope EXTRAN convention.  A negative flow in', 
     +' the output thus means ',/, 
     +'                 the flow was from your original upstream', 
     +' junction to your original',/, 
     +'                 downstream junction.  Any initial flow has', 
     +' been multiplied by -1.',/) 
 6205 FORMAT(13X,I5,'.  Conduit #...',I10,'  has been changed.') 
 6206 FORMAT(13X,I5,'.  Conduit #...',A10,'  has been changed.') 
change  11/97 
 6207 FORMAT(12x,' Conduit #...',I10,' has zero slope.', 
     a'  0.001 feet added to upstream invert.') 
 6208 FORMAT(12x,' Conduit #...',A10,' has zero slope.', 
     a'  0.001 feet added to upstream invert.') 
change 
C  BAC START -- TEMPORARY FORMAT STATEMENTS 
 6335 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',I10,/, 
     a5X,'INPUT N =',F7.4,' ENTK =',F7.4,' EXITK =',F7.4, 
     b' OTHERK =',F7.4,' ADJUSTED N = ',F7.4) 
 6336 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',A10,/, 
     a5X,'INPUT N =',F7.4,' ENTK =',F7.4,' EXITK =',F7.4, 
     b' OTHERK =',F7.4,' ADJUSTED N = ',F7.4) 
 6337 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',I10,/, 
     a5X,'INPUT N =',F7.4,' NEW LENGTH =',F10.2,' ENTK =',F7.4, 
     b' EXITK =',F7.4,' OTHERK =',F7.4,' ADJUSTED N = ',F7.4) 
 6338 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',A10,/, 
     a5X,'INPUT N =',F7.4,' NEW LENGTH =',F10.2,' ENTK =',F7.4, 
     b' EXITK =',F7.4,' OTHERK =',F7.4,' ADJUSTED N = ',F7.4) 
 6400 FORMAT(' LOSSES INCORPORATED INTO MOMENTUM EQUATION FOR CONDUIT ' 
     a,I10,/,' ENTK =',F7.4,' EXITK =',F7.4,' OTHERK =',F7.4) 
 6401 FORMAT(' LOSSES INCORPORATED INTO MOMENTUM EQUATION FOR CONDUIT ' 
     a,A10,/,' ENTK =',F7.4,' EXITK =',F7.4,' OTHERK =',F7.4) 
C  BAC END 
CIM CIM START  <><><><><><><><> 
 7000 FORMAT(' ERROR - CONDUIT TYPE NOT VALID FOR CONDUIT ID = ' 
     A,  I10,' INPUT NKLASS = ',I10) 
 7001 FORMAT(' ERROR - CONDUIT TYPE NOT VALID FOR CONDUIT ID = ' 
     A,  A10,' INPUT NKLASS = ',I10) 
CIM END   <><><><><><><><><><><> 
 7022 FORMAT(10X,'JUNCTION VOLUMES ARE COMPUTED USING SUBROUTINE', 
     1' VOLUME') 
 7024 FORMAT(10X,'JUNCTION VOLUMES ARE COMPUTED BY TRACKING TOTAL', 
     1' VOLUMES DURING THE SIMULATION') 
 7360 FORMAT(/,1H1,/, 
     +' *****************************************************',/, 
     +' *           Additional Junction Data                *',/, 
     +' *****************************************************',//, 
     147X,'BASEFLOW  SURCHARGE',/, 
     2' INP  JUNCTION',34X,'FACTOR   ELEVATION',/, 
     3' NUM    NUMBER',12X,'XLOC',11X,'YLOC     SET',7X,A4,/, 
     4' ---    ------   -------------   ------------  --------', 
     5'  --------') 
 7380 FORMAT(I4,1X,I10,2F15.2,I10,F10.2) 
 7381 FORMAT(I4,1X,A10,2F15.2,I10,F10.2) 
 7365 FORMAT(/,1H1,/, 
     +' *****************************************************',/, 
     +' *           Additional Junction Data                *',/, 
     +' *****************************************************',//, 
     147X,'SURCHARGE',/, 
     2' INP  JUNCTION',33X,'ELEVATION',/, 
     3' NUM    NUMBER',12X,'XLOC',11X,'YLOC',5X,A4,/, 
     4' ---    ------   -------------   ------------  --------') 
 7385 FORMAT(I4,1X,I10,2F15.2,F10.2) 
 7386 FORMAT(I4,1X,A10,2F15.2,F10.2) 
 7387 FORMAT(15X,'WARNING : MAXIMUM SURCHARGE ELEVATION IS LESS', 
     1' THAN GROUND ELEVATION.  PROGRAM WILL RESET TO EQUAL GROUND ', 
     2'ELEVATION') 
C 
 8020 FORMAT(/,5x,'INTERMEDIATE HEADER LINES ARE PRINTED AS IN', 
     a' ORIGINAL PROGRAM') 
 8022 FORMAT(/,5x,'INTERMEDIATE HEADER LINES ARE EXCLUDED FROM', 
     a' JUNCTION AND CONDUIT INPUT AND OUTPUT SUMMARY TABLES') 
 8024 FORMAT(/,5x,'IDS ARE WRITTEN AS IN ORIGINAL PROGRAM ') 
 8026 FORMAT(/,5x,'ALL 10 CHARACTERS AND DIGITS IN IDS ARE', 
     a' WRITTEN THROUGHOUT PROGRAM') 
 8184 FORMAT(/,5x,'JELEV = 0 (DEFAULT). STANDARD INPUTS ARE DEPTHS NOT ' 
     a,'ELEVATIONS') 
 8185 FORMAT(/,5x,'JELEV = 1, ZP1 AND ZP2 ON CONDUIT DATA INPUT LINES', 
     a' ARE READ AS ELEVATIONS IN PLACE OF DEPTHS') 
 8186 FORMAT(/,5x,'JELEV = 2, FOLLOWING DATA ARE READ AS ELEVATIONS ', 
     A'IN PLACE OF DEPTHS',/, 
     A5x,'    -  ZP1 AND ZP2 ON CONDUIT DATA INPUT LINES',/, 
     B5x,'    -  INITIAL WATER SURFACE ELEVATION (YO) ON D1 LINES') 
 8187 FORMAT(/,5x,'JELEV = 3, FOLLOWING DATA ARE READ AS ', 
     A'ELEVATIONS IN PLACE OF DEPTHS',/, 
     A5x,'    -  ZP1 AND ZP2 ON CONDUIT DATA INPUT LINES',/, 
     B5x,'    -  INITIAL WATER SURFACE ELEVATION (YO) ON D1 LINES',/, 
     c5x,'    -  SURFACE AREA / ELEVATION DATA ON E2 LINES') 
 8188 FORMAT(/,5x,'JELEV = 4, DEPTHS ARE READ IN PLACE OF ELEVATIONS ', 
     a'THROUGHOUT PROGRAM INPUT.',/, 
     a5x,'THESE ARE CONVERTED TO DEPTHS IN THE PROGRAM.') 
 8200 FORMAT(' ===> ERROR  THE GROUND ELEVATION OF JUNCTION ',I10, 
     *           ' LIES ABOVE THE JUNCTION INVERT ELEVATION.') 
 8201 FORMAT(' ===> ERROR  THE GROUND ELEVATION OF JUNCTION ',A10, 
     *           ' LIES ABOVE THE JUNCTION INVERT ELEVATION.') 
 8887 FORMAT(/,' ERROR   READING OR WRITING NATURAL CHANNEL', 
     +         ' INFORMATION ON NSCRAT(4).') 
 8999 FORMAT(/,' ERROR   THE NATURAL CHANNEL INFORMATION WAS', 
     +         ' NOT PRESENT ON THE NSCRAT(4) FILE.') 
 9010 FORMAT(/, 
     +' ************************************************************',/, 
     +' *               Flap Gate Conduit Information              *',/, 
     +' *               -----------------------------              *',/, 
     +' * POSITIVE FLAP GATE - FLOW ONLY ALLOWED FROM THE UPSTREAM *',/, 
     +' *                      TO THE DOWNSTREAM JUNCTION          *',/, 
     +' * NEGATIVE FLAP GATE - FLOW ONLY ALLOWED FROM THE          *',/, 
     +' *                      DOWNSTREAM TO THE UPSTREAM JUNCTION *',/, 
     +' ************************************************************',// 
     +,'    Conduit   Type of Flap Gate',/, 
     + '    -------   -----------------') 
 9020 FORMAT(1X,I10,A20) 
 9021 FORMAT(1X,A10,A20) 
 4060 FORMAT(' Flows in conduit will be limited to be greater than ' 
     a,'zero.') 
 4061 FORMAT(' Flows in conduit will be limited to be less than ' 
     a,'zero.') 
 9030 FORMAT(/) 
 9011 FORMAT(//,5x,'WARNING OF POSSIBLE ERROR',/, 
     a5X,'THE FOLLOWING CLOSED CONDUITS HAD NONZERO DATA ENTERED', 
     a' FOR SPHI AND/OR STHETA',/, 
     a5X,'EXTRAN NOW INTERPRETS THESE DATA AS THE MAXIMUM POSITIVE', 
     a' AND/OR NEGATIVE CONDUIT FLOWS AND WILL LIMIT FLOWS IN THESE', 
     a' CONDUITS ACCORDINGLY',/, 
     A5X,'PLEASE MAKE SURE THAT THESE WERE NOT ENTERED BY MISTAKE',//, 
     a5X'MAXIMUM POSITIVE OR NEGATIVE FLOWS IN THE FOLLOWING CONDUITS' 
     b,/,5X, 
     c'WILL BE LIMITED AS SPECIFIED BY SPHI AND STHETA ON C1 LINES' 
     d,//,5X, 
     e'   CONDUIT   FLOW LIMIT',/,1X, 
     f'----------   --------------------') 
 4064 FORMAT(5X,I10, 
     a' Flows will be limited to be less than ',F10.3) 
 4065 FORMAT(5X,I10, 
     a' Flows will be limited to be greater than',F10.3) 
 4074 FORMAT(5X,A10, 
     a' Flows will be limited to be less than ',F10.3) 
 4075 FORMAT(5X,A10, 
     a' Flows will be limited to be greater than',F10.3) 
 4062 FORMAT(11X,' WARNING - Entering negative SPHI to limit flow ', 
     a'may produce unexpected results') 
 4063 FORMAT(11X,' WARNING - Entering positive STHETA to limit flow ', 
     a'may produce unexpected results') 
 9050 FORMAT(/, 
     +       ' With steady-state dry-weather flow computations',/ 
     +       '   Maximum steady-state outflow             =', F10.3, 
     +       ' cfs',/, 
     +       '   Maximum steady-state flow imbalance      =', F10.3/ 
     +       '   Maximum change in flow at any location   =', F10.3, 
     +       ' cfs',/) 
 9051 FORMAT(/, 
     +       ' With steady-state dry-weather flow computations',/ 
     +       '   Maximum steady-state outflow             =', F10.3, 
     +       ' cms',/, 
     +       '   Maximum steady-state flow imbalance      =', F10.3/ 
     +       '   Maximum change in flow at any location   =', F10.3, 
     +       ' cms',/) 
 9060 FORMAT(' Surcharge Computations Use Preissman Slot Method'/) 
 4070 FORMAT(' ERROR - ELLIPTICAL PIPE SIZE (DEEP) ENTERED FOR ', 
     .'CONDUIT ',I10,' IS NOT VALID') 
 4071 FORMAT(' ERROR - ELLIPTICAL PIPE SIZE (DEEP) ENTERED FOR ', 
     .'CONDUIT ',A10,' IS NOT VALID') 
 4072 FORMAT(' ERROR - ARCH PIPE SIZE (DEEP) ENTERED FOR ', 
     .'CONDUIT ',I10,' IS NOT VALID') 
 4073 FORMAT(' ERROR - ARCH PIPE SIZE (DEEP) ENTERED FOR ', 
     .'CONDUIT ',A10,' IS NOT VALID') 
 5137 FORMAT(' ERROR - Detailed ASCII output was requested using a ', 
     a'negative INTER but JOUT is Zero',/, 
     b'         Please set JOUT to nonzero and assign ', 
     b'file name.') 
 5138 FORMAT(' ERROR -  Detailed ASCII outut file is opened', 
     a' as a scratch file',/, 
     a'          Please use @ line to save ASCII results for', 
     b' unit associated with JOUT = ',I10) 
 5139 FORMAT(/,5x,'INTER was entered as a negative number.',/, 
     a'  Intermediate output is written to JOUT in ASCII format') 
 5186 FORMAT(/,5X,'JDOWN = 0 - Minimum of normal or critical depth will' 
     a,' be used at free outfalls (I1).') 
 5187 FORMAT(/,5X,'JDOWN = 1 - Critical depth will be used at free ', 
     a'outfall conduits.') 
 5188 FORMAT(/,5X,'JDOWN = 2 - Normal depth will be used at free ', 
     a'outfall conduits.') 
 5189 FORMAT(/,5X,' The number of RATE/VRATE pairs will be read on', 
     a' H1 lines as defined by IPRATE on BB line.') 
 5190 FORMAT(/,5X,'Characteristic depth for M2 and S2 water ', 
     a'surface profiles will be computed as in previous versions ', 
     b'of EXTRAN (IM2 = 0).') 
 5191 FORMAT(/,5X,'Characteristic depth for M2 and S2 water ', 
     a'surface profiles computed using tabular correction ', 
     b'(IM2 = 1).') 
 5192 FORMAT(/,5X,'SEDIMENT DEPTHS WILL BE READ FROM C1 LINES',/, 
     a5x,'AREA, DEPTH, AND ZP ON CONDUIT DATA PRINTOUT HAVE', 
     b' BEEN ADJUSTED FOR SEDIMENT DEPTH.',/,5X, 
     c'NOTE THAT THIS OPTION HAS BEEN IMPLEMENTED ONLY FOR ', 
     d'CIRCULAR CONDUITS') 
 5193 FORMAT(/,5X,'SEDIMENT DEPTHS WILL NOT BE READ FROM C1 LINES') 
 6666 FORMAT(' Start time for hydraulic output....',F6.1,' hours'/ 
     &       ' Time interval for hydraulic output.',F6.1,' seconds'/) 
 7010 FORMAT(/,5X,'CONDUIT LENGTHS ON C1 LINE MUST EQUAL IRREGULAR', 
     a' SECTION LENGTH ENTERED ON THE C3 OR X1 LINES (IWLEN = 0)') 
 7020 FORMAT(/,5X,'PROGRAM USES IRREGULAR SECTION LENGTHS SPECIFIED', 
     a' ON THE C3 OR X1 LINES (IWLEN = 1)') 
 7030 FORMAT(/,5X,'PROGRAM USES IRREGULAR SECTION LENGTHS SPECIFIED', 
     a' ON THE C1 LINES (IWLEN = 2)') 
 8000 FORMAT(/,5X,'ERRORS WERE FOUND WHERE THE GROUND ELEVATION IS', 
     1' LESS THAT THE PIPE CROWN ELEVATION',/, 
     25X,'GROUND ELEVATIONS 0.01 FEET ABOVE MAXIMUM CROWN ELEVATIONS', 
     3' ARE LISTED IN THE FOLLOWING JUNCTION DATA TABLE',/, 
	45X,'CORRECT GROUND ELEVATION AND RUN AGAIN') 
 8005 FORMAT(/,5X,'Intermediate continuity output will not be created') 
 8010 FORMAT(/,5X,'Intermediate continuity output will be created', 
     a' every ',I5,' time steps.') 
C check for NCHN 9/1999  C. Moore 
 8040 FORMAT(/,5X,'ERROR - TOO MANY CONDUITS ENTERING JUNCTION',I5,' - ' 
     a,I10,/,5X,'MAXIMUM ALLOWED CURRENTLY EQUALS ',I5,/,5X, 
     b'EITHER MODIFY NETWORK OR CHANGE NCHN PARAMETER AND', 
     c' RECOMPILE PROGRAM') 
 8045 FORMAT(/,5X,'ERROR - TOO MANY CONDUITS ENTERING JUNCTION',I5,' - ' 
     a,I10,/,5X,'MAXIMUM ALLOWED CURRENTLY EQUALS ',I5,/,5X, 
     b'EITHER MODIFY NETWORK OR CHANGE NCHN PARAMETER AND', 
     c' RECOMPILE PROGRAM') 
C check for negative ZP  9/1999 C. Moore 
 8050 FORMAT(/,5X,'ERROR - ZP ENTERED FOR ',A10,' END OF CONDUIT ',I10, 
     a' IS LESS THAN INVERT ELEVATION OF JUNCTION ',I10, 
     b/,13X,'PIPE INVERT =     ',F10.3,/,13X,'JUNCTION INVERT = ',F10.3) 
 8055 FORMAT(/,5X,'ERROR - ZP ENTERED FOR ',A10,' END OF CONDUIT ',A10, 
     a' IS LESS THAN INVERT ELEVATION OF JUNCTION ',A10, 
     b/,13X,'PIPE INVERT =     ',F10.3,/,13X,'JUNCTION INVERT = ',F10.3) 
C --- 
C======================================================================= 
      END 
 
REM File: INDAT2.FOR 
 
      SUBROUTINE INDAT2 
C	EXTRAN BLOCK 
C     CALLED BY EXTRAN NEAR LINE 199 
C======================================================================= 
C     This subroutine reads data groups E1-I2 
C     except for hydrograph lines in 'INFLOW'. 
C     IT ALSO PERFORMS SOME INITIALIZATION.   ALL NODE-CONDUIT LINKAGES 
C     ARE SET UP AND CONVERTED TO THE INTERNAL NUMBER SYSTEM. 
C     Additional error message placed by WCH, 8/28/92. 
C     Add error check for minimum values of stage-area data, and correct 
C       power function volume calculation, WCH, 12/8/94. 
C     Add option for printing of detailed storage junction input data, 
C       WCH, 12/8/94. 
C     Alter E1 data error check to avoid conflict between Sub. ERROR and 
C       variable ERROR, WCH, 1/23/95. 
C     Correct check for weir/pump outfall junctions, allowing these to 
C       be used, RED, 3/12/95. 
C     Above correction also for outfalls with gates WCH (RED), 3/16/95. 
C     Increase allowable number of connecting channels to a junction, 
C       WCH, 8/4/95. 
C     Print-out correction, WCH (CIM), 3/27/00. 
C     Revise Format 8011/8012.  WCH, 2/12/01. 
C     Fix sequencing problem of F2 data.  WCH from RED, 7/22/04.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'WEIR.INC' 
      INCLUDE 'BND.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'TIDE.INC' 
      INCLUDE 'HYFLOW.INC' 
      INCLUDE 'VOLDAT.INC' 
CIM BE contains JELEV 
      INCLUDE 'BE.INC' 
cim pp 5/1/97 
CIM      DIMENSION ISWTCH(4) 
CIM 4/30/97 Change to make it less painfull to change program dimensions. 
cim change dimensions of ONAME, WNAME,PNAME,OUTF, and OUTG to the parameter 
cim values defined in TAPES.INC 
      CHARACTER JTYPE(3)*10,ONAME(NEO)*8,WNAME(NEW)*8, 
     +            PNAME(NEP)*8,OUTF(NTG)*8,OUTG(NTG)*8,BMJ*10 
      CHARACTER TMPSTR*8 
CIM START OOOOOOOOOOOO 
      LOGICAL CIRCULAR 
      CHARACTER*10 KCNODE 
      DIMENSION DEEPO(NEO),WIDEO(NEO) 
cim   newklass dimensioned for four basic orifice types: circle side, 
cim   circle bottom, rectangle side, rectangle bottom 
      DIMENSION NEWKLASS(4) 
CIM END  OOOOOOOOOOOO 
      DATA JTYPE/'  CONSTANT','  VARIABLE',' POWER FNC'/ 
C======================================================================= 
CIM initialize string variables 
CIM This will work as long as NEO, NEP, NEW, and NTG are less than 1000. 
cim 
CIM initialize ONAME with dimension of NEO 
      DO I = 1,NEO 
      IF (I.LT.10) THEN 
      WRITE(TMPSTR,'(I1)') I 
      ONAME(I) = 'ORF   #'//TMPSTR 
      ELSE 
      IF (I.LT.100) THEN 
      WRITE(TMPSTR,'(I2)') I 
      ONAME(I) = 'ORF  #'//TMPSTR 
      ELSE 
      WRITE(TMPSTR,'(I3)') I 
      ONAME(I) = 'ORF #'//TMPSTR 
      ENDIF 
      ENDIF 
      ENDDO 
CIM initialize WNAME with dimension of NEW 
      DO I = 1,NEW 
      IF (I.LT.10) THEN 
      WRITE(TMPSTR,'(I1)') I 
      WNAME(I) = 'WEIR  #'//TMPSTR 
      ELSE 
      IF (I.LT.100) THEN 
      WRITE(TMPSTR,'(I2)') I 
      WNAME(I) = 'WEIR #'//TMPSTR 
      ELSE 
      WRITE(TMPSTR,'(I3)') I 
      WNAME(I) = 'WEIR#'//TMPSTR 
      ENDIF 
      ENDIF 
      ENDDO 
CIM initialize PNAME with dimension of NEP 
      DO I = 1,NEP 
      IF (I.LT.10) THEN 
      WRITE(TMPSTR,'(I1)') I 
      PNAME(I) = 'PUMP  #'//TMPSTR 
      ELSE 
      IF (I.LT.100) THEN 
      WRITE(TMPSTR,'(I2)') I 
      PNAME(I) = 'PUMP #'//TMPSTR 
      ELSE 
      WRITE(TMPSTR,'(I3)') I 
      PNAME(I) = 'PUMP#'//TMPSTR 
      ENDIF 
      ENDIF 
      ENDDO 
CIM initialize OUTF with dimension of NTG 
      DO I = 1,NTG 
      IF (I.LT.10) THEN 
      WRITE(TMPSTR,'(I1)') I 
      OUTF(I) = 'FREE  #'//TMPSTR 
      ELSE 
      IF (I.LT.100) THEN 
      WRITE(TMPSTR,'(I2)') I 
      OUTF(I) = 'FREE #'//TMPSTR 
      ELSE 
      WRITE(TMPSTR,'(I3)') I 
      OUTF(I) = 'FREE#'//TMPSTR 
      ENDIF 
      ENDIF 
      ENDDO 
CIM initialize OUTG with dimension of NTG 
      DO I = 1,NTG 
      IF (I.LT.10) THEN 
      WRITE(TMPSTR,'(I1)') I 
      OUTG(I) = 'GATE  #'//TMPSTR 
      ELSE 
      IF (I.LT.100) THEN 
      WRITE(TMPSTR,'(I2)') I 
      OUTG(I) = 'GATE #'//TMPSTR 
      ELSE 
      WRITE(TMPSTR,'(I3)') I 
      OUTG(I) = 'GATE#'//TMPSTR 
      ENDIF 
      ENDIF 
      ENDDO 
CIM END 
C======================================================================= 
C#### WCH, 12/8/94.  READ STRICTLY OPTIONAL E0 LINE TO CONTROL PRINTING 
C     OF VARIABLE STORAGE JUNCTION INPUT DATA. 
C     NVSPR =  0 - DON'T ECHO DETAILED STORAGE JUNCTION INPUT DATA. 
C     NVSPR NE 0 - PRINT DETAILED DATA. 
C======================================================================= 
      NVSPR = 0 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'E0') READ(N5,*,ERR=888) CC,NVSPR 
C======================================================================= 
C     READ STORAGE JUNCTION DATA ON DATA GROUP E1 
C======================================================================= 
cim move this up to here 
          IF(METRIC.EQ.1) QCOEF = 43560.0 
          IF(METRIC.EQ.2) QCOEF = 10000.0 
cim 
      DO 640 I = 1,NVSE 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'E1') GO TO 645 
C======================================================================= 
C#### WCH, 12/8/94.  PRINT STORAGE JUNCTION HEADER FOR DETAILED PRINT. 
C======================================================================= 
      IF(NVSPR.NE.0) THEN 
           WRITE(N6,2999) 
           WRITE(N6,5060) ALPHA1,ALPHA2 
           WRITE(N6,5397) 
           ENDIF 
C======================================================================= 
      IF(JCE.EQ.0) THEN 
                   READ(N5,*,ERR=888) CC,JSTORE(I),ZTOP(I), 
     +                                ASTORE(I),NUMST 
      ELSE 
                   READ(N5,*,ERR=888) CC,KSTORE(I),ZTOP(I), 
     +                                ASTORE(I),NUMST 
      ENDIF 
C======================================================================= 
C     READ VARIABLE STORAGE JUNCTION DATA 
C#### WCH, 1/23/95.  WRITE OUT ERROR 119 HERE.  DON'T CALL SUB. ERROR. 
C======================================================================= 
      IF(ASTORE(I).LT.0.0.AND.NUMST.GT.0) THEN 
C####          IF(NUMST.GT.NVST) CALL ERROR(119) 
          IF(NUMST.GT.NVST) THEN 
               WRITE(N6,9119) 
               STOP ' PROGRAM STOPPED BEFORE E2 LINE DATA IN EXTRAN' 
               ENDIF 
C 
          NUMV(I) = NUMST 
          READ(N5,*,ERR=888) CC 
C#### WCH, 12/7/94.  IF USING GOTO888, HELPFUL TO SET CC = 'E2'. 
C####          IF(CC.NE.'E2') GO TO 888 
          IF(CC.NE.'E2') THEN 
               CC = 'E2' 
               GO TO 888 
               ENDIF 
C 
          BACKSPACE N5 
          READ(N5,*,ERR=888) CC,(VCURVE(I,1,J),VCURVE(I,2,J),J=1,NUMST) 
CIM If JELEV = 3 or 4 then convert elevation to depth here. 
	    IF (JELEV.GE.3) THEN 
CIM FIND CORRESPONDING JUNCTION 
          IF (JCE.EQ.0) THEN 
          DO JUNCIM = 1, NJ 
           IF(JSTORE(I).EQ.JUN(JUNCIM))  GO TO 498 
	    ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	    ELSE 
	    DO JUNCIM = 1,NJ 
          IF(KSTORE(I).EQ.AJUN(JUNCIM)) GO TO 498 
	    ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	    ENDIF 
  498 CONTINUE 
		DO J = 1 , NUMST 
	    VCURVE(I,2,J) = VCURVE(I,2,J) - Z(JUNCIM) 
	    ENDDO 
	    ENDIF 
CIM 
          DO 252 JES = 2,NUMST 
C#### WCH, 12/8/94.  PRINT JUNCTION ID WITH WARNING. 
          IF(VCURVE(I,2,JES-1).GT.VCURVE(I,2,JES)) THEN 
               IF(JCE.EQ.0) THEN 
                  WRITE(N6,998) JSTORE(I), 
     1                    VCURVE(I,2,JES-1),VCURVE(I,2,JES) 
               ELSE 
                  WRITE(N6,999) KSTORE(I), 
     1                    VCURVE(I,2,JES-1),VCURVE(I,2,JES) 
               ENDIF 
          ENDIF 
 252      CONTINUE 
C======================================================================= 
C#### WCH, 12/8/94.  CHECK TO BE SURE MIN. DEPTH = 0 AND MIN. AREA > 0. 
C======================================================================= 
          IF(VCURVE(I,2,1).GT.0.0.OR.VCURVE(I,1,1).LE.0.0) THEN 
               IF(JCE.EQ.0) THEN 
                 WRITE(N6,990) JSTORE(I) 
               ELSE 
                 WRITE(N6,991) KSTORE(I) 
               ENDIF 
               IF(VCURVE(I,2,1).GT.0.0) THEN 
                    WRITE(N6,992) VCURVE(I,2,1) 
                    VCURVE(I,2,1) = 0.0 
                    ENDIF 
               IF(VCURVE(I,1,1).LE.0.0) THEN 
                    WRITE(N6,993) VCURVE(I,1,1) 
cim this correction to avoid mixing units 
cim amen is in square feet 
cim area read in as acres or hectares and coverted below.  Should still be acres or hectares here. 
                    VCURVE(I,1,1) = AMEN/QCOEF 
cim 
                    ENDIF 
               ENDIF 
C======================================================================= 
C         INTEGRATE VOLUME CURVE FROM AREA/STAGE DATA 
C======================================================================= 
          VCURVE(I,3,1)         = 0.0 
cim          IF(METRIC.EQ.1) QCOEF = 43560.0 
cim          IF(METRIC.EQ.2) QCOEF = 10000.0 
          VCURVE(I,1,1) = VCURVE(I,1,1)*QCOEF 
          DO 251      J = 2,NUMST 
          VCURVE(I,1,J) = VCURVE(I,1,J)*QCOEF 
  251     VCURVE(I,3,J) = VCURVE(I,3,J-1)+ 
     +                    (VCURVE(I,2,J)-VCURVE(I,2,J-1))* 
     +                    (VCURVE(I,1,J)+VCURVE(I,1,J-1))/2.0 
C======================================================================= 
C#### WCH, 12/8/94.  OPTIONAL PRINT-OUT OF VARIABLE AREA DATA. 
C======================================================================= 
          IF(NVSPR.NE.0) THEN 
               IF(JCE.EQ.0) THEN 
                 WRITE(N6,890) JSTORE(I) 
               ELSE 
                 WRITE(N6,891) KSTORE(I) 
               ENDIF 
               IF(METRIC.EQ.1) WRITE(N6,892) 
               IF(METRIC.EQ.2) WRITE(N6,893) 
               WRITE(N6,894) (K,VCURVE(I,2,K),VCURVE(I,1,K)/QCOEF, 
     1                   VCURVE(I,3,K)/1000.0,K=1,NUMST) 
               ENDIF 
C======================================================================= 
          ENDIF 
C======================================================================= 
C     READ VARIABLE STORAGE JUNCTION DATA DEFINED AS A POWER FUNCTION 
C     VCURVE(I,1,1) = COEFFICIENT 
C     VCURVE(I,2,1) = POWER 
C======================================================================= 
      IF(NUMST.LT.0) THEN 
                      NUMV(I)   =   NUMST 
                      ASTORE(I) = -1234.0 
                      READ(N5,*,ERR=888) CC 
                      IF(CC.NE.'E2') GO TO 888 
                      BACKSPACE N5 
                      READ(N5,*,ERR=888) CC,VCURVE(I,1,1),VCURVE(I,2,1) 
C======================================================================= 
C#### WCH, 12/8/94.  OPTIONAL PRINT-OUT OF INPUT DATA. 
C======================================================================= 
                      IF(NVSPR.NE.0) THEN 
                           IF(JCE.EQ.0) THEN 
                             WRITE(N6,895) JSTORE(I), 
     1                       VCURVE(I,1,1),VCURVE(I,2,1) 
                           ELSE 
                             WRITE(N6,896) KSTORE(I), 
     1                       VCURVE(I,1,1),VCURVE(I,2,1) 
                           ENDIF 
                      ENDIF 
C 
                      ENDIF 
  640 CONTINUE 
  645 NSTORE = I-1 
C======================================================================= 
C     WRITE THE PAGE TITLES 
C======================================================================= 
      IF(NSTORE.GT.0) THEN 
                      WRITE(N6,2999) 
                      WRITE(N6,5060) ALPHA1,ALPHA2 
                      WRITE(N6,5398) 
      IF(METRIC.EQ.1) WRITE(N6,5495) 
      IF(METRIC.EQ.2) WRITE(N6,5496) 
C======================================================================= 
C     CONVERT TO INTERNAL NUMBER SYSTEM 
C======================================================================= 
      DO 646 I = 1,NSTORE 
      DO 648 J = 1,NJ 
      IF(JCE.EQ.0.AND.JSTORE(I).EQ.JUN(J))  GO TO 650 
      IF(JCE.EQ.1.AND.KSTORE(I).EQ.AJUN(J)) GO TO 650 
  648 CONTINUE 
      IF(JCE.EQ.0) THEN 
       WRITE(N6,5494) JSTORE(I) 
      ELSE 
       WRITE(N6,5484) KSTORE(I) 
      ENDIF 
      NSTOP     = NSTOP + 1 
  650 JSTORE(I) = J 
      JSKIP(J)  = 0 
cim  zcrown is used to define when things go into surcharge 
cim  I don't think that it is ever used to reduce surface area 
cim  for constant surface area storage nodes.  ZCROWN is set 
cim  to the crown elevation of the highest pipe in INDAT1.  If 
cim  ZTOP is less than ZCROWN defined previously, don't let it 
cim  reduce it below the highest pipe to avoid going to surcharge 
cim  calculations too soon. 
cim      ZCROWN(J) = ZTOP(I) 
      IF (ZTOP(I).GE.ZCROWN(J)) THEN 
         ZCROWN(J) = ZTOP(I) 
      ELSE 
         IF(JCE.EQ.0) THEN 
            WRITE(N6,8005) JSTORE(I),ZTOP(I),ZCROWN(J) 
            ELSE 
            WRITE(N6,8006) KSTORE(I),ZTOP(I),ZCROWN(J) 
            ENDIF 
         ZTOP(I) = ZCROWN(J) 
      ENDIF 
      JJ        = NUMV(I) 
      IF(ZCROWN(J).GT.GRELEV(J)) THEN 
	   WRITE(N6,7005) 
	       GRELEV(J) = ZCROWN(J) + 0.1 
	IF (GRELEV(J).GT.SURELEV(J)) THEN 
	   WRITE(N6,7010) 
	       SURELEV(J) = GRELEV(J) 
	ENDIF 
	ENDIF 
      IF(ASTORE(I).GT.0) THEN 
                         CF  = ASTORE(I)*(ZTOP(I)-Z(J)) 
                         AF  = ASTORE(I) 
                         JJJ = 1 
                         ENDIF 
      IF(ASTORE(I).LT.0.AND.JJ.GT.0) THEN 
                                     CF  = VCURVE(I,3,JJ) 
                                     AF  = VCURVE(I,1,JJ) 
                                     JJJ = 2 
                                     ENDIF 
      IF(ASTORE(I).LT.0.AND.JJ.LT.0) THEN 
                                     AF  = VCURVE(I,1,1) * 
     +                                (ZTOP(I)-Z(J))**VCURVE(I,2,1) 
C#### WCH, 12/8/94.  MUST >>INTEGRATE<< POWER FUNCTION TO GET VOLUME 
C     ALSO, USE MINIMUM AREA = AMEN. 
C####                                     CF  = AF*(ZTOP(I) - Z(J)) 
                                     CF = AMEN*(ZTOP(I)-Z(J)) 
                                     CF = CF + VCURVE(I,1,1) * 
     +             (ZTOP(I)-Z(J))**(VCURVE(I,2,1)+1)/(VCURVE(I,2,1)+1) 
                                     JJJ = 3 
                                     ENDIF 
      LSTORE  = JSTORE(I) 
      IF(JCE.EQ.0) THEN 
       WRITE(N6,5399)  JUN(LSTORE),JTYPE(JJJ),AF,CF,ZTOP(I) 
      ELSE 
       WRITE(N6,5499) AJUN(LSTORE),JTYPE(JJJ),AF,CF,ZTOP(I) 
      ENDIF 
  646 CONTINUE 
      NTL = NTL + NSTORE 
      ENDIF 
C======================================================================= 
C     INITIALIZE NTC AND NTL 
C======================================================================= 
      NTC  = NC 
      NTL  = NC 
      NVOR = 0 
CIM START   OOOOOOOOOO 
      NOGATES = 0 
CIM END  OOOOOOOOOOO 
C======================================================================= 
C     Read orifice data on data group F1. 
C======================================================================= 
cim start  <><><><><><><><><><> 
C     NKLASS(N) = 1, NEWKLASS(1) = 51 - SIDE OUTLET CIRCULAR ORIFICE 
C     NKLASS(N) = 2, NEWKLASS(2) = 52 - BOTTOM OUTLET (SUMP) CIRCULAR ORIFICE 
CIM START OOOOOOOOO 
CIM   NKLASS(N) = 3, NEWKLASS(3) = 53 - SIDE OUTLET RECTANGULAR ORIFICE 
CIM   NKLASS(N) = 4, NEWKLASS(4) = 54 - BOTTOM OUTLET (SUMP) RECTANGULAR ORIFICE 
CIM  END  OOOOOOOO 
      NEWKLASS(1) = 51 
      NEWKLASS(2) = 52 
CIM START  OOOOOOOOO 
      NEWKLASS(3) = 53 
      NEWKLASS(4) = 54 
CIM END  OOOOOOOOO 
cim end      <><><><><><><><> 
C======================================================================= 
C======================================================================= 
      DO 690 I = 1,NEO 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'F1') GO TO 695 
      N = NTC+I 
      IF(JCE.EQ.0) THEN 
          READ(N5,*,ERR=888) CC,(NJUNC(N,K),K=1,2), 
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N) 
          ELSE 
          READ(N5,*,ERR=888) CC,(KJUNC(N,K),K=1,2), 
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N) 
          ENDIF 
CIM START  OOOOOOOOO 
C  MODIFICATION TO READ DEEPO AND WIDEO FOR RECTANGULAR ORIFICE 
      CIRCULAR = .TRUE. 
      IF ((NKLASS(N).EQ.3) .OR. 
     .   (NKLASS(N).EQ.4) .OR. 
     .   (NKLASS(N).EQ.-3) .OR. 
     .   (NKLASS(N).EQ.-4) .OR. 
     .   (NKLASS(N).EQ.13) .OR. 
     .   (NKLASS(N).EQ.14) .OR. 
     .   (NKLASS(N).EQ.23) .OR. 
     .   (NKLASS(N).EQ.24)) THEN 
            CIRCULAR = .FALSE. 
            BACKSPACE N5 
            IF(JCE.EQ.0) THEN 
                   READ(N5,*,ERR=888) CC,(NJUNC(N,K),K=1,2), 
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N), 
     A                       DEEPO(I),WIDEO(I) 
                  ELSE 
                   READ(N5,*,ERR=888) CC,(KJUNC(N,K),K=1,2), 
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N), 
     A                       DEEPO(I),WIDEO(I) 
                  ENDIF 
	      IF (AORIF(I).EQ.0.0) AORIF(I) = DEEPO(I)*WIDEO(I) 
            ENDIF 
CIM change this next one to key on CORIF 
CIM   IF CORIF < 0 then gate closes from the bottom meaning that the 
CIM   ZU and ZP change as gate opening changes. 
      IF (CORIF(I).LT.0.0) then 
           CORIF(I) = - CORIF(I) 
           IOINV(I) = 1 
           ELSE 
           IOINV(I) = 0 
           ENDIF 
CIM END  OOOOOOOOOO 
CIM CHANGE FOR JELEV = 4.  ZU is elevation not depth 
	IF (JELEV.EQ.4) THEN 
CIM FIND UPSTREAM OR FROM JUNCTION INVERT ELEVATION 
           IF (JCE.EQ.0) THEN 
                DO JUNCIM = 1, NJ 
                 IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 678 
	          ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	          ELSE 
	          DO JUNCIM = 1,NJ 
                IF(KJUNC(N,1).EQ.AJUN(JUNCIM)) GO TO 678 
	          ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	          ENDIF 
  678      CONTINUE 
	     ZU(N) = ZU(N) - Z(JUNCIM) 
	     ENDIF 
CIM INSERT CHECK FOR NEGATIVE ZU 
	IF (ZU(N).LT.0.0) THEN 
	     WRITE(N6,5442) I 
	     NSTOP = NSTOP + 1 
	     ENDIF 
C======================================================================= 
C     READ F2 DATA GROUP FOR ORIFICES WITH A TIME HISTORY 
C======================================================================= 
      IF(NKLASS(N).LT.0) THEN 
                         NVOR      = NVOR + 1 
                         NKLASS(N) = IABS(NKLASS(N)) 
                         READ(N5,*,ERR=888) CC,NTIME,(VORIF(NVOR,J,1), 
     +                     VORIF(NVOR,J,2),VORIF(NVOR,J,3),J=1,NTIME) 
cred                     need place holder for the F2 line orifices 
cred                     otherwise they have to be at the top of the 
cred                     order of orifices - 4/15/2002 
Cwch, 7/22/04.  These variables show up again in INFLOW.  
	                   f2_line(nvor)  = i 
	                   f2_limit(nvor) = ntime                 
					   ENDIF 
CIM START  OOOOOOOO 
CIM======================================================================= 
CIM      READ F3 DATA GROUP FOR ORIFICES WITH TIMED CLOSURE GATE CONTROL 
CIM======================================================================= 
      IF((NKLASS(N).GT.10).AND.NKLASS(N).LT.20) THEN 
           NOGATES=NOGATES+1 
           NKLASS(N) = NKLASS(N)-10 
           IF(JCE.EQ.0) THEN 
                READ(N5,*,ERR=888) CC,ICNODE(I),OOPEN(I),OCLOSE(I), 
     .                                OCAREA(I),ORATE(I),IDIR(I), 
     .                                IOPRNT(I) 
                ELSE 
                READ(N5,*,ERR=888) CC,KCNODE,OOPEN(I),OCLOSE(I), 
     .                                OCAREA(I),ORATE(I),IDIR(I), 
     .                                IOPRNT(I) 
                ENDIF 
CIM   IF JELEV IS 4 THEN CONVERT OOPEN AND OCLOSE FROM ELEVATIONS TO DEPTHS HERE 
           IF (JELEV.EQ.4) THEN 
CIM FIND CONTROL JUNCTION INVERT ELEVATION 
                IF (JCE.EQ.0) THEN 
                     DO JUNCIM = 1, NJ 
                      IF(ICNODE(I).EQ.JUN(JUNCIM))  GO TO 679 
	               ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	               ELSE 
	               DO JUNCIM = 1,NJ 
                      IF(KCNODE.EQ.AJUN(JUNCIM)) GO TO 679 
	               ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	               ENDIF 
  679           CONTINUE 
	          OOPEN(I) = OOPEN(I) - Z(JUNCIM) 
	          OCLOSE(I) = OCLOSE(I) - Z(JUNCIM) 
	          ENDIF 
CIM ADD A CHECK FOR NEGATIVE OOPEN AND OOCLOSE 
	     IF ((OOPEN(I).LT.0.0) .OR. (OCLOSE(I).LT.0.0)) THEN 
	          WRITE(N6,5443) I 
	          NSTOP = NSTOP + 1 
	          ENDIF 
CIM  ECHO PRINT OF TIMED CLOSURE GATED CONTROL HERE 
           IF(JCE.EQ.0) THEN 
                WRITE(N6,660) I,ICNODE(I),OOPEN(I),OCLOSE(I), 
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I) 
                ELSE 
                WRITE(N6,661) I,KCNODE,OOPEN(I),OCLOSE(I), 
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I) 
                ENDIF 
           DO 680 J = 1,NJ 
           IF(JCE.EQ.0.AND.ICNODE(I).EQ.JUN(J))  GO TO 681 
           IF(JCE.EQ.1.AND.KCNODE.EQ.AJUN(J)) GO TO 681 
  680      CONTINUE 
           IF(JCE.EQ.0) THEN 
                WRITE(N6,5445) ICNODE(I) 
                ELSE 
                WRITE(N6,5446) KCNODE 
                ENDIF 
           NSTOP      = NSTOP+1 
CIM   NOTE THAT TIMED CLOSURE GATED CONTROL ORIFICES HAVE NEGATIVE ICNODE 
  681      ICNODE(I) = -J 
           END IF 
CIM======================================================================= 
CIM      READ F4 DATA GROUP FOR ORIFICES WITH HEAD DEPENDENT GATE CONTROL 
CIM======================================================================= 
      IF (NKLASS(N).GT.20) THEN 
           NOGATES=NOGATES+1 
           NKLASS(N) = NKLASS(N)-20 
           IF(JCE.EQ.0) THEN 
                 READ(N5,*,ERR=888) CC,ICNODE(I),OOPEN(I),OCLOSE(I), 
     .                                OCAREA(I),ORATE(I),IDIR(I), 
     .                                IOPRNT(I) 
                 ELSE 
                 READ(N5,*,ERR=888) CC,KCNODE,OOPEN(I),OCLOSE(I), 
     .                                OCAREA(I),ORATE(I),IDIR(I), 
     .                                IOPRNT(I) 
                 ENDIF 
CIM   IF JELEV IS 4 THEN CONVERT OOPEN AND OCLOSE FROM ELEVATIONS TO DEPTHS HERE 
           IF (JELEV.EQ.4) THEN 
CIM FIND CONTROL JUNCTION INVERT ELEVATION 
                IF (JCE.EQ.0) THEN 
                     DO JUNCIM = 1, NJ 
                      IF(ICNODE(I).EQ.JUN(JUNCIM))  GO TO 684 
	               ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	               ELSE 
	               DO JUNCIM = 1,NJ 
                      IF(KCNODE.EQ.AJUN(JUNCIM)) GO TO 684 
	               ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	               ENDIF 
  684           CONTINUE 
	          OOPEN(I) = OOPEN(I) - Z(JUNCIM) 
	          OCLOSE(I) = OCLOSE(I) - Z(JUNCIM) 
	          ENDIF 
CIM ADD A CHECK FOR NEGATIVE OOPEN AND OOCLOSE 
	     IF ((OOPEN(I).LT.0.0) .OR. (OCLOSE(I).LT.0.0)) THEN 
	          WRITE(N6,5443) I 
	          NSTOP = NSTOP + 1 
	          ENDIF 
           IF(OOPEN(I).EQ.OCLOSE(I)) THEN 
      WRITE(N5,*) ' ERROR - OPEN AND CLOSE DEPTHS CAN NOT BE EQUAL ', 
     .'FOR HEAD DEPENDENT GATES (F4 CARD)' 
                NSTOP = NSTOP + 1 
                END IF 
CIM ECHO PRINT OF INPUT DATA FOR HEAD DEPENDENT GATED CONTROL HERE 
           IF(JCE.EQ.0) THEN 
                 WRITE(N6,662) I,ICNODE(I),OOPEN(I),OCLOSE(I), 
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I) 
                 ELSE 
                 WRITE(N6,663) I,KCNODE,OOPEN(I),OCLOSE(I), 
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I) 
                 ENDIF 
           DO 685 J = 1,NJ 
           IF(JCE.EQ.0.AND.ICNODE(I).EQ.JUN(J))  GO TO 686 
           IF(JCE.EQ.1.AND.KCNODE.EQ.AJUN(J)) GO TO 686 
  685      CONTINUE 
           IF(JCE.EQ.0) THEN 
                WRITE(N6,5445) ICNODE(I) 
                ELSE 
                WRITE(N6,5446) KCNODE 
                ENDIF 
           NSTOP      = NSTOP+1 
  686      ICNODE(I) = J 
           END IF 
      IF (OCAREA(I).LT.0.00001) OCAREA(I)=0.00001 
      IF (AORIF(I).LT.0.00001)  AORIF(I) =0.00001 
CIM CONVERT RATE TO DELTA AREA PER UNIT TIME (SQ.FT./SECOND) 
      IF (ORATE(I).GT.0.0) THEN 
          ORATE(I)=ABS(AORIF(I)-OCAREA(I))/(ORATE(I)*60.0*60.0) 
          ELSE 
          ORATE(I)=999999999.99 
          ENDIF 
CIM   CHANGE IDIR TO MATCH DEFINITION OF INGATE 
      IF (IDIR(I).EQ.0) ITEMP=0 
      IF (IDIR(I).LT.0) ITEMP=2 
      IF (IDIR(I).GT.0) ITEMP=1 
      IDIR(I)=ITEMP 
CIM END      OOOOOOOOOO 
  690 CONTINUE 
  695 NORIF = I-1 
CIM START     OOOOOOOOO 
CIM   OPEN FILE FOR TEST PRINTOUT 
cim      IF (NOGATES.GT.0) OPEN(UNIT=7,FILE='TEST.OUT',STATUS='UNKNOWN') 
CIM END  OOOOOOOOOOOO 
      NTC   = NTC + NORIF 
      NTL   = NTL + NORIF 
      IF(NORIF.GT.0) THEN 
           IF(METRIC.EQ.1) WRITE(N6,5420) 
           IF(METRIC.EQ.2) WRITE(N6,5421) 
           DO 780 I = 1,NORIF 
           N        = NTC - NORIF + I 
CIM START  OOOOOOOOOO 
           CIRCULAR = ((NKLASS(N).EQ.1) .OR. 
     .   (NKLASS(N).EQ.2) .OR. 
     .   (NKLASS(N).EQ.-1) .OR. 
     .   (NKLASS(N).EQ.-2) .OR. 
     .   (NKLASS(N).EQ.11) .OR. 
     .   (NKLASS(N).EQ.12) .OR. 
     .   (NKLASS(N).EQ.21) .OR. 
     .   (NKLASS(N).EQ.22)) 
           IF (CIRCULAR) then 
                IF(JCE.EQ.0) THEN 
                   WRITE(N6,5440) (NJUNC(N,K),K=1,2),NKLASS(N), 
     +                             AORIF(I),CORIF(I),ZU(N) 
                   ELSE 
                   WRITE(N6,5441) (KJUNC(N,K),K=1,2),NKLASS(N), 
     +                             AORIF(I),CORIF(I),ZU(N) 
                   ENDIF 
           ELSE 
           AORIF(I) = WIDEO(I)*DEEPO(I) 
           IF(JCE.EQ.0) THEN 
                WRITE(N6,5440) (NJUNC(N,K),K=1,2),NKLASS(N), 
     +                             AORIF(I),CORIF(I),ZU(N), 
     A                             DEEPO(I),WIDEO(I) 
                ELSE 
                WRITE(N6,5441) (KJUNC(N,K),K=1,2),NKLASS(N), 
     +                             AORIF(I),CORIF(I),ZU(N), 
     A                             DEEPO(I),WIDEO(I) 
                ENDIF 
           ENDIF 
CIM END  OOOOOOOOOOOO 
C======================================================================= 
C     Convert to internal number system. 
C======================================================================= 
      LORIF(I) = N 
      NCOND(N) = N + 90000 
      IF(JCE.EQ.1) ACOND(N) = ONAME(I) 
CIM START  OOOOOOOOOO 
      IF (CIRCULAR) THEN 
           DEEP(N)  = SQRT(4.0*AORIF(I)/3.14159) 
           WIDE(N)  = DEEP(N) 
           AFULL(N) = AORIF(I) 
           RFULL(N) = DEEP(N)/4.0 
           ELSE 
           DEEP(N)  = DEEPO(I) 
           WIDE(N)  = WIDEO(I) 
           AFULL(N) = AORIF(I) 
           RFULL(N) = AFULL(N)/(2.0*DEEPO(I)+2.0*WIDEO(I)) 
           ENDIF 
CIM END      OOOOOOOOOOO 
      DDD = DELT 
C BAC START  
C NOTE CHANGE IN DEFINITION OF NEQUAL 
C      IF(NEQUAL.GT.1) DDD = FLOAT(NEQUAL) 
C BAC END   
      CLEN     = 2.0*DDD*SQRT(GRVT*DEEP(N)) 
      LEN(N)   = AMAX1(200.,CLEN) 
      CMANN    = CMET(9,METRIC) 
      ROUGH(N) = CMANN*RFULL(N)**.66667/(CORIF(I)*SQRT(LEN(N)*2.0*GRVT)) 
CIM START  <><><><><> 
cim            Revise nklass to internal number here  FIRST CHECK FOR VALID 
CIM            RANGE 
      IF (NKLASS(N).LT.1.OR.NKLASS(N).GT.4) THEN 
           IF(JCE.EQ.0) THEN 
                WRITE(N6,7000) (NJUNC(N,K),K=1,2),NKLASS(N) 
                ELSE 
                WRITE(N6,7001) (KJUNC(N,K),K=1,2),NKLASS(N) 
                ENDIF 
           STOP 'ORIFICE TYPE NOT VALID' 
           END IF 
      NKLASS(N)= NEWKLASS(NKLASS(N)) 
CIM END <><><><><><> 
CIM START OOOOOOOO 
CIM    BOTTOM OUTLET CONVERSION 
      IF((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) THEN 
           ZU(N) = -0.96*DEEP(N) 
CIM     INVERT ELEVATIONS FOR BOTTOM OUTLET WON'T CHANGE 
           IOINV(I) = 0 
           ENDIF 
CIM END     OOOOOOOOO 
      DO 770 K = 1,2 
      DO 700 J = 1,NJ 
      IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J))  GO TO 720 
      IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J)) GO TO 720 
  700 CONTINUE 
      IF(JCE.EQ.0) THEN 
           WRITE(N6,5450) NJUNC(N,K) 
           ELSE 
           WRITE(N6,5451) KJUNC(N,K) 
           ENDIF 
      NSTOP      = NSTOP+1 
  720 NJUNC(N,K) = J 
      IF(JSKIP(J).EQ.1) THEN 
                        JSKIP(J)   = 0 
                        IF(ZCROWN(J).LT.DEEP(N)) ZCROWN(J) = DEEP(N) 
                        ENDIF 
C======================================================================= 
C     SET ZU(N) FOR BOTTOM OUTLET 
C     SET ZU(N) AND ZD(N) ELEVATIONS 
C     LOWER Z(J) AT UPSTREAM END BY -0.96*DEEP(N) 
C======================================================================= 
      IF(K.EQ.1) THEN 
                 ZU(N) = ZU(N) + Z(J) 
                 ZD(N) = ZU(N) - 0.01/CMET(1,METRIC) 
CIM START  OOOOOOO 
CIM       BOTTOM OUTLET CONVERSION 
                 IF((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) THEN 
CIM END          OOOOOOOO 
                              IF(Y(J).GT.0.0) Y(J) = Y(J) + 0.96*DEEP(N) 
                              Z(J) = ZU(N) 
                         IF(JCE.EQ.0) THEN 
                          WRITE(N6,8011)  JUN(J),Z(J) 
                         ELSE 
                          WRITE(N6,8012) AJUN(J),Z(J) 
                         ENDIF 
                              ENDIF 
                 ENDIF 
C======================================================================= 
C     CHECK GROUND ELEVATION 
C======================================================================= 
      IF(ZU(N)+DEEP(N).GE.GRELEV(J)) THEN 
                                     IF(JCE.EQ.0) THEN 
                                      WRITE(N6,5455) JUN(J) 
                                     ELSE 
                                      WRITE(N6,5456)AJUN(J) 
                                     ENDIF 
                                     NSTOP = NSTOP+1 
                                     ENDIF 
      IF(ZD(N)+DEEP(N).GE.GRELEV(J)) THEN 
                                     IF(JCE.EQ.0) THEN 
                                      WRITE(N6,5455) JUN(J) 
                                     ELSE 
                                      WRITE(N6,5456)AJUN(J) 
                                     ENDIF 
                                     NSTOP = NSTOP+1 
                                     ENDIF 
  730 CONTINUE 
C#### WCH, 8/4/95.  INCREASE NUMBER OF CONNECTING CHANNELS. 
      DO 740 KK = 1,NCHN 
      IF(NCHAN(J,KK)) 760,760,740 
  740 CONTINUE 
      IF (NCHAN(J,KK).NE.0) THEN 
                     IF (JCE.EQ.0) THEN 
                       WRITE(n6,8330) JUN(J) 
                       ELSE 
                       WRITE(n6,8331) AJUN(J) 
                       ENDIF 
                     NSTOP = NSTOP + 1 
      ENDIF 
  760 NCHAN(J,KK) = N 
  770 CONTINUE 
C======================================================================= 
C     CHECK GRAVITY FLOW DIRECTION 
C======================================================================= 
      IF(ZU(N).LT.ZD(N)) THEN 
                         J2    = NJUNC(N,2) 
                         IF(JCE.EQ.0) THEN 
                          WRITE(N6,5458)  JUN(J2) 
                         ELSE 
                          WRITE(N6,5459) AJUN(J2) 
                         ENDIF 
                         NSTOP = NSTOP+1 
                         ENDIF 
  780 CONTINUE 
      DO 790 I = 1,NORIF 
      N        = LORIF(I) 
CIM START OOOOOO 
      CIRCULAR = ((NKLASS(N).EQ.51).OR.(NKLASS(N).EQ.52)) 
      IF (CIRCULAR) THEN 
      IF(JCE.EQ.0) THEN 
        WRITE(N6,6010) I,NCOND(N),DEEP(N),LEN(N), 
     +                            ROUGH(N),ZU(N),ZD(N) 
      ELSE 
        WRITE(N6,6011) I,ACOND(N),DEEP(N),LEN(N), 
     +                            ROUGH(N),ZU(N),ZD(N) 
      ENDIF 
      ELSE 
      IF(JCE.EQ.0) THEN 
        WRITE(N6,6012) I,NCOND(N),DEEP(N),WIDE(N),LEN(N), 
     +                            ROUGH(N),ZU(N),ZD(N) 
      ELSE 
        WRITE(N6,6013) I,ACOND(N),DEEP(N),WIDE(N),LEN(N), 
     +                            ROUGH(N),ZU(N),ZD(N) 
      ENDIF 
      END IF 
cim change ioninv(N) to IOINV(I) 
      IF (IOINV(I).EQ.1) WRITE(N6,6014) 
CIM END OOOOOOO 
  790 CONTINUE 
      ENDIF 
C======================================================================= 
C     READ WEIR DATA ON DATA GROUP G1. 
C     THIS ROUTINE HAS BEEN MODIFIED TO TRANSFER WEIR DISCHARGES FROM 
C     NODE TO NODE RATHER THAN FROM NODE TO CONDUIT. 
C======================================================================= 
      DO 820 I = 1,NEW 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'G1') GO TO 840 
      N = NTC+I 
C  BAC START  WWWWWWWWWWWWWWW 
C  READ NEW INPUTS FOR ADDITIONAL WEIR OPTIONS 
CIM 
CIM     KWEIR       : Type of weir. 
CIM                 = 1 Transverse horizontal weir (exponent = 3/2). 
CIM                 = 2 Transverse horizontal weir with tide gate. 
CIM                 = 3 Side flow horizontal weir (exponent = 5/3). 
CIM                 = 4 Side flow horizontal weir with tide gate. 
CIM                 = 5 V-notch or triangular (exponent = 5/2). 
CIM                 = 6 V-notch or triangular with tide gate. 
CIM                 = 7 Trapezoidal (compound exponent) 
CIM                 = 8 Trapezoidal with tide gate. 
C  SINCE THE LINE GROUP AND THE NUMBER OF INPUT FIELDS ON THE LINE 
C  GROUP THAT FOLLOWS THE WEIR LINES VARIES, READS MUST BE MADE IN 
C  TWO PARTS. 
C  IWRPRT IS USED FOR TELLING THE PROGRAM WHICH WRITE STATEMENT TO USE 
C  FOR THE INPUT ECHO OF THE WEIRS. 
      ISUBEQ(I)=0 
      ENDCON(I)=0.0 
      IWRPRT(I)=0 
      COEF2(I)=0.0 
      IF(JCE.EQ.0) THEN 
                   READ(N5,*,ERR=888) CC,(NJUNC(N,K),K=1,2),KWEIR(I), 
     +                             YCREST(I),YTOP(I),WLEN(I),COEF(I), 
     +                             ISUBEQ(I),ENDCON(I),THETAV(I), 
     +                             COEF2(I) 
      ELSE 
                   READ(N5,*,ERR=888) CC,(KJUNC(N,K),K=1,2),KWEIR(I), 
     +                             YCREST(I),YTOP(I),WLEN(I),COEF(I), 
     +                             ISUBEQ(I),ENDCON(I),THETAV(I), 
     +                             COEF2(I) 
      ENDIF 
Cwch, CIM, 3/27/00. SHOULD BE .NE. NOT .EQ. 
      IF(ENDCON(I)+THETAV(I)+COEF2(I).NE.0.0) IWRPRT(I)=1 
CIM   IF JELEV IS 4 THEN CONVERT OOPEN AND OCLOSE FROM ELEVATIONS TO 
C     DEPTHS HERE 
      IF (JELEV.EQ.4) THEN 
CIM FIND UPSTREAM JUNCTION INVERT ELEVATION 
          IF (JCE.EQ.0) THEN 
          DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 819 
	    ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	    ELSE 
	    DO JUNCIM = 1,NJ 
          IF(KJUNC(N,1).EQ.AJUN(JUNCIM)) GO TO 819 
	    ENDDO 
CIM SAVE CHECK FOR NO MATCH FOR LATER 
	    ENDIF 
  819 CONTINUE 
	YCREST(I) = YCREST(I) - Z(JUNCIM) 
	YTOP(I) = YTOP(I) - Z(JUNCIM) 
	ENDIF 
CIM ADD A CHECK FOR NEGATIVE YTOP OR YCREST 
	IF ((YCREST(I).LT.0.0) .OR. (YTOP(I).LT.0.0)) THEN 
	WRITE(N6,5444) I 
	NSTOP = NSTOP + 1 
	ENDIF 
C  BAC END  WWWWWWWWWWW 
  820 CONTINUE 
  840 NWEIR = I-1 
      IF(NWEIR.GT.0) THEN 
                     IF(METRIC.EQ.1) WRITE(N6,5480) 
                     IF(METRIC.EQ.2) WRITE(N6,5481) 
                     DO 1020 I = 1,NWEIR 
                     N1        = NTC+I 
                     LWEIR(I)  = N1 
                     IF(JCE.EQ.0) THEN 
                       NCOND(N1) = 90000 + N1 
                     ELSE 
                       ACOND(N1) = WNAME(I) 
                     ENDIF 
                     COEFS(I)  = 0.0 
C  BAC START  WWWWWWW 
      IF(JCE.EQ.0) THEN 
               IF(IWRPRT(I).EQ.0) THEN 
                                  WRITE(N6,5487) 
     +                            (NJUNC(N1,K),K=1,2), 
     +                            NCOND(N1),KWEIR(I),YCREST(I), 
     +                            YTOP(I),WLEN(I),COEF(I) 
               ELSE 
                                  WRITE(N6,5485) 
     +                            (NJUNC(N1,K),K=1,2), 
     +                            NCOND(N1),KWEIR(I),YCREST(I), 
     +                            YTOP(I),WLEN(I),COEF(I),ISUBEQ(I), 
     +                            ENDCON(I),THETAV(I),COEF2(I) 
               ENDIF 
      ELSE 
               IF(IWRPRT(I).EQ.0) THEN 
                                  WRITE(N6,5488) 
     +                            (KJUNC(N1,K),K=1,2), 
     +                            ACOND(N1),KWEIR(I),YCREST(I), 
     +                            YTOP(I),WLEN(I),COEF(I) 
               ELSE 
                                  WRITE(N6,5486) 
     +                            (KJUNC(N1,K),K=1,2), 
     +                            ACOND(N1),KWEIR(I),YCREST(I), 
     +                            YTOP(I),WLEN(I),COEF(I),ISUBEQ(I), 
     +                            ENDCON(I),THETAV(I),COEF2(I) 
               ENDIF 
      ENDIF 
C  BAC END  WWWWWW 
                     DO 875 K = 1,2 
                     IF(JCE.EQ.0.AND.NJUNC(N1,K).EQ.0)   GO TO 875 
                     IF(JCE.EQ.1.AND.KJUNC(N1,K).EQ.' ') GO TO 875 
                     DO 870 J = 1,NJ 
                     IF(JCE.EQ.0.AND.NJUNC(N1,K).EQ.JUN(J))  GO TO 871 
                     IF(JCE.EQ.1.AND.KJUNC(N1,K).EQ.AJUN(J)) GO TO 871 
  870                CONTINUE 
                     IF(JCE.EQ.0) THEN 
                       WRITE(N6,5490) NJUNC(N1,K) 
                     ELSE 
                       WRITE(N6,5491) KJUNC(N1,K) 
                     ENDIF 
                     NSTOP       = NSTOP+1 
  871                NJUNC(N1,K) = J 
cim   check for downstream node being higher than weir elevation 
                     IF (K.EQ.2) THEN 
                     WELEV = YCREST(I) + Z(NJUNC(N1,1)) 
                     IF (Z(NJUNC(N1,2)).GE.WELEV) THEN 
                     IF (JCE.EQ.0) THEN 
                         WRITE(N6,8332) I,JUN(NJUNC(N1,1)), 
     a                   JUN(NJUNC(N1,2)),Z(NJUNC(N1,2)),WELEV 
                     ELSE 
                         WRITE(N6,8333) I,AJUN(NJUNC(N1,1)), 
     a                   AJUN(NJUNC(N1,2)),Z(NJUNC(N1,2)),WELEV 
                     ENDIF 
 8332 FORMAT(' ERROR = Weir Number ',I10,' FROM NODE ',I10, 
     1' TO NODE ',I10,/, 
     2' Invert elevation of downstream node = ',F10.3, 
     3' is greater than elevation of weir crest = ',F10.3,'.',/, 
     4' This can cause erroneous results.  Set downstream node invert', 
     5' elevation to be less than weir crest and adjust ZP on', 
     6' connecting pipes.') 
 8333 FORMAT(' ERROR = Weir Number ',I10,' FROM NODE ',A10, 
     1' TO NODE ',A10,/, 
     2' Invert elevation of downstream node = ',F10.3, 
     3' is greater than elevation of weir crest = ',F10.3,'.',/, 
     4' This can cause erroneous results.  Set downstream node invert', 
     5' elevation to be less than weir crest and adjust ZP on', 
     6' connecting pipes.') 
                     NSTOP = NSTOP + 1 
                     ENDIF 
                     ENDIF 
                     DO 873 KK   = 1,NCHN 
                     IF(NCHAN(J,KK)) 874,874,873 
  873                CONTINUE 
cim write a warning 
                     WRITE(*,*) J,' ',AJUN(J),KK 
                     IF (NCHAN(J,KK).GE.0) THEN 
                     IF (JCE.EQ.0) THEN 
                       WRITE(n6,8330) JUN(J) 
                       ELSE 
                       WRITE(n6,8331) AJUN(J) 
                       ENDIF 
                     NSTOP = NSTOP + 1 
                     ENDIF 
  874                NCHAN(J,KK) = N1 
  875                CONTINUE 
 1020                CONTINUE 
                     NTL = NTL + NWEIR 
                     ENDIF 
C======================================================================= 
C     READ PUMP DATA ON DATA GROUP H1 
C 
C     IPTYP = 1   Off-line pump with wet well (program will 
C                 set pump junction invert to -100). 
C                 Off-line pump operates on wet well volume. 
C                 Note:  Only one pipe can be connected to a 
C                        type 1 pump node. 
C 
C     IPTYP = 2   In-line lift pump.  In-line pump operates on 
C                 head at pumped junction. 
C 
C     IPTYP = 3   Three-point head-discharge pump curve.  Pump 
C                 rate varies linearly based on head difference 
C                 between discharge and pumped junctions. 
C 
C     IPTYP = 4   Variable-speed in line pump.  Pump rate varies 
C                 linearly based on depth in pumped junction. 
C 
C     IPTYP = 5   Constant speed lift station type pump.  Pump rate 
C                 is entered for individual pumps.  Pumps stay on 
C                 until depth drops to POFF level.  When pumps come 
C                 on the rate increases linearly from zero to PRATE 
C                 over PONDELAY seconds.  Implemented by C. Moore of 
C                 CDM  6/99. 
C======================================================================= 
CIM CHANGE TO PRINT IF NUMBER OF PUMPS EXCEED NEP 6/97 
      DO 1060 I = 1,NEP+1 
C 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'H1') GO TO 1080 
C print error message 
      IF(I.GT.NEP) THEN 
      WRITE(N6,8010) NEP 
      STOP 'TOO MANY PUMPS, SEE ERROR MESSAGE IN OUTPUT FILE' 
      ENDIF 
CIM PP 5/1/97 various changes for reading optional NPRATE parameter 
      READ(N5,*,ERR=888) CC,IPTYP(I) 
      NPRATE(I) = 3 
C     INITIALIZE PUMP STATUS TO OFF 
C     USE FOR TYPE 3 and 5 
      DO K=1,MAXPRA 
	IPOPR(K,I) = -1 
	TIMEON(K,I) = 0.0 
	ENDDO 
      BACKSPACE N5 
      N = NTL + I 
      IF (IPRATE.EQ.0) THEN 
       SELECT CASE (IPTYP(I)) 
       CASE (1) 
        IF(JCE.EQ.0) THEN 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),VWELL(I) 
        ELSE 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),VWELL(I) 
        ENDIF 
       CASE (2) 
        IF(JCE.EQ.0) THEN 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     1                (VRATE(I,K),K=1,2) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1040 
	    ENDDO 
 1040      DO K = 1,2 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ELSE 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     1                (VRATE(I,K),K=1,2) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1041 
	    ENDDO 
 1041     DO K=1,2 
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	    ENDDO 
	  ENDIF 
        ENDIF 
cim  ADD A CHECK FOR NEGATIVE VRATES 
      IF((VRATE(I,1).LT.0.0).OR.(VRATE(I,2).LT.0.0)) THEN 
	WRITE(N6,5447) I 
	NSTOP = NSTOP + 1 
	ENDIF 
       CASE (3) 
        IF(JCE.EQ.0) THEN 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),VWELL(I),PON(I),POFF(I) 
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1042 
	    ENDDO 
 1042      PON(I) = PON(I) - Z(JUNCIM) 
           POFF(I) = POFF(I) - Z(JUNCIM) 
	  ENDIF 
        ELSE 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),VWELL(I),PON(I),POFF(I) 
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1043 
	    ENDDO 
 1043      PON(I) = PON(I) - Z(JUNCIM) 
           POFF(I) = POFF(I) - Z(JUNCIM) 
	  ENDIF 
        ENDIF 
CIM ADD A CHECK FOR NEGATIVE PON OR POFF 
        IF((PON(I).LT.0.0).OR.(POFF(I).LT.0.0)) THEN 
	   WRITE(N6,5448) I 
			NSTOP = NSTOP + 1 
	  ENDIF 
       CASE (4) 
	PON(I) = 0.0 
	POFF(I) = 0.0 
        IF(JCE.EQ.0) THEN 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),PON(I),POFF(I) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1044 
	    ENDDO 
 1044      DO K = 1,3 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ELSE 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),PON(I),POFF(I) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1045 
	    ENDDO 
 1045     DO K=1,3 
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	    ENDDO 
	  ENDIF 
        ENDIF 
cim  ADD A CHECK FOR NEGATIVE VRATES 
      DO K=1,3 
      IF(VRATE(I,K).LT.0.0) THEN 
	WRITE(N6,5447) I 
	NSTOP = NSTOP + 1 
	ENDIF 
	ENDDO 
c     New type 5 pump 
       CASE (5) 
        IF(JCE.EQ.0) THEN 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I) 
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1046 
	    ENDDO 
 1046      POFF(I) = POFF(I) - Z(JUNCIM) 
           DO K = 1,3 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ELSE 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I) 
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1047 
	    ENDDO 
 1047      POFF(I) = POFF(I) - Z(JUNCIM) 
           DO K = 1,3 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ENDIF 
CIM ADD A CHECK FOR NEGATIVE VRATES OR POFF 
        IF(POFF(I).LT.0.0) THEN 
	   WRITE(N6,5448) I 
			NSTOP = NSTOP + 1 
	  ENDIF 
	DO K=1,3 
	   IF (VRATE(I,K).LT.0.0) THEN 
	   WRITE(N6,5447) I 
	ENDIF 
	ENDDO 
	ENDSELECT 
        ELSE 
C this repeats above code when IPRATE is used 
        SELECT CASE (IPTYP(I)) 
        CASE (1) 
         IF(JCE.EQ.0) THEN 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)), 
     4                VWELL(I) 
         ELSE 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)), 
     3                VWELL(I) 
         ENDIF 
        CASE (2) 
        IF(JCE.EQ.0)  THEN 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)-1) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8040 
	    ENDDO 
 8040      DO K=1,NPRATE(I)-1 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ELSE 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)-1) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8041 
	    ENDDO 
 8041     DO K=1,NPRATE(I)-1 
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	    ENDDO 
	  ENDIF 
        ENDIF 
cim  ADD A CHECK FOR NEGATIVE VRATES 
      DO K = 1,NPRATE(I) - 1 
      IF (VRATE(I,K).LT.0.0) THEN 
	WRITE(N6,5447) I 
	NSTOP = NSTOP + 1 
	ENDIF 
	ENDDO 
        CASE(3) 
        IF(JCE.EQ.0)  THEN 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)), 
     4                VWELL(I),PON(I),POFF(I) 
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8042 
	    ENDDO 
 8042      PON(I) = PON(I) - Z(JUNCIM) 
           POFF(I) = POFF(I) - Z(JUNCIM) 
	  ENDIF 
        ELSE 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)), 
     4                VWELL(I),PON(I),POFF(I) 
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8043 
	    ENDDO 
 8043      PON(I) = PON(I) - Z(JUNCIM) 
           POFF(I) = POFF(I) - Z(JUNCIM) 
	  ENDIF 
        ENDIF 
CIM ADD A CHECK FOR NEGATIVE PON OR POFF 
        IF((PON(I).LT.0.0).OR.(POFF(I).LT.0.0)) THEN 
	   WRITE(N6,5448) I 
			NSTOP = NSTOP + 1 
	  ENDIF 
        CASE(4) 
	PON(I) = 0.0 
	POFF(I) = 0.0 
        IF(JCE.EQ.0) THEN 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     3                (VRATE(I,K),K=1,NPRATE(I)) 
     4                ,PON(I),POFF(I) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8044 
	    ENDDO 
 8044      DO K = 1,NPRATE(I) 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ELSE 
                      READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,NPRATE(I)), 
     2                (VRATE(I,K),K=1,NPRATE(I)),PON(I),POFF(I) 
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4 
        IF (JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8045 
	    ENDDO 
 8045     DO K=1,NPRATE(I) 
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	    ENDDO 
	  ENDIF 
        ENDIF 
cim  ADD A CHECK FOR NEGATIVE VRATES 
      DO K=1,NPRATE(I) 
      IF(VRATE(I,K).LT.0.0) THEN 
	WRITE(N6,5447) I 
	NSTOP = NSTOP + 1 
	ENDIF 
	ENDDO 
c     New type 5 pump 
       CASE (5) 
        IF(JCE.EQ.0) THEN 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (NJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I) 
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8046 
	    ENDDO 
 8046      POFF(I) = POFF(I) - Z(JUNCIM) 
           DO K = 1,NPRATE(I) 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ELSE 
                  READ(N5,*,ERR=888) CC,IPTYP(I), 
     1                (KJUNC(N,K),K=1,2),NPRATE(I), 
     2                (PRATE(I,K),K=1,3), 
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I) 
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4 
                  IF(JELEV.EQ.4) THEN 
	    DO JUNCIM = 1, NJ 
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8047 
	    ENDDO 
 8047      POFF(I) = POFF(I) - Z(JUNCIM) 
           DO K = 1,NPRATE(I) 
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM) 
	     ENDDO 
	  ENDIF 
        ENDIF 
CIM ADD A CHECK FOR NEGATIVE VRATES OR POFF 
        IF(POFF(I).LT.0.0) THEN 
	   WRITE(N6,5448) I 
			NSTOP = NSTOP + 1 
	  ENDIF 
	DO K=1,NPRATE(I) 
	   IF (VRATE(I,K).LT.0.0) THEN 
	   WRITE(N6,5447) I 
	ENDIF 
	ENDDO 
        END SELECT 
        ENDIF 
CIM      ISWTCH(IPTYP(I)) = IPTYP(I) 
 1060 CONTINUE 
 1080 NPUMP = I - 1 
C======================================================================= 
C     PRINT PUMP NODES 
C======================================================================= 
      IF(NPUMP.GT.0) THEN 
cim pp 5/1/97  change format of pump printout 
cim Simply print one pump at a time in order that they were input. 
cim Delete all lines associated with original input 
      WRITE(N6,5560) 
      DO I = 1,NPUMP 
      N         = NTL+I 
      IF(JCE.EQ.0) THEN 
        WRITE(N6,5562) I,(NJUNC(N,K),K=1,2) 
        ELSE 
        WRITE(N6,5564) I,(KJUNC(N,K),K=1,2) 
      ENDIF 
      SELECT CASE (IPTYP(I)) 
      CASE (1) 
C======================================================================= 
C     PRINT OFF-LINE PUMP DATA IPTYP = 1 
C======================================================================= 
       IF(METRIC.EQ.1) THEN 
          WRITE(N6,5566) VWELL(I) 
          WRITE(N6,5568) 
          ELSE 
          WRITE(N6,5570) VWELL(I) 
          WRITE(N6,5572) 
        ENDIF 
        WRITE(N6,5574) 0.0,VRATE(I,1),PRATE(I,1) 
        WRITE(N6,5574) (VRATE(I,K-1),VRATE(I,K),PRATE(I,K), 
     1                   K=2,NPRATE(I)) 
CIM CHECK THAT VRATES ARE IN INCREASING ORDER. 
        DO K=2,NPRATE(I) 
           IF (VRATE(I,K).LT.VRATE(I,K-1)) THEN 
             WRITE(N6,9010) 
             NSTOP = NSTOP+1 
           ENDIF 
        ENDDO 
      CASE (2) 
C======================================================================= 
C     PRINT IN-LINE PUMP DATA IPTYP = 2 
C======================================================================= 
        WRITE(N6,5576) 
        IF(METRIC.EQ.1) THEN 
          WRITE(N6,5578) 
          ELSE 
          WRITE(N6,5580) 
        ENDIF 
        WRITE(N6,5574) 0.0,VRATE(I,1),PRATE(I,1) 
        WRITE(N6,5574) (VRATE(I,K-1),VRATE(I,K),PRATE(I,K), 
     1                  K=2,NPRATE(I)-1) 
        WRITE(N6,5582) VRATE(I,NPRATE(I)-1),PRATE(I,NPRATE(I)) 
CIM CHECK THAT VRATES ARE IN INCREASING ORDER. 
        DO K=2,NPRATE(I)-1 
           IF (VRATE(I,K).LT.VRATE(I,K-1)) THEN 
             WRITE(N6,9010) 
             NSTOP = NSTOP+1 
           ENDIF 
        ENDDO 
      CASE (3) 
C======================================================================= 
C     PRINT PUMP CURVE DATA IPTYP = 3 
C======================================================================= 
        IF(METRIC.EQ.1) THEN 
          WRITE(N6,5584) PON(I),POFF(I) 
          WRITE(N6,5586) 
          ELSE 
          WRITE(N6,5588) PON(I),POFF(I) 
          WRITE(N6,5590) 
        ENDIF 
        WRITE(N6,5592) (VRATE(I,K),PRATE(I,K),K=1,NPRATE(I)) 
        WRITE(N6,5600) 
C####################################################################### 
C CHECK FOR FLAT PUMP CURVE.  CANNOT HAVE ADJACENT VRATES EQUAL 
C THIS AVOIDS ZERO DIVIDE IN SUBROUTINE BOUND WCH, 8/28/92 
C####################################################################### 
CIM ALSO CHECK THAT VRATES ARE IN DECREASING ORDER 
        DO K=1,NPRATE(I)-1 
           IF(VRATE(I,K).EQ.VRATE(I,K+1)) THEN 
             WRITE(N6,5575) 
             NSTOP = NSTOP+1 
           ENDIF 
           IF(VRATE(I,K).LT.VRATE(I,K+1)) THEN 
             WRITE(N6,9020) 
             NSTOP = NSTOP+1 
           ENDIF 
       ENDDO 
      CASE (4) 
C======================================================================= 
C     PRINT VARIABLE SPEED PUMP CURVE DATA IPTYP = 4 
C======================================================================= 
        WRITE(N6,5594) 
        IF(METRIC.EQ.1) THEN 
          WRITE(N6,5596) 
          ELSE 
          WRITE(N6,5598) 
        ENDIF 
        WRITE(N6,5592) (VRATE(I,K),PRATE(I,K),K=1,NPRATE(I)) 
        WRITE(N6,5600) 
        IF(METRIC.EQ.1) THEN 
          WRITE(N6,5602) PRATE(I,1),VRATE(I,1) 
          WRITE(N6,5604) PRATE(I,NPRATE(I)),VRATE(I,NPRATE(I)) 
          ELSE 
          WRITE(N6,5606) VRATE(I,1),PRATE(I,1) 
          WRITE(N6,5608) PRATE(I,NPRATE(I)),VRATE(I,NPRATE(I)) 
        ENDIF 
C####################################################################### 
C CHECK FOR FLAT PUMP CURVE.  CANNOT HAVE ADJACENT VRATES EQUAL 
C THIS AVOIDS ZERO DIVIDE IN SUBROUTINE BOUND WCH, 8/28/92 
C####################################################################### 
C CHECK THAT VRATES INCREASE 
        DO K=1,NPRATE(I)-1 
           IF(VRATE(I,K).EQ.VRATE(I,K+1)) THEN 
             WRITE(N6,5575) 
             NSTOP = NSTOP+1 
           ENDIF 
           IF(VRATE(I,K).GT.VRATE(I,K+1)) THEN 
           WRITE(N6,9010) 
           NSTOP = NSTOP+1 
           ENDIF 
        ENDDO 
c initialize to off 
	IPOPR(1,I)=-1 
	IF ((PON(I).EQ.0.0).AND.(POFF(I).EQ.0.0)) THEN 
	PON(I) = -0.1 
	POFF(I) = -0.2 
	ELSE 
	WRITE(N6,8400) PON(I),POFF(I) 
	ENDIF 
	CASE (5) 
C======================================================================= 
C     PRINT CONSTANT SPEED LIFT STATION TYPE PUMP DATA IPTYP = 5 
C======================================================================= 
	WRITE(N6,8100) 
	DO K=1,NPRATE(I) 
	IF (METRIC.EQ.1) THEN 
      WRITE(N6,8102) I,PRATE(I,K),'CFS',VRATE(I,K),'FT' 
	ELSE 
	WRITE(N6,8102) I,PRATE(I,K),'M3S',VRATE(I,K),'M ' 
	END IF 
	enddo 
	IF (METRIC.EQ.1) THEN	 
	WRITE(N6,8104) POFF(I),'FT',PONDELAY(I) 
	ELSE 
	WRITE(N6,8104) POFF(I),'M ',PONDELAY(I) 
	ENDIF 
      CASE DEFAULT 
        WRITE(N6,5576) 
        NSTOP = NSTOP+1 
      END SELECT 
      ENDDO 
C======================================================================= 
C                   CONVERT TO INTERNAL NUMBER SYSTEM 
C======================================================================= 
                    DO 1240 I = 1,NPUMP 
                    N         = NTL+I 
                    LPUMP(I)  = N 
                    NCOND(N)  = N + 90000 
                    IF(JCE.EQ.1) ACOND(N)  = PNAME(I) 
                    DO 1220 K = 1,2 
                    DO 1180 J = 1,NJ 
                    IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J))  GO TO 1190 
                    IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J)) GO TO 1190 
 1180               CONTINUE 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5610) NJUNC(N,K) 
                    ELSE 
                      WRITE(N6,5611) KJUNC(N,K) 
                    ENDIF 
                    NSTOP      = NSTOP+1 
 1190               NJUNC(N,K) = J 
                    DO 1195 KK = 1,NCHN 
                    IF(NCHAN(J,KK)) 1200,1200,1195 
 1195               CONTINUE 
      IF (NCHAN(J,KK).NE.0) THEN 
                     IF (JCE.EQ.0) THEN 
                       WRITE(n6,8330) JUN(J) 
                       ELSE 
                       WRITE(n6,8331) AJUN(J) 
                       ENDIF 
                     NSTOP = NSTOP + 1 
      ENDIF 
 1200               NCHAN(J,KK) = N 
                    IF(IPTYP(I).GE.2) GO TO 1220 
                    IF(KK.LE.2)       GO TO 1220 
                    IF(K.EQ.2)        GO TO 1220 
                    IF(JCE.EQ.0) THEN 
                     WRITE(N6,5615)  JUN(J) 
                    ELSE 
                     WRITE(N6,5614) AJUN(J) 
                    ENDIF 
                    NSTOP = NSTOP + 1 
 1220               CONTINUE 
C======================================================================= 
C                   SET INFLOW INDEX FOR PUMP NODE 
C======================================================================= 
                    JP  = NJUNC(N,1) 
                    IF(IPTYP(I).GE.2) GO TO 1235 
                    JSKIP(JP) = 1 
                    Z(JP)     = -100.0 
 1235               CONTINUE 
                    JPFUL(I)  = 1 
 1240               CONTINUE 
                    NTL       = NTL + NPUMP 
                    ENDIF 
CIM OK HAVE READ WEIRS ORIFICES AND PUMPS, NOW CHECK IF ALL NODES 
CIM ARE CONNECTED TO AT LEAST ONE PIPE AND QUIT IF ANY AREN'T 
      INCON = 0 
      DO J=1,NJ 
      IF (NCHAN(J,1).EQ.0) THEN 
        INCON = INCON + 1 
        JSKIP(J) = 1 
        IF (JCE.EQ.0) THEN 
          WRITE(N6,5350) JUN(J) 
        ELSE 
          WRITE(N6,5351) AJUN(J) 
        ENDIF 
      ENDIF 
      ENDDO 
      IF (INCON.GT.0) THEN 
      WRITE(N6,5352) INCON 
      WRITE(*,5352) INCON 
      STOP 
      ENDIF 
CIM END 
C======================================================================= 
C     READ DATA FOR OUTFALLS WITHOUT TIDE GATES ON DATA GROUP I1 
C======================================================================= 
      NFREE     = 0 
cimtide  JTIDE is not initialized.  Do so here just to be certain. 
cimtide 
      do i=1,nee 
      jtides(nee) = 0 
      enddo 
cimtide 
cim print error message 
      DO 1280 I = 1,NTG+1 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'I1') GO TO 1300 
C print error message 
      IF(I.GT.NTG) THEN 
      WRITE(N6,8015) NTG 
      STOP 'TOO MANY FREE OUTFALLS SEE ERROR MESSAGE IN OUTPUT FILE' 
      ENDIF 
      IF(JCE.EQ.0) THEN 
           READ(N5,*,ERR=888) CC,JFREE(I),NBCF(I) 
      ELSE 
           READ(N5,*,ERR=888) CC,KFREE(I),NBCF(I) 
      ENDIF 
      NFREE = NFREE + 1 
      IF(NPUMP.GT.0) THEN 
               DO 1340 K = 1,NPUMP 
               N         = LPUMP(K) 
               JDN       = NJUNC(N,2) 
               IF(JCE.EQ.1) BMJ       = KJUNC(N,2) 
               IF(JCE.EQ.0.AND.JUN(JDN).EQ.JFREE(I))  JSKIP(JDN) = 2 
               IF(JCE.EQ.1.AND.AJUN(JDN).EQ.KFREE(I)) JSKIP(JDN) = 2 
C              IF(JSKIP(JDN).EQ.2)   ZCROWN(JDN) = 2.0 + Z(JDN) 
 1340          CONTINUE 
               ENDIF 
C======================================================================= 
C     CHECK FOR WEIR OUTFALLS WITHOUT TIDE GATES 
C======================================================================= 
      IF(NWEIR.GT.0) THEN 
               DO 1350 K = 1,NWEIR 
               N         = LWEIR(K) 
               J         = NJUNC(N,1) 
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1) 
C#### RED, 3/12/95.  Compare JUN(J) with JFREE, not J with JFREE. 
C###               IF(JCE.EQ.0.AND.J.EQ.JFREE(I))   THEN 
               IF(JCE.EQ.0.AND.JUN(J).EQ.JFREE(I)) THEN 
                                                JTIDES(J) = NBCF(I) 
                                                NFREE     = NFREE - 1 
                                                GO TO 1350 
                                                ENDIF 
               IF(JCE.EQ.1.AND.BMJ.EQ.KFREE(I)) THEN 
                                                JTIDES(J) = NBCF(I) 
                                                NFREE     = NFREE - 1 
                                                GO TO 1350 
                                                ENDIF 
 1350          CONTINUE 
               ENDIF 
C======================================================================= 
C     CHECK FOR PUMP OUTFALLS. 
C======================================================================= 
      IF(NPUMP.GT.0) THEN 
               DO 1375 K = 1,NPUMP 
               N         = LPUMP(K) 
               J         = NJUNC(N,1) 
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1) 
C#### RED, 3/12/95.  Compare JUN(J) with JFREE, not J with JFREE. 
C###               IF(JCE.EQ.0.AND.J.EQ.JFREE(I))   THEN 
               IF(JCE.EQ.0.AND.JUN(J).EQ.JFREE(I)) THEN 
                                                JTIDES(J) = NBCF(I) 
                                                NFREE     = NFREE - 1 
                                                GO TO 1375 
                                                ENDIF 
               IF(JCE.EQ.1.AND.BMJ.EQ.KFREE(I)) THEN 
                                                JTIDES(J) = NBCF(I) 
                                                NFREE     = NFREE - 1 
                                                GO TO 1375 
                                                ENDIF 
 1375          CONTINUE 
               ENDIF 
 1280 CONTINUE 
 1300 CONTINUE 
C======================================================================= 
C     PRINT OUTFLOW NODES 
C======================================================================= 
      IF(NFREE.GT.0) THEN 
                     WRITE(N6,5616) 
                     IF(JCE.EQ.0) THEN 
                        WRITE(N6,5620) (JFREE(I),NBCF(I),I=1,NFREE) 
                     ELSE 
                        WRITE(N6,5621) (KFREE(I),NBCF(I),I=1,NFREE) 
                     ENDIF 
C======================================================================= 
C                    CONVERT TO INTERNAL NUMBER SYSTEM 
C======================================================================= 
                     DO 1390 I = 1,NFREE 
                     DO 1360 J = 1,NJ 
                     IF(JCE.EQ.0.AND.JFREE(I).EQ.JUN(J))  GO TO 1380 
                     IF(JCE.EQ.1.AND.KFREE(I).EQ.AJUN(J)) GO TO 1380 
 1360                CONTINUE 
                     IF(JCE.EQ.0) THEN 
                       WRITE(N6,5630) JFREE(I) 
                     ELSE 
                       WRITE(N6,5631) KFREE(I) 
                     ENDIF 
                     NSTOP      = NSTOP + 1 
 1380                JFREE(I)   = J 
C======================================================================= 
C                   CHECK FREE BC'S FOR MULTIPLE INPUT CONDUITS 
C======================================================================= 
                     IF(NCHAN(J,2).GT.0) THEN 
                              IF(JCE.EQ.0) THEN 
                               WRITE(N6,1853)  JUN(J) 
                              ELSE 
                               WRITE(N6,1854) AJUN(J) 
                              ENDIF 
                              NSTOP     = NSTOP + 1 
                              ENDIF 
                     JTIDES(J)  = NBCF(I) 
                     N          = NTL + I 
                     NJUNC(N,1) = J 
                     NJUNC(N,2) = 0 
                     IF(JCE.EQ.1) KJUNC(N,1) = AJUN(J) 
                     IF(JCE.EQ.1) KJUNC(N,2) = 'BOUNDARY  ' 
                     NCHAN(J,2) = N 
                     NCOND(N)   = N + 90000 
                     IF(JCE.EQ.1) ACOND(N)   = OUTF(I) 
                     IF(JSKIP(J).EQ.0) JSKIP(J)   = 1 
 1390                CONTINUE 
                     NTL        = NTL + NFREE 
                     ENDIF 
C======================================================================= 
C     READ DATA FOR OUTFALLS WITH TIDE GATES ON DATA GROUP I2 
C======================================================================= 
      NGATE     = 0 
cim print error message 
      DO 1420 I = 1,NTG+1 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'I2') GO TO 1440 
C print error message 
      IF(I.GT.NTG) THEN 
      WRITE(N6,8020) NTG 
      STOP 'TOO MANY OUTFALLS WITH TIDE GATES - SEE ERROR MESSAGE IN OUT 
     +PUT FILE' 
      ENDIF 
      IF(JCE.EQ.0) THEN 
       READ(N5,*,ERR=888) CC,JGATE(I),NBCG(I) 
      ELSE 
       READ(N5,*,ERR=888) CC,KGATE(I),NBCG(I) 
      ENDIF 
      NGATE = NGATE + 1 
C======================================================================= 
C     CHECK FOR WEIR OUTFALLS WITH TIDE GATES 
C======================================================================= 
      IF(NWEIR.GT.0) THEN 
               DO 1450 K = 1,NWEIR 
               N         = LWEIR(K) 
               J         = NJUNC(N,1) 
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1) 
C#### WCH (RED), 3/16/95. Compare JUN(J) with JGATE, not J with JGATE. 
C####               IF(JCE.EQ.0.AND.J.EQ.JGATE(I))   THEN 
               IF(JCE.EQ.0.AND.JUN(J).EQ.JGATE(I)) THEN 
                                                JTIDES(J) = NBCG(I) 
                                                NGATE     = NGATE - 1 
                                                GO TO 1450 
                                                ENDIF 
               IF(JCE.EQ.1.AND.BMJ.EQ.KGATE(I)) THEN 
                                                JTIDES(J) = NBCG(I) 
                                                NGATE     = NGATE - 1 
                                                GO TO 1450 
                                                ENDIF 
 1450          CONTINUE 
               ENDIF 
C======================================================================= 
C     CHECK FOR PUMP OUTFALLS WITH TIDE GATES 
C======================================================================= 
      IF(NPUMP.GT.0) THEN 
               DO 1475 K = 1,NPUMP 
               N         = LPUMP(K) 
               J         = NJUNC(N,1) 
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1) 
C#### WCH (RED), 3/16/95. Compare JUN(J) with JGATE, not J with JGATE. 
C####               IF(JCE.EQ.0.AND.J.EQ.JGATE(I))   THEN 
               IF(JCE.EQ.0.AND.JUN(J).EQ.JGATE(I)) THEN 
                                                JTIDES(J) = NBCG(I) 
                                                NGATE     = NGATE - 1 
                                                GO TO 1475 
                                                ENDIF 
               IF(JCE.EQ.1.AND.BMJ.EQ.KGATE(I)) THEN 
                                                JTIDES(J) = NBCG(I) 
                                                NGATE     = NGATE - 1 
                                                GO TO 1475 
                                                ENDIF 
 1475          CONTINUE 
               ENDIF 
 1420 CONTINUE 
 1440 CONTINUE 
CIM 4/00 PRINT WARNING IF NO BOUNDARIES ARE SPECIFIED (NO I1 OR I2 LINES FOUND) 
	IF ((NFREE.EQ.0).AND.(NGATE.EQ.0)) WRITE(N6,8500) 
C======================================================================= 
C     PRINT TIDE GATE NODES 
C======================================================================= 
      IF(NGATE.GT.0) THEN 
                     WRITE(N6,5656) 
                     IF(JCE.EQ.0) THEN 
                       WRITE(N6,5660) (JGATE(I),NBCG(I),I=1,NGATE) 
                     ELSE 
                       WRITE(N6,5661) (KGATE(I),NBCG(I),I=1,NGATE) 
                     ENDIF 
C======================================================================= 
C                    CONVERT TO INTERNAL NUMBER SYSTEM 
C======================================================================= 
                     DO 1510 I = 1,NGATE 
                     DO 1480 J = 1,NJ 
                     IF(JCE.EQ.0.AND.JGATE(I).EQ.JUN(J))  GO TO 1500 
                     IF(JCE.EQ.1.AND.KGATE(I).EQ.AJUN(J)) GO TO 1500 
 1480                CONTINUE 
                     IF(JCE.EQ.0) THEN 
                      WRITE(N6,5662) JGATE(I) 
                     ELSE 
                      WRITE(N6,5663) KGATE(I) 
                     ENDIF 
                     NSTOP      = NSTOP + 1 
 1500                JGATE(I)   = J 
C======================================================================= 
C                   CHECK TIDAL BC'S FOR MULTIPLE INPUT CONDUITS 
C======================================================================= 
                     IF(NCHAN(J,2).GT.0) THEN 
                              IF(JCE.EQ.0) THEN 
                               WRITE(N6,1853)  JUN(J) 
                              ELSE 
                               WRITE(N6,1854) AJUN(J) 
                              ENDIF 
                              NSTOP     = NSTOP + 1 
                              ENDIF 
                     JTIDES(J)  = NBCG(I) 
                     N          = NTL + I 
                     NJUNC(N,1) = J 
                     NJUNC(N,2) = 0 
                     IF(JCE.EQ.1) KJUNC(N,1) = AJUN(J) 
                     IF(JCE.EQ.1) KJUNC(N,2) = 'BOUNDARY  ' 
                     NCHAN(J,2) = N 
                     NCOND(N)   = N + 90000 
                     IF(JCE.EQ.1) ACOND(N)   = OUTG(I) 
                     JSKIP(J)   = 1 
 1510                CONTINUE 
                     NTL        = NTL + NGATE 
                     ENDIF 
C======================================================================= 
C     PRINT WEIR OUTFALL NODES 
C======================================================================= 
      IF(NWEIR.GT.0) THEN 
                     ILOOP      = 0 
                     DO 1470 K  = 1,NWEIR 
                     N          = LWEIR(K) 
                     J          = NJUNC(N,1) 
                     JJ         = NJUNC(N,2) 
                     IF(JJ.LE.0) THEN 
                          ILOOP = ILOOP + 1 
                          IF(ILOOP.EQ.1) WRITE(N6,6660) 
                          IF(JCE.EQ.0) THEN 
                            WRITE(N6,6665)  JUN(J),JTIDES(J) 
                          ELSE 
                            WRITE(N6,6670) AJUN(J),JTIDES(J) 
                          ENDIF 
                          ENDIF 
 1470                CONTINUE 
                     ENDIF 
C======================================================================= 
C     PRINT PUMP OUTFALL NODES 
C======================================================================= 
      IF(NPUMP.GT.0) THEN 
                     ILOOP      = 0 
                     DO 1570 K  = 1,NPUMP 
                     N          = LPUMP(K) 
                     J          = NJUNC(N,1) 
                     JJ         = NJUNC(N,2) 
                     IF(JJ.LE.0) THEN 
                        ILOOP = ILOOP + 1 
                        IF(ILOOP.EQ.1) WRITE(N6,6680) 
                        IF(JCE.EQ.0) THEn 
                          WRITE(N6,6665)  JUN(J),JTIDES(J) 
                        ELSE 
                          WRITE(N6,6670) AJUN(J),JTIDES(J) 
                        ENDIF 
                        ENDIF 
 1570                CONTINUE 
                     ENDIF 
C======================================================================= 
C     INTERNAL CONNECTIVITY INFORMATION 
C======================================================================= 
      WRITE(N6,2999) 
      WRITE(N6,5060) ALPHA1,ALPHA2 
      WRITE(N6,5665) 
      IF(JCE.EQ.0) THEN 
        WRITE(N6,5670) 
      ELSE 
        WRITE(N6,5671) 
      ENDIF 
      N1        = NC+1 
      DO 1525 N = N1,NTL 
      J1        = NJUNC(N,1) 
      J2        = NJUNC(N,2) 
      IF(J2.GT.0.AND.JCE.EQ.0) J2 = JUN(J2) 
      IF(JCE.EQ.0) THEN 
        WRITE(N6,5675) NCOND(N),JUN(J1),J2 
      ELSE 
        WRITE(N6,5685) ACOND(N),KJUNC(N,1),KJUNC(N,2) 
      ENDIF 
 1525 CONTINUE 
      IF(NJ.GT.NEE) THEN 
                    WRITE(N6,5676) NEE 
                    NSTOP = NSTOP+1 
                    ENDIF 
      IF(NTL.GT.NEE) THEN 
                    WRITE(N6,5677) NEE 
                    NSTOP = NSTOP+1 
                    ENDIF 
      RETURN 
 888  CALL IERROR 
C======================================================================= 
C#### WCH, 12/8/94.  NEW 890 - 999. 
  890 FORMAT(/' DETAILED DATA FOR VARIABLE AREA/TABULAR INPUT JUNCTION', 
     1 1X,I10,/,' POINT    DEPTH       AREA     VOLUME') 
  891 FORMAT(/' DETAILED DATA FOR VARIABLE AREA/TABULAR INPUT JUNCTION', 
     1 1X,A10,/,' POINT    DEPTH       AREA     VOLUME') 
  892 FORMAT(' NUMBER      FT         AC    1000-FT3',/, 
     1        ' -------------------------------------') 
  893 FORMAT(' NUMBER       M         HA     1000-M3',/, 
     1        ' -------------------------------------') 
  894 FORMAT(I6,F10.3,2E11.4) 
  895 FORMAT(/' INPUT DATA FOR VARIABLE AREA/POWER FUNCTION JUNCTION', 
     1 1X,I10,/,' COEFFICIENT =',F10.3,/,' EXPONENT    =',F10.3) 
  896 FORMAT(/' INPUT DATA FOR VARIABLE AREA/POWER FUNCTION JUNCTION', 
     1 1X,A10,/, ' COEFFICIENT =',F10.3,/,' EXPONENT    =',F10.3) 
  990 FORMAT(/,'  WARNING FOR VARIABLE AREA STORAGE JUNCTION NO. ' 
     1,I10) 
  991 FORMAT(/,'  WARNING FOR VARIABLE AREA STORAGE JUNCTION NO. ' 
     1,A10) 
  992 FORMAT(' LOWEST DEPTH = ',F9.4,'. MUST BE = 0.  VALUE SET TO 0.') 
  993 FORMAT( ' LOWEST AREA = ',F9.4,'. MUST BE > 0.  VALUE SET TO AMEN 
     1(LINE B2).') 
  998 FORMAT(/,' WARNING  FOR JUNCTION ',I10,' AREA DECREASES BETWEEN', 
     1' STAGES',F10.3,' AND ',F10.3) 
  999 FORMAT(/,' WARNING  FOR JUNCTION ',A10,' AREA DECREASES BETWEEN', 
     1' STAGES',F10.3,' AND ',F10.3) 
 1853 FORMAT(/,' ===> ERROR   OUTFALL JUNCTION ',I10,' HAS TWO OR',/, 
     +         '                MORE CONNECTING CONDUITS.') 
 1854 FORMAT(/,' ===> ERROR   OUTFALL JUNCTION ',A10,' HAS TWO OR',/, 
     +         '                MORE CONNECTING CONDUITS.') 
2999  FORMAT(/, 
     1       '1',40(2H--)/' ','ENVIRONMENTAL PROTECTION AGENCY',13X,40H* 
     2***   EXTENDED TRANSPORT PROGRAM   ****,8X,'WATER RESOURCES DIVISI 
     3ON',/,' ','WASHINGTON, D.C.            ',16X,4H****,32X,4H****,8X, 
     4'CAMP DRESSER & MCKEE INC.',/,' ','                ',28X,4H****, 
     56X,'   ANALYSIS MODULE  ',6X,4H****,8X,'ANNANDALE, VIRGINIA') 
 5060 FORMAT(/,5X,A80,/,5X,A80,/) 
 5397 FORMAT(//, 
     +' ******************************************************',/, 
     +' *          DETAILED STORAGE JUNCTION DATA            *',/, 
     +' ******************************************************',/) 
 5398 FORMAT(//, 
     +' ******************************************************',/, 
     +' *          STORAGE JUNCTION DATA SUMMARY             *',/, 
     +' ******************************************************',/) 
 5399 FORMAT(7X,I10,A10,2F18.2,F11.3) 
 5499 FORMAT(7X,A10,A10,2F18.2,F11.3) 
CIM START  OOOOOOO 
 5420 FORMAT(//, 
     +' *********************************************',/, 
     +' *              ORIFICE DATA                 *',/, 
     +' *********************************************',//, 
     *'       FROM         TO                AREA      DISCHARGE   HEIGH 
     +T ABOVE         RECTANGULAR ORIFICE',/, 
     *'   JUNCTION   JUNCTION      TYPE     (FT2)    COEFFICIENT  JUNCTI 
     +ON (FT)         DEPTH          WIDTH',/, 
     *'   --------   --------      ----     -----    -----------  ------ 
     +-------        ------          -----') 
 5421 FORMAT(//, 
     +' *********************************************',/, 
     +' *              ORIFICE DATA                 *',/, 
     +' *********************************************',//, 
     *'       FROM         TO                AREA      DISCHARGE   HEIGH 
     +T ABOVE         RECTANGULAR ORIFICE',/, 
     *'   JUNCTION   JUNCTION      TYPE    (MET2)    COEFFICIENT  JUNCTI 
     +ON  (M)         DEPTH          WIDTH',/, 
     *'   --------   --------      ----     -----    -----------  ------ 
     +-------        ------          -----') 
 5440 FORMAT(1X,3I10,F10.2,F15.3,3F15.3) 
 5441 FORMAT(1X,2A10,I10,F10.2,F15.3,3F15.3) 
 5442 FORMAT(' ERROR ** ORIFICE ZP HEIGHT ABOVE UPSTREAM', 
     a' NODE INVERT IS LESS THAN ZERO.' 
     a,/,'          ORIFICE NUMBER = ', I10) 
 5443	FORMAT(' ERROR ** OOPEN OR OCLOSE IS LESS THAN ZERO', 
     a' FOR ORIFICE NUMBER ',I10) 
 5444 FORMAT(' ERROR ** YTOP OR YCREST IS LESS THAN ZERO FOR WEIR', 
     A' NUMBER ',I10) 
 5445 FORMAT(/,' ====> ERROR   GATED ORIFICE CONTROL JUNCTION ',I10, 
     1' IS NOT CONTAINED IN JUNCTION DATA') 
 5446 FORMAT(/,' ====> ERROR   GATED ORIFICE CONTROL JUNCTION ',A10, 
     1' IS NOT CONTAINED IN JUNCTION DATA') 
 5447 FORMAT(' ERROR ** VRATE IS LESS THAN ZERO FOR PUMP NUMBER ',I10) 
 5448 FORMAT(' ERROR ** PON OR POFF IS LESS THAN ZERO FOR PUMP', 
     A' NUMBER ',I10) 
 5449 FORMAT(' ERROR ** IPTYP EQUALS ',I4,' WHICH IS NOT A VALID', 
     A' PUMP TYPE') 
CIM END     OOOOOOOO 
 5450 FORMAT(/,' ====> ERROR   ORIFICE JUNCTION ',I10, 
     1' IS NOT CONTAINED IN JUNCTION DATA') 
 5451 FORMAT(/,' ====> ERROR   ORIFICE JUNCTION ',A10, 
     1' IS NOT CONTAINED IN JUNCTION DATA') 
 5455 FORMAT(/,' ====> ERROR  ORIFICE TOP LIES ABOVE GROUND ELEVATION 
     . AT JUNCTION ',I10) 
 5456 FORMAT(/,' ====> ERROR  ORIFICE TOP LIES ABOVE GROUND ELEVATION 
     . AT JUNCTION ',A10) 
 5458 FORMAT(/,' ====> ERROR  ORIFICE OUTLET AT JUNCTION ',I10, 
     1' IS HIGHER THAN INLET') 
 5459 FORMAT(/,' ====> ERROR  ORIFICE OUTLET AT JUNCTION ',A10, 
     1' IS HIGHER THAN INLET') 
C  BAC START WWWWWWW 
 5480 FORMAT(//, 
     +' *********************************************',/, 
     +' *                 WEIR DATA                 *',/, 
     +' *********************************************',//, 
     *'     FROM       TO        LINK               CREST       WEIR   ' 
     *,'   WEIR        DISCHARGE   SUBMERGENCE  NUMBER OF END  V-NOTCH ' 
     *,'ANGLE  SECOND DISCHARGE',/, 
     *'   JUNCTION  JUNCTION    NUMBER      TYPE  HEIGHT(FT)   TOP(FT) ' 
     *,' LENGTH(FT)   COEFFICIENT   EQUATION    CONTRACTIONS   OR SIDE ' 
     *,'SLOPE    COEFFICIENT',/, 
     *'   --------  --------    ------      ----  ----------   ------- ' 
     *,' ----------   -----------  -----------  -------------  --------' 
     *,'-----  ----------------') 
C    *'       FROM        TO      LINK                 CREST      WEIR 
C    *      WEIR     DISCHARGE',/, 
C    *'   JUNCTION  JUNCTION    NUMBER      TYPE  HEIGHT(FT)   TOP(FT) 
C    *LENGTH(FT)   COEFFICIENT',/, 
C    *'   --------  --------    ------      ----  ----------   ------- 
C    *----------   -----------') 
 5481 FORMAT(//, 
     +' *********************************************',/, 
     +' *                 WEIR DATA                 *',/, 
     +' *********************************************',//, 
     *'     FROM       TO        LINK                CREST       WEIR  ' 
     *,'    WEIR       DISCHARGE   SUBMERGENCE  NUMBER OF END  V-NOTCH ' 
     * ,'ANGLE  SECOND DISCHARGE',/, 
     *'   JUNCTION  JUNCTION    NUMBER      TYPE   HEIGHT(M)    TOP(M) ' 
     *,'  LENGTH(M)   COEFFICIENT   EQUATION    CONTRACTIONS   OR SIDE ' 
     *,'SLOPE    COEFFICIENT',/, 
     *'   --------  --------    ------      ----   ---------    ------ ' 
     *,'  ---------   -----------  -----------  -------------  --------' 
     *,'-----  ----------------') 
C    *'       FROM        TO      LINK                 CREST      WEIR 
C    *      WEIR     DISCHARGE',/, 
C    *'   JUNCTION  JUNCTION    NUMBER      TYPE  HEIGHT (M)   TOP (M) 
C    *LENGTH (M)   COEFFICIENT',/, 
C    *'   --------  --------    ------      ----  ----------   ------- 
C    *----------   -----------') 
 5485 FORMAT(1X,3I10,I10,F12.2,F10.2,F12.2,F14.4,7X,I1,10X,F5.1,7X, 
     +F13.4,F17.2) 
 5486 FORMAT(1X,3A10,I10,F12.2,F10.2,F12.2,F14.4,7X,I1,10X,F5.1,7X, 
     +F13.4,F17.2) 
C  BAC END   WWWWW 
 5487 FORMAT(1X,4I10,F12.2,F10.2,F12.2,F14.4) 
 5488 FORMAT(1X,3A10,I10,F12.2,F10.2,F12.2,F14.4) 
 5490 FORMAT(/,' ====> ERROR  WEIR JUNCTION',I10, 
     1       ' IS NOT CONTAINED IN JUNCTION DATA') 
 5491 FORMAT(/,' ====> ERROR  WEIR JUNCTION ',A10, 
     1       ' IS NOT CONTAINED IN JUNCTION DATA') 
 5484 FORMAT(/,' ====> ERROR  STORAGE JUNCTION ',A10, 
     1' IS NOT CONTAINED IN JUNCTION DATA') 
 5494 FORMAT(/,' ====> ERROR  STORAGE JUNCTION ',I10, 
     1' IS NOT CONTAINED IN JUNCTION DATA') 
 5495 FORMAT( 
     +'                                MAXIMUM OR          PEAK OR     ' 
     +,'   CROWN  ',/, 
     +' STORAGE JUNCTION  JUNCTION  CONSTANT SURFACE   CONSTANT VOLUME ' 
     +,' ELEVATION',/, 
     +'   NUMBER OR NAME      TYPE     AREA (FT2)        (CUBIC FEET)  ' 
     +,'    (FT)  ',/, 
     +'   --------------  --------  ----------------   --------------- ' 
     +,' ---------') 
 5496 FORMAT( 
     +'                                MAXIMUM OR          PEAK OR     ' 
     +,'   CROWN  ',/, 
     +' STORAGE JUNCTION  JUNCTION  CONSTANT SURFACE   CONSTANT VOLUME ' 
     +,' ELEVATION',/, 
     +'   NUMBER OR NAME      TYPE     AREA  (M2)        (CUBIC MET.)  ' 
     +,'     (M)  ',/, 
     +'   --------------  --------  ----------------   --------------- ' 
     +,' ---------') 
CIM PP  NEW PUMP OUTPUT 5/1/97 
 5560 FORMAT(//, 
     +' *********************************************',/, 
     +' *                 PUMP DATA                 *',/, 
     +' *********************************************',//) 
 5562 FORMAT(5X,'PUMP NUMBER ',I3,' PUMPED JUNCTION = ',I10, 
     1'    RECEIVING JUNCTION = ',I10) 
 5564 FORMAT(5X,'PUMP NUMBER ',I3,' PUMPED JUNCTION = ',A10, 
     1'    RECEIVING JUNCTION = ',A10) 
 5566 FORMAT(/,5X,'OFF-LINE PUMP (IPTYP = 1)   INITIAL STORAGE', 
     1' VOLUME = ',F10.3,' CU. FT.') 
 5570 FORMAT(/,5X,'OFF-LINE PUMP (IPTYP = 1)   INITIAL STORAGE', 
     1' VOLUME = ',F10.3,' CU. M.') 
 5568 FORMAT(/,'          WET WELL VOLUMES',/, 
     1'          GREATER THAN         AND LESS            PUMPING',/, 
     2'           OR EQUAL              THAN                RATE',/, 
     3'            (FT^3)              (FT^3)              (CFS)') 
 5576 FORMAT(/,5X,'IN-LINE PUMP (IPTYP = 2)') 
 5578 FORMAT(/,'          PUMPED JUNCTION DEPTHS',/, 
     1'          GREATER THAN         AND LESS            PUMPING',/, 
     2'           OR EQUAL              THAN                RATE',/, 
     3'             (FT)                (FT)               (CFS)') 
 5574 FORMAT(3F20.3) 
 5582 FORMAT(F20.3,20X,F20.3) 
 5584 FORMAT(/,5X,'PUMP CURVE DATA (IPTYP = 3)   PUMP ON AT JUNCTION', 
     1' DEPTH = ',F10.3,' FEET.   PUMP OFF AT JUNCTION DEPTH = ', 
     2F10.3,' FEET.') 
 5586 FORMAT(/, 
     1'                                                   PUMPING',/, 
     2'          JUNCTION HEAD DIFFERENCE                   RATE',/, 
     3'                   (FEET)                           (CFS)') 
 5592 FORMAT(F25.3,F30.3) 
 5594 FORMAT(/,5X,'VARIABLE SPEED PUMP CURVE DATA (IPTYP = 4)') 
 5596 FORMAT('                      PUMPED',/, 
     1'                     JUNCTION                      PUMPING',/, 
     2'                      DEPTH                          RATE',/, 
     3'                       (FT)                         (CFS)') 
 5600 FORMAT('          Pumping rate is linearly interpolated from ', 
     1'the above values.') 
 5602 FORMAT('          Pumping rate equals ',F10.3,' cfs for depths ', 
     1'less than ',F10.3,' feet.') 
 5604 FORMAT('          Pumping rate equals ',F10.3,' cfs for depths ', 
     1'greater than ',F10.3,' feet.') 
 5572 FORMAT(/,'         WET WELL VOLUMES',/, 
     1'          GREATER THAN         AND LESS            PUMPING',/, 
     2'           OR EQUAL              THAN                RATE',/, 
     3'             (M^3)               (M^3)              (M3/S)') 
 5580 FORMAT(/,'          PUMPED JUNCTION DEPTHS',/, 
     1'          GREATER THAN         AND LESS            PUMPING',/, 
     2'           OR EQUAL              THAN                RATE',/, 
     3'             (M)                 (M)                (M3/S)') 
 5588 FORMAT(/,5X,'PUMP CURVE DATA (IPTYP = 3)   PUMP ON AT JUNCTION', 
     1' DEPTH = ',F10.3,' METERS.   PUMP OFF AT JUNCTION DEPTH = ', 
     2F10.3,' METERS.') 
 5590 FORMAT(/, 
     1'                                                   PUMPING',/, 
     2'          JUNCTION HEAD DIFFERENCE                   RATE',/, 
     3'                  (METERS)                          (M3/S)') 
 5598 FORMAT(/,'                      PUMPED',/, 
     1'                     JUNCTION                      PUMPING',/, 
     2'                      DEPTH                          RATE',/, 
     3'                        (M)                         (M3/S)') 
 5606 FORMAT('          Pumping rate equals ',F10.3,' M3/S for depths ', 
     1'less than ',F10.3,' meters.') 
 5608 FORMAT('          Pumping rate equals ',F10.3,' M3/S for depths ', 
     1'greater than ',F10.3,' meters.') 
 5575 FORMAT(/,' ====> ERROR  CANNOT HAVE EQUAL VRATE (HEAD) VALUES', 
     *' ON PUMP CURVE (TO AVOID ZERO DIVIDE UPON INTERPOLATION).',/, 
     *'       MUST PROVIDE AT LEAST MINIMAL HEAD DIFFERENCE.') 
 8100 FORMAT(/,5X,'LIFT STATION TYPE PUMP DATA (IPTYP = 5)',/) 
 8102 FORMAT(10X,'PUMP #',I2,' HAS A CAPACITY OF ',F10.3,A3, 
     1' AND STARTS AT A DEPTH OF ',F10.3,A2) 
 8104 FORMAT(/,10X,'ALL PUMPS TURN OFF WHEN DEPTH EQUALS ',F10.3,A2,/, 
     110X,'PUMPS DELAY',F10.3,' SECONDS TO INCREASE FROM ZERO FLOW', 
     2' TO CAPACITY') 
CIM 
 9010 FORMAT(\,' ===> ERROR  VRATES MUST BE INPUT IN INCREASING ', 
     a'ORDER FOR IPTYP 1, 2, AND 4 PUMPS.') 
 9020 FORMAT(\,' ===> ERROR  VRATES MUST BE INPUT IN DECREASING ', 
     a'ORDER FOR IPTYP 3 PUMPS.') 
CIM 
 5610 FORMAT(/,' ====> ERROR  PUMP JUNCTION ',I10, 
     +     ' IS NOT CONTAINED IN THE JUNCTION DATA') 
 5611 FORMAT(/,' ====> ERROR  PUMP JUNCTION ',A10, 
     +     ' IS NOT CONTAINED IN THE JUNCTION DATA') 
 5615 FORMAT(/,' ====> ERROR   MORE THAN ONE PIPE IS INFLUENT TO OFF- 
     .LINE PUMP JUNCTION ',I10) 
 5614 FORMAT(/,' ====> ERROR   MORE THAN ONE PIPE IS INFLUENT TO OFF- 
     .LINE PUMP JUNCTION ',A10) 
 8010 FORMAT ('ERROR ==> The number of pumps exceeds the maximum', 
     +' allowed by the program dimensions (NEP = ',I10,')',/,10X, 
     +'Change NEP in TAPES.INC and recompile') 
 5616 FORMAT(//, 
     +' **************************************************',/, 
     +' *          FREE OUTFALL DATA (DATA GROUP I1)     *',/, 
     +' *         BOUNDARY CONDITION ON DATA GROUP J1    *'/, 
     +' **************************************************',/) 
 5620 FORMAT(' OUTFALL AT JUNCTION....',I10, 
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10) 
 5621 FORMAT(' OUTFALL AT JUNCTION....',A10, 
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10) 
 5630 FORMAT(/,' ====> ERROR   FREE OUTFALL JUNCTION ',I10,' IS NOT', 
     1       ' CONTAINED IN JUNCTION DATA') 
 5631 FORMAT(/,' ====> ERROR   FREE OUTFALL JUNCTION ',A10,' IS NOT', 
     1       ' CONTAINED IN JUNCTION DATA') 
 8015 FORMAT ('ERROR ==> The number of free outfall exceeds the ', 
     +'maximum number', 
     +' allowed by the program dimensions (NTG = ',I10,')',/,10X, 
     +'Change NTG in TAPES.INC and recompile') 
 5656 FORMAT(//, 
     +' ***********************************************',/, 
     +' *    TIDE GATE OUTFALL DATA (DATA GROUP I2)   *',/, 
     +' *      BOUNDARY CONDITION ON DATA GROUP J1    *'/, 
     +' ***********************************************',/) 
 5660 FORMAT(' OUTFALL AT JUNCTION....',I10, 
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10) 
 5661 FORMAT(' OUTFALL AT JUNCTION... ',A10, 
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10) 
 5662 FORMAT(/,' ====> ERROR   TIDE GATE JUNCTION ',I10,' IS NOT', 
     1       ' CONTAINED IN JUNCTION DATA') 
 5663 FORMAT(/,' ====> ERROR   TIDE GATE JUNCTION ',A10,' IS NOT', 
     1       ' CONTAINED IN JUNCTION DATA') 
 8020 FORMAT ('ERROR ==> The number of outfall with tide gates ', 
     +'exceeds the maximum number', 
     +' allowed by the program dimensions (NTG = ',I10,')',/,10X, 
     +'Change NTG in TAPES.INC and recompile') 
 5665 FORMAT(//, 
     +' **************************************************',/, 
     +' *        INTERNAL CONNECTIVITY INFORMATION       *',/, 
     +' **************************************************',/) 
 5670 FORMAT('          CONDUIT     JUNCTION     JUNCTION',/, 
     +       '          -------     --------     --------') 
 5671 FORMAT('     CONDUIT      JUNCTION     JUNCTION',/, 
     +       '     -------      --------     --------') 
 5675 FORMAT(4X,I11,2I13) 
 5676 FORMAT(/,' ====> ERROR  TOTAL NUMBER OF JUNCTIONS(INCLUDING WEI 
     1RS) EXCEED PROGRAM DIMENSIONS, NEE =',I4) 
 5677 FORMAT(/,' ====> ERROR  TOTAL NUMBER OF LINKS EXCEEDS PROGRAM D 
     1IMENSIONS, NEE =',I4) 
 5685 FORMAT(5X,A10,3X,A10,3X,A10) 
CIM START OOOOOOOOOO 
 6010 FORMAT(/,' ====> EQUIVALENT CIRCULAR PIPE INFORMATION ', 
     .       'FOR ORIFICE # ',I7,/, 
     .       '       CONDUIT NUMBER..........................',I10,/, 
     .       '       PIPE DIAMETER........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.5,/, 
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/, 
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4) 
 6011 FORMAT(/,' ====> EQUIVALENT CIRCULAR PIPE INFORMATION ', 
     .       'FOR ORIFICE # ',I7,/, 
     .       '       CONDUIT NAME........................... ',A10,/, 
     .       '       PIPE DIAMETER........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.5,/, 
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/, 
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4) 
 6012 FORMAT(/,' ====> EQUIVALENT RECTANGULAR PIPE INFORMATION', 
     .       ' FOR ORIFICE # ',I7,/, 
     .       '       CONDUIT NUMBER..........................',I10,/, 
     .       '       PIPE DEPTH...........................',F12.2,/, 
     .       '       PIPE WIDTH...........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.5,/, 
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/, 
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4) 
 6013 FORMAT(/,' ====> EQUIVALENT RECTANGULAR PIPE INFORMATION ', 
     .               'FOR ORIFICE # ',I7,/, 
     .       '       CONDUIT NAME........................... ',A10,/, 
     .       '       PIPE DEPTH...........................',F12.2,/, 
     .       '       PIPE WIDTH...........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.5,/, 
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/, 
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4) 
 6014 FORMAT(/,'       INVERT CHANGES AS GATE OPENS AND CLOSES') 
  660 FORMAT(/,' ====> TIME CLOSURE GATE DATA FOR ORIFICE # ',I7,/, 
     .       '       CONTROL JUNCTION NAME............... ',I10,/, 
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/, 
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/, 
     .       '       CLOSED AREA..........................',F12.2,/, 
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/, 
     .       '       DIRECTION CONTROL....................',I12,/, 
     .       '       PRINT OPTION.........................',I12) 
  661 FORMAT(/,' ====> TIME CLOSURE GATE DATA FOR ORIFICE # ',I7,/, 
     .       '       CONTROL JUNCTION NAME............... ',A10,/, 
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/, 
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/, 
     .       '       CLOSED AREA..........................',F12.2,/, 
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/, 
     .       '       DIRECTION CONTROL....................',I12,/, 
     .       '       PRINT OPTION.........................',I12) 
  662 FORMAT(/,' ====> HEAD DEPENDENT CLOSURE GATE DATA FOR ORIFICE # ' 
     .       ,I7,/, 
     .       '       CONTROL JUNCTION NAME............... ',I10,/, 
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/, 
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/, 
     .       '       CLOSED AREA..........................',F12.2,/, 
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/, 
     .       '       DIRECTION CONTROL....................',I12,/, 
     .       '       PRINT OPTION.........................',I12) 
  663 FORMAT(/,' ====> HEAD DEPENDENT CLOSURE GATE DATA FOR ORIFICE # ' 
     .       ,I7,/, 
     .       '       CONTROL JUNCTION NAME............... ',A10,/, 
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/, 
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/, 
     .       '       CLOSED AREA..........................',F12.2,/, 
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/, 
     .       '       DIRECTION CONTROL....................',I12,/, 
     .       '       PRINT OPTION.........................',I12) 
CIM END   OOOOOOOOOO 
CIM START <><><><><><><> 
 5350 FORMAT(/,' ===> JUNCTION ',I10, 
     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT, PUMP STATION, ', 
     2         'WEIR, OR ORIFICE.') 
 5351 FORMAT(/,' ===> JUNCTION ',A10, 
     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT, PUMP STATION, ', 
     2         'WEIR, OR ORIFICE.') 
 5352 FORMAT(/,' ERROR  ',I5,' JUNCTIONS ARE NOT CONNECTED ',/, 
     1         ' RUN IS STOPPED') 
 7000 FORMAT(' ERROR - ORIFICE TYPE NOT VALID FOR ORIFICE ', 
     A'NJUNC1 = ',I10,' NJUNC2 = ',I10,' NKLASS = ',I10) 
 7001 FORMAT(' ERROR - ORIFICE TYPE NOT VALID FOR ORIFICE ', 
     A'KJUNC1 = ',A10,' KJUNC2 = ',A10,' NKLASS = ',I10) 
CIM END     <><><><><><> 
 6660 FORMAT(//, 
     +' ***********************************************',/, 
     +' *               WEIR OUTFALL DATA             *',/, 
     +' *      BOUNDARY CONDITION ON DATA GROUP J1    *'/, 
     +' ***********************************************',/) 
 6665 FORMAT(' WEIR OUTFALL AT JUNCTION....',I10, 
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10) 
 6670 FORMAT(' WEIR OUTFALL AT JUNCTION... ',A10, 
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10) 
 6680 FORMAT(//, 
     +' ***********************************************',/, 
     +' *               PUMP OUTFALL DATA             *',/, 
     +' *      BOUNDARY CONDITION ON DATA GROUP H1    *'/, 
     +' ***********************************************',/) 
C#### WCH, 1/23/95. 
 7005 FORMAT(15X,'WARNING - ZCROWN IS GREATER THAN GROUND ELEVATION.', 
     1'  GROUND ELEVATION IS SET TO ZCROWN + 0.1') 
 7010 FORMAT(15X,'WARNING - MAXIMUM SURCHARGE ELEVATION IS LESS THAN', 
     1' GROUND ELEVATION.  SURCHARGE ELEVATION IS SET EQUAL TO THE', 
     2' GROUND ELEVATION') 
 9119 FORMAT(/,' ERROR ===> NUMST on line E1 is greater than allowed by 
     1 NVST on the parameter statement on TAPES.INC') 
 8005 FORMAT(/,' WARNING ===> At storage junction ',I10,' the user ', 
     +'input ZTOP equals ',F10.3,/,14X,' which is less than the top ', 
     +'of the highest pipe entering the junction (',f10.3,')',/,14X, 
     +' ZTOP is set equal to highest crown elevation') 
 8006 FORMAT(/,' WARNING ===> At storage junction ',A10,' the user ', 
     +'input ZTOP equals ',F10.3,/,14X,' which is less than the top ', 
     +'of the highest pipe entering the junction (',F10.3,')',/,14X, 
     +' ZTOP is set equal to highest crown elevation') 
 8011 FORMAT(' >>NOTE, ROUTINE ADJUSTMENT of downstream orifice junction 
     a- Invert of junction ID ',I10,' was lowered to equal ',F10.3, 
     b' to allow for bottom outlet orifice.  Connecting channel slopes n 
     cot affected.') 
 8012 FORMAT(' >>NOTE, ROUTINE ADJUSTMENT of downstream orifice junction 
     a- Invert of junction ID ',A10,' was lowered to equal ',F10.3, 
     b' to allow for bottom outlet orifice.  Connecting channel slopes n 
     cot affected.') 
 8330 FORMAT('ERROR - TOO MANY CONDUITS ENTERING JUNCTION ',I10,/, 
     +'Change connectivity or increase NCHN in TAPES.INC and ', 
     +'recompile program or add dummy links.') 
 8331 FORMAT('ERROR - TOO MANY CONDUITS ENTERING JUNCTION ',A10,/, 
     +'Change connectivity or increase NCHN in TAPES.INC and ', 
     +'recompile program or add dummy links.') 
 8400	FORMAT(10X,'PUMP TURNS ON WHEN DEPTH EQUALS  ',F10.3,'FEET',/, 
     1       10X,'PUMP TURNS OFF WHEN DEPTH EQUALS ',F10.3,'FEET') 
 8500 FORMAT(5X,'WARNING - NO BOUNDARY WAS SPECIFIED ON I1 OR I2 LINES.' 
     A,'  MOST MODELS WILL HAVE AT LEAST ONE BOUNDARY SPECIFIED') 
C======================================================================= 
      END 
 
REM File: INDAT3.FOR 
 
      SUBROUTINE INDAT3 
C	EXTRAN BLOCK 
C	CALLED BY EXTRAN NEAR LINE 200 
C======================================================================= 
C     THIS SUBROUTINE READS DATA GROUPS J1-J4, EXCEPT FOR THE INPUT 
C          HYDROGRAPH LINES READ BY SUBROUTINE INFLOW.  IT ALSO PERFORMS 
C          SOME INITIALIZATION.  ALL NODE-CONDUIT LINKAGES ARE 
C          SET UP AND CONVERTED TO THE INTERNAL NUMBER SYSTEM. 
C     CORRECTION TO J4 READ BY WCH, 4/1/93 
C     CORRECTION FOR INITIAL DATE BY RED, 5/12/93 
C     CONVERT OPTIONAL USER-INPUT INITIAL DATE TO JULIAN, WCH, 4/11/94. 
C     ENHANCE ERROR MESSAGE FOR MIS-MATCH OF INPUT NODES, WCH, 11/10/94. 
C     ADD PRINT-OUT FOR K2 INPUT LOCATION LIST AND CHECK FOR DUPLICATE 
C       LOCATIONS ON THAT LIST, WCH, 10/17/95. 
C     ALLOW MIS-MATCH OF INTERFACE FILE JUNCTIONS AND EXTRAN JUNCTIONS. 
C       EXTRAN WILL IGNORE INFLOW FROM UN-MATCHED JUNCTS, WCH, 10/17/95. 
C     COMPUTE CORRECT TIME DISPLACEMENT FOR EXTRAN STARTING DATE/TIME 
C       WHEN USING HOT START WITH INTERFACE FILE, WCH, 7/25/96. 
C     SET INITIAL DATE (IDATEZ) TO B1-LINE VALUE (IDATZ) IF 
C       IDATZ ENTERED AS NEGATIVE NUMBER, WCH, 11/12/99. 
C     IMPROVE ERROR CHECK AND MESSAGES FOR K_ LINES 9/8/00 CIM 
C     ADD ERROR MESSAGE FOR NTIDE = 4.  WCH, 3/26/01. 
C     ALSO USE B1 TZERO IF NEGATIVE IDATZ, RED, 5/7/01. 
C	ERROR MESSAGE FOR INCOMPATIBLE $ANUM. WCH, 4/18/02. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'WEIR.INC' 
      INCLUDE 'BND.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'TIDE.INC' 
      INCLUDE 'HYFLOW.INC' 
CIM  NEW COMMON FOR WRITING OF RESULTS TO ASCII FILE 
      INCLUDE 'CWRITE.INC' 
CIM 
      DIMENSION LOCNOS(NIE) 
      CHARACTER KSW(NEH)*10,KOCNOS(NIE)*10 
C====================================================================== 
C     Read tidal boundary data on data gouups J1-J4. 
C====================================================================== 
      M2S2      = 0 
      DO 1800 I = 1,NTE 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.NE.'J1') GO TO 1801 
      IF(I.EQ.1) WRITE(N6,5710) 
      READ(N5,*,ERR=888) CC,NTIDE(I) 
      M2S2 = M2S2 + 1 
C====================================================================== 
C     NTIDE = 1  NO CONTROL WATERSURFACE AT THE OUTFALLS 
C             2  OUTFALL CONTROL WATER SURFACE AT CONSTANT ELEVATION=A1 
C             3  TIDE COEFFICIENTS READ BY PROGRAM FROM INPUT FILE 
C             4  COMPUTE TIDE COEFFICIENTS 
cimtide 
C             5  Stage-time history of water surface elevations input 
C                by user on J3 line. 
C             6  Stage time histories of water surface elevation input 
C                on separate file (NSCRAT4) 
cimtide 
C====================================================================== 
      IF(NTIDE(I).EQ.1) WRITE(N6,5715) I 
      IF(NTIDE(I).EQ.2) THEN 
C J2 line 
             READ(N5,*,ERR=888) CC,A1(I) 
             IF(METRIC.EQ.1) WRITE(N6,5790) I,A1(I) 
             IF(METRIC.EQ.2) WRITE(N6,5791) I,A1(I) 
             PHLAGS(I) = 0.0 
             ENDIF 
      IF(NTIDE(I).EQ.3) THEN 
C J2 line 
         READ(N5,*,ERR=888) CC,A1(I),W(I),A2(I), 
     1                      A3(I),A4(I),A5(I),A6(I),A7(I) 
         WRITE(N6,5780) I,A1(I),A2(I),A3(I),A4(I),A5(I),A6(I),A7(I),W(I) 
         W(I)      = 2.0*3.14159/W(I) 
         PHLAGS(I) = 0.0 
         ENDIF 
C====================================================================== 
C     READ DATA GROUPS J2, J3 AND J4 
C====================================================================== 
      IF(NTIDE(I).EQ.4) THEN 
C J2 line 
         READ(N5,*,ERR=888) CC,A1(I),W(I) 
C J3 line 
         READ(N5,*,ERR=888) CC,KO,NI,NCHTID,DELTA 
         NUMTID(I)  = NI 
         IF(DELTA.LE.0.0) THEN 
                          IF(METRIC.EQ.1) DELTA = 0.005 
                          IF(METRIC.EQ.2) DELTA = 0.001524 
                          ENDIF 
C#### WCH, 4/1/93  INSERT CHECK ON NUMBER OF DATA POINTS. 
         IF(NI.GT.NTVAL) THEN 
           WRITE (N6,5707) I,NTIDE(I),NI,NTVAL 
           NSTOP = NSTOP + 1 
           ENDIF 
Cwch, 3/26/01.  If KO = 1 then NI should = 4 for Sub. TIDCF to work OK. 
         IF(KO.EQ.1.AND.NI.NE.4) THEN 
	     WRITE (N6,5708) I,NI 
	     NSTOP = NSTOP + 1 
	     ENDIF 
         DO 1765  K = 1,NI,5 
         J1         = K + 4 
         IF(J1.GT.NI) J1 = NI 
C J4 line 
 1765    READ(N5,*,ERR=888) CC,(TT(J),YY(J),J=K,J1) 
         CALL TIDCF(KO,NI,NCHTID,I,DELTA) 
         ENDIF 
C======================================================================= 
C        READ DOWNSTREAM BOUNDARY STAGE INFORMATION 
C        READ DATA GROUPS J3 AND J4 
C======================================================================= 
      IF(NTIDE(I).EQ.5) THEN 
C J3 line 
         READ(N5,*,ERR=888) CC,KO,NI,NCHTID 
C####################################################################### 
C  WCH, 4/1/93.  FIX J4 READ WITH NTIDE=5 TO READ 5 VALUES PER LINE, 
C                WITH LINE IDENTIFIER. 
C####################################################################### 
         IF(NI.GT.NTVAL) THEN 
           WRITE (N6,5707) I,NTIDE(I),NI,NTVAL 
           NSTOP = NSTOP + 1 
           ENDIF 
         DO 1770  K = 1,NI,5 
         J1 = K + 4 
         IF(J1.GT.NI) J1 = NI 
C J4 line 
 1770    READ(N5,*,ERR=888) CC,(STIDE(I,1,J),STIDE(I,2,J),J=K,J1) 
C 
         IF(NCHTID.EQ.1) THEN 
                   IF(METRIC.EQ.1) WRITE(N6,1780) I 
                   IF(METRIC.EQ.2) WRITE(N6,1785) I 
                   WRITE(N6,1790) (J,STIDE(I,1,J),STIDE(I,2,J),J=1,NI) 
                   ENDIF 
         NUMTID(I) = NI 
         PHLAGS(I) = 0.0 
         ENDIF 
cimtide 
C======================================================================= 
C        READ DOWNSTREAM BOUNDARY STAGE INFORMATION FROM SEPARATE FILE 
C        NTIDE = 6 
C        CALL INTIDEF TO INITIALIZE TIDE STUFF 
C======================================================================= 
      IF(NTIDE(I).EQ.6) CALL INTIDEF 
CIMTIDE 
 1800 CONTINUE 
 1801 CONTINUE 
C======================================================================= 
C     CHECK JTIDES ARRAY FOR BC'S NOT INPUT ON J1-J4 DATA GROUPS 
C======================================================================= 
      DO 1850 J = 1,NJ 
      IF(JTIDES(J).LE.M2S2) GO TO 1850 
cimtide 
      if(jtides(j).gt.10000) go to 1850 
cimtide 
      IF(JCE.EQ.0) THEN 
        WRITE(N6,1851)  JUN(J),JTIDES(J) 
      ELSE 
       WRITE(N6,1852) AJUN(J),JTIDES(J) 
      ENDIF 
      NSTOP     = NSTOP + 1 
 1850 CONTINUE 
C======================================================================= 
C     SET PRINT : PLOT ARRAYS IN INTERNAL NUMBER SYSTEM 
C======================================================================= 
      IF(NQPRT.GT.0) THEN 
               DO 1550 K = 1,NQPRT 
               DO 1540 N = 1,NTL 
               IF(JCE.EQ.0.AND.NCOND(N).EQ.CPRT(K))   GO TO 1545 
               IF(JCE.EQ.1.AND.ACOND(N).EQ.AOUT(K,2)) GO TO 1545 
 1540          CONTINUE 
               IF(JCE.EQ.0) THEN 
                 WRITE(N6,5678) CPRT(K) 
               ELSE 
                 WRITE(N6,5679) AOUT(K,2) 
               ENDIF 
               NSTOP   = NSTOP+1 
 1545          CPRT(K) = N 
 1550          CONTINUE 
               ENDIF 
C======================================================================= 
      IF(LPLT.GT.0) THEN 
                    DO 1620 K = 1,LPLT 
                    DO 1580 N = 1,NTL 
                    IF(JCE.EQ.0.AND.NCOND(N).EQ.KPLT(K))   GO TO 1600 
                    IF(JCE.EQ.1.AND.ACOND(N).EQ.AOUT(K,4)) GO TO 1600 
 1580               CONTINUE 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5680) KPLT(K) 
                    ELSE 
                      WRITE(N6,5681) AOUT(K,4) 
                    ENDIF 
                    NSTOP = NSTOP+1 
                    GO TO 1620 
 1600               KPLT(K) = N 
 1620               CONTINUE 
                    ENDIF 
C======================================================================= 
      IF(NHPRT.GT.0) THEN 
                     DO 1660 I = 1,NHPRT 
                     DO 1650 J = 1,NJ 
                     IF(JCE.EQ.0.AND.JUN(J).EQ.JPRT(I))    GO TO 1655 
                     IF(JCE.EQ.1.AND.AJUN(J).EQ.AOUT(I,1)) GO TO 1655 
 1650                CONTINUE 
                     IF(JCE.EQ.0) THEN 
                      WRITE(N6,5690) JPRT(I) 
                     ELSE 
                      WRITE(N6,5691) AOUT(I,1) 
                     ENDIF 
                     NSTOP   = NSTOP+1 
 1655                JPRT(I) = J 
 1660                CONTINUE 
                     ENDIF 
C======================================================================= 
      IF(NPLT.GT.0) THEN 
                    DO 1720 N = 1,NPLT 
                    DO 1680 J = 1,NJ 
                    IF(JCE.EQ.0.AND.JUN(J).EQ.JPLT(N)) GO TO 1700 
                    IF(JCE.EQ.1.AND.AJUN(J).EQ.AOUT(N,3)) GO TO 1700 
 1680               CONTINUE 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5700) JPLT(N) 
                    ELSE 
                      WRITE(N6,5701) AOUT(N,3) 
                    ENDIF 
                    NSTOP = NSTOP+1 
                    GO TO 1720 
 1700               JPLT(N) = J 
 1720               CONTINUE 
                    ENDIF 
C======================================================================= 
      IF(NSURF.GT.0) THEN 
                     DO 1730 K = 1,NSURF 
                     DO 1740 N = 1,NTL 
                     IF(JCE.EQ.0.AND.NCOND(N).EQ.JSURF(K))  GO TO 1735 
                     IF(JCE.EQ.1.AND.ACOND(N).EQ.AOUT(K,5)) GO TO 1735 
 1740                CONTINUE 
                     IF(JCE.EQ.0) THEN 
                       WRITE(N6,5705) JSURF(K) 
                     ELSE 
                       WRITE(N6,5706) AOUT(K,5) 
                     ENDIF 
                     NSTOP = NSTOP+1 
                     GO TO 1730 
 1735                JSURF(K) = N 
 1730                CONTINUE 
                     ENDIF 
C======================================================================= 
CIM WRITING OF RESULTS TO ASCII FILE 
CIM  FIRST FIND CONDUIT NUMBER FOR ALL FLOWOUT OR AFLWOUT 
      IF(NOFLOW.GT.0) THEN 
                     DO 1751 K = 1,NOFLOW+NOFDUP 
                     DO 1750 N = 1,NTL 
                     IF(JCE.EQ.0.AND.NCOND(N).EQ.FLOWOUT(K))  GO TO 1755 
                     IF(JCE.EQ.1.AND.ACOND(N).EQ.AFLWOUT(K))  GO TO 1755 
 1750                CONTINUE 
                     IF(JCE.EQ.0) THEN 
                       WRITE(N6,5805) FLOWOUT(K) 
                     ELSE 
                       WRITE(N6,5806) AFLWOUT(K) 
                     ENDIF 
                     NSTOP = NSTOP+1 
                     GO TO 1751 
 1755                FLOWOUT(K) = N 
 1751                CONTINUE 
CIM NOW FIND REFERENCE FOR DUPLICATES 
                     DO 1760 K =1,NOFDUP 
                     DO 1761 N = 1,NOFLOW 
                     NN = FLOWOUT(N) 
CIM                  WRITE(N6,*) K,N,NN,ACOND(NN),AFLOWREF(K) 
                     IF (JCE.EQ.0.AND.NCOND(NN).EQ.FLOWREF(K)) 
     1                             GO TO 1766 
                     IF (JCE.EQ.1.AND.ACOND(NN).EQ.AFLOWREF(K)) 
     1                             GO TO 1766 
 1761                CONTINUE 
                     IF (JCE.EQ.0) THEN 
                       WRITE(N6,6807) FLOWREF(K),K 
                     ELSE 
                       WRITE(N6,6808) AFLOWREF(K),K 
                     ENDIF 
                     NSTOP = NSTOP + 1 
                     GO TO 1760 
 1766                FLOWREF(K) = N 
 1760                CONTINUE 
                     ENDIF 
CIM END 
C====================================================================== 
C     Conduit roughness initialization. 
C====================================================================== 
      DO 1820 N = 1,NTC 
 1820 ROUGH(N)  = GRVT*ROUGH(N)**2/CMET(9,METRIC)**2 
C====================================================================== 
C     Hydrograph input initialization. 
C====================================================================== 
      DO 1840  L = 1,NIE 
      DO 1840 K  = 1,2 
 1840 QTAPE(L,K) = 0.0 
      DO 1841  L = 1,NEH 
      JSW(L)     = 0 
      DO 1841  K = 1,2 
 1841 QCARD(L,K) = 0.0 
C====================================================================== 
C     Read input hydrograph information (disk file). 
C====================================================================== 
      LOCATS = 0 
      TIMDAY = TZERO 
C#### WCH, 4/11/94.  CODE TO CONVERT INITIAL YR/MO/DAY TO JULIAN. 
CWCH, 11/12/99. USE B1-LINE IDATZ IF ENTERED AS NEGATIVE NUMBER. 
	IISIGN = ISIGN(1,IDATZ) 
	IDATZ  = IABS(IDATZ) 
      MYEAR  = IDATZ/10000 
      MDAY   = IDATZ - MYEAR*10000 
      MMNTH  = MDAY/100 
      MDAY   = MDAY - MMNTH*100 
      IF (MYEAR.LT.100) MYEAR = MYEAR+1900 
      JULDAY = 1000*MYEAR + JDATE(MDAY,MMNTH,MYEAR) 
      IDATEZ = JULDAY 
	IDATZ  = IDATEZ 
C####     JULDAY = 88001 
C 
      IF(LAST.GT.0) THEN 
C#### WCH, 7/25/96. 
                    TZEROX = TZERO 
                    CALL INFACE(1,LAST) 
C======================================================================= 
Cwch, 4/18/02.  Add error check for incompatible JCE. 
C	Allow program to continue but warn of impending error.  
C======================================================================= 
                    IF(NJCE.NE.JCE) THEN 
	                   WRITE(N6,4005)  
	                   WRITE(*,4005) 
	    ENDIF 
C####################################################################### 
C#### WCH, 7/25/96.  ALWAYS START AT DATE GIVEN ON INTERFACE 
C     FILE, PLUS TZERO (HOURS) GIVEN ON LINE B1. 
C======================================================================= 
c                    IF(JREDO.EQ.1.OR.JREDO.EQ.3) THEN 
cim doesn't this next line double count TZERO??? 
Cim                       TZEROS = TZEROX + TZERO 
                         TZEROS = TZEROX 
                         TIMDAY = TZERO 
CWCH, 11/12/99. USE B1-LINE IDATZ IF ENTERED AS NEGATIVE NUMBER. 
cred            also use the B1 line for the starting time of the 
cred            day and not the interface starting time if the  
cred            date on line B1 is entered as a negative - 5/7/01 
					   IF(IISIGN.LT.0) THEN 
					     IDATEZ = IDATZ 
	                     TZEROS = TZEROX 
                           TIMDAY = TZEROX 
	                     ENDIF 
                         JULDAY = IDATEZ 
C======================================================================= 
C     NDATE computes new Julian date (JDAY) and time of day (TMDAY, sec) 
C     by adding TZEROS (sec) to current Julian date (JULDAY) and time 
C     of day (TIMDAY, sec). 
C======================================================================= 
                         CALL NDATE(TZEROS,JDAY,TMDAY) 
                         JULDAY = JDAY 
                         TIMDAY = TMDAY 
C======================================================================= 
C     DATED computes year, month, day etc. from current Julian day and 
C     time of day. 
C======================================================================= 
                         CALL DATED 
                         WRITE(N6,5815) JULDAY,NYEAR,MONTH,NDAY, 
     +                      TIMDAY/3600.,TZEROX/3600. 
c                         ELSE 
c                         TIMDAY = TZERO 
c                         JULDAY = IDATEZ 
ccim add call to dated 
c                         CALL DATED 
c                         ENDIF 
C====================================================================== 
C                   CONVERT TO INTERNAL NUMBERS 
C====================================================================== 
                    DO 1920 L = 1,LOCATS 
                    DO 1880 J = 1,NJ 
                    IF(JCE.EQ.0.AND.NLOC(L).EQ.JUN(J)) GO TO 1900 
                    IF(JCE.EQ.1.AND.KAN(L).EQ.AJUN(J)) GO TO 1900 
 1880               CONTINUE 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5820) NLOC(L) 
                    ELSE 
                      WRITE(N6,5821) KAN(L) 
                    ENDIF 
C#### WCH, 10/17/95.  CHANGE TO WARNING IF NO MATCH. 
C####                    NSTOP   = NSTOP + 1 
                    NLOC(L) = 0 
                    GO TO 1920 
 1900               NLOC(L) = J 
 1920               CONTINUE 
                    ENDIF 
      write(n6,*) ' TZERO = ',JULDAY,timday 
C====================================================================== 
C     Read input hydrograph data (lines) on data groups K1-K3. 
C====================================================================== 
      IF(NJSW.GT.0) THEN 
C====================================================================== 
C    >>>>>>>>>>>>> READ LINE K1 <<<<<<<<<<<<<<<<< 
C====================================================================== 
                    READ(N5,*,ERR=888) CC,NINC 
CIM### 9/8/00   ADD CHECK FOR K1 LINE 
      IF (CC.NE.'K1') THEN 
      NSTOP = NSTOP + 1 
CIM   5/15/2000 Improve error statment 
      WRITE(N6,6000) CC 
      ENDIF 
C#### WCH, 10/17/95.  ADD PRINT OF NINC. 
                    WRITE(N6,5064) NINC 
                    DO 1970  L = 1,NJSW,NINC 
                                   L1 = L + NINC - 1 
                    IF(L1.GT.NJSW) L1 = NJSW 
C====================================================================== 
C    >>>>>>>>>>>>> READ DATA GROUP K2 <<<<<<<<<<<<< 
C====================================================================== 
                    IF(JCE.EQ.0) THEN 
                                 READ(N5,*,ERR=888) CC,(JSW(LL),LL=L,L1) 
                    ELSE 
                                 READ(N5,*,ERR=888) CC,(KSW(LL),LL=L,L1) 
                    ENDIF 
CIM### 9/8/00      ADD CHECK FOR K2 LINE 
      IF (CC.NE.'K2') THEN 
      NSTOP = NSTOP + 1 
CIM   5/15/2000 Improve error statment 
      WRITE(N6,6010) CC 
      ENDIF 
 1970 CONTINUE 
CIM### 9/8/00     NEXT LINE SHOULD BE K3 CHECK IT 
      READ(N5,*) CC 
      BACKSPACE (N5) 
      IF (CC.NE.'K3') THEN 
      NSTOP = NSTOP + 1 
CIM   5/15/2000 Improve error statment 
      WRITE(N6,6020) CC 
      ENDIF 
C####################################################################### 
C#### WCH, 10/17/95.  PRINT K2 INPUT LOCATIONS AND CHECK FOR DUPLICATE 
C     LOCATIONS.  DO NOT ALLOW IDENTICAL LOCATION TO BE INPUT TWICE, 
C     CONTRARY TO USER'S MANUAL INSTRUCTIONS, P. 30. 
C======================================================================= 
                    IF(JCE.EQ.0) THEN 
                        WRITE (N6,5065) (JSW(L),L=1,NJSW) 
                    ELSE 
                        WRITE (N6,5066) (KSW(L),L=1,NJSW) 
                    ENDIF 
                    IF(NJSW.GT.1) THEN 
                         NJSWW = NJSW - 1 
                         DO 1975 K = 1,NJSWW 
                         LL = K + 1 
                         DO 1975 L = LL,NJSW 
                         IF(JCE.EQ.0.AND.JSW(K).NE.JSW(L)) GO TO 1975 
                         IF(JCE.EQ.1.AND.KSW(K).NE.KSW(L)) GO TO 1975 
C======================================================================= 
C     HERE IF THERE IS A DUPLICATION OF NUMBERS. 
C======================================================================= 
                         IF(JCE.EQ.0) THEN 
                           WRITE(N6,5067) JSW(K) 
                         ELSE 
                           WRITE(N6,5068) KSW(K) 
                         ENDIF 
                         NSTOP = NSTOP + 1 
 1975                    CONTINUE 
                         ENDIF 
C 
                    WRITE(N6,2999) 
                    WRITE(N6,5060) ALPHA1,ALPHA2 
C====================================================================== 
C                   Convert to internal numbers 
C====================================================================== 
                    DO 2020 L = 1,NJSW 
                    DO 1980 J = 1,NJ 
                    IF(JCE.EQ.0.AND.JSW(L).EQ.JUN(J))  GO TO 2000 
                    IF(JCE.EQ.1.AND.KSW(L).EQ.AJUN(J)) GO TO 2000 
 1980               CONTINUE 
                    IF(JCE.EQ.0) THEN 
                      WRITE(N6,5820) JSW(L) 
                    ELSE 
                      WRITE(N6,5821) KSW(L) 
                    ENDIF 
                    NSTOP  = NSTOP + 1 
                    GO TO 2020 
 2000               JSW(L) = J 
 2020               CONTINUE 
                    ENDIF 
C====================================================================== 
C     Determine outflow nodes. 
C====================================================================== 
      IF(NEXT.GT.0) THEN 
                    N1        = NTC + 1 
                    I         = 0 
                    DO 2045 N = N1,NTL 
                    IF(NJUNC(N,2).NE.0) GO TO 2045 
                    I         = I + 1 
                    IF(JCE.EQ.0) THEN 
                      LOCNOS(I) = JUN(NJUNC(N,1)) 
                    ELSE 
                      KOCNOS(I) = AJUN(NJUNC(N,1)) 
                    ENDIF 
 2045               CONTINUE 
                    MJSW    = I 
                    IF(MJSW.GT.NIE) WRITE(N6,5850) 
                    IF(MJSW.EQ.0) NSTOP = NSTOP + 1 
                    ENDIF 
C====================================================================== 
C     Write file headers for output hydrograph. 
C====================================================================== 
      IF(NEXT.GT.0) THEN 
C#### RED, 5/12/93. GIVE EXTRAN A NON-ZERO INITIAL DATE. 
C#### WCH, 4/11/94. 88001 IS DEFAULT ONLY IF NO USER-SUPPLIED VALUE. 
C#### WCH                    IF(LAST.EQ.0) IDATEZ = 88001 
                    REWIND NEXT 
                    NPOLL = 0 
                    WRITE(NEXT) MJSW,NPOLL 
                    IF(JCE.EQ.0) THEN 
                      WRITE(NEXT) (LOCNOS(I),I=1,MJSW) 
                    ELSE 
                      WRITE(NEXT) (KOCNOS(I),I=1,MJSW) 
                    ENDIF 
                    SOURCE = 'EXTRAN BLOCK' 
                    QQCONV = QCONV 
                    QCONV  = CMET(8,METRIC) 
                    TITLE(3) = ALPHA1 
                    TITLE(4) = ALPHA2 
                    CALL INFACE(2,NEXT) 
                    QCONV    = QQCONV 
                    ENDIF 
CIM### 9/8/00 
cim  move opening of NFOUT to here.  6/20000 
                    IF (IFLBIN.EQ.1) THEN 
cim here if IFLBIN = 1 
                          CLOSE(NFOUT,STATUS='DELETE') 
                          OPEN(NFOUT,FILE=FFNAME(53),FORM='UNFORMATTED', 
     +                        STATUS='UNKNOWN') 
C======================================================================= 
C     Write file headers for output hydrograph. 
C======================================================================= 
                         REWIND NFOUT 
                         NPOLL = 0 
                         WRITE(NFOUT) NOFLOW+NOFDUP,NPOLL 
                         IF(JCE.EQ.0) THEN 
                           WRITE(NFOUT) (FLOWOUT(N),N=1,NOFLOW+NOFDUP) 
                         ELSE 
                           WRITE(NFOUT) (AFLWOUT(N),N=1,NOFLOW+NOFDUP) 
                         ENDIF 
                         SOURCE = 'EXTRAN BLOCK' 
                         QQCONV = QCONV 
                         QCONV  = CMET(8,METRIC) 
                         TITLE(3) = ALPHA1 
                         TITLE(4) = ALPHA2 
                         CALL INFACE(2,NFOUT) 
                         QCONV    = QQCONV 
                         ENDIF 
      IF(NSTOP.GT.0) THEN 
                     WRITE(N6,5920) NSTOP 
                     STOP 
                     ENDIF 
C 
C====================================================================== 
 1780 FORMAT(/, 
     +' ******************************************',/, 
     +' *  DOWNSTREAM BOUNDARY STAGE INFORMATION *',/, 
     +' *  FOR BOUNDARY CONDITION # ',I5,'.       *',/, 
     +' ******************************************',//, 
     +'  NO.  TIME(HR) STAGE(FT)  NO.  TIME(HR) STAGE(FT)  NO.  TIME(HR) 
     + STAGE(FT)',/, 
     +'  ---  -------- --------   ---  -------- ---------  ---  -------- 
     + ---------') 
 1785 FORMAT(/, 
     +' ******************************************',/, 
     +' *  DOWNSTREAM BOUNDARY STAGE INFORMATION *',/, 
     +' *  FOR BOUNDARY CONDITION # ',I5,'.       *',/, 
     +' ******************************************',//, 
     +'  NO.  TIME(HR) STAGE (M)  NO.  TIME(HR) STAGE (M)  NO.  TIME(HR) 
cred99 STAGE(FT)',/,  - wrong label - 9/9/99 
     + STAGE (M)',/, 
     +'  ---  -------- --------   ---  -------- ---------  ---  -------- 
     + ---------') 
 1790 FORMAT(3(I5,F10.2,F10.3)) 
 1851 FORMAT(/,' ===> ERROR   JUNCTION ',I10,' HAD A BOUNDARY ',/, 
     +         ' CONDITION # (',I5,') NOT INPUT ON DATA GROUPS J1-J4') 
 1852 FORMAT(/,' ===> ERROR   JUNCTION ',A10,' HAD A BOUNDARY ',/, 
     +         ' CONDITION # (',I5,') NOT INPUT ON DATA GROUPS J1-J4') 
 2999 FORMAT(/, 
     1       '1',40(2H--)/' ','ENVIRONMENTAL PROTECTION AGENCY',13X,40H* 
     2***   EXTENDED TRANSPORT PROGRAM   ****,8X,'WATER RESOURCES DIVISI 
     3ON',/,' ','WASHINGTON, D.C.            ',16X,4H****,32X,4H****,8X, 
     4'CAMP DRESSER & MCKEE INC.',/,' ','                ',28X,4H****, 
     56X,'   ANALYSIS MODULE  ',6X,4H****,8X,'ANNANDALE, VIRGINIA') 
Cwch, 4/18/02. 
 4005 FORMAT(/,' ERROR SAME ALPHANUMERIC OPTION ($ANUM) WAS NOT USED IN 
     1 EXTRAN',/,' AS IN BLOCK THAT CREATED INTERFACE FILE.',/, 
	2' PROGRAM CONTINUES BUT UNPREDICTABLE ERROR WILL SOON RESULT.') 
 5060 FORMAT(/,5X,A80,/,5X,A80,/) 
C#### WCH, 10/17/95.  FIVE NEW FORMAT STATEMENTS. 
 5064 FORMAT (/, 
     1' **************************************************',/, 
     2' *   LINE-INPUT HYDROGRAPHS (DATA GROUPS K1-K3)   *',/, 
     3' *                                                *',/, 
     4' *    Expect ',I3,' junction IDs on each K2 line.    *',/, 
     5' **************************************************') 
 5065 FORMAT (/,' NJSW INPUT LOCATIONS FROM K2 LINES:',/,(8(I10,1X))) 
 5066 FORMAT (/,' NJSW INPUT LOCATIONS FROM K2 LINES:',/,(8(A10,1X))) 
 5067 FORMAT (/,' *** ERROR  INPUT LOCATION ',I10,' IS DUPLICATED LATER 
     1 IN K2 LIST.',/,' ALLOW LOCATION TO BE USED ONLY ONCE.  PROGRAM WI 
     2LL STOP BELOW.') 
 5068 FORMAT (/,' *** ERROR  INPUT LOCATION ',A10,' IS DUPLICATED LATER 
     1 IN K2 LIST.',/,' ALLOW LOCATION TO BE USED ONLY ONCE.  PROGRAM WI 
     2LL STOP BELOW.') 
C#### WCH, 7/25/96. 
 5815 FORMAT(/,' >>> STARTING DATE AND TIME OF EXTRAN RUN ARE:',/, 
     2' JULIAN DATE:',I8,/, 
     3' YR/MO/DA:   ',I4,'/',I2,'/',I2,/, 
     4' TIME OF DAY:',F7.3,' HRS',/, 
     5' THIS IS',F7.3,' HOURS BEYOND INTERFACE FILE STARTING TIME',/, 
     6' AS PROVIDED BY TZERO ON LINE B1.') 
 5678 FORMAT(/,' ====> ERROR  CONDUIT',I10, 
     1' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN CONDUIT DATA') 
 5679 FORMAT(/,' ====> ERROR  CONDUIT ',A10, 
     1     ' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN CONDUIT DATA') 
 5680 FORMAT(/,' ====> ERROR  CONDUIT ',I10, 
     1' REQUESTED FOR PLOTTING IS NOT CONTAINED IN CONDUIT DATA') 
 5681 FORMAT(/,' ====> ERROR  CONDUIT ',A10, 
     1     ' REQUESTED FOR PLOTTING IS NOT CONTAINED IN CONDUIT DATA') 
 5690 FORMAT(/,' ====> ERROR  JUNCTION ',I10, 
     1     ' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN JUNCTION DATA') 
 5691 FORMAT(/,' ====> ERROR  JUNCTION ',A10, 
     1 ' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN JUNCTION DATA') 
 5700 FORMAT(/,' ====> ERROR  JUNCTION ',I10, 
     1  ' REQUESTED FOR PLOTTING IS NOT CONTAINED IN JUNCTION DATA') 
 5701 FORMAT(/,' ====> ERROR  JUNCTION ',A10, 
     1  ' REQUESTED FOR PLOTTING IS NOT CONTAINED IN JUNCTION DATA') 
 5705 FORMAT(/,' ====> ERROR  CONDUIT ',I10, 
     1' REQUESTED FOR PLOTTING WATER SURFACE SLOPE IS NOT CONTAINED', 
     2' IN CONDUIT DATA') 
 5706 FORMAT(/,' ====> ERROR  CONDUIT ',A10, 
     1' REQUESTED FOR PLOTTING WATER SURFACE SLOPE IS NOT CONTAINED', 
     2' IN CONDUIT DATA') 
CIM WRITING OF FLOW TO FILE 
 5805 FORMAT(/,' ====> ERROR  CONDUIT ',I10, 
     1' REQUESTED FOR WRITING OF FLOWS TO ASCII FILE IS NOT CONTAINED', 
     2' IN CONDUIT DATA') 
 5806 FORMAT(/,' ====> ERROR  CONDUIT ',A10, 
     1' REQUESTED FOR WRITING OF FLOWS TO ASCII FILE IS NOT CONTAINED', 
     2' IN CONDUIT DATA') 
6807  FORMAT(/,' ====> ERROR  REFERENCE CONDUIT ',I10, 
     1' IS NOT CONTAINED IN CONDUITS REQUESTED ON B9 LINE FOR', 
     2' DUPLICATE CONDUIT NUMBER ',I10) 
6808  FORMAT(/,' ====> ERROR  REFERENCE CONDUIT ',A10, 
     1' IS NOT CONTAINED IN CONDUITS REQUESTED ON B9 LINE FOR', 
     2' DUPLICATE CONDUIT NUMBER ',I10) 
CIM END 
 5707 FORMAT(/,' ====> ERROR  FOR BOUNDARY CONDITION NO. ',I3, 
     1' AND NTIDE = ',I2,':',/,' NI =',I4,' TIME/STAGE POINTS GREATER TH 
     2AN NTVAL = ',I3, 'ALLOWED.  NTVAL VALUE SET IN TAPES.INC') 
Cwch, 3/26/01 
 5708 FORMAT(/,' ====> ERROR  FOR BOUNDARY CONDITION NO. ',I3,/, 
     1' FOR NTIDE = 4 AND KO = 1, SHOULD HAVE NI = 4.  ACTUAL NI =',I4, 
	2/,' ENTER ONLY 4 TIME-STAGE PAIRS FOR THIS CASE.  ELSE, USE KO = 0 
	3.') 
 5710 FORMAT(1H1,/, 
     +' *****************************************************',/, 
     +' *        BOUNDARY CONDITON INFORMATION              *',/, 
     +' *                 DATA GROUPS J1-J4                 *',/, 
     +' *****************************************************',//) 
 5715 FORMAT(/,' BC NUMBER..',I10, 
     +         ' HAS NO CONTROL WATER SURFACE.') 
 5780 FORMAT(/, 
     +' ******************************************',/, 
     +' *     USER SUPPLIED TIDAL COEFFICIENTS   *',/, 
     +' *  FOR BOUNDARY CONDITION # ',I5,'.       *',/, 
     +' ******************************************',/, 
     +' TIDAL COEFFICIENTS.........',7F10.4, 
     +' TIDAL PERIOD (HOURS).......',F10.2) 
 5790 FORMAT(/,' BC NUMBER..',I10, 
     +         ' CONTROL WATER SURFACE ELEVATION IS..',F10.2,' FEET.') 
 5791 FORMAT(/,' BC NUMBER..',I10, 
     +         ' CONTROL WATER SURFACE ELEVATION IS..',F10.2,' METERS.') 
C#### WCH, 11/10/94.  ENHANCE ERROR MESSAGES IN 5820 AND 5821. 
C#### WCH, 10/17/95.  CHANGE 5220,5821 ERROR MESSAGES TO WARNING MESGS. 
 5820 FORMAT(/,' ==> WARNING  PROGRAM CANNOT MATCH HYDROGRAPH AT NODE 
     1',   I10,' TO JUNCTION',/,' DATA.  EXTRAN WILL IGNORE INFLOW FROM 
     2THIS JUNCTION AND CONTINUE SIMULATION.') 
 5821 FORMAT(/,' ==> WARNING  PROGRAM CANNOT MATCH HYDROGRAPH AT NODE 
     1',   A10,' TO JUNCTION',/,' DATA.  EXTRAN WILL IGNORE INFLOW FROM 
     2THIS JUNCTION AND CONTINUE SIMULATION.') 
 5830 FORMAT(3X,I5,'/',F7.2,7(3X,I5,'/',F7.2)) 
 5850 FORMAT(/,' ====> ERROR  MORE THAN NIE OUTFALL JUNCTIONS.') 
 5920 FORMAT(//,' ====> ERROR  EXECUTION TERMINATED BECAUSE OF ', 
     *I3,' DATA ERROR(S).') 
CIM### 9/8/00 CHECK FOR K1,K2,AND K3 
CIM   5/15/2000 Improve error statment 
 6000 FORMAT(/,' ====> ERROR  DID NOT FIND K1 LINE',/, 
     a         '       Program was looking for a K1 line but found a', 
     b' line that starts with ',a2,/, 
     c         '       instead.  Error probably occurs in earlier', 
     d' data lines.') 
 6010 FORMAT(/,' ====> ERROR  DID NOT FIND K2 LINE',/, 
     a         '       Program was looking for a K2 line but found a', 
     b' line that starts with ',a2,/, 
     c         '       instead.  Error probably occurs in earlier', 
     d' data lines.') 
 6020 FORMAT(/,' ====> ERROR  DID NOT FIND K3 LINE',/, 
     a         '       Program was looking for a K3 line but found a', 
     b' line that starts with ',a2,/, 
     c         '       instead.  Error probably occurs in earlier', 
     d' data lines.') 
C======================================================================= 
      RETURN 
 888  CALL IERROR 
      END 
 
REM File: INFACE.FOR 
 
      SUBROUTINE INFACE(IDO,NTAPE) 
C     USED BY ALL BLOCKS TO WRITE/READ INTERFACE FILE 
C======================================================================= 
C     This subroutine reads or writes the header information 
C     for a SWMM interface file.  Created FEBRUARY, 1987 
C     by Robert E. Dickinson.  Last updated December, 1990. 
C     Updated 4/13/93 by WCH for minor format change. 
C     Added and updated error messages, WCH, 9/8/93 and 11/23/93. 
C     Alter IOSTAT number for Lahey, WCH, 8/4/95. 
C     Check number of interface locations against array dimension, 
C     CIM 9/8/00 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      CHARACTER KJN*10 
      DIMENSION JN(NIE),KJN(NIE) 
C======================================================================= 
C     Read interface headers. 
C======================================================================= 
      IF(IDO.EQ.0) THEN 
           REWIND NTAPE 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(1) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(2) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) IDATEZ,TZERO 
           IYRZ = IDATEZ/1000 
           IF (IYRZ.LT.100) THEN 
           IDATEZ = IDATEZ - IYRZ*1000 
           IYRZ = IYRZ + 1900 
           IDATEZ = IDATEZ + IYRZ*1000 
           ENDIF 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(3) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(4) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) SOURCE,LOCATS, 
     1        NQUAL,TRIBA,NJCE 
           IF(NJCE.EQ.0)READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1        (NLOC(I),I=1,LOCATS) 
           IF(NJCE.EQ.1)READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1        (KAN(I),I=1,LOCATS) 
           IF(NQUAL.GT.0) THEN 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (PNAME(J),J=1,NQUAL) 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (PUNIT(J),J=1,NQUAL) 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (NDIM(J),J=1,NQUAL) 
                ENDIF 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) QCONV 
           ENDIF 
C======================================================================= 
C     Read and write interface headers. 
C======================================================================= 
      IF(IDO.EQ.1) THEN 
           REWIND NTAPE 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(1) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(2) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) IDATEZ,TZERO 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(3) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(4) 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) SOURCE,LOCATS, 
     1        NQUAL,TRIBA,NJCE 
           WRITE(N6,1)  TITLE(1),TITLE(2) 
           WRITE(N6,2)  TITLE(3),TITLE(4) 
           WRITE(N6,3)  SOURCE 
           IYRZ = IDATEZ/1000 
           IF (IYRZ.LT.100) THEN 
           IDATEZ = IDATEZ - IYRZ*1000 
           IYRZ = IYRZ + 1900 
           IDATEZ = IDATEZ + IYRZ*1000 
           ENDIF 
           WRITE(N6,4)  IDATEZ,TZERO 
           WRITE(N6,5)  LOCATS,NQUAL,TRIBA,NJCE 
C======================================================================= 
C     Read sequence of location numbers. 
C======================================================================= 
           IF(NJCE.EQ.0) THEN 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (NLOC(I),I=1,LOCATS) 
                WRITE(N6,6) (NLOC(I),I=1,LOCATS) 
                ELSE 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (KAN(I),I=1,LOCATS) 
                WRITE(N6,66) (KAN(I),I=1,LOCATS) 
                ENDIF 
           IF(NQUAL.GT.0) THEN 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (PNAME(J),J=1,NQUAL) 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (PUNIT(J),J=1,NQUAL) 
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1             (NDIM(J),J=1,NQUAL) 
                WRITE(N6,7) (J,PNAME(J),PUNIT(J),NDIM(J),J=1,NQUAL) 
                ENDIF 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  QCONV 
           WRITE(N6,8)                   QCONV 
           ENDIF 
C======================================================================= 
C     Write interface headers. 
C======================================================================= 
      IF(IDO.EQ.2) THEN 
           REWIND NTAPE 
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) NEWOUT,NPOLL 
CIM###  Check that NEWOUT doesn't exceed NIE  6/16/2000 
      IF (NEWOUT.GT.NIE) THEN 
      WRITE(*,7000) NEWOUT,NIE 
      WRITE(N6,7000) NEWOUT,NIE 
      STOP 
      ENDIF 
CIM### 
           IF(JCE.EQ.0) READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1        (JN(I),I=1,NEWOUT) 
           IF(JCE.EQ.1) READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) 
     1        (KJN(I),I=1,NEWOUT) 
           REWIND NTAPE 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(1) 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(2) 
           IYRZ = IDATEZ/1000 
           IF (IYRZ.LT.100) THEN 
           IDATEZ = IDATEZ - IYRZ*1000 
           IYRZ = IYRZ + 1900 
           IDATEZ = IDATEZ + IYRZ*1000 
           ENDIF 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) IDATEZ,TZERO 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(3) 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(4) 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) SOURCE,NEWOUT,NPOLL,TRIBA,JCE 
           IF(JCE.EQ.0) WRITE(NTAPE,ERR=998,IOSTAT=IOS) 
     1        (JN(I),I=1,NEWOUT) 
           IF(JCE.EQ.1) WRITE(NTAPE,ERR=998,IOSTAT=IOS) 
     1        (KJN(I),I=1,NEWOUT) 
           IF(NPOLL.GT.0) THEN 
                WRITE(NTAPE,ERR=998,IOSTAT=IOS) (PNAME(J),J=1,NPOLL) 
                WRITE(NTAPE,ERR=998,IOSTAT=IOS) (PUNIT(J),J=1,NPOLL) 
                WRITE(NTAPE,ERR=998,IOSTAT=IOS) (NDIM(J),J=1,NPOLL) 
                ENDIF 
           WRITE(NTAPE,ERR=998,IOSTAT=IOS)   QCONV 
           ENDIF 
      RETURN 
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY. 
  998 WRITE(N6,1998) NTAPE,FFNAME(IOUTCT+25),MOD(IOS,256) 
      STOP 
  999 WRITE(N6,1999) NTAPE,FFNAME(INCNT),MOD(IOS,256) 
      STOP 
C#### WCH, 9/8/93 
 2000 WRITE(N6,2010) NTAPE,FFNAME(INCNT) 
      WRITE(*,2010)  NTAPE,FFNAME(INCNT) 
      STOP 
C======================================================================= 
1     FORMAT(//, 
     1' ###########################################',/, 
     2' # Header information from interface file: #',/, 
     3' ###########################################',//, 
     4 ' Title from first computational block:',/,1X,A80,/,1X,A80) 
2     FORMAT(/,' Title from immediately preceding computational block:', 
     1 /,1X,A80,/,1X,A80) 
3     FORMAT(/, 
     1 ' Name of preceding block:................',A20) 
4     FORMAT( 
     1 ' Initial Julian date (IDATEZ)......................',I8,/, 
     2 ' Initial time of day in seconds (TZERO)............',F8.1) 
C#### WCH, 4/13/93.  VERY MINOR FORMAT CHANGE FOR AREA. 
5     FORMAT(' No. transfered input locations....................',I8,/, 
     1       ' No. transfered pollutants.........................',I8,/, 
     2       ' Size of total catchment area (acres)..............', 
     2 F10.2, 
     3     /,' ID numbers (JCE=0) or alphanumeric (JCE=1)........',I8) 
6     FORMAT(/,' #################################################',/, 
     1' # Element numbers of interface inlet locations: # ',/, 
     2' #################################################',/, 
     3(9(1X,I10))) 
7     FORMAT(/,' #########################################',/, 
     1' # Quality parameters on interface file: #',/, 
     2' #########################################',//, 
     3 ' No. Name      Units     Type of units',/, 
     4 ' --- ----      -----     -------------',/, 
     5 (1X,I2,2X,A8,2X,A8,I7)) 
8     FORMAT (/,' Conversion factor to cfs for flow units',/, 
     1           ' on interface file.  Multiply by: ',F11.5) 
   66 FORMAT(/,' #################################################',/, 
     1' # Element numbers of interface inlet locations: # ',/, 
     2' #################################################',/, 
     3(9(1X,A10))) 
C#### WCH, 11/23/93 
 1998 FORMAT(/,' ===> Error   Writing the interface file on unit # ', 
     1    I3,/,'      File name... ',A60,/, 
     2         '      Fortran error number =',I5,'. Run stopped.') 
 1999 FORMAT(/,' ===> Error   Reading the interface file on unit # ', 
     1    I3,/,'      File name... ',A60,/, 
     2         '      Fortran error number =',I5,'. Run stopped.') 
C#### WCH, 9/8/93. 
 2010 FORMAT(/,' ERROR.  End-of-file reached unexpectedly while reading 
     1header information on',/,' interface file on unit no.',I3, 
     2'. File name = ',A20,/,' Check to see that this file is the proper 
     3 interface file.  Run stopped.') 
CIM### 9/8/00 
 7000 FORMAT(/,' ERROR.  Number of locations for which data are to be', 
     a' written to interface',/,9X, 
     b'file exceeds maximum allowed by program dimensions.  Subdivide' 
     c,/,9X,'model or increase program dimensions.',/,9X, 
     d'Number of interface locations = ',I10,/,9X, 
     d'Maximum allowed (NIE)         = ',I10) 
C======================================================================= 
      END 
 
REM File: INFIL.FOR 
 
      SUBROUTINE INFIL 
C     TRANSPORT BLOCK 
C     CALLED BY INTRAN NEAR LINE 1191 
C======================================================================= 
C     ROUTINE TO INPUT INFILTRATION PARAMETERS AND CALCULATE 
C     INFILTRATION INPUT TO MANHOLES OR OTHER NON-CONDUITS. 
C     UPDATED SEPTEMBER 1981 BY W.C.H. 
C     UPDATED NOVEMBER 1988 BY R.E.D. 
C     UPDATED NOVEMBER 1992 BY WCH TO CORRECT METRIC CONVERSION 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'NAMES.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEW81.INC' 
      DIMENSION NDD(12),NDXDAY(380) 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP K1 <<<<<<<<<<<< 
C======================================================================= 
      READ (N5,*,ERR=888) CC,DINFIL,GINFIL,RINFIL,RSMAX, 
     +                      (CPINF(I),I=1,NPOLL) 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP K2 <<<<<<<<<<<< 
C======================================================================= 
      READ (N5,*,ERR=888) CC,(NDD(I),I=1,12) 
                      CMET3 = 1.0 
      IF(METRIC.EQ.2) CMET3 = 35.31 
      WRITE (N6,600) 
      IF(METRIC.EQ.1) WRITE(N6,601) DINFIL,GINFIL,RINFIL,RSMAX 
      IF(METRIC.EQ.2) WRITE(N6,602) DINFIL,GINFIL,RINFIL,RSMAX 
      IF(NPOLL.GT.0)  WRITE(N6,603) (I,PNAME(I),CPINF(I), 
     +                               PUNIT(I),I=1,NPOLL) 
      NDYUD = JULDAY - 1000*(JULDAY/1000) 
      WRITE (N6,606) (I,NDD(I),I=1,12) 
      SINFIL = 0.0 
      IF(GINFIL.GT.0.0) GO TO 50 
      IF(RSMAX.LE.0.0) GO TO 200 
C======================================================================= 
C     HERE, WILL USE DEGREE-DAYS TO CALC. RESIDUAL MOISTURE MELT. 
C     DEGREE DAYS IN DEG. F * DAYS ONLY (NO METRIC). 
C======================================================================= 
      MFREZ = 0 
      MLTBE = 0 
      MLTEN = 0 
C======================================================================= 
C     PLACE MONTHLY VALUES AT MIDDLE OF MONTH 
C======================================================================= 
      II            = 0 
      DO 100 I      = 1,12 
      NDDAY         = II+15 
      NDXDAY(NDDAY) = NDD(I) 
      II            = II+30 
  100 CONTINUE 
C======================================================================= 
C     INTERPOLATE FOR FIRST AND LAST 15 DAYS OF 'YEAR' 
C======================================================================= 
      NX  = 345 
      NY1 = NDXDAY(345) 
      NY2 = NDXDAY(15) 
      NX1 = 345 
      NX2 = 375 
      DO 110 I   = 1,30 
      NX         = NX+1 
      NY         = ((NY2-NY1)*(NX-NX1))/30 + NY1 
      NDXDAY(NX) = NY 
  110 CONTINUE 
C======================================================================= 
C     CONVERT LAST 15 DAYS TO FIRST 15 
C======================================================================= 
      NX        = 360 
      DO 120 I  = 1,15 
      NX        = NX+1 
      NDXDAY(I) = NDXDAY(NX) 
  120 CONTINUE 
C======================================================================= 
C     INTERPOLATE FROM NDDAY=16 THRU NDDAY=344 
C======================================================================= 
      K   = 1 
      NX  = 16 
      NX1 = 15 
      NX2 = 45 
  130 NY1 = NDXDAY(NX1) 
      NY2 = NDXDAY(NX2) 
      NY  = ((NY2-NY1)*(NX-NX1))/30 + NY1 
      NDXDAY(NX) = NY 
      K  = K+1 
      NX = NX+1 
      IF(K.LE.30) GO TO 130 
      NX1 = NX1+30 
      NX2 = NX2+30 
      K   = 1 
      IF(NX2.LE.345) GO TO 130 
C======================================================================= 
C     DETERMINE BEGINNING OF FREEZING PERIOD(MFREZ) 
C======================================================================= 
      DO 150 I = 1,360 
      IF(NDXDAY(I).GT.750) GO TO 160 
  150 CONTINUE 
  160 MFREZ = I 
C======================================================================= 
C     IF STORM DAY IS PRIOR TO FREEZING, SET SINFIL=0.0 
C======================================================================= 
      IF(NDYUD.LE.MFREZ) GO TO 200 
C======================================================================= 
C     STORM OCCURED AFTER FREEZING BEGAN 
C======================================================================= 
      NTOT = 0 
      DO 170 I = MFREZ,360 
      IF(NDXDAY(I).LE.750) GO TO 175 
  170 NTOT   = NTOT+(NDXDAY(I)-750) 
  175 NAREA1 = NTOT 
      MLTBE  = I 
      NTOT   = 0 
      IF(NDYUD.LT.MLTBE) GO TO 200 
      DO 180 I = MLTBE,360 
      NTOT     = NTOT+(750-NDXDAY(I)) 
      IF(NTOT.GE.NAREA1) GO TO 185 
  180 CONTINUE 
C======================================================================= 
C     IF EQUAL AREA NOT REACHED SET MLTEN=360 
C======================================================================= 
  185 MLTEN = I 
      IF(NDYUD.GE.MLTEN) GO TO 200 
C======================================================================= 
C     CALCULATE SINFIL 
C======================================================================= 
      XMLTBE = MLTBE 
      XNDYUD = NDYUD 
      XMLTEN = MLTEN 
      XXARG  = ((XNDYUD-XMLTBE)/(XMLTEN-XMLTBE))*3.1416 
      SINFIL = RSMAX*SIN(XXARG) 
      IF(METRIC.EQ.1) WRITE (N6,610) SINFIL 
      IF(METRIC.EQ.2) WRITE (N6,611) SINFIL 
      GO TO 40 
  200 SINFIL = 0.0 
   40 QINF   = RINFIL+SINFIL+DINFIL 
      GO TO 60 
   50 QINF = GINFIL 
   60 CONTINUE 
      OPINF   = 0.0 
      OPNFIL  = 0.0 
      DO 70 K = 1,NE 
      M       = JR(K) 
      NTPE      = NTYPE(M) 
      IF(KLASS(NTPE).LE.2) OPINF = SQRT(AFULL(M))*DIST(M)+OPINF 
   70 CONTINUE 
      IF(METRIC.EQ.1) WRITE (N6,615) QINF 
      IF(METRIC.EQ.2) WRITE (N6,616) QINF 
      WRITE (N6,620) DINFIL,GINFIL,SINFIL,RINFIL 
      WRITE (N6,630) 
      IF(METRIC.EQ.1) WRITE (N6,631) 
      IF(METRIC.EQ.2) WRITE (N6,632) 
C 
      SUM     = 0.0 
      DO 80 K = 1,NE 
      M       = JR(K) 
      NTPE      = NTYPE(M) 
      IF(KLASS(NTPE).LE.2) THEN 
                         OPNFIL     = SQRT(AFULL(M))*DIST(M) 
                         OP         = OPNFIL/OPINF 
                         QQINF      = QINF*OP 
                         MI         = INUE(M,1) 
C###### WCH, 11/93 
C SHOULD MULTIPLY BY CMET3, NOT DIVIDE 
C###### 
                         QINFIL(MI) = QINFIL(MI) + QQINF*CMET3 
                         SUM        = SUM + QQINF 
                         IF(JCE.EQ.0) WRITE(N6,640) NOE(M), 
     +                                              QQINF,OP,NOE(MI) 
                         IF(JCE.EQ.1) WRITE(N6,641) KOE(M), 
     +                                              QQINF,OP,KOE(MI) 
                         ENDIF 
   80 CONTINUE 
      WRITE(N6,645) SUM 
      RETURN 
  888 CALL IERROR 
C======================================================================= 
  500 FORMAT (2X,F8.0,7F10.0) 
  501 FORMAT (2X,I3,11I5) 
  600 FORMAT(1H1,/, 
     1' *******************************************************',/, 
     2' * INFILTRATION APPORTIONMENT THROUGH CONDUIT NETWORK. *',/, 
     3' *              INPUT TO SUBROUTINE INFIL:             *',/, 
     4' *******************************************************'/) 
  601 FORMAT(' DINFIL =',F10.4,' CFS. BASE DRY-WEATHER INFILTRATION.',/, 
     1' GINFIL =',F10.4,' CFS. GROUNDWATER INFILTRATION.',/, 
     2' RINFIL =',F10.4,' CFS. RAINWATER INFILTRATION.',/, 
     3' RSMAX  =',F10.4,' CFS. PEAK RESIDUAL MOISTURE (TO BE MELTED).') 
  602 FORMAT (' DINFIL =',F10.4,' CU M/SEC. BASE DRY-WEATHER INFILTRATIO 
     1N.',/, 
     2' GINFIL =',F10.4,' CU M/SEC. GROUNDWATER INFILTRATION.',/, 
     3' RINFIL =',F10.4,' CU M/SEC. RAINWATER INFILTRATION.',/, 
     4' RSMAX  =',F10.4,' CU M/SEC. PEAK RESIDUAL MOISTURE (TO BE MELTED 
     5).') 
  603 FORMAT(//, 
     1' ************************************************',/, 
     2' * CONCENTRATION OF POLLUTANTS IN INFILTRATION: *',/, 
     3' ************************************************',//, 
     1' NO.   NAME    CONCENTRATION   UNITS',/, 
     2' ---   ----    -------------   -----',/, 
     3           4(1X,I2,2X,A8,F13.3,4X,A8,/)) 
  606 FORMAT (//, 
     1' ***************************************************',/ 
     1' * DEGREE-DAYS (DEG F * DAYS), JANUARY - DECEMBER: *',/, 
     2' ***************************************************',/, 
     3        1X,6(I5,' = ',I5),/,1X,6(I5,' = ',I5)) 
  610 FORMAT (//,' CALCULATED MELT INFILTRATION (SINFIL) =',F10.4, 
     1 ' CFS.') 
  611 FORMAT (//,' CALCULATED MELT INFILTRATION (SINFIL) =',F10.4, 
     1 ' CU M/SEC.') 
  615 FORMAT (//,10X,'TOTAL AREA INFILTRATION (CFS) =',F10.4,', DUE TO: 
     1',//, 
     2 10X,'BASE FLOW',5X,'GROUND WATER',11X,'    MELT',5X,'  RAIN',/, 
     3 10X,'---------',5X,'------------',11X,'    ----',5X,'  ----') 
  616 FORMAT (//,10X,'TOTAL AREA INFILTRATION (CU M/SEC) =',F10.4, 
     1 ', DUE TO:',//, 
     2 10X,'BASE FLOW',5X,'GROUND WATER',11X,'    MELT',5X,'  RAIN',/, 
     3 10X,'---------',5X,'------------',11X,'    ----',5X,'  ----') 
  620 FORMAT(10X,F9.4,5X,F12.4,11X,F8.4,3X,F8.4,//) 
  630 FORMAT (/, 
     1' ******************************************',/, 
     1' * APPORTIONED INFILTRATION (BY RELATIVE  *',/, 
     3' * CONDUIT PERIMETER AREA):               *',/, 
     1' ******************************************',//, 
     112X,'   INFILTRATION',15X,'  PROPORTION  ',T58,'INFIL.INPUT AT') 
  631 FORMAT (1X,'ELEMENT NO.',10X,'(CFS)',15X,'OF TOT. INFIL.',T58, 
     1'UPSTREAM ELE.NO.',/,1X,'-----------',5X,'----------',15X, 
     2'--------------',T58,'----------------',/) 
  632 FORMAT (1X,'ELEMENT NO.',10X,'(CMS)',15X,'OF TOT. INFIL.',T58, 
     1'UPSTREAM ELE.NO.',/,1X,'-----------',10X,'-----',15X, 
     2'--------------',T58,'----------------',/) 
  640 FORMAT(1X,I10,5X,F12.6,12X,F8.4,T63,I10) 
  641 FORMAT(1X,A10,5X,F12.6,12X,F8.4,T63,A10) 
  645 FORMAT(' TOTAL INFIL ',3X,F12.6) 
C======================================================================= 
      END 
 
 
REM File: INFLOW.FOR 
 
      SUBROUTINE INFLOW 
C	EXTRAN BLOCK 
C     CALLED BY TRANSX NEAR LINE 497 
C======================================================================= 
C     THIS SUBROUTINE SELECTS THE EXTRAN INPUT HYDROGRAPH 
C     ORDINATE FROM OFF-LINE FILES AND/OR USER INPUT (K3 LINES). 
C======================================================================= 
C     WCH, 6/16/94.  CORRECT USER INPUT OPTION FOR POSSIBILITY OF 
C       MULTIPLE VALUES FOR SAME JUNCTION (P. 30 OF EXTRAN MANUAL). 
C     WCH (SACHA HENCHMAN, METCALF AND EDDY, BOSTON), 10/17/95. 
C       REMOVE ABOVE FIX BY REMOVING DO 4010 LOOP, TO AVOID ADDING 50% 
C       MORE INFLOW WHEN USING BOTH INTERFACE FILE INPUT AND K3 INPUT. 
C       KEEP TRACK SEPARATELY OF INFLOWS FROM INTERFACE FILE (QINN) 
C       AND INFLOWS FROM K3 LINES (QINNK3) TO AVOID DOUBLE COUNTING. 
C       DO NOT ALLOW MULTIPLE INFLOWS FOR SAME JUNCTION ON K3 LINES. 
C     WCH, 10/17/95.  ALLOW MIS-MATCH OF EXTRAN AND INTERFACE FILE 
C       JUNCTIONS. 
C     WCH, 7/3/02. FIX HARD-WIRED MIN. ORIFICE LENGTH TO 200 FT OR  
C       200/3.28 M.  
C     WCH for Mitch Heineman, 7/20/04. ADD CHECK ON TOLCS1 TO OPTIONALLY 
C       AVOID PRINTOUTS FOR CHANGES IN STEADY-STATE CONDITION.  
C     WCH, 7/20/04. INTERPOLATION TIME CHECK FROM RED, 2/24/03.  
C     WCH (RED), 7/22/04. Fix problem of F2 line sequencing. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'HYFLOW.INC' 
      INCLUDE 'MOBFF.INC' 
      DIMENSION LSWIT(NIE),NSWIT(NIE),MSWIT(NIE), 
     +                                ORTIME(NVORF),NORPLC(NVORF) 
      CHARACTER*10 NSWIT,MSWIT 
C======================================================================= 
C     Define statement function for linear interpolation. 
C======================================================================= 
      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1) 
C======================================================================= 
C     Initialize new QINN, QINNK3 and QIN arrays. 
C======================================================================= 
      DO 40 J   = 1,NJ 
cim  change for variable base flows 
cim   QIN(J)    = QINST(J) 
      QIN(J)    = QINST(J)*BFFMONTH(1,IWHICH(J)) 
      QINN(J,1) = QINN(J,2) 
      QINN(J,2) = 0.0 
C#### WCH, 10/17/95.  ADD NEW QINNK3 
      QINNK3(J,1) = QINNK3(J,2) 
      QINNK3(J,2) = 0.0 
   40 CONTINUE 
C======================================================================= 
C     Calculate new depth and pipe length for an orifice with a 
C               time history. 
C======================================================================= 
      IF(NVOR.GT.0) THEN 
                    DO 9000 M = 1,NVOR 
cred  To handle sequencing of F2 lines, 4/15/02.  
Cwch, 7/22/04. Worry a bit that NORPLC is never initialized.  
                    mm        = f2_line(m) 
                    N         = LORIF(mm) 
C                    N         = LORIF(M) 
                    JJ        = NORPLC(M) 
                    IF(JJ.EQ.0) JJ = 1 
C                    DO 8990 J      = JJ,NVOTIM 
                    DO 8990 J      = JJ,f2_limit(m) 
                    IF(TIME/3600.0.GE.VORIF(M,J,1)) GO TO 8991 
 8990               CONTINUE 
                    GO TO 9000 
 8991               CONTINUE 
                    IF(ORTIME(M).GT.TIME/3600.0) GO TO 9000 
                    ORTIME(M) = VORIF(M,J,1) 
                    NORPLC(M) = J + 1 
                    ZZ        = 0.96*DEEP(N) 
cim begin OOOO 
CIM  adjustment for CIRCULAR orifices 
                    if (NKLASS(N).EQ.51.OR.NKLASS(N).EQ.52) THEN 
                    DEEPOLD   = DEEP(N) 
                    DEEP(N)   = SQRT(4.0*VORIF(M,J,3)/3.14159) 
                    WIDE(N)   = DEEP(N) 
                    AFULL(N)  = VORIF(M,J,3) 
                    RFULL(N)  = DEEP(N)/4.0 
CIM CHANGE INVERT 
CIM  NOTE  ZU + DEEPOLD = OLD CROWN ELEV. 
CIM        ZU + DEEPOLD - DEEP = new invert elev. 
                    IF (IOINV(M).EQ.1) then 
                    ZU(N) = ZU(N)+DEEPOLD-DEEP(N) 
                    ZD(N) = ZD(N)+DEEPOLD-DEEP(N) 
                    ENDIF 
                    ELSE 
CIM   ADJUST ONLY DEPTH FOR RECTANGULAR ORIFICE, WIDTH REMAINS UNCHANGED 
                    DEEPOLD   = DEEP(N) 
                    DEEP(N)   = VORIF(M,J,3)/WIDE(N) 
                    AFULL(N)  = VORIF(M,J,3) 
                    RFULL(N)  = AFULL(N)/(2.0*DEEP(N)+2.0*WIDE(N)) 
CIM CHANGE INVERT 
CIM  NOTE  ZU + DEEPOLD = OLD CROWN ELEV. 
CIM        ZU + DEEPOLD - DEEP = new invert elev. 
                    IF (IOINV(M).EQ.1) then 
                    ZU(N) = ZU(N)+DEEPOLD-DEEP(N) 
                    ZD(N) = ZD(N)+DEEPOLD-DEEP(N) 
                    ENDIF 
                    END IF 
CIM END   OOOOOOO 
                                    DDD = DELT 
C BAC START    
C                    IF(NEQUAL.GT.1) DDD = FLOAT(NEQUAL) 
C BAC END    
                    CLEN      = 2.0*DDD*SQRT(GRVT*DEEP(N)) 
Cwch, 7/2/03. Set minimum length = 200 ft or 200/3.28 m. 
C                    LEN(N)    = AMAX1(200.0,CLEN) 
                    LEN(N)    = AMAX1(200.0/CMET(1,METRIC),CLEN) 
                    CMANN     = CMET(9,METRIC) 
                    ROUGH(N)  = CMANN*RFULL(N)**.66667/ 
     +                         (VORIF(M,J,2)*SQRT(LEN(N)*2.0*GRVT)) 
                    DO 700 J = 1,NJ 
                    IF(JCE.EQ.0.AND.NJUNC(N,1).EQ.JUN(J))  GO TO 720 
                    IF(JCE.EQ.1.AND.KJUNC(N,1).EQ.AJUN(J)) GO TO 720 
  700               CONTINUE 
CIM START  OOOOOOOOOOOO 
CIM MODIFY TO INCLUDE RECTANGULAR BOTTOM OUTLET ORIFICE 
CIM ALSO MODIFY PRINT STATEMENT TO INCLUDE MODIFIED WIDTH 
  720               IF((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) THEN 
                       ZU(N)      = ZU(N) - 0.96*DEEP(N) + ZZ 
                       Z(J)       = ZU(N) 
                       ZD(N)      = ZU(N) - 0.01/CMET(1,METRIC) 
                       IF(JCE.EQ.0) WRITE(N6,6010) M,NCOND(N),DEEP(N), 
     +                              WIDE(N),LEN(N),ROUGH(N),ZU(N), 
     +                              ZD(N),TIME/3600.0 
                       IF(JCE.EQ.1) WRITE(N6,6011) M,ACOND(N),DEEP(N), 
     +                              WIDE(N),LEN(N),ROUGH(N),ZU(N), 
     +                              ZD(N),TIME/3600.0 
                       ELSE 
                       IF(JCE.EQ.0) WRITE(N6,6015) M,NCOND(N),DEEP(N), 
     +                               WIDE(N),LEN(N),ROUGH(N),TIME/3600.0 
                       IF(JCE.EQ.1) WRITE(N6,6016) M,ACOND(N),DEEP(N), 
     +                               WIDE(N),LEN(N),ROUGH(N),TIME/3600.0 
                       ENDIF 
CIM    CORRECTION    ROUGH NEEDS TO BE MODIFIED (SEE INDAT3) 
      ROUGH(N)  = GRVT*ROUGH(N)**2/CMET(9,METRIC)**2 
 9000               CONTINUE 
                    ENDIF 
CIM END  OOOOOO 
C======================================================================= 
C     Conditional time for first time step. 
C======================================================================= 
      IF(MTIME.EQ.1) THEN 
                     JDAY  = IDATEZ 
                     TMDAY = TZERO 
                     TEND  = TZERO 
                     IF(METRIC.EQ.1) THEN 
                                     QQCONV = QCONV 
                                     ELSE 
                                     QQCONV = QCONV/CMET(8,METRIC) 
                                     ENDIF 
                     ENDIF 
C======================================================================= 
C     Interface file hydrograph ordinates are interpolated. 
C     Note that in most cases, there is no interface file ordinate 
C     at time zero.  Hydrograph ordinate at time zero is implicitly 
C     assumed to equal zero. 
C======================================================================= 
      IF(LOCATS.EQ.0) THEN 
         NEWQTAPE = 1 
         ELSE 
cim      IF(LOCATS.GT.0) THEN 
 1000    IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GT.TMDAY)) THEN 
            DO 4523 I  = 1,LOCATS 
            QTAPE(I,1) = QTAPE(I,2) 
 4523       CONTINUE 
            IF(NQUAL.LE.0) THEN 
               READ(LAST,END=205) JDAY,TMDAY, 
     +                DELTA,(QTAPE(I,2),I=1,LOCATS) 
               ELSE 
               READ(LAST,END=205) JDAY,TMDAY, 
     +                DELTA,(QTAPE(I,2),(PDUM,J=1,NQUAL),I=1,LOCATS) 
               ENDIF 
            TREF = TIME/3600.0 
            CALL NTIME(JDAY,TMDAY,TFILE) 
            IF(TFILE.LT.0.0) GO TO 1000 
            TFILE      = TFILE/3600.0 
            DO 1400 I  = 1,LOCATS 
 1400       QTAPE(I,2) = QTAPE(I,2)*QQCONV 
C ### RHF 12/20/96 SET FLAG IF INFLOWS CHANGE 
C   NEWQTAPE IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY 
            IF (ISOLSKIP .EQ. 1) THEN 
               NEWQTAPE = 1 
               DO 1450 I = 1,LOCATS 
               DELTFLOW = ABS(QTAPE(I,1)-QTAPE(I,2)) 
               IF (DELTFLOW.GT.TOLCS2) NEWQTAPE = 0 
c     write(n6,*) 'inflow0',tstart,deltflow,tolcs2,newqtape 
 1450          CONTINUE 
               ENDIF 
C --- 
            ENDIF 
C======================================================================= 
C     Interpolate flow values. 
C======================================================================= 
         THR        = TIME/3600.0 - TREF 
         DO 1500 L  = 1,LOCATS 
         KSWIT      = NLOC(L) 
C#### WCH, 10/17/95.  CHECK FOR ZERO NLOC (NO EXTRAN JUNCTION). 
         IF(KSWIT.GT.0) THEN 
            IF(JCE.EQ.0) LSWIT(L)   =  JUN(KSWIT) 
            IF(JCE.EQ.1) MSWIT(L)   = AJUN(KSWIT) 
            ELSE 
            IF(JCE.EQ.0) LSWIT(L)   = 0 
            IF(JCE.EQ.1) MSWIT(L)   = KAN(L) 
            ENDIF 
 1500    CONTINUE 
Cwch (MCH), 7/20/04. Turn of some prints when TOLCS1 < 0. 
C     Requested by Mitch Heineman to avoid lenthy steady state output. 
C      IF(MOD(MTIME,INTER).EQ.0) THEN 
         IF(MOD(MTIME,INTER).EQ.0.AND.TOLCS1.GE.0) THEN 
            IF(METRIC.EQ.1) WRITE(N6,5000) TIME/3600.0 
            IF(METRIC.EQ.2) WRITE(N6,5001) TIME/3600.0 
            IF(JCE.EQ.0) WRITE(N6,5830)(LSWIT(L),QTAPE(L,2),L=1,LOCATS) 
            IF(JCE.EQ.1) WRITE(N6,5833) 
     1	      (ADJUSTR(MSWIT(L)),QTAPE(L,2),L=1,LOCATS) 
            ENDIF 
C======================================================================= 
         DO 4570 L = 1,LOCATS 
         J         = NLOC(L) 
C#### WCH, 10/17/95.  CHECK FOR NO NLOC = 0 (NO EXTRAN JUNCTION). 
         IF(J.EQ.0) GO TO 4570 
         QQ1       = QTAPE(L,1) 
         QQ2       = QTAPE(L,2) 
         IF(TFILE.EQ.0.0) THEN 
            QINN(J,2) = QQ2 
            QIN(J)    = QIN(J) + QQ1/2.0 + QQ2/2.0 
            ELSE 
            QEND      = QLINTP(QQ1,QQ2,0.0,TFILE,THR) 
            QINN(J,2) = QEND 
            QIN(J)    = QIN(J) + QINN(J,1)/2.0 + QEND/2.0 
            ENDIF 
 4570    CONTINUE 
         ENDIF 
C======================================================================= 
C     Line hydrograph input values are interpolated. 
C======================================================================= 
      IF(NJSW.EQ.0) THEN 
      NEWQCARD = 1 
      ELSE 
cim      IF(NJSW.GT.0) THEN 
C======================================================================= 
C     New input data required. 
C======================================================================= 
      IF(MTIME.EQ.1) THEN 
               READ(N5,*,ERR=888,END=889) CC 
               IF(CC.NE.'K3') THEN 
                              WRITE(N6,9100) TIME/3600.0 
                              STOP 
                              ENDIF 
               BACKSPACE N5 
               READ(N5,*,ERR=888,END=889)CC,TSTART,(QCARD(L,2),L=1,NJSW) 
               WRITE(N6,4999) 
               DO 2500 L     = 1,NJSW 
               KSWIT         = JSW(L) 
C#### WCH, 10/17/95.  FROM SUB. INDAT3, JSW() CANNOT BE ZERO.  THIS 
C     CODE NOT NEEDED. 
C####               IF(KSWIT.EQ.0) THEN 
C####                              WRITE(*,*) L,KSWIT,NJSW 
C####                              PAUSE 
C####                              ENDIF 
C#### WCH (M&E, BOSTON), 10/17/95.  USE NEW QINNK3() AND DON'T 
C     ADD QINST HERE. 
C####               QINN(KSWIT,1) = QCARD(L,2) + QINST(KSWIT) 
               QINNK3(KSWIT,1) = QCARD(L,2) 
               IF(JCE.EQ.0) LSWIT(L)  = JUN(KSWIT) 
 2500          IF(JCE.EQ.1) NSWIT(L)  = AJUN(KSWIT) 
               IF(METRIC.EQ.1) WRITE(N6,5831) TSTART 
               IF(METRIC.EQ.2) WRITE(N6,5832) TSTART 
               IF(JCE.EQ.0) WRITE(N6,5830)(LSWIT(L),QCARD(L,2),L=1,NJSW) 
               IF(JCE.EQ.1) WRITE(N6,5833) 
     1		 (ADJUSTR(NSWIT(L)),QCARD(L,2),L=1,NJSW) 
               TSTART = 3600.0*TSTART 
               TEND   = TSTART 
C ### RHF 12/20/96 SET FLAG IF INFLOWS CHANGE 
C   NEWQCARD IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY 
               IF (ISOLSKIP .EQ. 1) THEN 
                    NEWQCARD = 1 
                    DO 3100 I = 1,NJSW 
                    DELTFLOW = ABS(QCARD(I,1)-QCARD(I,2)) 
                    IF (DELTFLOW.GT.TOLCS2) NEWQCARD = 0 
c     write(n6,*) 'inflow1',tstart,deltflow,tolcs2,newqcard 
 3100               CONTINUE 
                    ENDIF 
C --- 
               ENDIF 
C====================================================================== 
 6666 CONTINUE 
      IF(TIME-TEND.GT.0.0) THEN 
               TSTART     = TEND 
               DO 300 L   = 1,NJSW 
  300          QCARD(L,1) = QCARD(L,2) 
               READ(N5,*,END=889,ERR=888,IOSTAT=IREADE) CC 
	         IF(IREADE.NE.0) GO TO 889 
c this next line shouldn't be needed 
c	         IF(EOF(N5)) GO TO 889  KAI DIDN'T LIKE THIS  
               IF(CC.NE.'K3') THEN 
                              WRITE(N6,9100) TIME/3600.0 
                              STOP 
                              ENDIF 
               BACKSPACE N5 
               READ(N5,*,END=889,ERR=888,IOSTAT=IREADE)  
     1		 CC,TEND,(QCARD(L,2),L=1,NJSW) 
	         IF(IREADE.NE.0) GO TO 889 
c this next line shouldn't be needed 
c	         IF(EOF(N5)) GO TO 889 
               WRITE(N6,5999) 
               DO 3000 L              = 1,NJSW 
               KSWIT                  = JSW(L) 
               IF(JCE.EQ.0) LSWIT(L)  = JUN(KSWIT) 
 3000          IF(JCE.EQ.1) NSWIT(L)  = AJUN(KSWIT) 
               IF(METRIC.EQ.1) WRITE(N6,5831) TEND 
               IF(METRIC.EQ.2) WRITE(N6,5832) TEND 
               IF(JCE.EQ.0) WRITE(N6,5830)(LSWIT(L),QCARD(L,2),L=1,NJSW) 
               IF(JCE.EQ.1) WRITE(N6,5833) 
     1		              (ADJUSTR(NSWIT(L)),QCARD(L,2),L=1,NJSW) 
               WRITE(N6,5999) 
               TEND = 3600.0*TEND 
C ### RHF 12/20/96 SET FLAG IF INFLOWS CHANGE 
C   NEWQCARD IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY 
      IF (ISOLSKIP .EQ. 1) THEN 
      NEWQCARD = 1 
      DO 3101 I = 1,NJSW 
      DELTFLOW = ABS(QCARD(I,1)-QCARD(I,2)) 
      IF (DELTFLOW.GT.TOLCS2) NEWQCARD = 0 
c     write(n6,*) 'inflow2',tstart,deltflow,tolcs2,newqcard 
 3101 continue 
      ENDIF 
C --- 
               GO TO 6666 
               ENDIF 
C======================================================================= 
C     No new input data required. 
C======================================================================= 
         DO 4000 L = 1,NJSW 
         J         = JSW(L) 
         QQ1       = QCARD(L,1) 
         QQ2       = QCARD(L,2) 
         T         = TIME/3600.0 
         T1        = TSTART/3600.0 
         T2        = TEND/3600.0 
Cwch, 7/20/04.  Seems unlikely, but... 
cred     fix for the bill medina identified problem of T1 being the  
cred     same as T2 in the flow interpolation equation - 2/24/2003 
         if(t2.gt.t1) then 
                 QQ        = QLINTP(QQ1,QQ2,T1,T2,T) 
                 else 
                 qq        = QQ2 
                 endif 
C         QQ        = QLINTP(QQ1,QQ2,T1,T2,T) 
         QINNK3(J,2) = QQ 
C#### WCH, 6/16/94.  NEED TO ADD QINN(J,1)/2 IN SEPARATE LOOP IN ORDER 
C    NOT TO ADD IT TWICE IN EVENT OF DUPLICATE INPUT NODES. 
C#### 4000    QIN(J)    = QIN(J) + QINN(J,1)/2.0 + QQ/2.0 
C#### WCH (M&E, BOSTON), 10/17/95.  KEEP K3 CONTRIBUTION SEPARATE 
C     USING NEW VARIABLE QINNK3(J, ). 
C     ALSO, DO NOT ALLOW MULTIPLE INPUTS FOR SAME JUNCTION IN K3 LINES. 
C 
 4000    QIN(J)    = QIN(J) + QQ/2.0 + QINNK3(J,1)/2.0 
C 
C#### WCH (M&E, BOSTON), 10/17/95.  REMOVE THIS LOOP BECAUSE HALF OF 
C    INFLOW IS ALREADY ADDED IN DO 4570 AND DO 4000, AND QINN(J,1) 
C    STARTS OUT WITH OLD INSTANT. INPUT DUE TO DO 40 LOOP.  SO, DO NOT 
C    ALLOW MULTIPLE INPUTS FOR SAME JUNCTION IN K3 LINES. 
C####         DO 4010 J = 1,NJ 
C#### 4010    QIN(J)    = QIN(J) + QINN(J,1)/2.0 
         ENDIF 
C======================================================================= 
      RETURN 
  888 CALL IERROR 
	STOP 
  889	WRITE(N6,9200) TIME/3600.0 
	TEND = 999999999.9 
      DO L=1,NJSW 
	QCARD(L,1)=0.0 
      QCARD(L,2)=0.0 
	ENDDO 
	RETURN 
C======================================================================= 
  205 DO 2000 L  = 1,LOCATS 
      QTAPE(L,1) = 0.0 
2000  QTAPE(L,2) = 0.0 
      WRITE(N6,9200) TIME/3600.0 
      JDAY       = 9999999 
      TMDAY      = 0.0 
      RETURN 
C======================================================================= 
 4980 FORMAT(/,' TZERO is later in time than last record on tape from 
     1interface file.') 
 4999 FORMAT(/,1X,40(2H# )) 
 5000 FORMAT(/,' ===> System inflows (file) at ',F8.2,' hours', 
     *' (  Junction / Inflow, cfs)',/) 
 5001 FORMAT(/,' ===> System inflows (file) at ',F8.2,' hours', 
     *' (  Junction / Inflow, cu m/s)',/) 
 5830 FORMAT(6(1X,I10,'/',1PE9.2)) 
 5833 FORMAT(6(1X,A10,'/',1PE9.2)) 
 5831 FORMAT(' ===> System inflows (data group K3) at ',F8.2, 
     +          ' hours ( Junction / Inflow,cfs )',/) 
 5832 FORMAT(' ===> System inflows (data group K3) at ',F8.2, 
     +          ' hours ( Junction / Inflow,cu m/s )',/) 
 5999 FORMAT(1X,40(2H# )) 
CIM START OOOOOOOOO 
 6010 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I9,/, 
     .       '       CONDUIT NUMBER..........................',I10,/, 
     .       '       PIPE DEPTH...........................',F12.2,/, 
     .       '       PIPE WIDTH...........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.4,/, 
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/, 
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4,/, 
     .       '       SIMULATION TIME IN HOURS.............',F12.4) 
 6011 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I9,/, 
     .       '       CONDUIT NANE............................',A10,/, 
     .       '       PIPE DEPTH...........................',F12.2,/, 
     .       '       PIPE WIDTH...........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.4,/, 
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/, 
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4,/, 
     .       '       SIMULATION TIME IN HOURS.............',F12.4) 
 6015 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I7,/, 
     .       '       INTERNAL CONDUIT NUMBER.................',I10,/, 
     .       '       PIPE DEPTH...........................',F12.2,/, 
     .       '       PIPE WIDTH...........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.4,/, 
     .       '       SIMULATION TIME IN HOURS.............',F12.4) 
 6016 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I7,/, 
     .       '       CONDUIT NAME............................',A10,/, 
     .       '       PIPE DEPTH...........................',F12.2,/, 
     .       '       PIPE WIDTH...........................',F12.2,/, 
     .       '       PIPE LENGTH..........................',F12.2,/, 
     .       '       MANNINGS ROUGHNESS...................',F12.4,/, 
     .       '       SIMULATION TIME IN HOURS.............',F12.4) 
CIM END     OOOOOOOOO 
 9100 FORMAT(/,' ===> Error  ',F12.5, 
     +        ' hours.') 
 9200 FORMAT(/,' ===> Warning  End of input file reached at time = ', 
     +         F6.1,' hours.',/, 
     +'                 Simulation continues with zero inflow.',/) 
C======================================================================= 
      END 
 
REM File: INITAL.FOR 
 
      SUBROUTINE INITAL 
C	TRANSPORT BLOCK 
C	CALLED BY INTRAN NEAR LINE 1209 
C======================================================================= 
C     ROUTINE INITIALIZES FLOWS, AREAS, AND CONCENTRATIONS TO VALUES 
C     CORRESPONDING TO DRY WEATHER FLOW PLUS INFILTRATION. 
C     WHEN THERE ARE NO INITIAL VALUES OF DWF OR INFIL, VALUES REMAIN 0.0 
C 
C     LAST UPDATED AUGUST 1989 AND MAY 1993 BY R.E.D. 
C     BE SURE TO INITIALIZE STORAGE CONCENTRATIONS, WCH, 10/6/93. 
C     For linked DO-BOD, print out initial reaeration, etc.  WCH, 7/6/01. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'DRWF.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEW81.INC' 
      INCLUDE 'TST.INC' 
CIMT  INCLUDE COMMON THAT INCLUDES PMANN 
      INCLUDE 'NEWTR.INC' 
CIMT 
Cwch, 7/6/01 
      INCLUDE 'TRANWQ.INC' 
C======================================================================= 
CIMT  SUM2 dimensioned to MQUAL 
      DIMENSION SUM2(MQUAL),QO(NET),QI(NET),QO1(NET),QO2(NET) 
      DIMENSION WELL1(NET),WELL2(NET) 
CIMT changed format for writting results 
CIMT  DIMENSION FIRMAT(13),KIRMAT(13),EFMT(2) 
CIMT  CHARACTER FIRMAT*4,KIRMAT*4,EFMT*4 
      CHARACTER BMJ*10 
      EQUIVALENCE (QO1(1),QMAX(1)),(QO2(1),QFULL(1)) 
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2)) 
      EQUIVALENCE (WELL1(1),SLOPE(1)),(WELL2(1),ROUGH(1)) 
CIMT      DATA FIRMAT/'(I6,','I7,3','F10.','3,2X',',F9.','3,1X',',F9.', 
CIMT     1            '3,1X',',F9.','3,1X',',F9.','3,1X',')   '/ 
CIMT      DATA KIRMAT/'(A9,','I4,3','F10.','3,2X',',F9.','3,1X',',F9.', 
CIMT     1            '3,1X',',F9.','3,1X',',F9.','3,1X',')   '/ 
CIMT      DATA EFMT/',1X,','E9.3'/ 
C======================================================================= 
      WRITE (N6,900) 
      IF(NPOLL.LE.0) THEN 
           WRITE (N6,905) 
           IF(METRIC.EQ.1) WRITE (N6,906) 
           IF(METRIC.EQ.2) WRITE (N6,907) 
	     WRITE(N6,908) 
Cwch, 7/6/01 
           ELSEIF(NWQ.EQ.0) THEN 
                WRITE (N6,905) (PNAME(K),K=1,NPOLL) 
                IF(METRIC.EQ.1) WRITE (N6,906) (PUNIT(K),K=1,NPOLL) 
                IF(METRIC.EQ.2) WRITE (N6,907) (PUNIT(K),K=1,NPOLL) 
	          WRITE(N6,908) ('--------',K=1,NPOLL) 
           ELSEIF(NWQ.EQ.1) THEN 
                WRITE (N6,9015) (PNAME(K),K=1,NPOLL) 
                IF(METRIC.EQ.1) WRITE (N6,9016) (PUNIT(K),K=1,NPOLL) 
                IF(METRIC.EQ.2) WRITE (N6,9017) (PUNIT(K),K=1,NPOLL) 
	          WRITE(N6,9018) ('--------',K=1,NPOLL) 
           ENDIF 
CIMT      IF(NPOLL.GT.0) THEN 
CIMT      DO 200 K = 1,NPOLL 
CIMT      IF(NDIM(K).NE.1) GO TO 200 
CIMT      NNX         = 2 + 2*K 
CIMT      DO 190 I    = 1,2 
CIMT      MMX         = NNX + I 
CIMT      KIRMAT(MMX) = EFMT(I) 
CIMT  190 FIRMAT(MMX) = EFMT(I) 
CIMT  200 CONTINUE 
CIMT      ENDIF 
C======================================================================= 
C     SET UP METRIC CONVERSION FACTORS. 
C     MULTIPLY FIRST UNITS TO OBTAIN SECOND UNITS. 
C======================================================================= 
      IF(METRIC.EQ.1) THEN 
                      CMET1 = 1.0 
                      CMET2 = 1.0 
                      CMET3 = 1.0 
                      ELSE 
                      CMET1 = 3.281 
C======================================================================= 
C                     SQ M TO SQ FT. 
C======================================================================= 
                      CMET2 = 10.764 
                      CMET3 = 35.31 
                      ENDIF 
      N        = 0 
      DO 100 I = 1,NE 
      M        = JR(I) 
      NTPE       = NTYPE(M) 
      IF(NTPE.EQ.22) KSTOR = KSTORE(M) 
C======================================================================= 
C     SUM UPSTREAM FLOWS AND POLLUTANT INFLOWS. 
C======================================================================= 
      SUM1    = 0.0 
      IF(NPOLL.GT.0) THEN 
                     DO 10 K = 1,NPOLL 
   10                SUM2(K) = 0.0 
                     ENDIF 
      DO 20 J = 1,3 
      L       = INUE(M,J) 
      NTPEU     = NTYPE(L) 
      IF(L.GT.NE) GO TO 20 
CIM THIS LINE NEEDS TO BE MODIFIED TO ROUTE FLOWS FOR  
CIM TYPE 27 
      IF(NTPEU.LE.20.OR.NTPEU.EQ.27) THEN 
                    QQ   = Q(L,2,1)*BARREL(L) 
                    ELSE 
                    KK   = GEOM3(L) 
                    BMJ  = KGEOM(L) 
                    QQ   = QO2(L) 
                    IF(JCE.EQ.0.AND.NOE(M).EQ.KK)  QQ = QO1(L) 
                    IF(JCE.EQ.1.AND.KOE(M).EQ.BMJ) QQ = QO1(L) 
                    ENDIF 
      IF(NPOLL.GT.0) THEN 
                     DO 25 K = 1,NPOLL 
   25                SUM2(K) = SUM2(K) + CPOL2(L,1,K) * QQ 
                     ENDIF 
      SUM1 = SUM1 + QQ 
   20 CONTINUE 
      KHR     = JHR + 1 
      IF(KHR.GT.24) KHR = 24 
                         QMAN    =  0.0 
CIM  CHANGE FOR VARIABLE BASE FLOW IN TRANSPORT 
CIM  CHANGE MADE TO INCLUDE MONTHLY FLOW FACTOR TO DETERMINE 
CIM  BASE FLOWS IN INITIAL CONDITIONS 
CIM 
      IF(NTPE.EQ.19) QMAN    = DIST(M)*BFFMONTH(1,NINT(GEOM3(M))) 
CIM                                        ------------------------ 
CIM 
CIM      IF(NTYPE(M).EQ.19) QMAN    = DIST(M) 
cim  monthly variation in DWF 
      IF (NTPE.EQ.19) THEN 
	    BFF = BFFMONTH(2,NINT(GEOM3(M))) 
	ELSE 
	    BFF = 1.0 
	ENDIF 
      QQQ      = QDWF(M)*DVDWF(KDAY)*HVDWF(KHR) 
cim  monthly variation 
     a           * BFF 
cims 
      SUM1     = SUM1 + QINFIL(M) + QMAN + QQQ 
      Q(M,1,1) = SUM1/BARREL(M) 
      Q(M,2,1) = Q(M,1,1) 
      IF(Q(M,1,1).LT.0.0) Q(M,1,1) = 0.0 
      IF(Q(M,2,1).LT.0.0) Q(M,2,1) = 0.0 
      IF(NPOLL.GT.0.AND.SUM1.GT.0.0) THEN 
           DO 35 K = 1,NPOLL 
           IF(K.EQ.1) SUM2(K) = SUM2(K)+WDWF(M,K)*DVBOD(KDAY)* 
     1                  HVBOD(KHR)*DVDWF(KDAY)*HVDWF(KHR) 
cim monthly variation 
     2                  * BFF 
cim 
           IF(K.EQ.2) SUM2(K) = SUM2(K)+WDWF(M,K)*DVSS(KDAY)* 
     1                  HVSS(KHR)*DVDWF(KDAY)*HVDWF(KHR) 
cim monthly variation 
     2                  * BFF 
cim 
           IF(K.EQ.3) SUM2(K) = SUM2(K)+WDWF(M,K)*1.0*HVCOLI(KHR)* 
     1                     DVDWF(KDAY)*HVDWF(KHR) 
cim monthly variation 
     2                  * BFF 
cim 
           PMAN = 0.0 
CIMT           IF(NTYPE(M).EQ.19) THEN 
CIMT                         IF(K.EQ.1) PMAN = GEOM1(M) 
CIMT                         IF(K.EQ.2) PMAN = SLOPE(M) 
CIMT                         IF(K.EQ.3) PMAN = ROUGH(M) 
CIMT                         IF(K.EQ.4) PMAN = GEOM2(M) 
CIMT                         ENDIF 
CIM CHANGE FOR MONTHLY BASE FLOW FACTORS 
cim note that geom1 ...  are now mass not concentration 
CIM    
CIMT Change for additional constituents 
      IF(NTPE.EQ.19)  PMAN = PMANN(M,K)*BFFMONTH(1,NINT(GEOM3(M))) 
CIMT 
           SUM2(K)      = SUM2(K) + PMAN + CPINF(K)*QINFIL(M) 
           CPOL1(M,1,K) = SUM2(K)/SUM1 
CIMQP   INITIAL INITIAL OUTFLOW FOR TYPE 27 Quality Splitting Elements 
      IF(NTPE.EQ.27) CPOL1(M,1,K) = CPOL1(M,1,K) * DRATIO(M,K) 
CIMQP 
           CPOL2(M,1,K) = CPOL1(M,1,K) 
           IF(NTPE.EQ.22.AND.PTC0(KSTOR,K).GT.0.0) 
     1                               CPOL2(M,1,K) = PTC0(KSTOR,K) 
   35      CONTINUE 
           ELSE 
C####################################################################### 
C     WCH, 10/6/93.  DON'T MISS OUT ON INITIALIZING STORAGE VOLUME 
C       CONCENTRATIONS JUST BECAUSE THERE'S NO INFLOW. 
C======================================================================= 
           IF(NPOLL.GT.0.AND.SUM1.LE.0.0.AND.NTPE.EQ.22) THEN 
                DO 38 K = 1,NPOLL 
   38           CPOL2(M,1,K) = PTC0(KSTOR,K) 
                ENDIF 
           ENDIF 
C======================================================================= 
C     ASSUME ALL DWF IS NON-DIVERTED IN A FLOW DIVIDER TYPE ELEMENT. 
C======================================================================= 
C   MODIFIY TO INCLUDE TYPE 26 FLOW SPLIT 
      IF(NTPE.EQ.21.OR.NTPE.EQ.23.OR.NTPE.EQ.26) THEN 
                               QO1(M) = SUM1 
                               QO2(M) = 0.0 
                               ENDIF 
C======================================================================= 
C     LIFT STATION. 
C======================================================================= 
      IF(NTPE.EQ.20) THEN 
                   WELL1(M) = WELL2(M) 
                   IF(Q(M,2,1).GT.DIST(M)) THEN 
                                           Q(M,2,1) = DIST(M) 
                                           WELL1(M) = GEOM1(M) 
                                           WELL2(M) = WELL1(M) 
                                           ENDIF 
                   ENDIF 
C======================================================================= 
C     STORAGE UNIT. 
C======================================================================= 
      IF(NTPE.EQ.22) THEN 
C#### RED, 5/25/93.  REMOVE THIS LINE:    NITER = 1 
                   CALL ROUTE(D1,Q1) 
                   ENDIF 
C======================================================================= 
C     BACKWATER ELEMENT. ALL INITIAL FLOW IS 
C                        THROUGH THE INTERMEDIATE CONDUITS. 
C======================================================================= 
      IF(NTPE.EQ.25) THEN 
                   QO1(M)   = 0.0 
                   QO2(M)   = SUM1 
                   ENDIF 
      VELINT   = 0.0 
      A(M,1,1) = 0.0 
	DD       = 0.0 
C======================================================================= 
C     DETERMINE INITIAL FLOW AREA FOR CONDUITS. 
C======================================================================= 
      IF(KLASS(NTPE).LE.2) THEN 
           PS       = Q(M,1,1)/QFULL(M) 
           CALL FINDA(PS,A(M,1,1)) 
           A(M,2,1) = A(M,1,1) 
	     A(M,1,2) = A(M,1,1) 
	     A(M,2,2) = A(M,1,1) 
	     Q(M,2,1) = Q(M,1,1) 
	     Q(M,2,2) = Q(M,1,1) 
           VELINT   = VEL(Q(M,1,1),A(M,1,1)) 
Cwch, 7/6/01.  Add depth. 
           DD   = DEPTH(A(M,1,1)/AFULL(M)) 
	     IF(NTPE.NE.10.AND.NTPE.NE.12) THEN 
	          DD = DD*GEOM1(M) 
	          ELSEIF(NTPE.EQ.10) THEN 
C     Modified basket handle 
                     DD = DD*(GEOM1(M)+GEOM2(M)/2.0) 
	          ELSEIF(NTPE.EQ.12) THEN 
C     Rectangular, round bottom 
                     DD = DD*P2(M)*DIST(M) 
                ENDIF 
	     ENDIF 
      W1              = SUM1/CMET3 
      IF(NTPE.EQ.22) W1 = QO(M) 
      W2              = A(M,1,1)/CMET2 
      W3              = VELINT/CMET1 
	W4              = DD/CMET1 
C======================================================================= 
Cwch, 7/6/01.  For linked DO-BOD, print out inital Ka values. 
C======================================================================= 
      IF(NWQ.EQ.1) THEN 
	   IF(KLASS(NTPE).LE.2.OR.NTPE.EQ.22) THEN 
	     CALL QUALPARM(ASURF,ASSETL,DBAR,DBARSETL,VELL,CS,WAVG) 
           CALL REAERATE(DECAY2,DBAR,VELL,WIND(M),TAIR(M),TWATER(M),REA, 
     1THETA(3),KWIND,KOVAR,GNUW,GNUA,RHOW,RHOA,DMOLEC,XLAMBDA,ZEE,CAPPA, 
     2 GAMMAZ,UTSTAR,PRESURE,UCSTAR,CAPPA3,CDRAG,IYZ,DELG1,ZZERO,USTAR, 
     3 CAYEL,DECAY2W,SALINITY,G1,ZAA,N6,DECAY2F) 
           IF(JCE.EQ.0.AND.NPOLL.GT.0) WRITE(N6,7011) NOE(M),NTPE, 
     1        W1,W2,W3,W4,DBAR/CMET1,WAVG/CMET1,CS, 
     2        DECAY2F*86400.,DECAY2W*86400.,(CPOL2(M,1,K),K=1,NPOLL) 
           IF(JCE.EQ.1.AND.NPOLL.GT.0) WRITE(N6,7012) KOE(M),NTPE, 
     1        W1,W2,W3,W4,DBAR/CMET1,WAVG/CMET1,CS, 
     2        DECAY2F*86400.,DECAY2W*86400.,(CPOL2(M,1,K),K=1,NPOLL) 
	     ELSE 
           IF(JCE.EQ.0) WRITE(N6,7021) NOE(M),NTPE,W1, 
     +                            (CPOL2(M,1,K),K=1,NPOLL) 
           IF(JCE.EQ.1) WRITE(N6,7022) KOE(M),NTPE,W1, 
     +                            (CPOL2(M,1,K),K=1,NPOLL) 
           ENDIF 
         ELSE 
CIMT  CHANGE FORMAT ON OUTPUTS  7001 was FIRMAT and 7002 was KIRMAT     
      IF(JCE.EQ.0.AND.NPOLL.LT.1) WRITE(N6,7001) NOE(M),NTPE,W1,W2,W3,W4 
      IF(JCE.EQ.1.AND.NPOLL.LT.1) WRITE(N6,7002) KOE(M),NTPE,W1,W2,W3,W4 
      IF(JCE.EQ.0.AND.NPOLL.GT.0) WRITE(N6,7001) NOE(M),NTPE,W1,W2,W3,W4 
     +                            ,(CPOL2(M,1,K),K=1,NPOLL) 
      IF(JCE.EQ.1.AND.NPOLL.GT.0) WRITE(N6,7002) KOE(M),NTPE,W1,W2,W3,W4 
     +                            ,(CPOL2(M,1,K),K=1,NPOLL) 
	   ENDIF      
  100 CONTINUE 
      RETURN 
C======================================================================= 
  900 FORMAT(1H1,/, 
     1' ************************************************************',/, 
     2' * ELEMENT FLOWS, AREAS, AND CONCENTRATIONS ARE INITIALIZED *',/, 
     3' *         TO DRY WEATHER FLOW AND INFILTRATION VALUES.     *',/, 
     4' ************************************************************',// 
     5) 
CIM SET MAXIMUM NUMBER TO 99 
CWCH, 9/27/99.  USE WIDTH-12 FIELDS, IN CASE OF LARGE BACTERIA NOS.  
  905 FORMAT (3X,' ELEMENT',9X,'FLOW',6X,'AREA',5X,'VELOCITY', 
     + '    DEPTH ',99(4X,A8)) 
  906 FORMAT (5X, 'NUMBER  TYPE   (CFS)    (SQ FT)   (FT/SEC)',  
     + '     (FT) ', 99(4X, A8)) 
  907 FORMAT (5X, 'NUMBER  TYPE   (CMS)    (SQ M)     (M/SEC)',  
     + '     (M)  ', 99(4X, A8)) 
  908 FORMAT (5X,'------  ----   -----    ------    -------- ', 
     + '  ------- ',99(4x,A8)) 
 7001 FORMAT(I10,I6,4F10.3,1X,99F12.3) 
 7002 FORMAT(A10,I6,4F10.3,1X,99F12.3) 
Cwch, 7/6/01 
 7011 FORMAT(I10,I6,9F10.3,1X,99F12.3) 
 7012 FORMAT(A10,I6,9F10.3,1X,99F12.3) 
 7021 FORMAT(I10,I6,F10.3,81X,99F12.3) 
 7022 FORMAT(A10,I6,F10.3,81X,99F12.3) 
 9015 FORMAT (3X,' ELEMENT',9X,'FLOW',6X,'AREA',5X,'VELOCITY', 
     + '    DEPTH ',' AVG DEPTH',' TOP WIDTH','  SAT. DO ', 
     2 '  FLOW Ka ','  WIND Ka ',99(4X,A8)) 
 9016 FORMAT (5X, 'NUMBER  TYPE   (CFS)    (SQ FT)   (FT/SEC)',  
     1 '     (FT) ','     (FT) ','     (FT) ','   (MG/L) ', 
     2 '  (1/DAY) ','  (1/DAY) ',99(4X, A8)) 
 9017 FORMAT (5X, 'NUMBER  TYPE   (CMS)    (SQ M)     (M/SEC)',  
     1 '     (M)  ','     (M)  ','     (M)  ','   (MG/L) ', 
     2 '  (1/DAY) ','  (1/DAY) ',99(4X, A8)) 
 9018 FORMAT (5X,'------  ----   -----    ------    -------- ', 
     1 '  -------', '  --------','  --------','  --------', 
     2 '  --------','  --------',99(4x,A8)) 
C======================================================================= 
      END 
 
REM File: INTCHR.FOR 
 
      FUNCTION INTCHR(J1) 
C     RAIN BLOCK 
C     CALLED BY GTRAIN NEAR LINE 969 
C======================================================================= 
C     Change a character to an integer. 
C======================================================================= 
      CHARACTER*1 J1(3) 
      INTEGER      I(3) 
      INTCHR   = 0 
      DO 100 J = 1,3 
      I(J)     = ICHAR(J1(J)) - 48 
100   INTCHR   = INTCHR + I(J)*10**(3-J) 
      RETURN 
      END 
 
REM File: NDATE.FOR 
 
      SUBROUTINE NDATE(TIME,JDAY,TMDAY) 
C####################################################################### 
C     THIS SUBROUTINE CALCULATES THE NEW JULIAN DAY AND TIME OF DAY 
C     RESULTING FROM ADDING TIME TO THE EXISTING JULDAY AND TIMDAY 
C 
C     JDAY  = NEW JULIAN DAY 
C     TMDAY = NEW TIME OF DAY IN SECONDS 
C     TIME  = TIME INCREMENT IN SECONDS 
C####################################################################### 
      INCLUDE 'STIMER.INC' 
C======================================================================= 
      TMDAY = TIMDAY + TIME 
      JDAY  = JULDAY 
 100  IF(TMDAY.GE.86400.0) THEN 
                TMDAY = TMDAY - 86400.0 
                JDAY  = JDAY + 1 
                JYEAR = JDAY/1000 
                IDAY  = JDAY - 1000*JYEAR 
                IF (JYEAR.LT.100) JYEAR = JYEAR + 1900 
                IF(MOD(JYEAR,4).EQ.0.AND.IDAY.GE.367.OR. 
     +             MOD(JYEAR,4).NE.0.AND.IDAY.GE.366) THEN 
                                         JYEAR  = JYEAR + 1 
                                         JDAY   = JYEAR*1000 + 1 
                                         ENDIF 
                ENDIF 
      IF(TMDAY.GE.86400.0) GO TO 100 
      RETURN 
      END 
 
 
REM File: NHEAD.FOR 
 
      SUBROUTINE NHEAD(N,NL,NH,HEAD1,HEAD2,QP,AREA,VEL,HRAD, 
     +                          ANH,ANL,RNL,RNH,IDOIT,KINK,AS1) 
C     EXTRAN BLOCK 
C	CALLED BY _ROUTE ROUTINES AND ELSEWHERE 
C======================================================================= 
C     This subroutine performs the following functions: 
C       1 - Converts NODAL depths to pipe depths. 
C       2 - Assigns conduit surface areas to upstream and downstream 
C           junctions depending on depth and flow conditions. Note that 
C           a surface area is not assigned to orifice or weir links. 
C       3 - Computes average conduit hydraulic parameters AREA, VEL, HRAD 
C           used to compute flow in _ROUTE routines. 
C 
C     WCH, 11/16/93.  CORRECT MID-CHANNEL WIDTH VALUE FOR NORMAL 
C       SUBCRITICAL FLOW CASE. 
C     RED, 12/31/93.  CORRECTION FOR INTEGER IDOIT VALUE. 
C     WCH, 12/7/94.  ADD RED COMMENTS, SET FASNH = 1.0 ALWAYS, AND 
C       MAKE SEVERAL CODE CHANGES TO CORRESPOND TO RED CODE. 
C     WRM, 07/01/1997 CREATED NHEAD FROM HEAD BY ADDING ARGUMENT AS1 
C       AND CHANGING ALL OCCURANCES OF AS->AS1. REDUCTIONS INTO AS1 
C       ARE NO LONGER IN COMMON AND CAN THUS BE PERFORMED IN PARALLEL. 
C     WCH, 7/20/04. CHANGE AREA WEIGHTING FOR CASE CR2, CRITICAL FLOW 
C       DOWNSTREAM.  
C     WCH, 7/20/04. KEEP ALL SURFACE AREA WHEN FASHN<1 IN CASE=SUB. 
C     WCH (RED), 7/23/04. ADD OPTION FOR AREA ETC. WEIGHTING FOR  
C       CASE=SUB. 
C 
C   Revised by Chuck Moore (CDM Annandale to improve computational 
C   efficiency.  Gives results identical to original program. 
C   Revised by C. Moore and Brett Cunningham to improve consistency 
C   in calculations.  Major revision to improve calculation of 
C   representative or average pipe characteristics to provide 
C   consistent flow calculations in _ROUTE subroutines. 
C 
C   Definition of terms. 
C     Downstream end of pipe is the end with the lowest pipe invert 
C     elevation. 
C 
C                                       UPSTREAM  DOWNSTREAM 
C 
C     Junction                             NL        NH 
C     Junction invert elevation            Z(NL)     Z(NH) 
C     Conduit invert elevation             ZU(N)     ZD(N) 
C     Flow elevation                       HEAD1     HEAD2 
C     Flow depth in conduit                YNL       YNH 
C 
C     IDOIT = 0, Means a dry pipe and no flow calculation. 
C     Note, HEAD1 = Z(NL) + Y(NL) in calling subroutines, and ZU not 
C     necessarily = Z(NL). 
C     Also, HEAD2 = Z(NH) + Y(NH) in calling subroutines, and ZD not 
C     necessarily = Z(NH). 
C 
C     Assigns pipes to one of four conditions: 
C     SUB - Depths of flow at both the upstream and downstream ends 
C           is are greater than the critical and normal flow depths. 
C           Use depths at upstream and downstream junctions for depths 
C           at upstream and downstream ends of conduit.  Assigns 1/2 of 
C           conduit surface area to upstream and downstream junctions. 
C     CR1 - Reverse flow and depth at upstream junction is less than 
C           critical flow depth.  Flow must pass through critical at 
C           upstream end. 
C           Use critical flow depth at upstream end, junction depth 
C           at downstream end.  Flow must pass through critical at 
C           downstream end.  Apply conduit surface area to downstream 
C           junction. 
C     CR2 - Positive flow and depth at downstream junction is less than 
C           critical or normal depth.  Assign minimum of normal or 
C           critical depth to downstream end of conduit and junction 
C           elevation at the upstream end.  Flow must pass through 
C           critical or normal depth at downstream end.  Assign conduit 
C           surface area to upstream junction. 
C     DR1 - If pipe is completely dry, set all parameters to small 
C           values and return. 
C           If the depth in the downstream end is such that there is 
C           water in the pipe, set depth at downstream end to junction 
C           depth.  Set depth at upstream end to small value.  Estimate 
C           actual surface area in pipe and assign to downstream junction. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'OUT.INC' 
      DIMENSION AS1(NEE) 
CIMspeed  don't have character if statements 
CIM  make KINK integer 
cim  make appropriate changes to array link in other parts of program 
cim  add variables DR1, SUB, CR1, and CR2 to new common in OUT.INC 
cim  initialize in parameter statement 
cim      CHARACTER*3 KINK 
C======================================================================= 
      YNL   = HEAD1 - ZU(N) 
cim limit ynl and ynh to crown of pipe and to be greater than zero 
      YNL   = AMIN1(YNL,DEEP(N) + 2.0 * fudge) 
      YNL   = AMAX1(YNL,fudge) 
      YNH   = HEAD2 - ZD(N) 
      YNH   = AMIN1(YNH,DEEP(N) + 2.0 * fudge) 
      YNH   = AMAX1(YNH,fudge) 
      FASNH = 1.0 
      IDOIT = 1 
CIM SPEED MOVE FUDGE INITIALIZATION TO TRANSX      FUDGE = 0.0001 
CIM fudge now equals 0.00001 
CIM REDO THESE IF STATEMENTS 
      IF(YNL.GT.FUDGE.AND.YNH.GT.FUDGE) THEN 
C======================================================================= 
C     Computations for YNL > 0.0, YNH > 0.0   start 
C     Elevation in both upstream and downstream junctions is 
C     greater than the pipe invert 
C======================================================================= 
C              FLOW = QP < 0.0  ==> ADVERSE FLOW 
C======================================================================= 
C :(    Eliminate checks between pipe invert elevation and invert 
C :(    elevation of adjacent node.  By definition, the elevation of 
C :(    all pipes must be greater than or equal to the junction invert. 
C :(    Only sump type orifices can have inverts less than upstream 
C :(    conduit.  Note that there is special code below for sump orifice, 
C :(    this orifice code may need to be modified to account for the 
C :(    commenting out of these lines. 
C :(      The conduit is SUB if the invert elevation of 
C :(      the upstream junction is less than the invert elevation 
C :(      of the conduit, and subcritical or critical otherwise. 
C         SUB if upstream junction depth is greater than the 
C         critical conduit depth. 
C         CR1 if upstream junction depth is less than the 
C         critical conduit depth. 
C======================================================================= 
           IF(QP.LT.0.0) THEN 
                IF(ZU(N)-Z(NL).LE.FUDGE) THEN 
                     KINK = SUB 
                     ELSE 
                     CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM) 
C####                     IF(YC-YNL.LE.FUDGE) KINK = SUB 
C####                     IF(YC-YNL.GT.FUDGE) KINK = CR1 
C#### WCH (RED), 12/7/94.  CHANGE TO FORM USED BY RED. 
                     IF(YC+ZU(N)-HEAD1.LE.FUDGE) KINK = SUB 
                     IF(YC+ZU(N)-HEAD1.GT.FUDGE) KINK = CR1 
                     ENDIF 
C                ENDIF  (change end if to else below) 
C======================================================================= 
C               FLOW = QP > 0.0   ==> POSITIVE FLOW 
C======================================================================= 
C         CR2 if the downstream junction depth is less than the 
C         minimum of critical or normal conduit depth. 
C         SUB if the downstream junction depth is greater than the 
C         maximum of critical or normal conduit depth. 
C         If the downstream depth is between normal and critical, 
C         calculate the value of weighting variable FASNH. 
C======================================================================= 
CIM change to else           IF(QP.GE.0.0) THEN 
                ELSE 
c   ZD should not be less than Z (maybe orifices) 
                IF(ZD(N)-Z(NH).LE.FUDGE) THEN 
                     KINK = SUB 
                     ELSE 
                     CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM) 
                     Y2 = AMIN1(YC,YNORM) 
C$$$$$  Brett Cunningham  change FUDGE to -FUDGE below 
                     IF(Y2-YNH.GT.FUDGE) THEN 
                         KINK = CR2 
C$$$$$  Brett Cunningham  change FUDGE to -FUDGE below????? 
                         ELSE IF(YNH-AMAX1(YC,YNORM).GT.FUDGE) THEN 
                             KINK = SUB 
                         ELSE 
C======================================================================= 
C     Variable FASNH accounts for case in which downstream depth, YNH, 
C     is between critical and normal depth of entering pipe.  Idea is 
C     if YNH ~ Ycrit then FASNH ~ small and don't use much pipe area 
C     for this junction since entering flow is very near critical.  If 
C     YNH ~ Ynorm, then FASNH ~ 1.0 and use most of pipe area for this 
C     junction since entering flow is near normal.  However, must 
C     check for QP = 0 and YNH = 0 ==> Ycrit = Ynorm = YNH = 0.  In 
C     this case, assume downstream flow will be close to critical 
C     and set FASNH = 0. 
C======================================================================= 
C#### WCH, 12/7/94.  CHECK FOR ZERO DENOMINATOR. 
                         IF(ABS(YNORM-YC).GT.FUDGE) THEN 
                              FASNH = (YNH-Y2)/ABS(YNORM-YC) 
                              ELSE 
                              FASNH = 0.0 
                              ENDIF 
                         ENDIF 
                     ENDIF 
                ENDIF 
cimspeedy           ENDIF 
cimspeedy       End of Computations for YNL > 0.0, YNH > 0.0 
cim 
           else 
           IF(YNL.LE.FUDGE.AND.YNH.LE.FUDGE) THEN 
C======================================================================= 
C     DRY PIPE-> depth in upstream and downstream junctions is less than 
C     the pipe invert elevation. 
C 
C======================================================================= 
cim don't think that this should be done but not too sure 
cim take out for now 6/97 
c           HEAD1     = HEAD2 
                YMID      = FUDGE 
                KINK      = DR1 
                ANH       = FUDGE 
                ANL       = FUDGE 
                RNL       = FUDGE 
                BMID      = FUDGE 
C#### WCH (RED), 12/7/94.  Add AMID and RMID. 
                AMID      = FUDGE 
                RMID      = FUDGE 
                AREA      = FUDGE 
                VEL       = 0.0 
                QO(N)     = 0.0 
                HRAD      = FUDGE 
C#### RED (WCH), 12/31/93.  CORRECT INTEGER IDOIT TO BE ZERO. 
C####    IDOIT     = FUDGE 
                IDOIT     = 0 
                AOVERB(N) = FUDGE 
C#### WCH, 12/7/94.  RED CODE USES SAME CALC. FOR NKLASS = 10. 
C####           IF(NKLASS(N).LE.9)  THEN 
                AS1(NL) = AS1(NL) + BMID*LEN(N)/2.0 
                AS1(NH) = AS1(NH) + BMID*LEN(N)/2.0 
C####                ENDIF 
C####           IF(NKLASS(N).EQ.10) AS1(NL) = AS1(NL) + BMID*LEN(N)/2.0 
c     write(n6,*) 1,n,qp,ynl,ynh,ymid,kink 
                RETURN 
C  end of dry pipe calculations. 
cim speedy           ENDIF 
                elseif (YNH.GT.FUDGE) THEN 
C======================================================================= 
C     YNL LE 0, YNH.GT.0 
C     YNL < 0.0, YNH > 0.0 
C     Elevation at upstream junction is less than US conduit invert. 
C     Elevation at downstream junction is greater than DS conduit invert. 
C     If downstream HGL is less than the invert of the upstream 
C     end of the conduit, the conduit has no flow, use condition DR1 
C     If downstream HGL is greater than the invert of the upstream 
C     end of the conduit, flow is in reverse direction, assign critical 
C     depth to upstream end, use condition CR1. 
C======================================================================= 
CIMSPEED      IF(YNL.LE.FUDGE) THEN 
                     IF(HEAD2-ZU(N).LT.FUDGE) THEN 
                          KINK = DR1 
                          ELSE IF(ZU(N).LE.Z(NL)) THEN 
                            KINK = SUB 
                          ELSE 
                          CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM) 
                          KINK = CR1 
                          ENDIF 
cimspeed           ENDIF 
C======================================================================= 
C     YNH LE 0, YNL GT 0 
C     YNL > 0.0, YNH < 0.0 
C     Here elevation in downstream node is less than DS pipe invert and 
C     elevation in upstream node is greater than US pipe invert. 
C     Always minimum of critical or normal downstream, CR2 
C     RED added the following code.. 
C     If upstream HGL is less than the invert of the downstream 
C     end of conduit + fudge, conduit is dry (RED code) (very flat pipe) 
C     1 - This should never ever happen.  If the upstream pipe invert end 
C         by definition is always greater than or equal to the elevation of 
C         the downstream invert, then if the elevation is greater than the 
C         upstream invert it must alway be greater than the invert of the 
C         downstrea invert. 
C     2-  The way that the program assigns YNL to fudge in DR1 part of the 
C         code is not correct even if this could occur. 
C         Comment these lines out. 
C======================================================================= 
                else 
cimspeed      IF(YNH.LE.FUDGE) THEN 
C#### WCH (RED), 12/7/94.  ADD ADDITIONAL IF INVOLVING HEAD1 AND GOTO2000. 
C :*         IF(HEAD1-ZD(N).LT.FUDGE) THEN 
C :*            KINK = DR1 
                IF(ZD(N).LE.Z(NH)) THEN 
                     KINK = SUB 
                     ELSE 
                     CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM) 
                     Y2 = AMIN1(YC,YNORM) 
                     KINK = CR2 
                     ENDIF 
                GO TO 2000 
                ENDIF 
            ENDIF 
C======================================================================= 
C     SPECIAL CONDITION FOR SUMP ORIFICES 
C======================================================================= 
C#### WCH, 12/7/94.  THIS IF-GROUP HAS BEEN COMMENTED OUT IN OSU/EPA 
C     CODE. UN-COMMENT (USE FORTRAN LINES) TO CORRESPOND TO RED CODE. 
C     WCH: AGREE WITH THESE LINES.  ELSE IF DOWNSTREAM INVERT, ZD, < 
C     INVERT OF DOWNSTREAM JUNCTION, Z(NH) OR Z(J) BELOW, THEN 
C     EQUIVALENT ORIFICE CONDUIT WILL ALWAYS "SEE" A DOWNSTREAM DEPTH 
C     OF AT LEAST THE POSITIVE DIFFERENCE, Z(NH) - ZD WHEN IN FACT THE 
C     DEPTH SHOULD BE ZERO.  THESE STATEMENTS ALSO KEEP INITIAL VOLUME 
C     IN ORIFICE PIPE SET AT ZERO VALUE (OR AS CLOSE AS POSSIBLE USING 
C     FUDGE VALUE FOR CROSS SECTIONAL AREA). 
CIM START  OOOOOOOOOOO 
CIM   MODIFY TO INCLUDE RECTANGULAR BOTTOM OUTLET ORIFICE 
C======================================================================= 
      IF(((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) 
CIM END OOOOOOOOOOO 
     A    .AND.YNL.LE.0.96*DEEP(N)) THEN 
              J   = NJUNC(N,2) 
              YNH = HEAD2 - Z(J) 
              IF(YNH.LE.FUDGE) THEN 
                               CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM) 
                               Y2 = AMIN1(YC,YNORM) 
                               KINK  = CR2 
                               ELSE 
                               KINK  = SUB 
                               ENDIF 
              ENDIF 
C======================================================================= 
C     'NORMAL SITUATION' HALF SURFACE AREA AT EACH END 
C======================================================================= 
C#### WCH, 12/7/94.  NOTE, RED CODE HAS SPECIAL SITUATION FOR OUTFALL 
C     CONDUITS.  OSU/EPA CODE DOES NOT HAVE VARIABLE HTAS. 
C 
C      IF(HTAS(NL).GT.0.AND.HTAS(NH).GT.0) THEN 
C                                    IF(KINK.EQ.CRT1) KINK = SUBN 
C                                    IF(KINK.EQ.CRT2) KINK = SUBN 
C                                    ENDIF 
C======================================================================= 
C#### WCH (RED), 12/7/94.  CREATE STMT 2000. 
C 
 2000 CONTINUE 
CIM SPEEDY IF(KINK.EQ.SUB) THEN 
      SELECT CASE (KINK) 
      CASE (SUB) 
CIM SPEEDY 
change ---------------------------------------------------------------- 
CHANGE DEFAULT CASE IS TO USE MIDDLE VALUE 
C 
change           YMID = 0.5*(YNL+YNH) 
         FACTOR = 0.5 
CHANGE  This is correction for YMID, do only if called for by IM2 
         IF (IM2.EQ.1) THEN 
CHANGE  IF Q is positive and HGL slope is greater than bottom slope 
            IF ((QP.GT.0.0).AND.((HEAD1-HEAD2)-(ZU(N)-ZD(N)). 
     1                                      GT.0.0)) THEN 
CHANGE YNORM GT YC INDICATES MILD BOTTOM SLOPE - This is M2 condition.... 
               IF(YNORM.GT.YC) THEN 
                  FACTOR = RM2INTER(YNL,YNH,YNORM,YC,NKLASS(N),DEEP(N)) 
                  ELSEIF  (YNORM.LT.YC) THEN 
CHANGE THIS IS FOR STEEP BOTTOM SLOPE S2 drawdown condition 
                    FACTOR = RS2INTER(YNL,YC,YNORM,YC,NKLASS(N),DEEP(N)) 
                  ELSE 
CHANGE ALSO TRAP FOR CRITICAL BOTTOM SLOPE (YNORM=YC) to avoid zero divide 
                  FACTOR = 0.5 
                  ENDIF 
               ENDIF 
            ENDIF 
         YMID = YNH + (YNL-YNH)*FACTOR 
CHANGE 
change ---------------------------------------------------------------- 
         IF(YMID.LT.FUDGE) YMID = FUDGE 
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL) 
C#### WCH, 11/16/93.  SERIOUS ERROR.  CHANGE "WIDTH" TO BMID 
C####         CALL HYDRAD(N,NKLASS(N),YMID,HRAD,AREA,WIDTH) 
Cwch, 7/23/04         CALL HYDRAD(N,NKLASS(N),YMID,HRAD,AREA,BMID) 
         CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID) 
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH) 
C#### WCH, 12/7/94.  RED CODE DOES NOT DISTIGUISH BETWEEN KLASS 10 
C     AND OTHERS. 
C 
C####           IF(NKLASS(N).LE.9) THEN 
         AS1(NL) = AS1(NL)+0.25*(BNL+BMID)*LEN(N) 
         AS1(NH) = AS1(NH)+0.25*(BMID+BNH)*LEN(N)*FASNH 
Cwch, 7/20/04. If FASNH < 1, add remaining area, i.e., area not added  
C     to downstream node, to upstream node. Optional, from AA line.  
      IF(FASNH.LT.1.0.AND.NFASNH.EQ.1) AS1(NL) = AS1(NL) +  
     1    0.25*(BMID+BNH)*LEN(N)*(1.0-FASNH) 
C####                ENDIF 
C####           IF(NKLASS(N).EQ.10)AS1(NL) = AS1(NL) + BMID*LEN(N) 
C======================================================================= 
C#### WCH, 12/7/94.  RED CODE OMITS FOLLOWING LINES UP TO RETURN AND 
C     USES COMPLEX WEIGHTING CALCULATION AT END.  DON'T USE 
C     RED CODE UNTIL BETTER UNDERSTOOD BY WCH.  THUS, LEAVE THESE LINES. 
C======================================================================= 
change ---------------------------------------------------------------- 
change           AREA      = 0.50*(ANL+ANH) 
change           HRAD      = 0.50*(RNL+RNH) 
change           WIDTH     = 0.50*(BNL+BNH) 
Cwch, 7/23/04         WIDTH = BMID 
change 
change ---------------------------------------------------------------- 
Cwch, 7/23/04. Add option for three different weighting schemes, for 
C     backward and forward compatibility.  From RED. 
C     NAVER = 1 is SWMM3 (1/4,1/2,1/4) 
C     NAVER = 2 is SWMM4 (0,1,0) = default 
C     NAVER = 3 is SWMM5 (1/6,2/3,1/6)  
cred  move to the past on the areas of links - 2/27/2003 
      AREA  = wup(naver)*ANL+wmd(naver)*AMID+wdn(naver)*ANH 
      HRAD  = wup(naver)*RNL+wmd(naver)*RMID+wdn(naver)*RNH 
      WIDTH = wup(naver)*BNL+wmd(naver)*BMID+wdn(naver)*BNH 
C 
         HRAD      = AMAX1(HRAD,FUDGE) 
         WIDTH     = AMAX1(WIDTH,FUDGE) 
         VEL       = QP/AREA 
         AOVERB(N) = AREA/WIDTH 
c     write(n6,*) 2,n,qp,ynl,ynh,ymid,kink 
         RETURN 
cim speedy           ENDIF 
C======================================================================= 
C     CRITICAL SECTION UPSTREAM AND SURFACE AREA DOWNSTREAM 
C======================================================================= 
cim speedy      IF(KINK.EQ.CR1) THEN 
      CASE (CR1) 
cim speedy 
         HEAD1 = YC + ZU(N) 
         YNL   = YC 
change ---------------------------------------------------------------- 
c 
CHANGE DEFAULT CASE IS TO USE MIDDLE VALUE 
C 
change           YMID = 0.5*(YNL+YNH) 
         FACTOR = 0.5 
CHANGE  This is correction for YMID, do only if called for by IM2 
         IF (IM2.EQ.1) THEN 
CHANGE  IF Q is positive and HGL slope is greater than bottom slope 
            IF ((QP.GT.0.0).AND.((HEAD1-HEAD2)-(ZU(N)-ZD(N)). 
     1                                     GT.0.0)) THEN 
CHANGE YNORM GT YC INDICATES MILD BOTTOM SLOPE - This is M2 condition.... 
               IF(YNORM.GT.YC) THEN 
                  FACTOR = RM2INTER(YNL,YNH,YNORM,YC,NKLASS(N),DEEP(N)) 
                  ELSEIF  (YNORM.LT.YC) THEN 
CHANGE THIS IS FOR STEEP BOTTOM SLOPE S2 drawdown condition 
                    FACTOR = RS2INTER(YNL,YC,YNORM,YC,NKLASS(N),DEEP(N)) 
                  ELSE 
CHANGE ALSO TRAP FOR CRITICAL BOTTOM SLOPE (YNORM=YC) to avoid zero divide 
                  FACTOR = 0.5 
                  ENDIF 
               ENDIF 
            ENDIF 
         YMID = YNH + (YNL-YNH)*FACTOR 
CHANGE 
change ---------------------------------------------------------------- 
         IF(YMID.LE.FUDGE) YMID = FUDGE 
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL) 
         CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID) 
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH) 
C#### WCH, 12/7/94.  RED USES COEF OF 0.5, NOT 0.25. 
C####           AS1(NH) = AS1(NH) + 0.25*(BMID+BNH)*LEN(N) 
         AS1(NH) = AS1(NH) + 0.5*(BMID+BNH)*LEN(N) 
cim speedy           ENDIF 
C======================================================================= 
C     CRITICAL SECTION DOWNSTREAM AND SURFACE AREA UPSTREAM 
C======================================================================= 
cim speedy      IF(KINK.EQ.CR2) THEN 
      CASE (CR2) 
cim speedy 
         YNH   = Y2 
         HEAD2 = YNH + ZD(N) 
change ---------------------------------------------------------------- 
CHANGE DEFAULT CASE IS TO USE MIDDLE VALUE 
C 
change           YMID = 0.5*(YNL+YNH) 
         FACTOR = 0.5 
CHANGE  This is correction for YMID, do only if called for by IM2 
         IF (IM2.EQ.1) THEN 
CHANGE  IF Q is positive and HGL slope is greater than bottom slope 
            IF ((QP.GT.0.0).AND.((HEAD1-HEAD2)-(ZU(N)-ZD(N)). 
     1                                GT.0.0)) THEN 
CHANGE YNORM GT YC INDICATES MILD BOTTOM SLOPE - This is M2 condition.... 
               IF(YNORM.GT.YC) THEN 
                  FACTOR = RM2INTER(YNL,YNH,YNORM,YC,NKLASS(N),DEEP(N)) 
                  ELSEIF  (YNORM.LT.YC) THEN 
CHANGE THIS IS FOR STEEP BOTTOM SLOPE S2 drawdown condition 
                    FACTOR = RS2INTER(YNL,YC,YNORM,YC,NKLASS(N),DEEP(N)) 
                  ELSE 
CHANGE ALSO TRAP FOR CRITICAL BOTTOM SLOPE (YNORM=YC) to avoid zero divide 
                  FACTOR = 0.5 
                  ENDIF 
               ENDIF 
            ENDIF 
         YMID = YNH + (YNL-YNH)*FACTOR 
CHANGE 
change ---------------------------------------------------------------- 
         IF(YMID.LE.FUDGE) YMID = FUDGE 
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL) 
         CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID) 
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH) 
C======================================================================= 
Cwch, 7/20/04. After extensive consideration by Bob Dickinson, with  
C     input from Larry Roesener and others, the consensus (RED, WCH, 
C     LAR, TedB) is that *all* surface area of pipe should go to 
C     upstream node when downstream node is critical or supercritical, 
C     regardless of status of upstream node.  Hence, coefficient below 
C     should be 0.50, not 0.25. 
C======================================================================= 
C         AS1(NL) = AS1(NL) + 0.25*(BNL+BMID)*LEN(N) 
         AS1(NL) = AS1(NL) + 0.50*(BNL+BMID)*LEN(N) 
cim speedy           ENDIF 
C======================================================================= 
C     DRY UPSTREAM AND SURFACE AREA DOWNSTREAM 
C======================================================================= 
cim speedy      IF(KINK.EQ.DR1) THEN 
      CASE (DR1) 
cim speedy 
CIM BAC This next statement seems to be a total screw up, 
CIM  No reason to change upstream head to downstream head 
CIM           HEAD1 = HEAD2 
         YNL   = FUDGE 
C#### WCH, 12/7/94.  RED CODE DIFFERS CONSIDERABLY. 
C     BELOW, COMMENT OUT OLD LINES AND INCLUDE COMMENT FOR EACH 
C     NEW RED LINE.  BASICALLY, DON'T USE MID (YMID, ETC.) VALUES. 
C####           YMID  = HEAD2-0.5*(ZU(N)+ZD(N)) 
C####           IF(YMID.LT.FUDGE) YMID = FUDGE 
CIM if YNL = fudge simply set others to fudge and get on with it.? 
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL) 
cim              RNL = FUDGE 
cim              ANL = FUDGE 
cim              BNL = FUDGE 
CIM 
C####           CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID) 
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH) 
C####           AREA      = 0.25*(ANL+2.0*AMID+ANH) 
C####           HRAD      = 0.5*(RMID+RNH) 
C#### WCH, 12/7/94.  NEW AREA =   AND HRAD =. 
cim note that if ANL is FUDGE then AREA will be FUDGE 
         AREA      = SQRT(ANL*ANH) 
         AREA      = AMAX1(AREA,FUDGE) 
cim set HRAD to that of downstream end? 
         HRAD      = RNH 
         HRAD      = AMAX1(HRAD,FUDGE) 
C 
         VEL       = 0.0 
         QO(N)     = 0.0 
         IDOIT     = 0 
         AOVERB(N) = FUDGE 
C#### WCH, 12/7/94.  RED INCLUDES CALC. FOR HGL NOT IN OSU/EPA CODE. OMIT. 
C####         HGL(N,1)  = YNL + ZU(N) 
C####         HGL(N,2)  = YNH + ZD(N) 
C#### OLD OSU/EPA CODE: 
C####           AS1(NH) = AS1(NH) + 0.25*(BMID+BNH)*LEN(N) 
C####           IF(ZU(N)-Z(NL).LT.FUDGE) AS1(NL) = 
C####     +                            AS1(NL) + 0.25*(BNL+BMID)*LEN(N) 
C#### NEW RED CODE. 
cim seems like this overestimates area, entire length won't be flooded to 
cim width of downstream end. 
         AS1(NH)    = AS1(NH) + BNH*LEN(N) 
cim  seems like this next line double counts conduit area. Again ZU(N) 
cim  shou not be less than Z(NL) 
           IF(ZU(N)-Z(NL).LT.FUDGE) AS1(NL) = AS1(NL) + BNL*LEN(N) 
C#### OSU/EPA CODE DOES NOT INCLUDE LINK(N) 
C####           LINK(N)   = KINK 
C 
c     write(n6,*) 3,n,qp,ynl,ynh,ymid,kink 
         RETURN 
cim speedy           ENDIF 
      END SELECT 
cim speedy 
C======================================================================= 
C     COMPUTE CROSS-SECTION AREA, VELOCITY * HYDRAULIC RADIUS 
C======================================================================= 
C#### WCH, 12/7/94.  HERE, RED CODE USES COMPLEX WEIGHTING TO CALCULATE 
C     AREA, HRAD AND WIDTH.  DO NOT USE UNTIL BETTER UNDERSTOOD BY WCH. 
C     SO THIS CODE REMAINS UNCHAGED. 
C======================================================================= 
change ---------------------------------------------------------------- 
c      AREA  = 0.25*(ANL+2.0*AMID+ANH) 
c      HRAD  = 0.25*(RNL+2.0*RMID+RNH) 
c      WIDTH = 0.25*(BNL+2.0*BMID+BNH) 
      AREA = AMID 
      HRAD = RMID 
      WIDTH = BMID 
change 
change ---------------------------------------------------------------- 
      HRAD  = AMAX1(HRAD,FUDGE) 
      WIDTH = AMAX1(WIDTH,FUDGE) 
      IF(AREA.LE.FUDGE) THEN 
           VEL       = 0.0 
           QO(N)     = 0.0 
           IDOIT     = 0 
           AREA      = FUDGE 
           AOVERB(N) = FUDGE 
           ELSE 
           VEL       = QP/AREA 
           AOVERB(N) = AREA/WIDTH 
           IF(VEL.GT.50.0)  VEL =  50.0 
           IF(VEL.LT.-50.0) VEL = -50.0 
           ENDIF 
c     write(n6,*) 4,n,qp,ynl,ynh,ymid,kink 
      RETURN 
      END 
 
REM File: NTIME.FOR 
 
      SUBROUTINE NTIME(JDAY,TMDAY,TRAIN) 
C####################################################################### 
C     CALCULATE THE TIME DIFFERENCE IN SECONDS BETWEEN JDAY AND TMDAY 
C     AND THE EXISTING JULDAY AND TIMDAY 
C 
C     JDAY   = JULIAN DAY 
C     TMDAY  = TIME OF DAY IN SECONDS 
C     TRAIN  = TIME DIFFERENCE IN SECONDS (+ or -) 
C     TRAIN is positive if JDAY/TMDAY > JULDAY/TIMDAY. 
C####################################################################### 
      INCLUDE 'STIMER.INC' 
      JYEAR = JDAY/1000 
      IYEAR = JULDAY/1000 
      LDAY  = JDAY   - JYEAR*1000 
      KDAY  = JULDAY - IYEAR*1000 
      IF (JYEAR.LT.100) THEN 
           JYEAR = JYEAR + 1900 
           JDAY = LDAY + JYEAR*1000 
           ENDIF 
      IF (IYEAR.LT.100) THEN 
           IYEAR = IYEAR + 1900 
           JULDAY = KDAY + IYEAR*1000 
           ENDIF 
      JDIFF = 0 
C======================================================================= 
C     IYEAR AND JYEAR ARE DIFFERENT YEARS 
C======================================================================= 
      IF(JYEAR.GT.IYEAR) THEN 
           IY    = IYEAR  + 1 
           JY    = JYEAR  - 1 
           IF(JY.GE.IY) THEN 
                   DO 100 KYEAR = IY,JY 
                                         ID = 365 
                   IF(MOD(KYEAR,4).EQ.0) ID = 366 
                   JDIFF = JDIFF + ID 
 100               CONTINUE 
                   ENDIF 
           JDIFF = JDIFF + LDAY 
                                 ID = 365 
           IF(MOD(IYEAR,4).EQ.0) ID = 366 
           JDIFF = JDIFF + ID - KDAY 
           ENDIF 
C======================================================================= 
C     IYEAR AND JYEAR ARE DIFFERENT YEARS 
C======================================================================= 
      IF(JYEAR.LT.IYEAR) THEN 
           IY    = IYEAR  - 1 
           JY    = JYEAR  + 1 
           IF(IY.GE.JY) THEN 
                   DO 200 KYEAR = JY,IY 
                                         ID = 365 
                   IF(MOD(KYEAR,4).EQ.0) ID = 366 
                   JDIFF = JDIFF - ID 
 200               CONTINUE 
                   ENDIF 
           JDIFF = JDIFF - KDAY 
                                 ID = 365 
           IF(MOD(JYEAR,4).EQ.0) ID = 366 
           JDIFF = JDIFF - ID + LDAY 
           ENDIF 
C======================================================================= 
C     IYEAR AND JYEAR ARE THE SAME YEAR 
C======================================================================= 
      IF(JYEAR.EQ.IYEAR) THEN 
                         JDIFF = LDAY - KDAY 
                         ENDIF 
C======================================================================= 
C     CALCULATE DIFFERENCE IN SECONDS 
C======================================================================= 
      TDIFF = TMDAY - TIMDAY 
      TRAIN = FLOAT(JDIFF)*86400.0 + TDIFF 
      RETURN 
      END 
 
REM File: OUTPUT.FOR 
 
      SUBROUTINE OUTPUT 
C       EXTRAN BLOCK 
C       CALLED BY EXTRAN NEAR LINE 207 
C======================================================================= 
C     Subroutine prints output and controls the printer/plot routines. 
C     WCH, 11/29/93.  Correct metric depth/diameter units to meters. 
C     WCH, 8/4/95.  Don't print junction outflows < 0.001 cf or cm. 
C     CIM, 9/8/00.  Write threshold table and allow more hours in output 
C     WCH, 2/9/01.  Include corrections for output of upstream and 
C       downstream heads, and slope, for conduits, suggested by 
C       Nerkez Gavranovic, Sydney, Australia. (Comment = cng) 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'LAB.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'HYFLOW.INC' 
      INCLUDE 'FCHAN.INC' 
CIM 1/99 CHANGE FOR BA OUTPUT CONTROLS    - OUTPUT CONTROLS 
      INCLUDE 'BALINES.INC' 
	INCLUDE 'TRANAID.INC' 
C======================================================================= 
      DIMENSION FMAX(NPO),FMEAN(NPO),FMIN(NPO),YY(201,2) 
      DIMENSION GMAX(NPO),GMEAN(NPO),GMIN(NPO),NPT(2),X(201,2), 
     +          PSF(NPO,2) 
Cwch, 2/9/01.  Add VER5 
      CHARACTER TP*1,VER1*10,VER2*10,VER3*10,VER4*10,VER5*10, 
     +               YER1*10,YER2*10,YER3*10,YER4*10,BMJ*10 
      CHARACTER ASTER*1,XID*1,POUND*1,DOLLAR*1 
      DATA VER1/' CONDUIT  '/,VER2/' FLOW IN  '/,VER3/'   CFS    ' /, 
     +     VER4/'  CU M/S  '/,VER5/' SLOPE(%) ' / 
      DATA YER1/' JUNCTION '/,YER2/'WATER SURF'/,YER3/' ELEV(FT) ' /, 
     +     YER4/' ELEV(M)  '/ 
      DATA TP/' '/,ASTER/'*'/,POUND/'#'/,DOLLAR/'$'/ 
C======================================================================= 
C     Write Junction inflows. 
C======================================================================= 
      WRITE(N6,5002) 
      WRITE(N6,5004) 
      IF(METRIC.EQ.1) WRITE(N6,5007) 
      IF(METRIC.EQ.2) WRITE(N6,4995) 
      SUMQIN  = 0.0 
      DO 19 J = 1,NJ 
      IF(QQI(J).LE.0.0) GO TO 19 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,5003)  JUN(J),QQI(J) 
	ELSE 
	  WRITE(N6,5013) AJUN(J),QQI(J) 
	ENDIF 
C       This next line was needed when having 
C     flows on K3 lines and flows on table 
C     causes a NAN. 
c      IF (ISNAN(QOU(J))) QOU(J) = 0.0 
C  Print when node has a positive QQI and a 
C  negative QOU 
	IF (QOU(J).LT.0.0) 
     1WRITE(N6,*)'THE ABOVE NODE HAS A POSITIVE QQI AND A', 
     2' NEGATIVE QOU.' 
      SUMQIN    = SUMQIN  + QQI(J) 
  19  CONTINUE 
      DO 20 J = 1,NJ 
      IF(QOU(J).GE.0.0) GO TO 20 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,5003)  JUN(J),-QOU(J) 
	ELSE 
	  WRITE(N6,5013) AJUN(J),-QOU(J) 
	ENDIF 
      SUMQIN    = SUMQIN  - QOU(J) 
  20  CONTINUE 
C======================================================================= 
C     Write Junction outflows. 
C======================================================================= 
      IF(METRIC.EQ.1) WRITE(N6,5005) 
      IF(METRIC.EQ.2) WRITE(N6,4998) 
      SUMOUT   = 0.0 
      DO 119 J = 1,NJ 
C#### WCH, 8/4/95.  DO NOT PRINT OUTFLOWS < 0.001 CU FT OR CU M. 
C     THAT IS, INCREASE FROM CHECK FOR .LE.0 TO .LE.0.0001. 
      IF(QOU(J).LE.0.0001) GO TO 119 
cim try leaving 0.0 
cim      IF(QOU(J).LE.0.0) GO TO 119 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,5003)  JUN(J),QOU(J) 
	ELSE 
	  WRITE(N6,5013) AJUN(J),QOU(J) 
	ENDIF 
      SUMOUT   = SUMOUT + QOU(J) 
  119 CONTINUE 
C======================================================================= 
C     PRINT CONTINUITY SUMMARY 
C======================================================================= 
      IF(METRIC.EQ.1) WRITE(N6,5001) VINIT,SUMQIN,VINIT+SUMQIN 
      IF(METRIC.EQ.2) WRITE(N6,4999) VINIT,SUMQIN,VINIT+SUMQIN 
      IF(METRIC.EQ.1) WRITE(N6,5008) SUMOUT 
      IF(METRIC.EQ.2) WRITE(N6,4997) SUMOUT 
      IF(METRIC.EQ.1) WRITE(N6,5009) VLEFT,VLEFT+SUMOUT 
      IF(METRIC.EQ.2) WRITE(N6,4996) VLEFT,VLEFT+SUMOUT 
      SUME   = VINIT + SUMQIN 
      PCTERR = (SUME - SUMOUT - VLEFT) / SUME * 100.0 
      WRITE(N6,5006) PCTERR 
CIM TEST OF ALTERNATIVE CALCULATION OF FINAL VOLUME 
C   COMPUTED BY TRACKING TOTAL VOLUME IN EACH JUNCTION 
	VLEFT2 = 0.0 
	DO  N   = 1,NTC 
	VLEFT2 = VLEFT2 + VOL(N) 
	ENDDO 
	PCTERR2 = (SUME - SUMOUT - VLEFT2) / SUME * 100.0 
      WRITE(N6,7000) VLEFT2,PCTERR2 
cim write continuity error to console 
      WRITE(*,6006) PCTERR 
cim intercon  call fintercon to output results 
      call fintercon 
cim end 
C 
C******** PRINT FULL FLOW SUMMARY IF REQUIRED 
C 
      DO IWFA=1,NTL 
       IF(IFULL(IWFA).GT.0) GO TO 47 
      ENDDO 
       GO TO 49 
   47    WRITE(N6,5047) 
      DO 48 IWF=IWFA,NTL 
	 IF(IFULL(IWF).GT.0) THEN 
	 IF (JCE.EQ.0) THEN 
	       WRITE(N6,5048) NCOND(IWF),NFIRST(IWF), 
     *                        FHOUR(IWF),NLAST(IWF),FLHOUR(IWF) 
	 ELSE 
	       WRITE(N6,5049) ACOND(IWF),NFIRST(IWF), 
     *                        FHOUR(IWF),NLAST(IWF),FLHOUR(IWF) 
	 ENDIF 
	 ENDIF 
   48 CONTINUE 
      WRITE(N6,5050) 
   49 CONTINUE 
      NOUT     = NSCRAT(1) 
C======================================================================= 
C     PRINT H.G.L. AND WATER DEPTH AT NODES 
C======================================================================= 
      IF(NHPRT.GT.0) THEN 
      DO 100 I = 1,NHPRT 
      FMEAN(I) = 0.0 
      FMAX(I)  = 0.0 
      FMIN(I)  = 1.0E30 
      GMEAN(I) = 0.0 
      GMAX(I)  = 0.0 
      GMIN(I)  = 1.0E30 
      MJPRT    = JPRT(I) 
      JPRT(I)  = JUN(MJPRT) 
  100 PRGEL(I) = GRELEV(MJPRT) 
      DO 125 I = 1,NHPRT,5 
      REWIND NOUT 
cim change nout to unformatted sequential 
      READ(NOUT) JCE,NHPRT,NQPRT,NSURF 
C======================================================================= 
C     READ THE HEADER INFORMATION ON THE NOUT FILE 
C======================================================================= 
      IF(JCE.EQ.0) THEN 
      IF(NHPRT.GT.0) READ(NOUT) (N1,J=1,NHPRT) 
      IF(NQPRT.GT.0) READ(NOUT) (N1,J=1,NQPRT) 
      IF(NSURF.GT.0) READ(NOUT) (N1,J=1,NSURF) 
      ELSE 
      IF(NHPRT.GT.0) READ(NOUT) (BMJ,J=1,NHPRT) 
      IF(NQPRT.GT.0) READ(NOUT) (BMJ,J=1,NQPRT) 
      IF(NSURF.GT.0) READ(NOUT) (BMJ,J=1,NSURF) 
      ENDIF 
      IF(METRIC.EQ.1) WRITE(N6,5020) 
      IF(METRIC.EQ.2) WRITE(N6,5030) 
      WRITE(N6,5000)  ALPHA1,ALPHA2 
      IT = I + 4 
      IF(IT.GT.NHPRT) IT = NHPRT 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,5040) (TP,JPRT(L),L=I,IT) 
	ELSE 
	  WRITE(N6,5041) (TP,AOUT(L,1),L=I,IT) 
	ENDIF 
      WRITE(N6,5060) (TP,PRGEL(L),L=I,IT) 
      WRITE(N6,5061) (TP,L=I,IT) 
      WRITE(N6,5062) (TP,L=I,IT) 
      LT       = MIN0(I+4,NHPRT) 
      IF(LTIME.GT.0) THEN 
      DO 120 L = 1,LTIME 
      IF(JPRINT.EQ.1) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                    K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT), 
     +                              (PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.2) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                     K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT) 
      IF(JPRINT.EQ.3) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                                                 K=1,NHPRT) 
      IF(JPRINT.EQ.4) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                   K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.5) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J), 
     +                   J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.6) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J), 
     +                                        PRTV(J),J=1,NQPRT) 
      IF(JPRINT.EQ.7) READ(NOUT) TIME,MINUTE,JSEC, 
     +                                (PSF(J,1),PSF(J,2),J=1,NSURF) 
      DO 110 K = I,LT 
      FMEAN(K) = FMEAN(K) + PRTH(K) 
      GMEAN(K) = GMEAN(K) + PRTY(K) 
      IF(PRTH(K).GT.FMAX(K)) FMAX(K) = PRTH(K) 
      IF(PRTY(K).GT.GMAX(K)) GMAX(K) = PRTY(K) 
      IF(PRTH(K).LT.FMIN(K)) FMIN(K) = PRTH(K) 
      IF(PRTY(K).LT.GMIN(K)) GMIN(K) = PRTY(K) 
 110  CONTINUE 
      LTIMEH   = IFIX(TIME/3600.0) 
      WRITE(N6,5080) LTIMEH,MINUTE,JSEC,(PRTH(K),PRTY(K),K=I,LT) 
  120 CONTINUE 
      DENOM = FLOAT(LTIME) 
      ELSE 
      DENOM = 1.0 
      ENDIF 
      WRITE(N6,5243) (FMEAN(K)/DENOM,GMEAN(K)/DENOM,K=I,LT) 
      WRITE(N6,5245) (FMAX(K),GMAX(K),K=I,LT) 
      WRITE(N6,5250) (FMIN(K),GMIN(K),K=I,LT) 
      WRITE(N6,6666) 
  125 CONTINUE 
      ENDIF 
C======================================================================= 
C     COMPUTE AND PRINT SUMMARY STATISTICS FOR JUNCTIONS 
C======================================================================= 
      IBAD     = 1 
      JBAD     = 1 
      YMAX     = 0.0 
      IXPLAN   = 0 
CIM 1/99  Skip printing of page headers if JHEAD = 1 
CIM print first header line 
      WRITE(N6,750) 
      WRITE(N6,5000) ALPHA1,ALPHA2 
      IF(METRIC.EQ.1) WRITE(N6,751) 
      IF(METRIC.EQ.2) WRITE(N6,749) 
      DO 700 J = 1,NJ 
      IF(JHEAD.EQ.0.AND.MOD(J,40).EQ.0) THEN 
      WRITE(N6,750) 
      WRITE(N6,5000) ALPHA1,ALPHA2 
      IF(METRIC.EQ.1) WRITE(N6,751) 
      IF(METRIC.EQ.2) WRITE(N6,749) 
      END IF 
C======================================================================= 
C     COMPUTE FEET MAXIMUM DEPTH IS BELOW GROUND ELEVATION 
C======================================================================= 
		    FTBLG = GRELEV(J)-(DEPMAX(J)+Z(J)) 
C======================================================================= 
C PRINT SYMBOL IF INFLOW OCCURS AT SURFACE FLOODING LOCATION 
C======================================================================= 
      XID = TP 
      IF(FTBLG.LE.0.0) THEN 
		       FTBLG = 0.0 
		       DO 703 I = 1,LOCATS 
		       IF(J.EQ.NLOC(I)) XID = ASTER 
  703                  CONTINUE 
		       DO 704 I = 1,NJSW 
		       IF(J.EQ.JSW(I).AND.XID.EQ.TP) XID = POUND 
		       IF(J.EQ.JSW(I).AND.XID.EQ.ASTER) XID = DOLLAR 
  704                  CONTINUE 
		       IF(XID.NE.TP) IXPLAN = 1 
		       ENDIF 
C======================================================================= 
C     COMPUTE FEET OF SURCHARGE AT MAXIMUM DEPTH 
C======================================================================= 
			SURMAX = DEPMAX(J)+Z(J)-ZCROWN(J) 
      IF(SURMAX.LE.0.0) SURMAX = 0.0 
C======================================================================= 
C     PRINT JUNCTION STATISTICS 
C======================================================================= 
      SURLEN(J) = SURLEN(J)/60.0 
      FLDLEN(J) = FLDLEN(J)/60.0 
      YTOT(J)   = YTOT(J)/FLOAT(NTCYC) 
      YDEV(J)   = 100.0*YDEV(J)/FLOAT(NTCYC) 
      YTOT(J)   = YTOT(J)   + Z(J) 
      DEPMAX(J) = DEPMAX(J) + Z(J) 
      IF(YDEV(J).GT.YMAX) THEN 
			  JBAD = J 
			  YMAX = YDEV(J) 
			  ENDIF 
CIM CHANGE TO PRINT 10 CHARACTERS AND DIGITS 
	IF (JP10.EQ.0) THEN 
CIM THESE ARE ORIGINAL FORMATS 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,752) JUN(J),GRELEV(J),ZCROWN(J), 
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J), 
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J) 
	ELSE 
	  WRITE(N6,762) AJUN(J),GRELEV(J),ZCROWN(J), 
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J), 
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J) 
	ENDIF 
	ELSE 
CIM THESE ARE MODIFIED FORMATS 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,6752) JUN(J),GRELEV(J),ZCROWN(J), 
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J), 
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J) 
	ELSE 
	  WRITE(N6,6762) AJUN(J),GRELEV(J),ZCROWN(J), 
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J), 
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J) 
	ENDIF 
	ENDIF 
  700 CONTINUE 
      IF(IXPLAN.NE.0) WRITE(N6,770) 
      IF(IXPLAN.NE.0) WRITE(N6,771) 
CIM ### 9/8/00 
C======================================================================= 
C     PRINT JUNCTION ELEVATION SUMMARY STATISTICS 
C======================================================================= 
      CALL WRTETHRESH 
C======================================================================= 
C     PRINT FLOWS * VELOCITIES IN PIPES 
C======================================================================= 
      IF(NQPRT.GT.0) THEN 
      AMULT    = FLOAT(JNTER) 
      DO 140 I = 1,NQPRT 
      L        = CPRT(I) 
      FMEAN(I) = 0.0 
      FMAX(I)  = 0.0 
      FMIN(I)  = 1.0E30 
      GMEAN(I) = 0.0 
      GMAX(I)  = 0.0 
      GMIN(I)  = 1.0E30 
  140 CPRT(I)  = NCOND(L) 
      DO 160 I = 1,NQPRT,5 
      REWIND NOUT 
      READ(NOUT) JCE,NHPRT,NQPRT,NSURF 
C======================================================================= 
C     READ THE HEADER INFORMATION ON THE NOUT FILE 
C======================================================================= 
      IF(JCE.EQ.0) THEN 
      IF(NHPRT.GT.0) READ(NOUT) (N1,J=1,NHPRT) 
      IF(NQPRT.GT.0) READ(NOUT) (N1,J=1,NQPRT) 
      IF(NSURF.GT.0) READ(NOUT) (N1,J=1,NSURF) 
      ELSE 
      IF(NHPRT.GT.0) READ(NOUT) (BMJ,J=1,NHPRT) 
      IF(NQPRT.GT.0) READ(NOUT) (BMJ,J=1,NQPRT) 
      IF(NSURF.GT.0) READ(NOUT) (BMJ,J=1,NSURF) 
      ENDIF 
      IF(METRIC.EQ.1) WRITE(N6,5100) 
      IF(METRIC.EQ.2) WRITE(N6,5101) 
      WRITE(N6,5000) ALPHA1,ALPHA2 
		      IT = I + 4 
      IF(IT.GT.NQPRT) IT = NQPRT 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,5120) (TP,CPRT(L),L=I,IT) 
	ELSE 
	  WRITE(N6,5130) (TP,AOUT(L,2),L=I,IT) 
	ENDIF 
      WRITE(N6,5121) (TP,L=I,IT) 
      WRITE(N6,5122) (TP,L=I,IT) 
      LT       = MIN0(I+4,NQPRT) 
      IF(LTIME.GT.0) THEN 
      DO 165 L = 1,LTIME 
      IF(JPRINT.EQ.1) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                    K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT), 
     +                              (PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.2) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                     K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT) 
      IF(JPRINT.EQ.3) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                                                 K=1,NHPRT) 
      IF(JPRINT.EQ.4) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                   K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.5) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J), 
     +                   J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.6) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J), 
     +                                                 J=1,NQPRT) 
      IF(JPRINT.EQ.7) READ(NOUT) TIME,MINUTE,JSEC, 
     +                                (PSF(J,1),PSF(J,2),J=1,NSURF) 
      DO 170 K = I,LT 
      FMEAN(K) = FMEAN(K) + PRTQ(K) 
      GMEAN(K) = GMEAN(K) + PRTV(K) 
      IF(PRTQ(K).GT.FMAX(K)) FMAX(K) = PRTQ(K) 
      IF(PRTV(K).GT.GMAX(K)) GMAX(K) = PRTV(K) 
      IF(PRTQ(K).LT.FMIN(K)) FMIN(K) = PRTQ(K) 
      IF(PRTV(K).LT.GMIN(K)) GMIN(K) = PRTV(K) 
 170  CONTINUE 
      LTIMEH   = IFIX(TIME/3600.0) 
      IF(METRIC.EQ.1) WRITE(N6,5140) LTIMEH,MINUTE,JSEC, 
     +                               (PRTQ(K),PRTV(K),K=I,LT) 
      IF(METRIC.EQ.2) WRITE(N6,5141) LTIMEH,MINUTE,JSEC, 
     +                               (PRTQ(K),PRTV(K),K=I,LT) 
  165 CONTINUE 
      DENOM = FLOAT(LTIME) 
      ELSE 
      DENOM = 1.0 
      ENDIF 
      IF(METRIC.EQ.1) THEN 
		WRITE(N6,5142) (FMEAN(K)/DENOM,GMEAN(K)/DENOM,K=I,LT) 
		WRITE(N6,5145) (FMAX(K),GMAX(K),K=I,LT) 
		WRITE(N6,5150) (FMIN(K),GMIN(K),K=I,LT) 
		WRITE(N6,5144) (FMEAN(K)*DELT*AMULT,K=I,LT) 
		ELSE 
		WRITE(N6,5143) (FMEAN(K)/DENOM,GMEAN(K)/DENOM,K=I,LT) 
		WRITE(N6,5146) (FMAX(K),GMAX(K),K=I,LT) 
		WRITE(N6,5151) (FMIN(K),GMIN(K),K=I,LT) 
		WRITE(N6,5144) (FMEAN(K)*DELT*AMULT,K=I,LT) 
		ENDIF 
      WRITE(N6,6666) 
  160 CONTINUE 
      ENDIF 
C======================================================================= 
C     Compute and print summary statistics for conduits. 
C======================================================================= 
CIM 1/99 eliminate header lines if JHEAD =1 
CIM write first header line 
				   WRITE(N6,800) 
				   WRITE(N6,5000) ALPHA1,ALPHA2 
CIM 1/99 MODIFY HEADER TO GO WITH EXPANDED FORMATS 
      IF(JP10.EQ.0) THEN 
CIM THESE ARE ORIGINAL FORMATS 
				    IF(METRIC.EQ.1) THEN 
										 WRITE(N6,801) 
				      ELSE 
						   WRITE(N6,799) 
				      ENDIF 
	ELSE 
CIM MODIFIED FORMATS 
				    IF(METRIC.EQ.1) THEN 
										 WRITE(N6,6801) 
				      ELSE 
						   WRITE(N6,6799) 
				      ENDIF 
	ENDIF 
      DO 900 N = 1,NTL 
      IF(JHEAD.EQ.0.AND.MOD(N,40).EQ.0) THEN 
				   WRITE(N6,800) 
				   WRITE(N6,5000) ALPHA1,ALPHA2 
	IF(JP10.EQ.0) THEN 
CIM THESE ARE ORIGINAL HEADER FORMATS 
				   IF(METRIC.EQ.1) THEN 
										 WRITE(N6,801) 
				     ELSE 
						   WRITE(N6,799) 
				     ENDIF 
	ELSE 
CIM MODIFIED FORMATS 
				   IF(METRIC.EQ.1) THEN 
										 WRITE(N6,6801) 
				     ELSE 
						   WRITE(N6,6799) 
				     ENDIF 
	ENDIF 
      ENDIF 
C======================================================================= 
C     COMPUTE DESIGN VELOCITY AND FLOW IN CONDUIT 
C     COMPUTE RATIO OF MAX TO DESIGN FLOW IN CONDUIT 
C======================================================================= 
      IF(N.LE.NTC) THEN 
			     QRATIO = 0.0 
	 IF(QFULL(N).GT.0.0) QRATIO = QMAXX(N)/QFULL(N) 
C======================================================================= 
C        COMPUTE MAX WATER DEPTH ABOVE CONDUIT INVERT AT BOTH ENDS 
C======================================================================= 
	 SLOPE     = (ZU(N)-ZD(N))/LEN(N) 
	 VDSGN     = SQRT(GRVT*SLOPE/ROUGH(N))*RFULL(N)**0.6666667 
	 DMAXNL    = PMAX(N,1) - ZU(N) 
	 DMAXNH    = PMAX(N,2) - ZD(N) 
	 SUPLEN(N) = SUPLEN(N)/60.0 
	 IF(METRIC.EQ.1) VHGHT = DEEP(N)*12.0 
C#### WCH, 11/29/93.  CORRECT METRIC DIAMETER/DEPTH OUTPUT TO METERS. 
	 IF(METRIC.EQ.2) VHGHT = DEEP(N) 
	 ELSE 
	 SLOPE     = 1.0E20 
	 ENDIF 
C======================================================================= 
C     Print conduit statistics. 
C======================================================================= 
CIM 1/99 WRITE ALL 10 DIGITS AND CHARACTERS 
	IF(JP10.EQ.0) THEN 
CIM WRITE ORIGINAL FORMAT STATEMENTS 
      IF(SLOPE.LT.1.0E10) THEN 
	       IF(JCE.EQ.0.OR.N.GT.NC) WRITE(N6,802) 
     2                      NCOND(N),QFULL(N),VDSGN,VHGHT, 
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N), 
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH, 
     2                      SUPLEN(N),SLOPE 
	       IF(JCE.EQ.1.AND.N.LE.NC) WRITE(N6,812) 
     2                      ACOND(N),QFULL(N),VDSGN,VHGHT, 
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N), 
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH, 
     2                      SUPLEN(N),SLOPE 
	       ELSE 
	       IF(JCE.EQ.0) WRITE(N6,803) NCOND(N),QMAXX(N), 
     +                                    IQHR(N),IQMIN(N) 
	       IF(JCE.EQ.1) WRITE(N6,813) ACOND(N),QMAXX(N), 
     +                                    IQHR(N),IQMIN(N) 
	       ENDIF 
	ELSE 
CIM WRITE MODIFIED FORMAT STATEMENTS 
      IF(SLOPE.LT.1.0E10) THEN 
	       IF(JCE.EQ.0.OR.N.GT.NC) WRITE(N6,6802) 
     2                      NCOND(N),QFULL(N),VDSGN,VHGHT, 
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N), 
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH, 
     2                      SUPLEN(N),SLOPE 
	       IF(JCE.EQ.1.AND.N.LE.NC) WRITE(N6,6812) 
     2                      ACOND(N),QFULL(N),VDSGN,VHGHT, 
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N), 
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH, 
     2                      SUPLEN(N),SLOPE 
	       ELSE 
	       IF(JCE.EQ.0) WRITE(N6,6803) NCOND(N),QMAXX(N), 
     +                                    IQHR(N),IQMIN(N) 
	       IF(JCE.EQ.1) WRITE(N6,6813) ACOND(N),QMAXX(N), 
     +                                    IQHR(N),IQMIN(N) 
	       ENDIF 
	ENDIF 
  900 CONTINUE 
C======================================================================= 
C     Print conduit link conditions. 
C======================================================================= 
      QMAX     = 0.0 
CIM 1/99 ELIMINATE INTERMEDIATE HEADER LINES IF JHEAD = 1 
CIM WRITE FIRST HEADER LINE HERE 
				   IF(METRIC.EQ.1) WRITE(N6,940) 
				   IF(METRIC.EQ.2) WRITE(N6,941) 
      DO 950 N = 1,NTL 
      IF(JHEAD.EQ.0.AND.MOD(N,40).EQ.0) THEN 
				   IF(METRIC.EQ.1) WRITE(N6,940) 
				   IF(METRIC.EQ.2) WRITE(N6,941) 
				   ENDIF 
      QMEAN    = QTOT(N)/FLOAT(NTCYC) 
      QDEV(N)  = 100.0*QDEV(N)/FLOAT(NTCYC) 
      QTOT(N)  = QTOT(N)*RDELT 
      IF(N.LE.NTC) THEN 
      IF(QDEV(N).GT.QMAX) THEN 
			  IBAD = N 
			  QMAX = QDEV(N) 
			  ENDIF 
      IF(JCE.EQ.0) THEN 
		     WRITE(N6,955) NCOND(N),CTIME(N,1)/60.0, 
     +                           CTIME(N,2)/60.0,CTIME(N,3)/60.0, 
     +                           CTIME(N,4)/60.0,QMEAN,QDEV(N),QTOT(N), 
     +                           HMAX(N),AMAX(N) 
	ELSE 
		   WRITE(N6,965) ACOND(N),CTIME(N,1)/60.0, 
     +                           CTIME(N,2)/60.0,CTIME(N,3)/60.0, 
     +                           CTIME(N,4)/60.0,QMEAN,QDEV(N),QTOT(N), 
     +                           HMAX(N),AMAX(N) 
	ENDIF 
      ELSE 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,975) NCOND(N),QMEAN,QTOT(N) 
	ELSE 
	  WRITE(N6,985) ACOND(N),QMEAN,QTOT(N) 
	ENDIF 
      ENDIF 
  950 CONTINUE 
      WRITE(N6,9400) 
      IF(JCE.EQ.0) THEN 
		     WRITE(N6,9410) NCOND(IBAD),QDEV(IBAD), 
     +                                       JUN(JBAD),YDEV(JBAD) 
	ELSE 
		   WRITE(N6,9420) ACOND(IBAD),QDEV(IBAD), 
     +                                       AJUN(JBAD),YDEV(JBAD) 
	ENDIF 
C======================================================================= 
C     Printer plot package. 
C======================================================================= 
      HORIZ(1) = '  CLOCK TIME IN HOURS. ' 
      HORIZ(2) = '                       ' 
      HTITLE(1)= 'PLOT OF JUNCTION ELEVATION  ' 
      HTITLE(2)= '                            ' 
C======================================================================= 
C     Plot Junction water surface elevations. 
C======================================================================= 
      IF(NPLT.GT.0) THEN 
		VERT1 = YER1 
		VERT2 = YER2 
		IF(METRIC.EQ.1) VERT3 = YER3 
		IF(METRIC.EQ.2) VERT3 = YER4 
		NPT(1)   = NPTOT 
		NPT(2)   = 0 
		DO 200 N = 1,NPLT 
		J        = JPLT(N) 
		NJUN     = JUN(J) 
		CALL CURVE(TPLT,YPLT(1,N),NPT,1,NJUN,AJUN(J)) 
		IF(METRIC.EQ.1) WRITE(N6,2000) Z(J),ZCROWN(J),GRELEV(J) 
  200           IF(METRIC.EQ.2) WRITE(N6,2001) Z(J),ZCROWN(J),GRELEV(J) 
		ENDIF 
C======================================================================= 
C     Plot conduit flows. 
C======================================================================= 
      IF(LPLT.GT.0) THEN 
		    HTITLE(1) = ' PLOT OF CONDUIT FLOW' 
		    HTITLE(2)= '                      ' 
		    VERT1 = VER1 
		    VERT2 = VER2 
		    IF(METRIC.EQ.1) VERT3 = VER3 
		    IF(METRIC.EQ.2) VERT3 = VER4 
		    NPT(1)   = NPTOT 
		    NPT(2)   = 0 
		    DO 280 N = 1,LPLT 
		    L        = KPLT(N) 
		    NKON     = NCOND(L) 
  280               CALL CURVE(TPLT,QPLT(1,N),NPT,1,NKON,ACOND(L)) 
		    ENDIF 
C======================================================================= 
C     Plot water surface slopes. 
C======================================================================= 
      IF(NSURF.GT.0.AND.LTIME.GT.0) THEN 
         MP    = (LTIME+200)/200 
c 
cng   plot of junction elevations + slope 
c 
         DO 123 M = 1, NSURF 
         REWIND NOUT 
         READ(NOUT) JCE,NHPRT,NQPRT,NSURF 
C======================================================================= 
C     READ THE HEADER INFORMATION ON THE NOUT FILE 
C======================================================================= 
         IF(JCE.EQ.0) THEN 
            IF(NHPRT.GT.0) READ(NOUT) (N1,J=1,NHPRT) 
            IF(NQPRT.GT.0) READ(NOUT) (N1,J=1,NQPRT) 
            IF(NSURF.GT.0) READ(NOUT) (N1,J=1,NSURF) 
            ELSE 
            IF(NHPRT.GT.0) READ(NOUT) (BMJ,J=1,NHPRT) 
            IF(NQPRT.GT.0) READ(NOUT) (BMJ,J=1,NQPRT) 
            IF(NSURF.GT.0) READ(NOUT) (BMJ,J=1,NSURF) 
            ENDIF 
         KO        = 0 
         DO 6000 L = 1,LTIME 
         IF(JPRINT.EQ.1) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                    K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT), 
     +                              (PSF(J,1),PSF(J,2),J=1,NSURF) 
         IF(JPRINT.EQ.2) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                     K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT) 
         IF(JPRINT.EQ.3) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                                                 K=1,NHPRT) 
      I   F(JPRINT.EQ.4) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K), 
     +                   K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
         IF(JPRINT.EQ.5) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J), 
     +                   J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
         IF(JPRINT.EQ.6) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J), 
     +                                                 J=1,NQPRT) 
         IF(JPRINT.EQ.7) READ(NOUT) TIME,MINUTE,JSEC, 
     +                                (PSF(J,1),PSF(J,2),J=1,NSURF) 
         IF(MOD(L,MP).EQ.0) THEN 
			 KO         = KO + 1 
			 TPLT(KO)   = TIME/3600.0 
			 X(KO,1)    = TIME/3600.0 
			 X(KO,2)    = TIME/3600.0 
			 J          = JSURF(M) 
			 YY(KO,1)   = PSF(M,1) 
			 YY(KO,2)   = PSF(M,2) 
c 
cng  qplt chaneged to [%] - was it used before ? 
c 
			 QPLT(KO,1) = 100.0*(PSF(M,1)-PSF(M,2))/LEN(J) 
			 ENDIF 
 6000    CONTINUE 
         HTITLE(1) = 'PLOT OF JUNCTION ELEVATIONS' 
         HTITLE(2) = 'AT EACH END OF THE CONDUIT ' 
         VERT1     = YER1 
         VERT2     = YER2 
         IF(METRIC.EQ.1) VERT3 = YER3 
         IF(METRIC.EQ.2) VERT3 = YER4 
         L         = JSURF(M) 
         NKON      = NCOND(L) 
         NPT(1)    = KO 
         NPT(2)    = KO 
         CALL CURVE(X,YY,NPT,2,NKON,ACOND(L)) 
         WRITE(N6,9380) 
         NPT(2)    = 0 
         HTITLE(1) = 'PLOT OF WATER SURFACE SLOPE' 
         HTITLE(2) = '                           ' 
         VERT1     = VER1 
         VERT3     = VER5 
         CALL CURVE(TPLT,QPLT,NPT,1,NKON,ACOND(L)) 
  123    CONTINUE 
         ENDIF 
C 
      RETURN 
C======================================================================= 
cim 10/98  change to avoid strings that wrap around which 
c          is not handled well by all compilers 
  749 FORMAT(3X, 
     +'                     UPPERMOST    MEAN             MAXIMUM ', 
     +'    TIME   METERS OF   METERS MAX.      LENGTH    LENGTH   ', 
     +'  MAXIMUM',/,2X, 
     +'            GROUND  PIPE CROWN  JUNCTION  JUNCTION JUNCTION', 
     +'     OF     SURCHARGE    DEPTH IS         OF        OF     ', 
     +' JUNCTION',/,2X, 
     +' JUNCTION ELEVATION  ELEVATION ELEVATION   AVERAGE   ELEV. ', 
     +'  OCCURENCE   AT MAX    BELOW GROUND   SURCHARGE  FLOODING ', 
     +'     AREA',/,2X, 
     6'   NUMBER     (M)        (M)       (M)    % CHANGE     (M) ', 
     +'  HR. MIN.  ELEVATION    ELEVATION      (MIN)      (MIN)   ', 
     +' (SQ.MET)',/,2X, 
     +' -------- --------- ----------  -------- --------- --------', 
     +'  ---------  ---------   ------------  ---------  -------- ', 
     +' --------') 
  750 FORMAT(/,1H1,/, 
     +' ************************************************************',/, 
     +' *   J U N C T I O N   S U M M A R Y   S T A T I S T I C S  *',/, 
     +' ************************************************************',/) 
  751 FORMAT(3X, 
     +'                     UPPERMOST    MEAN             MAXIMUM ', 
     +'    TIME     FEET OF     FEET MAX.      LENGTH    LENGTH   ', 
     +'  MAXIMUM',/,2X, 
     +'            GROUND  PIPE CROWN  JUNCTION  JUNCTION JUNCTION', 
     +'     OF     SURCHARGE    DEPTH IS         OF        OF     ', 
     +' JUNCTION',/,2X, 
     +' JUNCTION ELEVATION  ELEVATION ELEVATION   AVERAGE   ELEV. ', 
     +'  OCCURENCE   AT MAX    BELOW GROUND   SURCHARGE  FLOODING ', 
     +'     AREA',/,2X, 
     6'   NUMBER    (FT)       (FT)       (FT)   % CHANGE   (FT)  ', 
     +'  HR. MIN.  ELEVATION    ELEVATION      (MIN)      (MIN)   ', 
     +'  (SQ.FT)',/,2X, 
     +' -------- --------- ----------  -------- --------- --------', 
     +'  ---------  ---------   ------------  ---------  -------- ', 
     +' --------') 
cim modify format to include 10 characters 
  752 FORMAT(1X,I8,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2, 
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3) 
  762 FORMAT(1X,A8,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2, 
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3) 
CIM WRITE ALL 10 CHARACTERS AND DIGITS 
 6752 FORMAT(1X,I10,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2, 
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3) 
 6762 FORMAT(1X,A10,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2, 
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3) 
  770 FORMAT(/,5X,'WARNING.  INFLOW TO EXTRAN OCCURED AT JUNCTION THAT', 
     *' EXPERIENCED SURFACE FLOODING.',/, 
     *5X,'IF THIS INFLOW OCCURED SIMULTANEOUSLY WITH FLOODING, WATER W', 
     *'ILL NOT ENTER EXTRAN',/, 
     *5X,'AND IS LOST FROM SIMULATION EXCEPT FOR CONTINUITY CHECK.',/, 
     *5X,'USER MAY WISH TO CONSIDER EFFECTS ON UPSTREAM CHANNELS/PIPES', 
     *' NOT MODELED IN EXTRAN.') 
  771 FORMAT(/,5X,'ASTERISK (*) => INFLOW AT JUNCTION WITH INFLOW FROM', 
     *' SWMM INTERFACE FILE.',/, 
     *5X,'POUND (#)    => INFLOW AT JUNCTION WITH INFLOW FROM K3 GROUP', 
     *'.',/, 
     *5X,'DOLLAR ($)   => INFLOW AT JUNCTION WITH INFLOWS FROM BOTH SO', 
     *'URCES.',//, 
     *5X,'NOTE THAT CONSTANT JUNCTION INFLOWS CAN ENHANCE FLOODING.') 
  800 FORMAT(/,1H1,/, 
     +' ***********************************************************',/, 
     +' *   C O N D U I T   S U M M A R Y   S T A T I S T I C S   *',/, 
     +' ***********************************************************',/) 
C#### WCH, 11/29/93.  CHANGE DIAMETER/DEPTH PRINT TO METERS. 
  799 FORMAT(/, 
     +1X,'                             CONDUIT   MAXIMUM     TIME  ', 
     +'     MAXIMUM    TIME      RATIO OF   MAXIMUM DEPTH ABOVE ', 
     +' LENGTH CONDUIT',/, 
     +1X,'          DESIGN    DESIGN  VERTICAL  COMPUTED      OF   ', 
     +'   COMPUTED      OF       MAX. TO   INV. AT CONDUIT ENDS ', 
     +' OF NORM  SLOPE',/, 
     +1X,'CONDUIT     FLOW   VELOCITY   DEPTH     FLOW   OCCURRENCE', 
     +'    VELOCITY  OCCURRENCE   DESIGN  UPSTREAM   DOWNSTREAM ', 
     +'   FLOW',/, 
     +1X,' NUMBER    (CMS)     (M/S)      (M)    (CMS)    HR.  MIN.', 
     +'     (MPS)    HR.  MIN.    FLOW       (M)        (M)     ', 
     +'  (MIN)   (M/M)',/, 
     +1X,' ------  -------  --------  --------   -------  ---------', 
     +'-   -------  ----------   -------  --------    --------- ', 
     +'  -----  ------') 
  801 FORMAT(/, 
     +1X,'                             CONDUIT   MAXIMUM     TIME   ', 
     +'    MAXIMUM    TIME      RATIO OF   MAXIMUM DEPTH ABOVE ', 
     +' LENGTH CONDUIT',/, 
     +1X,'          DESIGN    DESIGN  VERTICAL  COMPUTED      OF    ', 
     +'  COMPUTED      OF       MAX. TO   INV. AT CONDUIT ENDS ', 
     +' OF NORM  SLOPE',/, 
     +1X,'CONDUIT     FLOW   VELOCITY   DEPTH     FLOW   OCCURRENCE ', 
     +'   VELOCITY  OCCURRENCE   DESIGN  UPSTREAM   DOWNSTREAM ', 
     +'   FLOW',/, 
     +1X,' NUMBER    (CFS)     (FPS)     (IN)    (CFS)    HR.  MIN. ', 
     +'    (FPS)    HR.  MIN.    FLOW      (FT)       (FT)     ', 
     +'  (MIN) (FT/FT)',/, 
     +1X,' ------  -------  --------  --------   -------  ----------', 
     +'   -------  ----------   -------  --------    --------- ', 
     +'  -----  ------') 
 6801   FORMAT(/, 
     1'                                   CONDUIT   MAXIMUM  ', 
     2'     TIME      MAXIMUM      TIME   RATIO OF  MAXIMUM ', 
     3'DEPTH ABOVE    LENGTH  CONDUIT',/, 
     4'               DESIGN    DESIGN   VERTICAL   COMPUTED ', 
     5'      OF       COMPUTED      OF     MAX. TO  INV. AT ', 
     6'CONDUIT ENDS  OF NORM   SLOPE ',/, 
     7'   CONDUIT      FLOW    VELOCITY     DEPTH     FLOW   ', 
     8'  OCCURRENCE   VELOCITY  OCCURRENCE DESIGN  UPSTREAM ', 
     9'  DOWNSTREAM    FLOW          ',/, 
     1'   NUMBER       (CFS)     (F/S)      (IN)     (CFS)   ', 
     2'   HR.  MIN.    (F/S)    HR.  MIN.    FLOW      (FT) ', 
     3'      (FT)      (MIN)  (FT/FT)',/, 
     4' ----------  ---------- -------- --------- -----------', 
     5' ----- ----- --------- ----- ----- -------- -------- ', 
     6'----------- --------- -------- ') 
 6799   FORMAT(/, 
     1'                                   CONDUIT   MAXIMUM  ', 
     2'     TIME      MAXIMUM      TIME   RATIO OF  MAXIMUM ', 
     3'DEPTH ABOVE    LENGTH  CONDUIT',/, 
     4'               DESIGN    DESIGN   VERTICAL   COMPUTED ', 
     5'      OF       COMPUTED      OF     MAX. TO  INV. AT ', 
     6'CONDUIT ENDS  OF NORM   SLOPE ',/, 
     7'   CONDUIT      FLOW    VELOCITY     DEPTH     FLOW   ', 
     8'  OCCURRENCE   VELOCITY  OCCURRENCE DESIGN  UPSTREAM ', 
     9'  DOWNSTREAM    FLOW          ',/, 
     1'   NUMBER       (CMS)     (M/S)       (M)     (CMS)   ', 
     2'   HR.  MIN.    (M/S)    HR.  MIN.    FLOW      (M)  ', 
     3'      (M)       (MIN)   (M/M) ',/, 
     4' ----------  ---------- -------- --------- -----------', 
     5' ----- ----- --------- ----- ----- -------- -------- ', 
     6'----------- --------- -------- ') 
cim original formats 
  802 FORMAT(' ',I7,1PE9.2,2X,0PF8.2,1X,F9.3,1X,1PE9.2,I6,I6,2X, 
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5) 
  803 FORMAT(' ',I7,1X,'   UNDEF',2(2X,'   UNDEF'),1X,1PE9.2,I6,I6) 
  813 FORMAT(' ',A10,' UNDEF',2(2X,'   UNDEF'),1X,1PE9.2,I6,I6) 
CWCH, 9/27/99.  Increase conduit ID field to 8 for now (to A8 from A7) 
  812 FORMAT(' ',A8,1PE9.2,2X,0PF8.2,1X,F9.3,1X,1PE9.2,I6,I6,2X, 
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5) 
cim revised formats 
 6802 FORMAT(1X,I10,1X,1PE11.4,1X,0PF8.2,1X,F9.3,1X,1PE11.4,I6,I6,2X, 
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5) 
 6803 FORMAT(1X,I10,7X,'UNDEF',4X,'UNDEF',5X,'UNDEF',1X,1PE11.4,I6,I6) 
 6813 FORMAT(1X,A10,7X,'UNDEF',4X,'UNDEF',5X,'UNDEF',1X,1PE11.4,I6,I6) 
 6812 FORMAT(1X,A10,1X,1PE11.4,1X,0PF8.2,1X,F9.3,1X,1PE11.4,I6,I6,2X, 
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5) 
cim 
  940 FORMAT(/,1H1,/,10X, 
     +' **************************************************',/,10X, 
     +' * SUBCRITICAL AND CRITICAL FLOW ASSUMPTIONS FROM *',/,10X, 
     +' * SUBROUTINE HEAD.  SEE FIGURE 5-4 IN THE EXTRAN *',/,10X, 
     +' *       MANUAL FOR FURTHER INFORMATION.          *',/,10X, 
     *' **************************************************',//, 
     +'               LENGTH     LENGTH       LENGTH       LENGTH ',/, 
     +'                 OF         OF        OF UPSTR. OF DOWNSTR.  ', 
     +'      MEAN                   TOTAL     MAXIMUM     MAXIMUM',/, 
     +'    CONDUIT     DRY     SUBCRITICAL    CRITICAL   CRITICAL   ', 
     +'      FLOW     AVERAGE        FLOW   HYDRAULIC  CROSS SECT',/, 
     +'     NUMBER   FLOW(MIN)  FLOW(MIN)    FLOW(MIN)   FLOW(MIN)  ', 
     +'     (CFS)    % CHANGE    CUBIC FT  RADIUS(FT)   AREA(FT2)',/, 
     +'    -------  ---------- -----------   ---------   ---------  ', 
     +'  --------   ---------   ---------  ---------   ----------') 
  941 FORMAT(/,1H1,/,10X, 
     +' **************************************************',/,10X, 
     +' * SUBCRITICAL AND CRITICAL FLOW ASSUMPTIONS FROM *',/,10X, 
     +' * SUBROUTINE HEAD.  SEE FIGURE 5-4 IN THE EXTRAN *',/,10X, 
     +' *       MANUAL FOR FURTHER INFORMATION.          *',/,10X, 
     *' **************************************************',//, 
     +'               LENGTH     LENGTH       LENGTH       LENGTH ',/, 
     +'                 OF         OF        OF UPSTR. OF DOWNSTR.  ', 
     +'      MEAN                   TOTAL     MAXIMUM     MAXIMUM',/, 
     +'    CONDUIT     DRY     SUBCRITICAL    CRITICAL    CRITICAL  ', 
     +'      FLOW     AVERAGE        FLOW   HYDRAULIC  CROSS SECT',/, 
     +'     NUMBER   FLOW(MIN)  FLOW(MIN)    FLOW(MIN)   FLOW(MIN)  ', 
     +'     (CMS)    % CHANGE   CUBIC MET RADIUS(MET)  AREA(SQ.M)',/, 
     +'    -------  ---------- -----------   ---------   ---------  ', 
     +'  --------   ---------   ---------  ---------   ----------') 
  955 FORMAT(1X,I10,5F12.2,F12.4,1PE12.4,0PF12.4,F12.4) 
  965 FORMAT(1X,A10,5F12.2,F12.4,1PE12.4,0PF12.4,F12.4) 
  975 FORMAT(1X,I10,4('   UNDEFINED'),F12.2,12X,1PE12.4) 
  985 FORMAT(1X,A10,4('   UNDEFINED'),F12.2,12X,1PE12.4) 
 2000 FORMAT(/,20X,'INVERT ELEV -',F8.2,' FEET',/,20X, 
     .             ' CROWN ELEV -',F8.2,' FEET',/,20X, 
     .             'GROUND ELEV -',F8.2,' FEET') 
 2001 FORMAT(/,20X,'INVERT ELEV -',F8.2,' METERS',/,20X, 
     .             ' CROWN ELEV -',F8.2,' METERS',/,20X, 
     .             'GROUND ELEV -',F8.2,' METERS') 
 4995 FORMAT(4X,'JUNCTION',2X,' INFLOW, CU M',/, 
     +       4X,'--------',2X,'-------------') 
 4997 FORMAT(' *******************************************************', 
     +     /,' * TOTAL SYSTEM OUTFLOW         = ',1PE14.4,' CU M  *') 
 4996 FORMAT(' * VOLUME LEFT IN SYSTEM        = ',1PE14.4,' CU M  *',/, 
     +       ' * OUTFLOW + FINAL VOLUME       = ',1PE14.4,' CU M  *',/, 
     +       ' *******************************************************') 
 4998 FORMAT(/,4X,'JUNCTION',2X,'OUTFLOW, CU M',/, 
     +       4X,'--------',2X,'-------------') 
 4999 FORMAT(/, 
     1    ' *******************************************************',/, 
     1       ' * INITIAL SYSTEM VOLUME        = ',1PE14.4,' CU M  *',/, 
     1       ' * TOTAL SYSTEM INFLOW VOLUME   = ',1PE14.4,' CU M  *',/, 
     2       ' * INFLOW + INITIAL VOLUME      = ',1PE14.4,' CU M  *') 
 5000 FORMAT(/,10X,A80,/,10X,A80,/) 
 5001 FORMAT(/, 
     1    ' *******************************************************',/, 
     1       ' * INITIAL SYSTEM VOLUME        = ',1PE14.4,' CU FT *',/, 
     1       ' * TOTAL SYSTEM INFLOW VOLUME   = ',1PE14.4,' CU FT *',/, 
     2       ' * INFLOW + INITIAL VOLUME      = ',1PE14.4,' CU FT *') 
 5002 FORMAT(/,1H1,/, 
     +' ***************************************************',/, 
     +' * EXTRAN CONTINUITY BALANCE AT THE LAST TIME STEP *',/, 
     +' ***************************************************',/) 
 5003 FORMAT(2X,I10,1PE14.4) 
 5013 FORMAT(2X,A10,1PE14.4) 
 5004 FORMAT( 
     +' ************************************************',/, 
     +' * JUNCTION INFLOW, OUTFLOW OR STREET FLOODING *',/, 
     +' ************************************************',/) 
 5005 FORMAT(/,4X,'JUNCTION',2X,'OUTFLOW, FT3',/, 
     +       4X,'--------',2X,'------------') 
 5006 FORMAT(' * ERROR IN CONTINUITY, PERCENT = ',F14.2,'       *',/, 
     +    ' *******************************************************') 
 7000 FORMAT(//, 
     1' TEST WRITE OF ALTERNATIVE CONTINUITY ERROR CALCULATION',/, 
     1' VOLUME LEFT IN SYSTEM       = ',1PE14.4,' CU. FT.',/, 
	1' ERROR IN CONTINUITY PERCENT = ',F14.2) 
 6006 FORMAT(' ===> Continuity error (percent): ',F10.2) 
  311 FORMAT(' ===> Elapsed Time  (minutes)   : ',F24.3) 
 5007 FORMAT(4X,'JUNCTION',2X,' INFLOW, FT3',/, 
     +       4X,'--------',2X,'------------') 
 5008 FORMAT( 
     +   ' *******************************************************',/, 
     +       ' * TOTAL SYSTEM OUTFLOW         = ',1PE14.4,' CU FT *') 
 5009 FORMAT(' * VOLUME LEFT IN SYSTEM        = ',1PE14.4,' CU FT *',/, 
     +       ' * OUTFLOW + FINAL VOLUME       = ',1PE14.4,' CU FT *',/, 
     +       ' *******************************************************') 
 5020 FORMAT(/,1H1,/, 
     +' #########################################################',/, 
     +' #  T i m e  H i s t o r y  o f  t h e  H. G. L. ( Feet) #',/, 
     +' #########################################################',/) 
 5030 FORMAT(/,1H1,/, 
     +' ##########################################################',/, 
     +' #  T i m e  H i s t o r y  o f  t h e  H. G. L. (meters) #',/, 
     +' ##########################################################',/) 
 5040 FORMAT('          ',5(A1,' Junction:',I10)) 
 5041 FORMAT('          ',5(A1,' Junction:',A10)) 
 5047 FORMAT(//,16(2H- ),' SUMMARY OF FULL FLOW CHANNEL WARNINGS ', 
     *21(2H- ),//, 
     *'   OPEN CHANNEL   TIME STEP OF FIRST   TIME OF FIRST', 
     *'   TIME STEP OF LAST   TIME OF LAST',/, 
     *'      NUMBER          OCCURRENCE        OCCURRENCE  ', 
     *'      OCCURRENCE        OCCURRENCE',/, 
     *42X,'(HOURS)',28X,'(HOURS)',/, 
     *'   ------------   ------------------   -------------', 
     *'   -----------------   ------------') 
 5048 FORMAT(1X,I10,13X,I5,13X,F6.2,13X,I5,11X,F6.2) 
 5049 FORMAT(1X,A10,13X,I5,13X,F6.2,13X,I5,11X,F6.2) 
 5050 FORMAT(/, 
     A3X,'THE PROGRAM USES FULL DEPTH CHANNEL CHARACTERISTICS', 
     A' TO COMPUTE FLOW THROUGH THE TRAPEZOIDAL, IRREGULAR, OR ',/, 
     B3X,'PARABOLIC/POWER FUNCTION CONDUIT WHEN THE COMPUTED DEPTHS ', 
     C'EXCEED MAXIMUM DEPTH.  THIS WILL AFFECT THE MAXIMUM',/, 
     D3X,'COMPUTED HEAD AND FLOWS IN THE MODEL.  IT IS HIGHLY ', 
     E'RECOMMENDED THAT THE MODELED CROSS SECTIONS BE EXTENDED',/, 
     F3X,'TO ELIMINATE THESE FULL FLOW CHANNEL WARNINGS') 
 5060 FORMAT('    Time  ',5(A1,'   Ground:',F10.2)) 
 5061 FORMAT('  Hr:Mn:Sc',5(A1,' Elevation     Depth')) 
 5062 FORMAT('  --------',5(A1,' ---------     -----'),/) 
 5080 FORMAT (' ',I3,':',I2,':',I2,5(F11.2,F10.2)) 
 5100 FORMAT(/,1H1,/, 
     +' #############################################',/, 
     +' #     Time History of Flow and Velocity     #',/, 
     +' #    Q(cfs), Vel(ft/s), Total(cubic feet)   #',/, 
     +' #############################################',/) 
 5101 FORMAT(/,1H1,/, 
     +' #############################################',/, 
     +' #     Time History of Flow and Velocity     #',/, 
     +' #    Q(cms), Vel(m/s), Total(cubic meters)  #',/, 
     +' #############################################',/) 
 5120 FORMAT(/,'    Time  ',5(A1,' Conduit:',I10)) 
 5121 FORMAT('  Hr:Mn:Sc',5(A1,'     Flow    Veloc.')) 
 5122 FORMAT('  --------',5(A1,'     ----    ------')) 
 5130 FORMAT(/,'   Time   ',5(A1,' Conduit:',A10)) 
 5140 FORMAT(1H ,I3,':',I2,':',I2,5(F10.2,F10.2)) 
 5141 FORMAT(1H ,I3,':',I2,':',I2,5(F10.4,F10.4)) 
 5142 FORMAT('     Mean ',5(F10.2,F10.2)) 
 5143 FORMAT('     Mean ',5(F10.4,F10.4)) 
 5144 FORMAT('    Total ',5(1PE10.3,10X)) 
 5145 FORMAT('  Maximum ',5(F10.2,F10.2)) 
 5146 FORMAT('  Maximum ',5(F10.4,F10.4)) 
 5150 FORMAT('  Minimum ',5(F10.2,F10.2)) 
 5151 FORMAT('  Minimum ',5(F10.4,F10.4)) 
 5243 FORMAT('     Mean ',5(F11.2,F10.2)) 
 5245 FORMAT('  Maximum ',5(F11.2,F10.2)) 
 5250 FORMAT('  Minimum ',5(F11.2,F10.2)) 
 6666 FORMAT(/) 
cim 7000 FORMAT(200(I10,1X)) 
cim 7010 FORMAT(200(A10,1X)) 
cim 7020 FORMAT(E12.5,2I7,200(E12.5,1X)) 
 9380 FORMAT(/,20X,'Upstream ==> Asterisk  Downstream ===> Plus') 
 9400 FORMAT(/, 
     +' ************************************************************',/, 
     +' * AVERAGE % CHANGE IN JUNCTION OR CONDUIT IS DEFINED AS:   *',/, 
     +' * CONDUIT  % CHANGE ==> 100.0 ( Q(n+1) - Q(n) ) / Qfull    *',/, 
     +' * JUNCTION % CHANGE ==> 100.0 ( Y(n+1) - Y(n) ) / Yfull    *',/, 
     +' ************************************************************') 
 9410 FORMAT(/, 
     +'  The Conduit with the largest average change... ',I10, 
     +' had',F10.3,' percent',/, 
     +' The Junction with the largest average change... ',I10, 
     +' had',F10.3,' percent',/) 
 9420 FORMAT(/, 
     +'  The Conduit with the largest average change... ',A10, 
     +' had',F10.3,' percent',/, 
     +' The Junction with the largest average change... ',A10, 
     +' had',F10.3,' percent',/) 
C======================================================================= 
      END 
 
REM File: PPLOT.FOR 
 
      SUBROUTINE PPLOT(IX,IY,K,NPLOT,ALPLOT) 
C======================================================================= 
C     THIS PART OF GRAPHING ROUTINES PRINTS THE 51 BY 101 ARRAY, A, 
C               OF POINTS. 
C     IT ALSO ASSIGNS SYMBOLS TO THE ARRAY AND PRINTS TITLES, LABELS. 
C     THIS SUBROUTINE LAST MODIFIED MARCH, 1988 BY RED. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'PLTARY.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'LAB.INC' 
C======================================================================= 
      CHARACTER ALPLOT*10,SYM(9)*1 
      DATA SYM/'*','+','''','X','.','2',' ','I','-'/ 
C======================================================================= 
C     PLACE PROPER SYMBOL IN ARRAY LOCATION. 
C======================================================================= 
      IF(K-99) 10,20,240 
   10 A(51-IY,IX+1) = SYM(K) 
      RETURN 
C======================================================================= 
C     PRINT TOTAL ARRAY, A, PLUS LABELS AND TITLES. 
C======================================================================= 
   20 CONTINUE 
      I  = 0 
      J2 = 1 
      WRITE(N6,31) 
      DO 180 II = 1,6 
      I         = I+1 
      IF(YLAB(1).LE.100000.0) THEN 
                              WRITE(N6,90) YLAB(II),(A(I,J),J=1,101) 
                              ELSE IF(YLAB(1).GT.100000.0) THEN 
                              WRITE(N6,100) YLAB(II),(A(I,J),J=1,101) 
                              ELSE 
                              WRITE(N6,95) YLAB(II),(A(I,J),J=1,101) 
                              ENDIF 
      IF(II.EQ.6) GO TO 190 
C======================================================================= 
      DO 170 JJ = J2,9 
      I         = I+1 
      IF(I.EQ.24) THEN 
                  WRITE(N6,120) VERT1,(A(I,J),J=1,101) 
                  ENDIF 
      IF(I.EQ.26) THEN 
                  WRITE(N6,120) VERT2,(A(I,J),J=1,101) 
                  ENDIF 
      IF(I.EQ.28) THEN 
                  WRITE(N6,120) VERT3,(A(I,J),J=1,101) 
                  ENDIF 
      IF(I.NE.24.AND.I.NE.26.AND.I.NE.28) WRITE(N6,160) (A(I,J),J=1,101) 
  170 CONTINUE 
      J2 = 1 
  180 CONTINUE 
  190 CONTINUE 
      WRITE(N6,200) XLAB 
      IF(JCE.EQ.0) WRITE(N6,210) NPLOT,HORIZ(1),HORIZ(2) 
      IF(JCE.EQ.1) WRITE(N6,211) ALPLOT,HORIZ(1),HORIZ(2) 
      WRITE(N6,30) HTITLE 
      RETURN 
C======================================================================= 
C     INITIALIZE PLOT OUTLINE. 
C======================================================================= 
  240 DO 260 I = 1,50 
      DO 250 J = 1,101 
  250 A(I,J)   = SYM(7) 
      A(I,1)   = SYM(8) 
      A(I,101) = SYM(8) 
  260 CONTINUE 
      DO 270 J = 1,101 
      A(1,J)   = SYM(9) 
  270 A(51,J)  = SYM(9) 
      DO 280 I = 1,101,10 
      A(1,I)   = SYM(8) 
  280 A(51,I)  = SYM(8) 
      DO 290 I = 11,41,10 
      A(I,1)   = SYM(9) 
      A(I,101) = SYM(9) 
  290 CONTINUE 
C======================================================================= 
   30 FORMAT(/,18X,A30,1X,A30) 
   31 FORMAT(/,'1') 
   90 FORMAT(' ',F14.3,1X,101A1) 
   95 FORMAT(' ',F14.6,1X,101A1) 
  100 FORMAT(' ',1PE14.2,1X,101A1) 
  120 FORMAT(1X,A10,5X,101A1) 
  160 FORMAT(16X,101A1) 
  200 FORMAT(F18.1,10F10.1) 
  210 FORMAT(/,18X,'LOCATION NO. : ',I9,1X,A30,2X,A30) 
  211 FORMAT(/,17X,'LOCATION NO. : ',A10,1X,A30,2X,A30) 
C======================================================================= 
      RETURN 
      END 
 
REM File: PSI.FOR 
 
      FUNCTION PSI(ALPHA) 
C     TRANSPORT BLOCK 
C======================================================================= 
C     FINDS Q/QFULL (PSI) GIVEN A/AFULL (ALPHA) FOR FUNCTIONAL Q-A CURVE 
C 
C     UPDATED (NEW COMMON) BY W.C.H., SEPTEMBER 1981. 
C     USE QCURVE(4), NOT (3) FOR FLOW.  WCH, 7/6/01.  
C     FIX MAX NUMBER OF TABULAR POINTS FOR UNLIKELY BUT POSSIBLE ERROR. 
C       WCH, 5/24/02. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'PSIDPS.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEW81.INC' 
      INCLUDE 'FLODAT.INC' 
C======================================================================= 
      PSI = 0.0 
      IF(ALPHA.LE.0.0) RETURN 
      NTPE  = NTYPE(M) 
C======================================================================= 
C     CALL SPECIAL ROUTINE TO GET HIGH ACCURACY AT LOW FLOWS 
C======================================================================= 
      IF(NTPE.EQ.1) THEN 
                  ALF = ALPHA 
                  CALL CIRCLE(ALF,PS,DN,1) 
                  PSI = PS 
                  RETURN 
                  ENDIF 
C======================================================================= 
C     SPECIAL FUNCTIONAL FORM FOR RECTANGULAR CONDUITS. 
C======================================================================= 
      IF(NTPE.EQ.2) THEN 
                  R = P5(M) 
                  IF(ALPHA.GT.ALFMAX(NTPE)) THEN 
                           PSI = P4(M)+(ALPHA-ALFMAX(NTPE))* 
     1                           (1.0-P4(M))/(1.0-ALFMAX(NTPE)) 
                           RETURN 
                           ENDIF 
                  AAA = 2.0*R*ALPHA+1.0 
                  CATH = (ALPHA*P7(M)/AAA)**0.6666667 
                  PSI  = ALPHA*CATH 
                  RETURN 
                  ENDIF 
C======================================================================= 
C     FUNCTIONAL FORM FOR MODIFIED BASKET-HANDLE. 
C======================================================================= 
      IF(NTPE.EQ.10) THEN 
                   AA = ALPHA*AFULL(M) 
                   IF (AA.GT.GEOM3(M)) THEN 
                          RH = RADH(AA) 
                          PSI = 1.49/ROUGH(M)*AA*RH**0.6666667/P1(M) 
                          RETURN 
                          ENDIF 
                   ALF  = AA/GEOM3(M) 
                   R    = GEOM1(M)/GEOM2(M) 
                   AAA  = 2.0*ALF*R+1.0 
                   CATH = (ALF*P7(M)/AAA)**0.6666667*P6(M) 
                   PSI  = ALF*CATH 
                   RETURN 
                   ENDIF 
C======================================================================= 
C     FUNCTIONAL FORM FOR RECTANGULAR, TRIANGULAR BOTTOM. 
C======================================================================= 
      IF(NTPE.EQ.11) THEN 
                   AB = GEOM3(M)*GEOM2(M)/2.0 
                   AA = ALPHA*AFULL(M) 
                   IF (AA.LE.AB) THEN 
                                 PSI = P7(M)*ALPHA**1.333333 
                                 RETURN 
                                 ENDIF 
                   IF (ALPHA.GT.ALFMAX(NTPE)) THEN 
                           PSI = P4(M)+(ALPHA-ALFMAX(NTPE))* 
     1                           (1.0-P4(M))/(1.0-ALFMAX(NTPE)) 
                           RETURN 
                           ENDIF 
                   AAA = GEOM3(M)/P5(M)-GEOM3(M)+(2.0*GEOM1(M) - 
     1                   GEOM3(M))*ALPHA 
                   CATH = (ALPHA*P6(M)/AAA)**0.6666667 
                   PSI = ALPHA*CATH 
                   RETURN 
                   ENDIF 
C======================================================================= 
C     FUNCTIONAL FORM FOR RECTANGULAR, ROUND BOTTOM. 
C======================================================================= 
      IF(NTPE.EQ.12) THEN 
                   AA = ALPHA*AFULL(M) 
                   IF(AA.GT.P6(M)) THEN 
                            IF (ALPHA.GT.ALFMAX(NTPE)) THEN 
                                PSI = P4(M)+(ALPHA-ALFMAX(NTPE))* 
     1                                (1.0-P4(M))/(1.0-ALFMAX(NTPE)) 
                                RETURN 
                                ENDIF 
                            D1 = GEOM3(M)*P5(M)+2.0*GEOM1(M)+GEOM2(M) 
                            D2 = GEOM3(M)*P5(M)+2.0/GEOM2(M)* 
     1                           (AFULL(M)*ALPHA-P6(M)) 
                            CATH = (ALPHA*D1/D2)**0.6666667 
                            PSI  = ALPHA*CATH 
                            RETURN 
                            ENDIF 
                   ALF = ALPHA*AFULL(M)/(3.1415965*GEOM3(M)*GEOM3(M)) 
                   IF(ALF.LT.0.04) THEN 
                                   CALL CIRCLE (ALF,PS,DN,1) 
                                   PSI = PS 
                                   PSI = PSI*P7(M) 
                                   RETURN 
                                   ENDIF 
                   I = IFIX(ALF/0.02) + 1 
                   PSI = QNORM(1,I)+(QNORM(1,I+1)-QNORM(1,I))/0.02* 
     1                              (ALF-ANORM(1,I)) 
                   PSI = PSI*P7(M) 
                   RETURN 
                   ENDIF 
C======================================================================= 
C    FUNCTIONAL FORM FOR TRAPEZOID 
C======================================================================= 
      IF(NTPE.EQ.13) THEN 
                   AA   = ALPHA * AFULL(M) 
                   AAA  = (-GEOM2(M) + SQRT(GEOM2(M)**2 + 
     1                     4.0 * AA/GEOM3(M))) * 0.5 * GEOM3(M) 
                   CATH =  AA/(GEOM2(M) + AAA * P5(M))/P6(M) 
                   PSI  = ALPHA * CATH**0.6666667 
                   RETURN 
                   ENDIF 
C======================================================================= 
C     INCLUDE TABULAR PSI CALC. IN CASE PSI IS CALLED BY KLASS=2 CONDUIT 
Cwch, 3/14/02. This same code for power function and natural channels. 
C     NTPE also = 16 for these two channels (changed from 14 and 15 in  
C     Sub. INTRAN).   
C======================================================================= 
      IF(NTPE.EQ.16) THEN 
                   KK = NQC(M) 
                   DALPHA = QCURVE(KK,2,2) - QCURVE(KK,2,1) 
                   I      = IFIX(ALPHA/DALPHA + 1.0) 
                   IF(I.GE.26) I = 25 
Cwch, 7/6/01. Use QCURVE(4), not (3) for flow.  
                   PSI    = QCURVE(KK,4,I) + (QCURVE(KK,4,I+1) - 
     1                      QCURVE(KK,4,I)) / DALPHA * 
     2                     (ALPHA - QCURVE(KK,2,I)) 
                   ELSE 
                   DALPHA = ANORM(NTPE,2) - ANORM(NTPE,1) 
                   I      = IFIX(ALPHA/DALPHA + 1.0) 
Cwch, 5/24/02. Should not be in this ELSE-location, but in case we are, 
C     should use MM(MTPE) as max, not 26.  
C                   IF(I.GE.26) I = 25 
                   IF(I.GE.MM(NTPE)) I = MM(NTPE) - 1 
                   PSI    = QNORM(NTPE,I) + (QNORM(NTPE,I+1) - 
     1                      QNORM(NTPE,I))/DALPHA*(ALPHA-ANORM(NTPE,I)) 
                   ENDIF 
      RETURN 
      END 
 
REM File: QHYDRO.FOR 
 
      SUBROUTINE QHYDRO 
C	RUNOFF BLOCK 
C	CALLED BY SUBROUTINE RUNOFF NEAR LINE 224 
C======================================================================= 
C     QHYDRO was created NOVEMBER, 1981 BY R.DICKINSON 
C     last updated December, 1990. 
C     Updated 4/93 by WCH to correct land-use input and print-out 
C       from groups L1 and L2 and slight format modifications. 
C     WCH, 9/3/93. Add quality input for infiltration/inflow. 
C     WCH (Warren Chrusciel), 9/28/93.  Fix metric conversion for QFACT3. 
C     WCH, 9/29/93.  Add warning and code for too many J2 lines. 
C     WCH, 11/15/93.  Change loop for IEND to NQSS + 2 from NRQ + 2. 
C     WCH, 10/19/95.  Add warning messages for L1 and M1 lines. 
C     WCH, 8/14/96.  Correct units conversion for RCOEF for KWASH > 0. 
C     CIM, 4/1/99.  Changes to increase maximum number of constituents 
C                   from 10 to MQUAL 
C     WCH, 12/20/00. Add variables for overland flow quality. 
C     WCH, 1/18/01. Fix J4 output. 
C     WCH, 2/10.01. Add input for BMP removal in channels, new line J7. 
C     WCH (RED), 5/8/01. Fix loop for reading L1-L2 lines. 
C     WCH, 3/29/02. Fix warning message printout re. L2 lines. Slightly 
C      alter constituent printout to avoid asterisks for too-big fields. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
      INCLUDE 'QUALTY.INC' 
      INCLUDE 'NEW88.INC' 
      INCLUDE 'NEW89.INC' 
      INCLUDE 'GRWTR.INC' 
C#### WCH, 9/93 
      INCLUDE 'RDII.INC' 
Cwch, 12/20/00.  And increase dimension of XINJ3 to 12. 
      INCLUDE 'OVERLAND.INC' 
      DIMENSION XINJ2(6),RJLAND(6),DJLAND(6), 
     1          XINJ3(12),DNQS(10),RNQS(MQUAL),EROS(5),REROS(5), 
     2          DEROS(5),SUBQL(MQUAL+2),DSUBQL(MQUAL+2),RSUBQL(MQUAL+2) 
Cwch, 2/10/01. 
      DIMENSION GREMV(MQUAL) 
	CHARACTER*10 KGNAME 
      CHARACTER JDLINK(2)*16,IDASH*4,ISTAR*4,ISPACE*4,KKN*10, 
     1          JDBET(3)*20,JDFDB(3)*16,JDTBC(5)*16,JDTWC(3)*20 
      DATA IDASH/'----'/,ISTAR/'****'/,ISPACE/'    '/ 
      DATA JDLINK/' NO SNOW LINKAGE','BUILDUP FOR SNOW'/ 
      DATA JDBET/'   POWER LINEAR(0) ',' EXPONENTIAL(1)    ', 
     1           ' MICHAELIS MENTEN(2)'/ 
      DATA JDFDB/'CHAN. LENGTH(0) ','        AREA(1) ', 
     1           '    CONSTANT(2) '/ 
C#### WCH, 9/9/93. REMOVE ONE BLANK FROM BEFORE "RATG" AND COSMETIC. 
      DATA JDTWC/'  POWER EXPONEN.(0) ',' RATG CURVE NO UL(1)', 
     1           '  RATING CURVE UL(2)'/ 
      DATA JDTBC/' FRACT. BLDUP(0)',' POWER-LINEAR(1)', 
     1           '  EXPONENTIAL(2)',' MICH. MENTEN(3)', 
     2           '   NO BUILDUP(4)'/ 
C======================================================================= 
      DO 50     I = 1,MQUAL 
      NDIM(I)     = 0 
      DO 50     J = 1,NLU 
      KEY(J,I)    = 0 
      KALC(J,I)   = 0 
      KWASH(J,I)  = 0 
      TEMPLD(J,I) = 0.0 
      KACGUT(J,I) = 0 
      WASHPO(J,I) = 0.0 
      CONCRN(J,I) = 0.0 
      RCOEF(J,I)  = 0.0 
      RCOEFX(J,I) = 0.0 
 50   CBFACT(J,I) = 0.0 
C======================================================================= 
C#### WCH, 10/19/95.  Add check for possible error of calling quality 
C     routines with no quality data. 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'M1') THEN 
           WRITE(N6,6001) 
           STOP 
           ENDIF 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>> READ DATA GROUP JJ <<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'JJ') THEN 
                     READ(N5,*,ERR=888) CC,IMUL 
                     IF(IMUL.LT.0) CALL ERROR(143) 
                     ELSE 
                     IMUL = 0 
                     ENDIF 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>> READ DATA GROUP J1 <<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,NQS,JLAND,IROS,IROSAD,DRYDAY,CBVOL, 
     1                   DRYBSN,RAINIT,REFFDD,KLNBGN,KLNEND 
      IF(CC.NE.'J1') CALL ERROR(140) 
CIM move these checks up to here 
      IF(NQS.LE.0)  CALL ERROR(3) 
      IF(NQS.GT.MQUAL) CALL ERROR(4) 
      IF(NQS.EQ.MQUAL.AND.IROS.EQ.1) CALL ERROR(5) 
      IF(IMUL.EQ.0) N1 = 1 
      IF(IMUL.GT.0) N1 = JLAND 
C======================================================================= 
C     Add an erosion constituent if IROS = 1. 
C======================================================================= 
      IF(IROS.GT.0) THEN 
cim                    NQS        =  NQS + 1 
                    PNAME(NQS+1) = KEROS(1) 
                    PUNIT(NQS+1) = KEROS(2) 
                    NDIM(NQS+1)  = 0 
cim                    NQS = NQS - 1 
                    ENDIF 
      NQSS = NQS 
      IF(KLNEND.LE.0)   KLNEND = 367 
      IF(DRYBSN.LE.0.0) THEN 
                        WRITE(N6,1623) DRYBSN 
                        DRYBSN = 1.0 
                        ENDIF 
C======================================================================= 
C     Write the quality input data. 
C======================================================================= 
      IF(IPRN(7).EQ.0) THEN 
        IF(METRIC.EQ.1) WRITE(N6,1180) NQS,JLAND,CBVOL 
        IF(METRIC.EQ.2) WRITE(N6,1190) NQS,JLAND,CBVOL 
        IF(IROS.EQ.0) WRITE(N6,1590) IROS 
        IF(IROS.EQ.1) WRITE(N6,1600) IROS 
        IF(IROS.EQ.1) WRITE(N6,1610) IROSAD 
        IF(METRIC.EQ.1.AND.IROS.EQ.1) WRITE(N6,1615) RAINIT 
        IF(METRIC.EQ.2.AND.IROS.EQ.1) WRITE(N6,1616) RAINIT 
                                      WRITE(N6,1620) DRYDAY 
        WRITE(N6,1625) DRYBSN 
        WRITE(N6,1630) REFFDD 
        WRITE(N6,1635) KLNBGN,KLNEND 
        ENDIF 
      CBVOL  = CBVOL  * CMET(8,METRIC) 
      RAINIT = RAINIT / CMET(5,METRIC) 
C======================================================================= 
C     Set the default limits and default ratio for land use. 
C======================================================================= 
      DO 1045 J = 1,6 
      DJLAND(J) = 0.0 
 1045 RJLAND(J) = 1.0 
      DJLAND(1) = 1.0E35 
C======================================================================= 
C     Read in JLAND land use data groups. 
C======================================================================= 
      IF(JLAND.LE.0)   CALL ERROR(1) 
      IF(JLAND.GT.NLU) CALL ERROR(2) 
      J          = 0 
      DO 1070 JJ = 1,500 
      J          = J + 1 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP J2 <<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,LNAME(J),METHOD(J),JACGUT(J), 
     1                      (XINJ2(K),K=1,6) 
      IF(CC.NE.'J2') CALL ERROR(141) 
C======================================================================= 
C     SET THE NEW DEFAULT VALUES -- METHOD(J) = -2 
C======================================================================= 
      IF( METHOD(J).EQ.-2 ) THEN 
                            DO 1055 K = 1,6 
 1055                       IF(XINJ2(K).GT.0.0) DJLAND(K)=XINJ2(K) 
                            J = J - 1 
                            GO TO 1070 
                            ENDIF 
C======================================================================= 
C     SET THE NEW RATIO  -- METHOD(J) = - 1 
C======================================================================= 
      IF(METHOD(J).EQ.-1) THEN 
                          DO 1060 K = 1,6 
 1060                     IF(XINJ2(K).GT.0.0) RJLAND(K)=XINJ2(K) 
                          J = J - 1 
                          GO TO 1070 
                          ENDIF 
C======================================================================= 
C     MULTIPLY BY THE RATIOS AND ASSIGN DEFAULT VALUES 
C======================================================================= 
      DO 1067 K = 1,6 
      IF(XINJ2(K).LE.0.0) XINJ2(K) = DJLAND(K) 
 1067                     XINJ2(K) = XINJ2(K) * RJLAND(K) 
      DDLIM(J)  = XINJ2(1) 
      DDPOW(J)  = XINJ2(2) 
      DDFACT(J) = XINJ2(3) 
      CLFREQ(J) = XINJ2(4) 
      AVSWP(J)  = XINJ2(5) 
      DSLCL(J)  = XINJ2(6) 
      IF(METHOD(J).LT.0.OR.METHOD(J).GT.2)    CALL ERROR(8) 
      IF(JACGUT(J).LT.0.OR.JACGUT(J).GT.2)    CALL ERROR(9) 
C####################################################################### 
C     WCH, 9/29/93.  ADD CODE FOR MORE J2 LINES THAN VALUE OF JLAND. 
C======================================================================= 
      IF(J.EQ.JLAND.AND.JLAND.EQ.NLU) GO TO 1071 
      IF(J.LT.JLAND) GO TO 1070 
C======================================================================= 
C     READ NEXT LINE TO SEE IF IT IS ANOTHER LAND USE LINE. 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'J2') THEN 
           JLAND = JLAND + 1 
           WRITE(N6,6018) J,JLAND 
           IF(JLAND.GT.NLU) CALL ERROR(2) 
           IF(IMUL.GT.0) N1 = JLAND 
           GO TO 1070 
           ELSE 
           GO TO 1071 
           ENDIF 
 1070 CONTINUE 
 1071 CONTINUE 
C======================================================================= 
C     SET THE DEFAULT VALUES AND DEFAULT RATIOS 
C     FOR THE BUILDUP PARAMETERS AND NQS PARAMETERS 
C======================================================================= 
      DO 1072 I = 1,10 
      DNQS(I)   = 0.0 
1072  RNQS(I)   = 1.0 
C======================================================================= 
C     Read in the NQS quality constituents. 
C======================================================================= 
      K          = 0 
      DO 1075 KK = 1,500 
      K          = K + 1 
      DO 1090  J = 1,N1 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP J3 <<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
Cwch, 12/20/00.  Add REMOVE and DECAY (XINJ3(11 and 12)) 
C======================================================================= 
      READ(N5,*,ERR=888) CC,PNAME(K),PUNIT(K),NDIM(K),KALC(J,K), 
     1                      KWASH(J,K),KACGUT(J,K),LINKUP(J,K), 
     2                      (XINJ3(L),L=1,12) 
      IF(CC.NE.'J3') CALL ERROR(142) 
C======================================================================= 
C     SET THE NEW DEFAULT VALUES -- KALC(J,K) = -2 
C======================================================================= 
         IF(KALC(J,K).EQ.-2) THEN 
                             DO 1076 I = 1,12 
 1076                        IF(XINJ3(I).GT.0.0) DNQS(I) = XINJ3(I) 
                             K         = K - 1 
                             GO TO 1075 
                             ENDIF 
C======================================================================= 
C     Set the new ratio  -- KALC(J,K) = -1 
C======================================================================= 
       IF(KALC(J,K).EQ.-1) THEN 
                           DO 1078 I = 1,12 
 1078                      IF(XINJ3(I).GT.0.0) RNQS(I) = XINJ3(I) 
                           K         = K - 1 
                           GO TO 1075 
                           ENDIF 
1079  DO 1080 I      = 1,10 
      IF(XINJ3(I).LT.0.0) XINJ3(I) = DNQS(I) 
1080  XINJ3(I)       = XINJ3(I)    * RNQS(I) 
      QFACT(J,1,K)   = XINJ3(1) 
      QFACT(J,2,K)   = XINJ3(2) 
      QFACT(J,3,K)   = XINJ3(3) 
      QFACT(J,4,K)   = XINJ3(4) 
      QFACT(J,5,K)   = XINJ3(5) 
      WASHPO(J,K)    = XINJ3(6) 
C#### WCH, 4/13/93.  CHECK FOR EXTREME VALUE OF WASHPO. 
        IF(WASHPO(J,K).GT.25.) WRITE(N6,6017) J,K,WASHPO(J,K) 
      RCOEF(J,K)     = XINJ3(7) 
      CBFACT(J,K)    = XINJ3(8) 
      CONCRN(J,K)    = XINJ3(9) 
      REFF(J,K)      = XINJ3(10) 
Cwch, 12/20/00.   Note, later convert QDECAY from 1/day to 1/s. 
	REMOVE(J,K)    = XINJ3(11) 
	IF(J.EQ.1) QDECAY(K) = XINJ3(12) 
1090  CONTINUE 
      IF(K.EQ.NQS) GO TO 1175 
1075  CONTINUE 
1175  CONTINUE 
      IF(RAINIT.LT.0.AND.IROS.EQ.1)   CALL ERROR(7) 
C======================================================================= 
C     Write the land use data. 
C======================================================================= 
      IF(IPRN(7).EQ.0) WRITE(N6,1639) 
      IF(IPRN(7).EQ.0) WRITE(N6,1640) 
      DO 1645 J = 1,JLAND 
      JET       = METHOD(J) + 1 
      JAM       = JACGUT(J) + 1 
      IF(IPRN(7).EQ.0) WRITE(N6,1641) 
     1                 LNAME(J),JDBET(JET),JDFDB(JAM),DDLIM(J),DDPOW(J), 
     2                 DDFACT(J),CLFREQ(J),AVSWP(J),DSLCL(J) 
C======================================================================= 
C     Make the units conversion from metric input to U.S. Standard units 
C     for DDLIM and DDFACT. 
C======================================================================= 
                      CLB = 1.0 
      IF(METRIC.EQ.2) CLB = 1000.0/453.7 
      IF(JACGUT(J).EQ.0) DDLIM(J) = DDLIM(J) * 
     1                              CLB/CMET(1,METRIC) 
      IF(JACGUT(J).EQ.1) DDLIM(J) = DDLIM(J) * CLB/CMET(2,METRIC) 
      IF(JACGUT(J).EQ.2) DDLIM(J) = DDLIM(J) * CLB 
      IF(METHOD(J).LE.0) THEN 
                         IF(JACGUT(J).EQ.0) DDFACT(J) = DDFACT(J) * 
     1                                           CLB/CMET(1,METRIC) 
                         IF(JACGUT(J).EQ.1) DDFACT(J) = DDFACT(J) * 
     1                                           CLB/CMET(2,METRIC) 
                         IF(JACGUT(J).EQ.2) DDFACT(J) = DDFACT(J)*CLB 
                         ENDIF 
 1645 CONTINUE 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP J4 <<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      DO 1647 I = 1,MQUAL 
      DO 1647 J = 1,MQUAL 
 1647 F1(I,J)   = 0.0 
 1650 READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'J4') THEN 
                     READ(N5,*,ERR=888) CC,KTO,KFROM,FIN1 
                     IF(KTO.GT.0) F1(KTO,KFROM) = FIN1 
                     GO TO 1650 
                     ENDIF 
C======================================================================= 
C     Write the constituent data. 
C======================================================================= 
      IF(IPRN(7).EQ.0) THEN 
         WRITE(N6,1660) 
         DO 2000 K = 1,NQS,5 
         DO 1990 J = 1,N1 
         KK        = K + 4 
         IF(NQS.LT.KK)  KK = NQS 
         WRITE(N6,2001) (PNAME(I),I=K,KK) 
         WRITE(N6,2002) (ISPACE,I=K,KK) 
         WRITE(N6,2003) (PUNIT(I),I=K,KK) 
         WRITE(N6,2004) (NDIM(I),I=K,KK) 
         WRITE(N6,2006) (KALC(J,I),I=K,KK) 
         WRITE(N6,2205) (JDTBC(KALC(J,I)+1),I=K,KK) 
         WRITE(N6,2007) (KWASH(J,I),I=K,KK) 
         WRITE(N6,2206) (JDTWC(KWASH(J,I)+1),I=K,KK) 
         WRITE(N6,2008) (KACGUT(J,I),I=K,KK) 
C#### WCH 4/12/93.  SHOULD PRINT JDFDB, NOT JDTBC. 
         WRITE(N6,2207) (JDFDB(KACGUT(J,I)+1),I=K,KK) 
         WRITE(N6,2009) (LINKUP(J,I),I=K,KK) 
         WRITE(N6,2208) (JDLINK(LINKUP(J,I)+1),I=K,KK) 
         WRITE(N6,2209) (QFACT(J,1,I),I=K,KK) 
         WRITE(N6,2500) (QFACT(J,2,I),I=K,KK) 
         WRITE(N6,2501) (QFACT(J,3,I),I=K,KK) 
         WRITE(N6,2502) (QFACT(J,4,I),I=K,KK) 
         WRITE(N6,2503) (QFACT(J,5,I),I=K,KK) 
         WRITE(N6,2504) (WASHPO(J,I),I=K,KK) 
         WRITE(N6,2505) (RCOEF(J,I),I=K,KK) 
         WRITE(N6,2506) (CBFACT(J,I),I=K,KK) 
         WRITE(N6,2507) (CONCRN(J,I),I=K,KK) 
         WRITE(N6,2508) (REFF(J,I),I=K,KK) 
Cwch, 12/20/00 
         WRITE(N6,2510) (REMOVE(J,I),I=K,KK) 
	   WRITE(N6,2511) (QDECAY(I),I=K,KK) 
         WRITE(N6,2509) (J,I=K,KK) 
1990     CONTINUE 
2000     CONTINUE 
         ENDIF 
Cwch, 12/20/00.  Convert decay rate to 1/s from 1/day. 
      DO I = 1,NQS 
	     QDECAY(I) = QDECAY(I)/86400. 
           ENDDO 
C======================================================================= 
C     Make the units conversion from Metric input to U.S. Customary units 
C======================================================================= 
      IF(METRIC.EQ.2) THEN 
           DO 2700 K = 1,NQS 
           DO 2690 J = 1,N1 
           IF(KWASH(J,K).EQ.0) RCOEF(J,K) = RCOEF(J,K)*  25.4 ** 
     1                                             WASHPO(J,K) 
C#### WCH, 8/14/96.  WRONG CONVERSION.  SHOULD >DIVIDE<, NOT MULTIPLY. 
C####           IF(KWASH(J,K).GT.0) RCOEF(J,K) = RCOEF(J,K)*35.315 ** 
           IF(KWASH(J,K).GT.0) RCOEF(J,K) = RCOEF(J,K)/35.315 ** 
     1                                             WASHPO(J,K) 
C 
           IF(KALC(J,K).EQ.0.OR.KALC(J,K).EQ.4) GO TO 2700 
C 
           IF(KACGUT(J,K).EQ.0) QFACT(J,1,K) = QFACT(J,1,K) * 
     1                                        2.205 / 32.808 
           IF(KACGUT(J,K).EQ.1) QFACT(J,1,K) = QFACT(J,1,K) * 
     1                                        2.205 / 2.4710 
           IF(KACGUT(J,K).EQ.2) QFACT(J,1,K) = QFACT(J,1,K) * 2.205 
C 
           IF(KALC(J,K).EQ.1) THEN 
                IF(KACGUT(J,K).EQ.0) QFACT(J,3,K) = QFACT(J,3,K) * 
     1                                        2.205 / 32.808 
C#### WCH (W. CHRUSCIEL), 9/28/93.  DIVIDE BY 2.471, NOT 32.808 
                IF(KACGUT(J,K).EQ.1) QFACT(J,3,K) = QFACT(J,3,K) * 
     1                                        2.205 / 2.4710 
                IF(KACGUT(J,K).EQ.2) QFACT(J,3,K) = QFACT(J,3,K) * 2.205 
                ENDIF 
 2690      CONTINUE 
 2700      CONTINUE 
           ENDIF 
C####################################################################### 
      DO 3070 I = 1,NQS 
      DO 3070 J = 1,NQS 
      IF(F1(I,J).NE.0.0) GO TO 3075 
3070  CONTINUE 
      GO TO 3099 
3075  CONTINUE 
C======================================================================= 
C     Write the fractional constituent data. 
C======================================================================= 
      IF(IPRN(7).EQ.0) THEN 
      WRITE(N6,3076) 
      WRITE(N6,3077) 
      WRITE(N6,3078) (PNAME(JJ),JJ=1,NQS) 
      WRITE(N6,3094) (IDASH,ISTAR,KK=1,NQS) 
C 
      DO 3080 I = 1,NQS 
      DO 3085 JTEST = 1,NQS 
      IF(F1(I,JTEST).NE.0.0) GO TO 3086 
3085  CONTINUE 
      GO TO 3080 
3086  WRITE(N6,3090) (ISTAR,KK=1,NQS) 
      WRITE(N6,3091) (ISTAR,KK=1,NQS) 
      WRITE(N6,3092) (ISTAR,KK=1,NQS) 
      WRITE(N6,3093) PNAME(I),(F1(I,JJ),JJ=1,NQS) 
      WRITE(N6,3094) (IDASH,ISTAR,KK=1,NQS) 
3080  CONTINUE 
      ENDIF 
C======================================================================= 
C     Read groundwater quality data if present on data group J5. 
C======================================================================= 
3099  CONTINUE 
      IF(NOGWSC.GT.0) THEN 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>> READ DATA LINE J5 <<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
                READ(N5,*,ERR=888) CC 
                BACKSPACE N5 
                IF(CC.EQ.'J5')THEN 
                              READ(N5,*,ERR=888) CC,(CGWQ(K),K=1,NQS) 
                              WRITE(N6,3010) (PNAME(K), 
     1                                        CGWQ(K),PUNIT(K),K=1,NQS) 
                              ENDIF 
                ENDIF 
C======================================================================= 
C     Read infiltration/inflow quality data if present on data group J6. 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>> READ DATA LINE J6 <<<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
                IF(CC.EQ.'J6')THEN 
                              READ(N5,*,ERR=888) CC,(CONCII(K),K=1,NQS) 
                              WRITE(N6,3015) (PNAME(K), 
     1                                      CONCII(K),PUNIT(K),K=1,NQS) 
                              ENDIF 
C======================================================================= 
Cwch, 2/10/01. New input of BMP removal fraction for channel/pipes. 
C>>>>>>>>>>>>>>>>>>>>>> READ DATA LINES J7 <<<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IJK = 0 
	DO J = 1,NQS 
	   GREMV(J) = 0.0 
	   ENDDO 
 3100 READ(N5,*,ERR=888) CC 
	BACKSPACE N5 
	   IF(CC.EQ.'J7') THEN 
	     IJK = IJK + 1 
C     Error message for too many J7 lines, but continue. 
		 IF(IJK.GT.NOG) WRITE(N6,6023) IJK,NOG 
	     IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,NGNAME,(GREMV(J),J=1,NQS) 
	     IF(JCE.EQ.1) READ(N5,*,ERR=888) CC,KGNAME,(GREMV(J),J=1,NQS) 
C     Find matching channel/pipe, to get subscript. 
	     DO 3150 N = 1,NOG 
	     NNN = N 
C     Error message for no match for channel/pipe name.  But continue. 
	     IF(JCE.EQ.0.AND.NGNAME.EQ.NAMEG(N)) GOTO 3155 
	     IF(JCE.EQ.1.AND.KGNAME.EQ.KAMEG(N)) GOTO 3155 
 3150      CONTINUE 
           IF(JCE.EQ.0) WRITE(N6,6021) NGNAME 
	     IF(JCE.EQ.1) WRITE(N6,6022) KGNAME 
	     GOTO 3100 
 3155      DO J = 1,NQS 
              GREMOVE(J,NNN) = GREMV(J) 
	        ENDDO 
           IF(IJK.EQ.1) WRITE(N6,6025) (PNAME(J),J=1,NQS) 
	     IF(IJK.EQ.1) WRITE(N6,6026) (IDASH,J=1,2*NQS) 
	     IF(JCE.EQ.0) WRITE(N6,6027) NGNAME,(GREMV(J),J=1,NQS) 
	     IF(JCE.EQ.1) WRITE(N6,6028) KGNAME,(GREMV(J),J=1,NQS) 
	     GOTO 3100 
	     ENDIF 
C======================================================================= 
C     NWPGE is a line counter for the printout 
C             of erosion and subcatchment data. 
C======================================================================= 
      NWPGE = 0 
      IF(IROS.GT.0) THEN 
C======================================================================= 
C     Erosion input 
C======================================================================= 
C     Set the default values and default ratios for erosion. 
C======================================================================= 
      DO 4000 I = 1,5 
      DEROS(I)  = 0.0 
4000  REROS(I)  = 1.0 
C======================================================================= 
C     Print the erosion title data group depending on metric. 
C======================================================================= 
      IF(METRIC.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,4050) 
      IF(METRIC.EQ.2.AND.IPRN(7).EQ.0) WRITE(N6,4051) 
      NWPGE       = 13 
      DO 5000  II = 1,1000 
      NWPGE       = NWPGE + 1 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP K1 <<<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
      IF(CC.EQ.'K1') THEN 
                     IF(JCE.EQ.0) READ(N5,*,ERR=888) CC, 
     1                                    N,(EROS(K),K=1,5) 
                     IF(JCE.EQ.1) READ(N5,*,ERR=888) CC, 
     1                                    KKN,(EROS(K),K=1,5) 
                     ELSE 
                     GO TO 5005 
                     ENDIF 
C======================================================================= 
C     Set the default values for erosion. 
C======================================================================= 
      IF(N.NE.-2) GO TO 4065 
      DO 4064 J = 1,5 
      IF(EROS(J).GT.0.0) DEROS(J) = EROS(J) 
4064  CONTINUE 
      GO TO 5000 
C======================================================================= 
C     Set the new ratios for erosion 
C======================================================================= 
4065  IF(N.NE.-1) GO TO 4067 
      DO 4066 J = 1,5 
      IF(EROS(J).GT.0.0) REROS(J) = EROS(J) 
4066  CONTINUE 
      GO TO 5000 
4067  DO 4080 J = 1,NOW 
      IF(JCE.EQ.0.AND.N.NE.NAMEW(J)) GO TO 4080 
      IF(JCE.EQ.1.AND.KKN.NE.KAMEW(J)) GO TO 4080 
      K = J 
      GO TO 4090 
4080  CONTINUE 
C======================================================================= 
C     No match was found call ERROR subroutine. 
C======================================================================= 
      CALL ERROR(11) 
C======================================================================= 
C     Multiply by the ratios and assign default values. 
C======================================================================= 
4090  DO 4085 I = 1,5 
      IF(EROS(I).LE.0.0) EROS(I) = DEROS(I) 
4085  EROS(I)   = EROS(I) * REROS(I) 
C======================================================================= 
      ERODAR  = EROS(1) 
      ERLEN   = EROS(2) 
      SOILF   = EROS(3) 
      CROPMF  = EROS(4) 
      CONTPF  = EROS(5) 
      ERLEN   = ERLEN  * CMET(1,METRIC) 
      ERODAR  = ERODAR * CMET(2,METRIC) 
C======================================================================= 
C     The new values of ERLEN and ERODAR are used internally in 
C     the runoff block.  The input values are saved in EROS(1) 
C     and EROS(2) and will be printed on the output sheet. 
C======================================================================= 
C     Compute the slope length gradient ratio. 
C======================================================================= 
      SLGR = SQRT(ERLEN) * (0.0076 + 0.53 * WSLOPE(K) + 
     1                             7.6 * WSLOPE(K)**2 ) 
C======================================================================= 
C     COMPUTE THE PARTIAL USLE ( MINUS THE RAINFALL FACTOR) 
C     UNITS ARE IN MILLIGRAMS 
C     THE NUMBER 9.072E08 = 2000.0 * 453.6E03 
C     THE UNITS ARE LBS/TON * MG/LBS. 
C======================================================================= 
      CNSTNT(K) = SLGR * SOILF * CROPMF * CONTPF * ERODAR * 9.072E08 
C======================================================================= 
      IF(IPRN(7).EQ.0) THEN 
      IF(METRIC.EQ.1.AND.NWPGE.EQ.55) WRITE(N6,4050) 
      IF(METRIC.EQ.2.AND.NWPGE.EQ.55) WRITE(N6,4051) 
      IF(NWPGE.EQ.55) NWPGE = 13 
      WRITE(N6,4070) N,EROS(1),EROS(2),SOILF,CROPMF,CONTPF, 
     1           SLGR,CNSTNT(K) 
      ENDIF 
5000  CONTINUE 
5005  IF(IPRN(7).EQ.0) WRITE(N6,4075) 
C======================================================================= 
C     Since IROS = 1 , add a new quality constituent. 
C======================================================================= 
      NQSS = NQS 
      NQS  = NQS + 1 
      ENDIF 
C======================================================================= 
C     Read the subcatchment quality data. 
C======================================================================= 
C     Set the default values and default ratios. 
C======================================================================= 
      DO 5020 I = 1,MQUAL+2 
      DSUBQL(I) = 0.0 
5020  RSUBQL(I) = 1.0 
      DO 5030 I = 1,MQUAL 
5030  RNQS(I)   = 0.0 
      M         = 0 
      SMCTCH    = 0.0 
      GUTSM     = 0.0 
C#### WCH, 11/15/93 
      IEND      = NQSS + 2 
C======================================================================= 
Cred (WCH), 5/8/01 Increase loop to 200000 to allow for max no. subcats. 
      DO 6010 JJ = 1,200000 
      M          = M + 1 
      IF(M.GT.NOW) GO TO 6020 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>>>>>> Read data group L1 <<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,N,KL,(SUBQL(K),K=1,IEND) 
      IF(JCE.EQ.1) READ(N5,*,ERR=888) CC,KKN,KL,(SUBQL(K),K=1,IEND) 
C======================================================================= 
C     Alter ratios 
C======================================================================= 
      IF(N.NE.-1) GO TO 5070 
      DO 5065 I = 1,IEND 
5065  IF(SUBQL(I).NE.0.0) RSUBQL(I) = SUBQL(I) 
      M = M - 1 
      GO TO 6010 
C======================================================================= 
C     Alter the default values 
C======================================================================= 
5070  IF(N.NE.-2) GO TO 5080 
      DO 5075 I = 1,IEND 
5075  DSUBQL(I) = SUBQL(I) 
      M = M - 1 
      GO TO 6010 
5080  DO 6000 K = 1,NOW 
      IF(JCE.EQ.0.AND.N.NE.NAMEW(K))   GO TO 6000 
      IF(JCE.EQ.1.AND.KKN.NE.KAMEW(K)) GO TO 6000 
      KK = K 
      GO TO 6005 
6000  CONTINUE 
      IF(JCE.EQ.0) WRITE(N6,6006)   N 
      IF(JCE.EQ.1) WRITE(N6,6016) KKN 
6005  DO 6007 I   = 1,MQUAL+2 
      IF(SUBQL(I).LE.0.0) SUBQL(I) = DSUBQL(I) 
6007  SUBQL(I)      = SUBQL(I) * RSUBQL(I) 
C#### WCH, 4/19/93.  DON'T ALLOW ZERO FOR KL. 
C#### WCH, 10/19/95.  ADD WARNING MESSAGE. 
C####      IF(KL.LE.0.OR.KL.GT.NLU)  KL = 1 
Cwch 3/29/02. KL should be first in two prints below. . 
      IF(KL.LE.0.OR.KL.GT.JLAND) THEN 
           IF(JCE.EQ.0) WRITE(N6,6003) KL,N,JLAND 
           IF(JCE.EQ.1) WRITE(N6,6004) KL,KKN,JLAND 
           KL = 1 
           ENDIF 
      KLAND(KK)     = KL 
      BASINS(KK)    = SUBQL(1) 
      GQLEN(KK)     = SUBQL(2) 
C======================================================================= 
C>>>>>>>>>>>>>>>>>>>>>>>>>> Read data group L2 <<<<<<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(IMUL.EQ.0) PLAND(KL,KK) = 1.0 
      IF(IMUL.GT.0) READ(N5,*,ERR=888) CC,(PLAND(I,KK),I=1,N1) 
      TOLAND     = 0.0 
      DO 6008  I = 1,JLAND 
      IF(IMUL.EQ.0.AND.I.NE.KL) PLAND(I,KK) = 0.0 
      TOLAND     = TOLAND + PLAND(I,KK) 
6008  CONTINUE 
C##### WCH, 4/12/93.  RELAX CONSTRAINT ON SUM = 1.00000000000000000000. 
      IF(ABS(TOLAND-1.0).GT.0.001) THEN 
                        WRITE(N6,6300) KK 
                        CALL ERROR(154) 
                        ENDIF 
C======================================================================= 
Cwch, 1/4/01. This has to be an ERROR. In subs QINT and QSHED set 
C     land use subscript to KLAND if N1 = 1. To input intial loads, 
C     need to do the same here. 
C     Change land use subscript accordingly. 
C======================================================================= 
      DO 6009  LL   = 1,N1 
      IF(N1.EQ.1) J = KLAND(KK) 
      IF(N1.GT.1) J = LL 
C#### WCH, 11/15/93 
      DO 6009  I    = 1,NQSS 
C### WCH, 4/12/93.  REMOVE MULTIPLICATION BY PLAND.  DONE IN SUB QINT. 
6009  PSHED(J,I,KK) = SUBQL(I+2) 
6010  CONTINUE 
6020  CONTINUE 
      IF(IMUL.EQ.0.AND.JLAND.GT.1) THEN 
                                   DO 7100  K   = 1,NQS 
                                   DO 7100  J   = 1,JLAND 
                                   KALC(J,K)    = KALC(1,K) 
                                   KWASH(J,K)   = KWASH(1,K) 
                                   KACGUT(J,K)  = KACGUT(1,K) 
                                   LINKUP(J,K)  = LINKUP(1,K) 
C#### WCH, 3/30/95.  I THINK MISTAKE HERE FOR KALC = 0. 
C  PROGRAM USES ONLY QFACT(J,1,K), NEVER A MIDDLE SUBSCRIPT > 1. 
C  THUS, FOR KALC = 0, NEED TO SET QFACT(J,1,K) = QFACT(1,J,K).?? 
C 
                                   QFACT(J,1,K) = QFACT(1,1,K) 
                                   QFACT(J,2,K) = QFACT(1,2,K) 
                                   QFACT(J,3,K) = QFACT(1,3,K) 
                                   QFACT(J,4,K) = QFACT(1,4,K) 
                                   QFACT(J,5,K) = QFACT(1,5,K) 
                                   WASHPO(J,K)  = WASHPO(1,K) 
                                   RCOEF(J,K)   = RCOEF(1,K) 
                                   CBFACT(J,K)  = CBFACT(1,K) 
                                   CONCRN(J,K)  = CONCRN(1,K) 
                                   REFF(J,K)    = REFF(1,K) 
7100                               CONTINUE 
                                   ENDIF 
C======================================================================= 
C     Do not write a new page heading if there is less than 55 lines 
C                                 printed on the erosion output page. 
C======================================================================= 
      DO 6200 N = 1,NOW 
      NWPGE     = NWPGE + 1 
      IF(N.GT.1)       GO TO 6240 
      IF(NWPGE.EQ.55)  GO TO 6100 
      IF(IPRN(7).EQ.0) WRITE(N6,6029) 
      GO TO 6040 
C======================================================================= 
C     Write a new page heading. 
C======================================================================= 
6100  IF(IPRN(7).EQ.0) WRITE(N6,6101) 
6040  IF(IPRN(7).EQ.0) WRITE(N6,6102) (ISPACE,LL=1,NQSS) 
      IF(IPRN(7).EQ.0) WRITE(N6,6103) (ISPACE,LL=1,NQSS) 
C### WCH, 4/12/93.  MODIFY PRINT-OUT TO GIVE UNITS. 
      IF(METRIC.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,6104) (ISPACE,LL=1,NQSS) 
      IF(METRIC.EQ.2.AND.IPRN(7).EQ.0) WRITE(N6,6114) (ISPACE,LL=1,NQSS) 
C======================================================================= 
C     Write the descriptor line for GUTTER length depending 
C                                    on the value of METRIC. 
C======================================================================= 
      IF(IPRN(7).EQ.0) THEN 
             IF(METRIC.EQ.1) WRITE(N6,6105) (PNAME(LL),LL=1,NQSS) 
             IF(METRIC.EQ.2) WRITE(N6,6106) (PNAME(LL),LL=1,NQSS) 
             WRITE(N6,6109) (ISPACE,JJ=1,NQSS) 
             ENDIF 
      NWPGE = 10 
6240  KOUT  = KLAND(N) 
Cwch, 1/4/01.  Here, must use KOUT as subscript for PSHED. 
      IF(JCE.EQ.0.AND.IPRN(7).EQ.0) WRITE(N6,6250) 
     1       N,NAMEW(N),LNAME(KOUT),KLAND(N),GQLEN(N),BASINS(N), 
     2                                  (PSHED(KOUT,K,N),K=1,NQSS) 
      IF(JCE.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,6251) 
     1       N,KAMEW(N),LNAME(KOUT),KLAND(N),GQLEN(N),BASINS(N), 
     2                                  (PSHED(KOUT,K,N),K=1,NQSS) 
C======================================================================= 
C     Sum the GUTTER lengths and the number of catchbasins for printout. 
C======================================================================= 
      SMCTCH    = SMCTCH   + BASINS(N) 
      GUTSM     = GUTSM    + GQLEN(N) 
      GQLEN(N)  = GQLEN(N) * CMET(10,METRIC) 
Cwch, 1/4/01.  Here again must convert land use subscript. 
      DO 6190 JJ = 1,N1 
	IF(N1.EQ.1) J = KLAND(N) 
	IF(N1.GT.1) J = JJ 
      DO 6190 K  = 1,NQSS 
C##### WCH, 4/12/93.  CONVERT TO TOTAL LOAD. 
      IF(METRIC.EQ.1) 
     1 RNQS(K) = RNQS(K)+PSHED(J,K,N)*WAREA(N)/43560.*PLAND(J,N) 
      IF(METRIC.EQ.2) 
     1 RNQS(K) = RNQS(K)+PSHED(J,K,N)*WAREA(N)/(43560.*2.471)*PLAND(J,N) 
6190  CONTINUE 
6200  CONTINUE 
C======================================================================= 
C     Write the gutter length and catchbasin sums. 
C======================================================================= 
C### WCH, 4/12/93. ALTER PRINT-OUT FOR METRIC. 
      IF(METRIC.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,6270) 
     1 GUTSM,SMCTCH,(RNQS(I),I=1,NQSS) 
      IF(METRIC.EQ.2.AND.IPRN(7).EQ.0) WRITE(N6,6271) 
     1 GUTSM,SMCTCH,(RNQS(I),I=1,NQSS) 
C####################################################################### 
C  WCH, 4/13/93.  PRINT OUT LAND USE FRACTIONS FROM GROUP L2 
C======================================================================= 
C     Do not write a new page heading if there are fewer than 45 lines 
C                         printed on the last subcatchment output page. 
C======================================================================= 
      IF(IPRN(7).EQ.0.AND.IMUL.GT.0) THEN 
           IF(NWPGE.GT.45) NWPGE = 55 
           DO 6400 N = 1,NOW 
           NWPGE     = NWPGE + 1 
           IF(N.GT.1.AND.NWPGE.LE.55)  GO TO 6340 
C======================================================================= 
C     Write a new page heading. 
C======================================================================= 
           IF(NWPGE.LT.45) WRITE(N6,6500) 
           IF(NWPGE.GE.45) WRITE(N6,6501) 
           WRITE(N6,6502) 
           WRITE(N6,6503) (LL,LL=1,N1) 
           WRITE(N6,6504) (LNAME(LL),LL=1,N1) 
           NWPGE = 10 
6340       KOUT  = KLAND(N) 
           IF(JCE.EQ.0) WRITE(N6,6505) N,NAMEW(N),(PLAND(LL,N),LL=1,N1) 
           IF(JCE.EQ.1) WRITE(N6,6506) N,KAMEW(N),(PLAND(LL,N),LL=1,N1) 
6400       CONTINUE 
C     END LOOP FOR L2 FRACTIONS PRINT 
           ENDIF 
C======================================================================= 
C     INITIALIZE WATERSHED POLLUTION LOADS..... 
C======================================================================= 
      CALL QINT 
      RETURN 
  888 CALL IERROR 
C======================================================================= 
 1180 FORMAT(/,1H1,/, 
     1' ###################################################',/, 
     2' #              Quality Simulation                 #',/, 
     3' ###################################################',/, 
     4' #      General Quality Control Data Groups        #',/, 
     5' ###################################################',//, 
     62X,'Description',28X,'Variable',7X,'Value',/,2X, 
     7'-----------',28X,'--------',7X,'-----',//, 
     82X,'Number of quality constituents.....    NQS.......',I10, 
     9//,2X,'Number of land uses................  JLAND.......', 
     9I10,//,2X,'Standard catchbasin volume.........  CBVOL.......', 
     1F10.2,' cubic feet',/) 
 1190 FORMAT(/,1H1,/, 
     1' ###################################################',/, 
     2' #              Quality Simulation                 #',/, 
     3' ###################################################',/, 
     4' #      General Quality Control Data Groups        #',/, 
     5' ###################################################',//, 
     62X,'Description',28X,'Variable',7X,'Value',/,2X, 
     7'-----------',28X,'--------',7X,'-----',//, 
     82X,'Number of quality constituents.....    NQS.......',I10, 
     9//,2X,'Number of land uses................  JLAND.......', 
     9I10,//,2X,'Standard catchbasin volume.........  CBVOL.......', 
     1F10.2,' cubic meters',/) 
 1590 FORMAT(2X,'Erosion is not simulated.........    IROS........', 
     1       I10,/) 
 1600 FORMAT(2X,'Erosion is simulated using the ',/, 
     1       2X,'Universal soil loss equation.......  IROS........', 
     2       I10,/) 
 1610 FORMAT(2X,'Erosion added to constituent....... IROSAD.......', 
     1  I10,/) 
 1615 FORMAT(2X,'HIGHEST AVERAGE 30 MINUTE RAINFALL',/,2X, 
     1           'INTENSITY DURING STORM OR YEAR..... RAINIT.......', 
     2 F10.3,' IN/HR',/) 
 1616 FORMAT(2X,'HIGHEST AVERAGE 30 MINUTE RAINFALL',/,2X, 
     1           'INTENSITY DURING STORM OR YEAR..... RAINIT.......', 
     2 F10.3,' MM/HR',/) 
 1620 FORMAT(2X,'DRY DAYS PRIOR TO START OF STORM... DRYDAY.......', 
     1  F10.2,' DAYS',/) 
 1623 FORMAT(/,' ====> ERROR  DRYBSN HAS A', 
     1      'VALUE OF ',F10.3,' AND HAS BEEN CHANGED TO 1.0',/) 
 1625 FORMAT(2X,'DRY DAYS REQUIRED TO RECHARGE',/,2X, 
     1           'CATCHBASIN CONCENTRATION TO  ',/,2X, 
     2           'INITIAL VALUES..................... DRYBSN.......', 
     3 F10.2,' DAYS',/) 
 1630 FORMAT(2X,'DUST AND DIRT',/, 
     1 2X,'STREET SWEEPING EFFICIENCY......... REFFDD.......', 
     2 F10.3,/) 
 1635 FORMAT(2X,'DAY OF YEAR ON WHICH STREET ',/,2X, 
     1           'SWEEPING BEGINS.................... KLNBGN.......', 
     2 I10,//,2X,'DAY OF YEAR ON WHICH STREET',/,2X, 
     3           'SWEEPING ENDS...................... KLNEND.......', 
     4 I10,/) 
 1639 FORMAT(/, 
     1' ###########################################',/, 
     2' #     Land use data on data group J2      #',/, 
     3' ###########################################',/) 
 1640 FORMAT(1X,'                                                 ', 
     1'            LIMITING                      CLEANING  AVAIL.', 
     2'    DAYS SINCE',/, 
     3'                                                              ', 
     4'BUILDUP    BUILDUP  BUILDUP   INTERVAL  FACTOR       LAST',/, 
     5'LAND USE   BUILDUP EQUATION TYPE   FUNCTIONAL DEPENDENCE OF', 
     6'   QUANTITY   POWER    COEFF.    IN DAYS   FRACTION   SWEEPING', 
     7/,'(LNAME)            (METHOD)        BUILDUP PARAMETER(JACGUT)', 
     8'  (DDLIM)    (DDPOW)  (DDFACT)  (CLFREQ)  (AVSWP)     (DSLCL)',/, 
     9'--------   ---------------------   -------------------------', 
     9'  --------   -------  --------  --------  -------    ---------') 
 1641 FORMAT(1X,A8,1X,A20,5X,A16,8X,1PE11.3,5(0PF10.3)) 
 1660 FORMAT(//,1H1,/ 
     1' ##############################################',/, 
     2' #     Constituent data on data group J3      #',/, 
     3' ##############################################',/) 
 2001 FORMAT(/,26X,99(6X,A8,6X)) 
 2002 FORMAT(26X,99(5X,A1,'--------',6X)) 
 2003 FORMAT(1X,'Constituent units........',99(6X,A8,6X)) 
 2004 FORMAT(1X,'Type of units............',99(8X,I4,8X)) 
 2006 FORMAT(1X,'KALC.....................',99(8X,I4,8X)) 
 2007 FORMAT(1X,'KWASH....................',99(8X,I4,8X)) 
 2008 FORMAT(1X,'KACGUT...................',99(8X,I4,8X)) 
 2009 FORMAT(1X,'LINKUP...................',99(8X,I4,8X)) 
C#### WCH 4/13/93.  WCH MONKEYED WITH THESE FORMATS. 
Cwch, 3/29/02. Change 4X,F12.3 to 1X,F15.3 
 2205 FORMAT(1X,'Type of buildup calc.....',99(2X,A16,2X)) 
 2206 FORMAT(1X,'Type of washoff calc.....',99A20) 
 2207 FORMAT(1X,'Dependence of buildup....',99(2X,A16,2X)) 
 2208 FORMAT(1X,'Linkage to snowmelt......',99(2X,A16,2X)) 
 2209 FORMAT(1X,'Buildup param 1 (QFACT1).',99(1X,F15.3,4X)) 
 2500 FORMAT(1X,'Buildup param 2 (QFACT2).',99(1X,F15.3,4X)) 
 2501 FORMAT(1X,'Buildup param 3 (QFACT3).',99(1X,F15.3,4X)) 
 2502 FORMAT(1X,'Buildup param 4 (QFACT4).',99(1X,F15.3,4X)) 
 2503 FORMAT(1X,'Buildup param 5 (QFACT5).',99(1X,F15.3,4X)) 
 2504 FORMAT(1X,'Washoff power (WASHPO)...',99(1X,F15.3,4X)) 
 2505 FORMAT(1X,'Washoff coef. (RCOEF)....',99(1X,F15.3,4X)) 
 2506 FORMAT(1X,'Init catchb conc (CBFACT)',99(1X,F15.3,4X)) 
 2507 FORMAT(1X,'Precip. conc. (CONCRN)...',99(1X,F15.3,4X)) 
 2508 FORMAT(1X,'Street sweep effic (REFF)',99(1X,F15.3,4X)) 
 2509 FORMAT(1X,'Land use number..........',99(4X,I12,4X)) 
Cwch, 12/20/00 
 2510 FORMAT(1X,'Remove fraction (REMOVE).',99(1X,F15.3,4X)) 
 2511 FORMAT(1X,'1st order QDECAY, 1/day..',99(1X,F15.3,4X)) 
 3010 FORMAT(/, 
     1       ' *************************************************',/, 
     2       ' * Constant Groundwater Quality Concentration(s) *',/, 
     3       ' *************************************************',//, 
     4       (2X,A10,' has a concentration of..',F10.4,' ',A10,/)) 
 3015 FORMAT(/, 
     1       ' *************************************************',/, 
     2       ' * Constant Infil/Inflw Quality Concentration(s) *',/, 
     3       ' *************************************************',//, 
     4       (2X,A10,' has a concentration of..',F10.4,' ',A10,/)) 
 3076 FORMAT(/,1H1,/, 
     1' *******************************************',/, 
     2' * Fractions for contributions from other  *',/, 
     3' *     constituents on data group J4       *',/, 
     4' *******************************************',//) 
 3077 FORMAT(15X,' CONSTITUENT FROM WHICH THE FRACTION IS COMPUTED', 
     1  /,15X,' -----------------------------------------------') 
Cwch, 1/18/01.  These should work, but don't.  Try another route. 
C 3078 FORMAT(/,15X,'*',(A8,1X,'*'),/) 
C 3090 FORMAT(1X,'Fraction will *',(9X,A1)) 
C 3091 FORMAT(1X,' be added to  *',(9X,A1)) 
C 3092 FORMAT(1X,'  Constituent *',(9X,A1)) 
C 3093 FORMAT(4X,A8,3X,'*',(1X,F7.3,1X,'*')) 
C 3094 FORMAT(15X,'*',(A4,'-----',A1)) 
 3078 FORMAT(/,15X,'*',99(A8,1X,'*')) 
 3090 FORMAT(1X,'Fraction will *',99(9X,A1)) 
 3091 FORMAT(1X,' be added to  *',99(9X,A1)) 
 3092 FORMAT(1X,'  Constituent *',99(9X,A1)) 
 3093 FORMAT(4X,A8,3X,'*',99(1X,F7.3,1X,'*')) 
 3094 FORMAT(15X,'*',99(A4,'-----',A1)) 
C 
 4050 FORMAT(/,1H1,T20,'*******************************',/, 
     1           T20,'*      EROSION INPUT DATA     *',/, 
     2           T20,'*        DATA GROUP K1        *',/, 
     3           T20,'*******************************',//, 
     4           T11,'SUBCAT',T20,'EROSION',T30,'  FLOW',T45,'  SOIL', 
     5           T60,'CROPPING',T75,'CONTROL',T90,' SLOPE',T105, 
     6               'PARTIAL',/, 
     7           T10, 'NUMBER',T20,'AREA-ACRES',T30,' LENGTH-FT',T45, 
     8               ' FACTOR',T60,' FACTOR',T75,' FACTOR',T90, 
     9               'LENGTH',T105,' USLE *',/,T90,'GRAD-RATIO',/, 
     9            T10,2('--------',2X),6('----------',5X)) 
 4051 FORMAT(/,1H1,T20,'*******************************',/, 
     1           T20,'*      EROSION INPUT DATA     *',/, 
     2           T20,'*        DATA GROUP K1        *',/, 
     3           T20,'*******************************',//, 
     4           T11,'SUBCAT',T20,'EROSION',T30,'  FLOW',T45,'  SOIL', 
     5           T60,'CROPPING',T75,'CONTROL',T90,' SLOPE',T105, 
     6               'PARTIAL',/, 
     7           T10, 'NUMBER',T20,' AREA-HA  ',T30,' LENGTH-M',T45, 
     8               ' FACTOR',T60,' FACTOR',T75,' FACTOR',T90, 
     9               'LENGTH',T105,' USLE *',/,T90,'GRAD-RATIO',/, 
     9            T10,2('--------',2X),6('----------',5X)) 
 4070 FORMAT(9X,I6,3X,2F10.1,5X,4(F10.3,5X),1PE10.2) 
 4075 FORMAT(/,' ===> PARTIAL USLE = ERODAR * SOILF * CROPMF * CONTPF * 
     1SLGR * (9.072E8 MG/TON)') 
C#### WCH, 10/19/95.  THREE NEW FORMAT STATEMENTS. 
 6001 FORMAT(' ==> ERROR  YOU INDICATE QUALITY SIMULATION (KWALTY = 1) 
     2BUT JUMP RIGHT TO',/,' M1 LINES. ADD QUALITY DATA OR SET KWALTY = 
     30 ON LINE B1.  RUN STOPPED.') 
 6003 FORMAT(' ==> WARNING  LAND USE NUMBER = ',I2,' ON L1 SUBCATCHMEN 
     1T NO. ',I10,/,' KL VALUE MUST BE IN RANGE 1 -',I2,' AND HAS BEEN S 
     2ET = 1.') 
 6004 FORMAT(' ==> WARNING  LAND USE NUMBER = ',I2,' ON L1 SUBCATCHMEN 
     1T NO. ',A10,/,' KL VALUE MUST BE IN RANGE 1 -',I2,' AND HAS BEEN S 
     2ET = 1.') 
 6006 FORMAT(' ===> ERROR   NO MATCH WAS FOUND FOR', 
     1       ' SUBCATCHMENT ',I10,' ON DATA GROUP L1',/, 
     2           '                      WITH ANY SUBCATCHMENT ', 
     3       'NUMBERS ON DATA GROUP H1.') 
 6016 FORMAT(' ===> ERROR   NO MATCH WAS FOUND FOR', 
     1       ' SUBCATCHMENT ',A10,' ON DATA GROUP L1',/, 
     2           '                      WITH ANY SUBCATCHMENT ', 
     3       'NUMBERS ON DATA GROUP H1.') 
C#### WCH, 4/13/93 
 6017 FORMAT(' $$$$$ WARNING  FOR LAND USE',I2,' AND POLLUTANT',I3, 
     1 ' WASHPO =',F8.2,/,' VALUES GREATER THAN APPROX. 25 LIKELY TO CAU 
     2SE NUMERICAL PROBLEMS.',/,' E.G., EXTREMELY LARGE OR SMALL WASHOFF 
     3 VALUES.') 
C#### WCH, 9/29/93. 
 6018 FORMAT (' $$$$ WARNING JLAND VALUE ON LINE J1 =',I2,' AND IS LESS 
     1 THAN NUMBER OF J2 LINES.',/,' JLAND INCREASED TO',I3,' AND CONTIN 
     2UE READING THE J2 LINES IN HOPES OF INPUTTING ALL LAND USE DATA.') 
Cwch, 2/10/01. 
 6021 FORMAT(' **ERROR** NO MATCH FOR NAME OF CHANNEL/PIPE ',I10, 
     1 ' ON J7 LINE. VALUES FOR GREMOVE ON THIS LINE NOT USED.') 
 6022 FORMAT(' **ERROR** NO MATCH FOR NAME OF CHANNEL/PIPE ',A10, 
     1 ' ON J7 LINE. VALUES FOR GREMOVE ON THIS LINE NOT USED.') 
 6023 FORMAT(' $$WARNING$$ MORE J7 LINES (',I4,') THAN NUMBER OF CHANNEL 
     1/PIPES (',I4,')',/, 
     2' BUT CONTINUE READING J7 LINES.') 
 6025 FORMAT(//, 
     1 ' ************************************************',/, 
	2 ' * REMOVAL FRACTIONS FOR SELECTED CHANNEL/PIPES *',/, 
	3 ' * FROM J7 LINES                                *',/, 
	4 ' ************************************************',//, 
	5 '   CHANNEL/   CONSTITUENT',/, 
	6 '      PIPE ',99(A10)) 
 6026 FORMAT(' ----------',99(2X,2A4)) 
 6027 FORMAT(1X,I10,99F10.3) 
 6028 FORMAT(1X,A10,99F10.3) 
C 
 6029 FORMAT(//, 
     1' *****************************************************',/, 
     2' *     Subcatchment surface quality on data group L1 *',/, 
     3' *****************************************************',/) 
 6101 FORMAT(/,1H1,/, 
     1' *****************************************************',/, 
     2' *     Subcatchment surface quality on data group L1 *',/, 
     3' *****************************************************',/) 
C#### WCH, 4/12/93.  ALTER FORMATS SLIGHTLY FOR METRIC LOAD UNITS 
C                    AND WIDER SUBCAT. NO. FIELD. 
cim 4/5/99 change 10( to 99( 
 6102 FORMAT(//,31X,'    Total   Number',99(A1,'  Input '),/) 
 6103 FORMAT(26X,'Land',1X,'   Gutter     of  ',99(A1,' Loading')) 
 6104 FORMAT(15X,'   Land     Use    Length   Catch-', 
     1       99(A1,' load/ac')) 
 6114 FORMAT(15X,'   Land     Use    Length   Catch-', 
     1       99(A1,' load/ha')) 
 6105 FORMAT(13X,'No.  Usage    No.   10**2ft   Basins  ', 
     1       99(1X,A8)) 
 6106 FORMAT(13X,'No.  Usage    No.      Km     Basins  ', 
     1       99(1X,A8)) 
6109  FORMAT(9X,'------',' --------','  ----','   --------', 
     1          ' --------',99(A1,' -------')) 
 6250 FORMAT(1X,I4,1X,I10,1X,A8,1X,I2,4X,2F9.2,99(1X,1PE8.1)) 
 6251 FORMAT(1X,I4,1X,A10,1X,A8,1X,I2,4X,2F9.2,99(1X,1PE8.1)) 
 6270 FORMAT(4X,'Totals (Loads in lb or other)',F8.2,F9.2,99(1X,1PE8.1)) 
 6271 FORMAT(4X,'Totals (Loads in kg or other)',F8.2,F9.2,99(1X,1PE8.1)) 
 6300 FORMAT(' ===> Problem with subcatchment # ',I6,' L2 line.') 
 6500 FORMAT(//, 
     1' ********************************************************',/, 
     2' *   Subcatchment land use fractions on data group L2   *',/, 
     3' ********************************************************',/) 
 6501 FORMAT(/,1H1,/, 
     1' ********************************************************',/, 
     2' *   Subcatchment land use fractions on data group L2   *',/, 
     3' ********************************************************',/) 
 6502 FORMAT(14X,'FRACTION FOR LAND USE NUMBER:') 
CIM FIX THREEE STATMENT FOR NUMEROUS LAND USES 
 6503 FORMAT(5X,'CATCHMENT  ',I6,99I10) 
 6504 FORMAT(1X,'NO.      NAME ',99(2X,A8)) 
 6505 FORMAT(I4,1X,I10,99F10.3) 
 6506 FORMAT(I4,1X,A10,99F10.3) 
 8000 FORMAT(1H1) 
C======================================================================= 
      END 
 
REM File: QUALSOLN.FOR 
 
	SUBROUTINE QUALSOLN(IP,QAVG,CQAVG,DVDT,VOL,DECAYY,ERODE, 
     1 DEPOS,REMOVE,XLDECAY) 
C======================================================================= 
C	Routine to evaluate analytical solution to Transport pollutant 
C       routing using complete mixing solutions.   
C     Called from Sub. QUAL.  Replaces code at end of QUAL. 
C     Created 7/6/01 by Wayne Huber in order to provide linked DO-BOD- 
C       NOD simulation.  
C     Follow procedure similar to that used in Sub. SHEDQUAL. 
C     Correct for non-calc when there is zero flow and thus, zero 
C       DENOM.  WCH, 8/6/03. 
C======================================================================= 
C	CAUTION 
C     THERE MAY BE SOME IDENTICAL NAMES USED IN ARGUMENT LIST AS IN  
C     TRANSPORT COMMON.  BE VERY CAREFUL IF LATER DECIDE TO INCLUDE   
C     VARIOUS LABELED COMMONS. 
C     Caution. Most Transport Common blocks not accessed. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
	INCLUDE 'TRANWQ.INC' 
	INCLUDE 'HUGO.INC' 
C======================================================================= 
C 
C     IP      = Constituent number. 
C     M       = Element number (should be channel/pipe or element 
C               with storage). (HUGO.INC) 
C     QAVG    = Average outflow from element, cfs. 
C               "Average"  means average of beginning and end of time 
C               step. 
C     CQAVG   = Average incoming load to element, cfs * mg/L. 
C     DVDT    = dV/dt = change in volume per time step, cfs. 
C	VOL     = Average volume of water in element, ft3. 
C     DECAYY  = First-order decay coefficient, 1/sec. 
C     DT      = Time step, sec. (HUGO.INC) 
C     ERODE   = Load from erosion, cfs*mg/L. 
C     DEPOS	= Deposition, cfs*mg/L. 
C	REMOVE  = BMP removal fraction, affecting all loads. 
C   CPOL2 values are in Common in HUGO.INC 
C     CPOL2(M,1,IP)  = Downstream concentration at beginning of  
C               time step, mg/L. 
C     CPOL2(M,2,IP)  = Downstream concentration at end of time  
C               step, mg/L. 
C 
C     XLREMOV = mg/L*ft3 removed by removal fraction. 
C     XLDECAY = mg/L*ft3 removed by first-order decay. 
C     XLSETL  = mg/L*ft3 removed by settling. 
C======================================================================= 
C     The following equation uses average quantities over the 
C     time step to avoid stability problems. 
C 
C     The equation integrated is: 
C 
C     V*dC/dt = (Qin*Cin + Load)*(1 - Remove) - Q*C - C*dV/dt - Vs*As  
C         - K*C*V + [possible linkages among CBOD, NOD, NO3-N & DO] 
C 
C     (See User's Manual, Appendix IX.) 
C 
C     C       = outflow concentration, mg/L 
C     Vs      = settling velocity, ft/s 
C     As      = surface area, ft2 
C     Q       = QAVG = outflow rate, cfs 
C     Qin*Cin = CQAVG = incoming load, cfs*mg/L 
C     Load    = other loads, cfs*mg/L 
C     K       = DECAYY, 1/s 
C 
C     Note that evaporation does not remove mass.  Outflow by evaporation 
C     is accounted for in (1/V)dV/dt term.  Hence, evaporation can increase 
C     concentrations, especially when outflow (and volume or depth) are 
C     very small.  
C     No evaporation in Transport Block, July 2001.   
C 
C     Use average values for the time step in order to integrate  
C     equation with constant coefficients.   
C 
C     C = Cnew [1 - EXP(-ARG)] + Cold EXP(-ARG) + [Possible additional 
C         terms reflecting linked CBOD, NOD, NO3-N, DO] 
C 
C     where  
C     Cnew  = TOP/DENOM 
C     ARG   = DENOM*DT, 
C     TOP   = [Qin*Cin + Load]*(1-REMOVE)/V 
C     DENOM = [Q/V + (1/V)dV/dt + Vs/D + K] 
C     D     = Average depth, ft 
C     Cold  = C at last time step. 
C     Cnew, Cold and C have units of mg/ft3 
C======================================================================= 
C     Compute current values of channel parameters for routing. 
C     For linked DO simulation, need surface area, average depth, 
C     and velocity. 
C======================================================================= 
C     DENOM can be negative when there is evaporation.   
C     But no evaporation in Transport, as of July 2001.  Hence, should 
C     not have negative DENOM.  
C======================================================================= 
C     This subroutine is only called when VOL > 0.0.  Hence, there are  
C     no checks for zero divide with VOL.  
C======================================================================= 
      DENOM = 0.0 
	TOP   = 0.0 
	DENOM = (QAVG + DVDT)/VOL 
C======================================================================= 
C     Determine several parameters used by constituents during 
C     evaluation for IP = 1. 
C======================================================================= 
      IF(IP.EQ.1) CALL QUALPARM(ASURF,ASSETL,DBAR,DBARSETL,VELL,CS,WAVG) 
      IF(NWQ.EQ.1.AND.IP.LE.4) THEN 
         SELECT CASE (IP) 
	      CASE (1)   CBOD 
C======================================================================= 
C     Here, simulate ultimate, carbonaceous BOD = CBOD. 
C     Use same solution form as for other constituents -- no "upstream" 
C     linkages. 
C======================================================================= 
            DECAYY  = DEKD(M)*THETA(1)**(TWATER(M)-20.0) 
	      DECAYYD = DECAYY 
            DENOM   = DENOM + DECAYY 
	      IF(DBARSETL.GT.0.0)  
     1	       DENOM = DENOM + (1.0-FDIS(1))*VSETL(1)/DBARSETL 
	      IF(DENOM.LT.0.0) DENOM = 0.0 
	      DENBOD = DENOM 
	      TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL 
            TOPBOD = TOP 
            CASE (2)   NBOD 
C======================================================================= 
C     Here, simulate nitrogenous oxygen demand = NOD. 
C     This may be simulated as TKN or NH3-N, but will be called NOD 
C     in output.  
C     Use same solution form as for other constituents -- no "upstream"  
C     linkages. 
C======================================================================= 
            DECAYY  = DEKN(M)*THETA(2)**(TWATER(M)-20.0) 
	      DECAYYN = DECAYY 
            DENOM   = DENOM + DECAYY 
	      IF(DBARSETL.GT.0.0) DENOM = DENOM +  
     1          (1.0-FDIS(2))*VSETL(2)/DBARSETL 
	      IF(DENOM.LT.0.0) DENOM = 0.0 
	      DENNOD = DENOM 
	      TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL 
            TOPNOD = TOP 
            CASE (3)   NO3-N 
C======================================================================= 
C     Here, simulate NO3-N. 
C     This is linked to decay of NOD, so must evaluate fully linked 
C     integral solution. 
C======================================================================= 
            DENOM  = DENOM + DECAYY 
	      IF(DBARSETL.GT.0.0) DENOM = DENOM +  
     1          (1.0-FDIS(3))*VSETL(3)/DBARSETL 
	      IF(DENOM.LT.0.0) DENOM = 0.0 
	      TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL 
	      CASE (4)   DO 
C======================================================================= 
C     Here, simulate dissolve oxygen deficit DEFICIT = Csat - DO. 
C     This is linked to decay of BOD and NOD, so must evaluate fully 
C     linked integral solution. 
C     Calculate the reaeration coefficient = decay coef. for DEFICIT. 
C     Units of TOP are mg/L * ft3/s.  Units of SOD are mg/ft2-sec. 
C     For same units for settling load, divide by average depth 
C     (ft) and divide by 28.3 L/ft3.  
C======================================================================= 
           CALL REAERATE(DECAY2,DBAR,VELL,WIND(M),TAIR(M),TWATER(M),REA, 
     1THETA(3),KWIND,KOVAR,GNUW,GNUA,RHOW,RHOA,DMOLEC,XLAMBDA,ZEE,CAPPA, 
     2 GAMMAZ,UTSTAR,PRESURE,UCSTAR,CAPPA3,CDRAG,IYZ,DELG1,ZZERO,USTAR, 
     3 CAYEL,DECAY2W,SALINITY,G1,ZAA,N6,DECAY2F) 
	      DECAYY = DECAY2 
	      DENOM  = DENOM + DECAY2 
	      SEDMD  = 0.0 
	      IF(DBARSETL.GT.0.0) SEDMD = SOD(M)/DBARSETL/28.3 
C======================================================================= 
C     Do not include ERODE and DEPOS for DEFICIT, for now. 
C     Do not include REMOVE for DEFICIT. 
C     Assume upstream and incoming deficit load is QAVG*CS - CQAVG 
C     where CQAVG is "load" of incoming DO. 
C======================================================================= 
            DEFLOAD = QAVG*CS - CQAVG 
	      IF(DEFLOAD.LT.0.0) DEFLOAD = 0.0 
	      TOP = DEFLOAD/VOL + SEDMD 
	      END SELECT 
C======================================================================= 
	   ELSE 
C======================================================================= 
C     Here for "ordinary" constituent. 
C======================================================================= 
         DENOM = DENOM + DECAYY 
	   IF(DBARSETL.GT.0.0) DENOM = DENOM +  
     1          (1.0-FDIS(IP))*VSETL(IP)/DBARSETL 
	   IF(DENOM.LT.0.0) DENOM = 0.0 
	   TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL 
         ENDIF 
C======================================================================= 
C     EXXP => 0 ==> Big ARG, big Qin/V, concentration => Cin. 
C     EXXP >  0 ==> Smaller ARG, smaller Qin/V, and 
C      concentration between Cin and Co.   
C     EXXP => 1 ==> ARG => 0, Qin/V => 0, concentration => Co. 
C     EXXP > 1.0 for negative DENOM (increase concentration because 
C      of evaporation).  But no evap in Transport yet. 
C======================================================================= 
                      EXXP = 0.0 
				    ARG  = DENOM*DT 
	IF(ARG.EQ.0.0)  EXPP = 1.0 
      IF(ARG.LT.10.0.AND.ARG.GT.0.0) EXXP = EXP(-ARG) 
C======================================================================= 
C     For all cases except DO, first part of solution is the same. 
C======================================================================= 
      C2NEXT = 0.0 
	CZERO  = CPOL2(M,1,IP) 
	IF(NWQ.EQ.1.AND.IP.EQ.4) CZERO = CS - CPOL2(M,1,4) 
	IF(CZERO.LT.0.0) CZERO  = 0.0 
	IF(DENOM.NE.0.0) C2NEXT = TOP/DENOM*(1.0-EXXP) + CZERO*EXXP 
Cwch, 8/6/03 
      IF(DENOM.EQ.0.0) C2NEXT = CZERO 
C======================================================================= 
      IF(NWQ.EQ.1.AND.IP.LE.4) THEN 
	   SELECT CASE (IP) 
	     CASE (1)   CBOD 
	     EXPBOD = EXXP 
	     CPOL2(M,2,1) = C2NEXT 
	     CASE (2)   NBOD 
	     EXPNOD = EXXP 
	     CPOL2(M,2,2) = C2NEXT 
	     CASE (3)   NO3-N 
C======================================================================= 
C     Add linkage to NOD decay to NO3-N. 
C======================================================================= 
           PART2 = 0.0 
	     PART3 = 0.0 
	     IF(DENOM.NE.0.0.AND.DENNOD.NE.0.0) THEN 
		    PART2 = DECAYYN*TOPNOD/DENOM/DENNOD*(1.0 - EXXP) 
	        IF(ABS(DENOM-DENNOD).GT.0.0001) THEN 
	           PART3 = DECAYYN/(DENOM-DENNOD)* 
     1     	   (CPOL2(M,1,2)-TOPNOD/DENNOD)*(EXPNOD-EXXP) 
	           ELSE 
C======================================================================= 
C     Use solution for lim->(DENOM->DENNOD) 
C======================================================================= 
                 PART3 = DECAYYN*(CPOL2(M,1,2)-TOPNOD/DENNOD)*(-DT*EXXP) 
	           ENDIF 
              ENDIF 
	     CPOL2(M,2,3) = C2NEXT + PART2 + PART3 
           CASE (4)   DO	 
C======================================================================= 
C     Add linkage to NOD and BOD decay to DEFICIT.  First, BOD. 
C======================================================================= 
           PART4 = 0.0 
	     PART5 = 0.0 
	     IF(DENOM.NE.0.0.AND.DENBOD.NE.0.0) THEN 
		    PART4 = DECAYYD*TOPBOD/DENOM/DENBOD*(1.0 - EXXP) 
	        IF(ABS(DENOM-DENBOD).GT.0.0001) THEN 
	           PART5 = DECAYYD/(DENOM-DENBOD)* 
     1              (CPOL2(M,1,1)-TOPBOD/DENBOD)*(EXPBOD-EXXP) 
	           ELSE 
C======================================================================= 
C     Use solution for lim->(DENOM->DENBOD) 
C======================================================================= 
                 PART5 = DECAYYD*(CPOL2(M,1,1)-TOPBOD/DENBOD)*(-DT*EXXP) 
	           ENDIF 
              ENDIF 
C======================================================================= 
C     Similarly for NOD, but need to multiply by  
C     stoichiometric constant, TKN to NO3-N, 64/14 = 4.57. 
C======================================================================= 
           PART6 = 0.0 
	     PART7 = 0.0 
	     IF(DENOM.NE.0.0.AND.DENNOD.NE.0.0) THEN 
		    PART6 = DECAYYN*TOPNOD/DENOM/DENNOD*(1.0 - EXXP) 
	        IF(ABS(DENOM-DENNOD).GT.0.0001) THEN 
	           PART7 = DECAYYN/(DENOM-DENNOD)* 
     1              (CPOL2(M,1,2)-TOPNOD/DENNOD)*(EXPNOD-EXXP) 
	           ELSE 
C======================================================================= 
C     Use solution for lim->(DENOM->DENNOD) 
C======================================================================= 
                 PART7 = DECAYYN*(CPOL2(M,1,2)-TOPNOD/DENNOD)*(-DT*EXXP) 
	           ENDIF 
              ENDIF 
	     CPOL2(M,2,4) = CS - (C2NEXT + PART4 + PART5  
     1                    + 4.57*(PART6 + PART7)) 
           IF(CPOL2(M,2,4).LT.0.0) CPOL2(M,2,4) = 0.0 
           END SELECT 
C======================================================================= 
	   ELSE 
C======================================================================= 
C     For "ordinary" pollutants, just use C2NEXT previously computed.  
C======================================================================= 
	   CPOL2(M,2,IP) = C2NEXT 
	   ENDIF 
C======================================================================= 
C     For continuity, try to keep track of losses (mg/L * ft3/s)*sec = 
C     mg/L * ft3.  Processes include: 
C       -removal fraction (XLREMOV) 
C       -settling (XLSETL) 
C       -decay (XLDECAY) -- sum in Sub. QUAL 
C       -NOD decay to NO3-N (XLNO3SRC) 
C       -reaeration (XLREAER) 
C       -sediment oxygen demand (XLSEDOD) 
C       -For DO: deficit source from CBOD (XLBOD2DO) 
C                deficit source from NOD  (XLNOD2DO) 
C======================================================================= 
      XLREMOV(IP) = XLREMOV(IP) + REMOVE*(CQAVG + ERODE - DEPOS)*DT	 
	CAVG        = (CPOL2(M,1,IP)+CPOL2(M,2,IP))/2.0 
	XLSETL(IP)  = XLSETL(IP) + ASSETL*(1-FDIS(IP))*VSETL(IP)*CAVG*DT	 
      IF(NWQ.EQ.1.AND.(IP.EQ.3.OR.IP.EQ.4)) THEN 
	   SELECT CASE (IP) 
	     CASE (3)   NO3-N 
C======================================================================= 
C     For NO3-N, keep track of mass added by NOD decay. 
C======================================================================= 
           XLNO3SRC = XLNO3SRC  
     1       + DECAYYN*VOL*DT*(CPOL2(M,1,2)+CPOL2(M,2,2))/2.0 
           XLDECAY  = DECAYY*VOL*CAVG*DT 
	     CASE (4)   DO 
C======================================================================= 
C     For DO continuity check, calculate mass of DO from reaeration by 
C     knowing deficits.  Use current Cs for old and current time step.  
C     Also need deficit source from BOD, NOD, and sediment OD.  
C======================================================================= 
	                        DEFICIT = CS-CAVG 
	     IF(DEFICIT.LT.0.0) DEFICIT = 0.0 
	     XLREAER  = XLREAER + DECAY2*VOL*DEFICIT*DT 
	     XLSEDOD  = XLSEDOD + VOL*SEDMD*DT 
	     XLBOD2DO = XLBOD2DO 
     1       + DECAYYD*VOL*DT*(CPOL2(M,1,1)+CPOL2(M,2,1))/2.0 
	     XLNOD2DO = XLNOD2DO 
     1       + DECAYYN*VOL*DT*(CPOL2(M,1,2)+CPOL2(M,2,2))/2.0*4.57 
           END SELECT 
	     ELSE 
           XLDECAY = DECAYY*VOL*CAVG*DT 
	     ENDIF 
C======================================================================= 
      RETURN 
	END 
 
REM File: RAIN.FOR 
 
      SUBROUTINE RAIN 
C======================================================================= 
C     Created June 1988 by Bob Dickinson (R.E.D.) 
C     Last updated December, 1990 by R.E.D. 
C     WCH, March 1993.  Add warning message for multiple stations. 
C     WCH, August 1993. Add option to process new EarthInfo ASCII files 
C       and to place 15-min. data on interface file at 15-min intervals, 
C       not in the form of hourly totals. 
C     WCH, 9/7/93.  Add option to bypass all statistical calculations 
C       if IDECID = 0. 
C     WCH, 11/12/93. Fix THISO-HISTO problem for IFORM = 3 and add 
C       option for user-defined input for hours to range from 1-24 as 
C       well as 0-23. 
C     WCH, 4/22/94. Set units for depth for IFORM <= 1. 
C     WCH, 4/25/94. Add to logic for recovery of 15-min. data. 
C     WCH, 4/26/94. Provide input for optional treatment of accumulated 
C       rainfall (NCDC code = A). 
C     WCH, 4/26/94. Correct minor error for print of inches missing 
C       data. 
C     WCH, 4/26/94. Print indication of special rainfall codes in event 
C       summary. 
C     WCH, 5/25/94. Reset MFLAG parameter at end of each day during 
C       event definition calcs.  Also fix KUNIT definition. 
C     WCH, 10/15/94. Fix check for old HIST = new THISTO.  Prevented 
C       use of multiple gages except for IFORM >= 9. 
C     WCH, 2/27/95.  Typo in Format 1026. 
C     WCH, 8/1/95.  Allow alphanumeric station IDs for AES precipitation 
C       files (IFORM = 5 or 13).  Change involves converting integer 
C       station IDs to character after input for other data.  This 
C       change affects the Runoff and Statistics Blocks that read 
C       the rainfall interface file.  Also, 
C       read AES ID from AES data as A7 instead of I8 (Sub. GTRAIN). 
C     WCH, 7/23/96.  Change heading for interevent time hours.  Open 
C       NSCRAT1 as unformatted file if DOS name entered on @-line, 
C       thus avoiding query of user for IFILE=1.  Add header for this 
C       ASCII file. 
C     WCH, 7/25/96.  Allow over-writing of existing rainfall interface 
C       file. 
C     WCH (Bruce LaZerte), 10/2/96.  Correct formats 2023, 2024. 
C     WCH, 12/3/96.  Initialize some variables that change during run 
C       in statements, not DATA statements. 
C	WCH, 11/22/99.  Allow 4-digit years in Canadian AES format.  
C       (IFORM = 14) and 15-min.data (IFORM = 15). 
C     WCH, 11/23/99.  Add some routine totals for each year. 
C     WCH, 3/27/00.  Format change for 4-digit year in ASCII stats file. 
C     WCH, 3/27/00.  Delete line near line 816, in by mistake. 
C     WCH, 2/9/01.  Initialize KSUM, TSUM, and SUM.  Suggested by  
C       Nerkez Gavranovic, Sydney, Australia 
C     WCH, 8/27/03. Error message about NUVAL. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'PRECIP.INC' 
C======================================================================= 
      INTEGER JK5(2),JSUM(2),IPRN(5,5),Y1(2),M1(2),D1(2),KSUM(2) 
      INTEGER KEY(LSTORM,3),JK1(3),JK2(3),DURAT,MIT,DURLS,JK4(2),COND 
CWCH, 11/23/99  
      INTEGER MORAIN(12),MDRAIN(12),MHRAIN(12) 
C#### WCH, 8/1/95. 
C####      INTEGER DRY,WET,PRCON,STORM,MSTRM,DSTRM,YSTRM,HSTRM,JSTA(10) 
      INTEGER DRY,WET,PRCON,STORM,MSTRM,DSTRM,YSTRM,HSTRM 
C 
CIM INCREASE HYETOGRAPHS   ~~~~~~~~~~~~~~~~~~~ 
      REAL INTEN,STAT(5,8),TSUM(2),XOUT(500),WANE(MAXRG),WAX(MAXRG) 
cim      REAL INTEN,STAT(5,8),TSUM(2),XOUT(500),WANE(10),WAX(10) 
cim  ~~~~~~~~~~~~~~~~~~ 
cim  rainfall totals 
      REAL SUMRAIN(MAXRG) 
      CHARACTER  TITL(6)*10,NABRK(4)*6,VALUE(4)*6,VALMM(4)*6 
      CHARACTER*128 NEWFIL 
C#### WCH, 4/26/94. 
      CHARACTER* 1 BLANK 
C#### WCH, 8/1/95.  CHANGE STATION NAMES TO CHARACTER INTERNALLY. 
CIM INCREASE HYETOGRAPHS  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
      CHARACTER*8 JSTA(MAXRG) 
cim      CHARACTER*8 JSTA(10) 
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
C======================================================================= 
      DATA BLANK/' '/ 
      DATA JK1/1,3,0/,JK2/1,1,0/,JK4/1,0/,JK5/2,0/,DRY/2/ 
      DATA WET/1/ 
      DATA VALUE/' Hours',' in/hr','Inches',' Hours'/ 
      DATA VALMM/' Hours',' mm/hr','Millim',' Hours'/ 
      DATA NABRK/'Month ','Year  ','Storm ','Avg yr'/ 
      DATA TITL/'Duration  ','Intensity ','Volume    ', 
     1          'Delta     ','Years     ','Months    '/ 
C####      DATA JSUM/0,0/,XINT/0/,MHDATA/0/,MSDATA/0/,DURLS/0/ 
C####      DATA COND/2/,NDRY/0/,NDRHR/0/,VOLUM/0/,DURAT/0/,STORM/0/ 
C####      DATA NOYRS/0/,LOC11/0/ 
C======================================================================= 
C#### WCH, 12/3/96.  INITIALIZE MOST VARIABLES HERE, NOT IN DATA STMTS. 
C======================================================================= 
      JK4(1)  = 1 
      JK4(2)  = 0 
      JSUM(1) = 0 
      JSUM(2) = 0 
Cwch, 2/9/01.  Add KSUM, TSUM and SUM 
      KSUM(1) = 0 
	KSUM(2) = 0 
	TSUM(1) = 0.0 
	TSUM(2) = 0.0 
	SUM(1)  = 0.0 
	SUM(2)  = 0.0 
      XINT    = 0. 
      MHDATA  = 0 
      MSDATA  = 0 
      DURLS   = 0 
      COND    = 2 
      NDRY    = 0 
      NDRHR   = 0 
      VOLUM   = 0. 
      DURAT   = 0 
      STORM   = 0 
      NOYRS   = 0 
      LOC11   = 0 
CWCH, 11/23/99 
	MGDAY   = 0 
	MGHR    = 0 
C#### WCH, 12/3/96.  ADD INITIALIZATION OF IGO. 
      IGO     = 0 
C 
      MIT     = 1 
      KUNIT   = 0 
      METRIC  = 0 
C#### WCH, 8/1/95. 
      LENREC  = 0 
C#### WCH, 4/26/94.  INITIALIZE NEW VARIABLE ACODE. 
      DO 5 I = 1,366 
      DO 5 J = 1,4 
    5 ACODE(I,J) = BLANK 
      INCNT  = INCNT + 1 
      IOUTCT = IOUTCT + 1 
      IO     = JIN(INCNT) 
      JO     = JOUT(IOUTCT) 
      ITEMP  = NSCRAT(2) 
C#### WCH, 8/93. 
      HIST   = 0.0 
CCC      THISTO = 60.0 
C======================================================================= 
C     Open Rainfall file(s). 
C======================================================================= 
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR. 
     +      FFNAME(INCNT).EQ.'JIN.UF')) 
     +      OPEN(JIN(INCNT),FORM='FORMATTED',STATUS='SCRATCH') 
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND. 
     +      FFNAME(INCNT).NE.'JIN.UF') 
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='FORMATTED', 
     +      STATUS='UNKNOWN') 
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR. 
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF')) 
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND. 
     +      FFNAME(25+IOUTCT).NE.'JIN.UF') 
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
C#### WCH, 7/23/96.  ALLOW USER TO ENTER NSCRAT1 FILE NAME WITH @-LINE. 
      IF(JKP(51).EQ.1.AND.NSCRAT(1).GT.0.AND.FFNAME(51).NE.' ') 
     +OPEN(NSCRAT(1),FILE=FFNAME(51),FORM='FORMATTED',STATUS='UNKNOWN') 
C 
      IF(JKP(52).NE.2.AND.NSCRAT(2).GT.0.AND.FFNAME(52).NE.'SCRT2.UF') O 
     +PEN(NSCRAT(2),FILE=FFNAME(52),FORM='UNFORMATTED',STATUS='UNKNOWN') 
      IF(JKP(52).NE.2.AND.NSCRAT(2).GT.0.AND.FFNAME(52).EQ.'SCRT2.UF') 
     +             OPEN(NSCRAT(2),FORM='UNFORMATTED',STATUS='SCRATCH') 
      REWIND IO 
C======================================================================= 
C#### WCH, 8/1/95.  CHECK TO BE SURE INPUT FILE CONTAINS SOME DATA. 
C     STRANGE ERRORS INVOLVING SYSTEM HANG-UPS MAY RESULT OTHERWISE. 
C 
C     CAUTION TO PROGRAMMERS.  OPTION "FLEN=" MAY BE SPECIFIC TO LAHEY 
C     FORTRAN. 
C======================================================================= 
c     INQUIRE (UNIT=IO,FLEN=LENREC) 
c     IF(LENREC.LE.0) THEN 
c          WRITE (N6,965) IO 
c          WRITE (*,965) IO 
c          STOP 
c          ENDIF 
C======================================================================= 
      WRITE(N6,1000) 
      WRITE(*,1000) 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP A1 <<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,TITLE(1) 
      READ(N5,*,ERR=888) CC,TITLE(2) 
      WRITE(N6,68)          TITLE(1),TITLE(2) 
C####################################################################### 
C#### WCH, 4/26/94. 
C     INSERT OPTIONAL DATA GROUP B0 FOR NEW PARAMETER KODEA. 
C     KODEA   = 0, DON'T INCLUDE NCDC CUMULATIVE VALUES IN RAINFALL 
C                  TIME SERIES.  HISTORICAL SWMM METHOD (DEFAULT). 
C             = 1, AVERAGE CUMULATIVE VALUES (NCDC CODE = "A") OVER 
C                  PRECEDING TIME PERIOD. 
C             = 2, TREAT CUMULATIVE VALUE AS INSTANTANEOUS VALUE AT 
C                  INDICATED TIME. 
C     OPTIONS 1,2 ONLY FOR IFORM = 0,1,4,6, >=9. 
C     KODEPRT = 0, DON'T PRINT INDICATION OF SPECIAL CODES FOR ALL 
C                  DATES, ONLY FOR DATES OF EVENTS (DEFAULT). 
C             = 1, PRINT INDICATOR IN EVENT SUMMARY FOR ANY DATE ON 
C                  WHICH SPECIAL CODES ARE PRESENT. 
C#### WCH, 7/25/96.  ALLOW OVERWRITING OF EXISTING INTERFACE FILE. 
C     KOVER   = 0, ADD NEW RAINGAGE DATA TO EXISTING INTERFACE FILE. 
C              =1, OVERWRITE EXISTING RAINFALL INTERFACE FILE, CREATING 
C                  FILE CONTAINING ONLY THE DATA FOR CURRENT GAGE. 
C======================================================================= 
      KOVER  = 0 
      KODEA  = 0 
      KODEPR = 0 
C======================================================================= 
C >>>>>>>>>>>>> READ OPTIONAL DATA GROUP B0 <<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      BACKSPACE N5 
C#### WCH, 7/25/96.  ADD KOVER 
      IF(CC.EQ.'B0') READ(N5,*,ERR=888) CC,KODEA,KODEPR,KOVER 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP B1 <<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
C#### WCH, 8/1/95. 
C     READ ALPHANUMERIC ISTA IF IFORM = 5 OR .GE.13. 
C     READ INTEGER IISTA OTHERWISE, AND CONVERT TO CHARACTER ISTA. 
C     AFFECTS APPROXIMATELY NEXT 20 LINES. 
C======================================================================= 
Cwch, 7/28/04 
      IFORM1 = 0 
      READ(N5,*,ERR=888) CC,IFORM 
      IF(CC.NE.'B1') THEN 
           CC = 'B1' 
           GO TO 888 
           ELSE 
           BACKSPACE N5 
           ENDIF 
CWCH, 11/22/99. MAKE .LT.13 
      IF(IFORM.NE.5.AND.IFORM.LT.13) READ(N5,*,ERR=888) CC,IFORM, 
     1     IISTA,IDECID,JYBEG,JYEND,IYEAR,ISUM 
Cwch, 7/28/04. Add option for unformatted read for IFORM=1 
      IF(IFORM.EQ.-1) THEN 
	     IFORM1 = 1 
	     IFORM  = 1 
	     ENDIF 
CWCH, 11/22/99. MAKE .GE.13 
      IF(IFORM.EQ.5.OR.IFORM.GE.13)  READ(N5,*,ERR=888) CC,IFORM, 
     1     ISTA,IDECID,JYBEG,JYEND,IYEAR,ISUM 
      IF(IDECID.GT.0) THEN 
                      BACKSPACE N5 
CWCH, 11/22/99. MAKE .LT.13 
                      IF(IFORM.NE.5.AND.IFORM.LT.13) 
     +                   READ(N5,*,ERR=888) CC,IFORM,IISTA,IDECID,JYBEG, 
     +                      JYEND,IYEAR,ISUM,MIT,NPTS,IFILE,A,NOSTAT 
Cwch, 7/28/04. Add option for unformatted read for IFORM=1 
                      IF(IFORM.EQ.-1) THEN 
	                     IFORM1 = 1 
	                     IFORM  = 1 
	                     ENDIF 
CWCH, 11/22/99. MAKE .GE.13 
                      IF(IFORM.EQ.5.OR.IFORM.GE.13) 
     +                   READ(N5,*,ERR=888) CC,IFORM,ISTA,IDECID,JYBEG, 
     +                      JYEND,IYEAR,ISUM,MIT,NPTS,IFILE,A,NOSTAT 
                      ENDIF 
      IF(IDECID.EQ.2) THEN 
                      JO   = 0 
                      NSTA = 1 
                      ENDIF 
      IYBEG(1) = JYBEG/10000 
      IF((JYBEG.NE.0).AND.(IYBEG(1).LT.100)) THEN 
		JYBEG = JYBEG - IYBEG(1)*10000 
		IYBEG(1) = IYBEG(1)+1900 
		JYBEG = JYBEG + IYBEG(1)*10000 
		ENDIF 
      IYBEG(2) = (JYBEG - IYBEG(1)*10000)/100 
      IYEND(1) = JYEND/10000 
      IF((JYEND.NE.0).AND.(IYEND(1).LT.100)) THEN 
		JYEND = JYEND - IYEND(1)*10000 
		IYEND(1) = IYEND(1)+1900 
		JYEND = JYEND + IYEND(1)*10000 
		ENDIF 
      IYEND(2) = (JYEND - IYEND(1)*10000)/100 
      IYEND(3) = JYEND - IYEND(1)*10000 - IYEND(2)*100 
      IYBEG(3) = JYBEG - IYBEG(1)*10000 - IYBEG(2)*100 
      IF(IYBEG(2).EQ.0) IYBEG(2) =  1 
      IF(IYBEG(3).EQ.0) IYBEG(3) =  1 
      IF(IYEND(2).EQ.0) IYEND(2) = 12 
      IF(IYEND(3).EQ.0) IYEND(3) = 31 
C======================================================================= 
C#### WCH, 8/1/95.  CONVERT INTEGER IISTA TO CHARACTER ISTA. 
C     AMAZING (TO WCH) CONVERSION METHOD IS WRITE TO "INTERNAL FILES". 
C     SEE LAHEY LANGUAGE REFERENCE, SECTION 9.2.1 
CWCH, 11/22/99. MAKE .LT.13 
C======================================================================= 
      IF(IFORM.NE.5.AND.IFORM.LT.13) WRITE(ISTA,'(I8)') IISTA 
C======================================================================= 
C#### WCH, 8/1/95.  REMEMBER, FROM HERE ON, ISTA AND JSTA() ARE 
C     CHARACTER VARIABLES. 
C======================================================================= 
      IF(IDECID.GT.0) WRITE(N6,1021) ISTA,IYBEG,IYEND,MIT,NPTS,IFORM, 
     +                ISUM,IYEAR,IFILE,IDECID,A,NOSTAT 
      IF(IDECID.EQ.0) WRITE(N6,1022) ISTA,IYBEG,IYEND,IFORM, 
     +                                    ISUM,IYEAR,IDECID 
C#### WCH, 4/26/94. 
      WRITE(N6,1025) KODEA 
      WRITE(N6,1026) KODEPR 
C#### WCH, 7/25/96. 
      WRITE(N6,1028) KOVER 
C#### WCH, 8/1/95 AND 11/22/99. ADD NOTE FOR IFORM.GE.13. 
      IF(IFORM.GE.13) WRITE(N6,1027) 
C======================================================================= 
C     READ THE NUMBER OF STATIONS ON JO FILE 
C          IF THE FILE IS EMPTY STATEMENT 123 WILL BE CALLED 
C======================================================================= 
      IF(IDECID.LE.1) THEN 
                      IF(JO.EQ.0) CALL ERROR(111) 
                      MSTA   = 0 
                      READ(JO,END=123,ERR=123) NSTA,MRAIN, 
     +                                         (JSTA(I),I=1,NSTA) 
C####################################################################### 
C#### WCH, 7/25/96.  ALLOW USER TO OVERWRITE EXISTING FILE WITH NEW 
C     GAGE DATA. 
C####################################################################### 
                      IF(KOVER.EQ.1) THEN 
                           WRITE (N6,2121) JO,NSTA 
                           GOTO 123 
                           ENDIF 
                      MSTA   = NSTA 
CIM INCREASE HYETOGRAPHS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                      IF(NSTA.EQ.MAXRG) CALL ERROR(113) 
                      DO J = 1, MAXRG 
                      SUMRAIN(J) = 0.0 
                      ENDDO 
cim                      IF(NSTA.EQ.10) CALL ERROR(113) 
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
                                      NSTA =  NSTA + 1 
                      WRITE(N6,2115)  NSTA 
C####################################################################### 
C  WCH, 3/3/93  WRITE CAUTION MESSAGE WHEN NSTA > 1 
C####################################################################### 
                      IF(NSTA.GT.1) WRITE(N6,2116) JO, JO 
                      IF(NSTA.GT.1) WRITE(*,2116)  JO, JO 
                      JSTA(NSTA)  =   ISTA 
                      MRAIN       =   1000000 
                      WRITE(N6,2120) (I,JSTA(I),I=1,NSTA) 
C======================================================================= 
C                     Read and save JO on NSCRAT(2) scratch file. 
C======================================================================= 
                      IF(ITEMP.EQ.0) CALL ERROR(114) 
                      REWIND ITEMP 
                      DO 2110 I = 1,1000000 
                      READ(JO,END=2112) JULDAY,RHOUR, 
     +                                  THISTO,(WANE(J),J=1,MSTA) 
C#### WCH, 8/93. CHECK FOR COMPATIBILITY OF TIME INTERVALS. 
C#### WCH, 10/25/94.  DO THIS ONLY FOR IFORM >= 9.  CHECK OCCURS 
C     LATER FOR IFORM = 3 AND IN SUB. GTRAIN FOR OTHER IFORM VALUES. 
C####                      IF(I.EQ.1) THEN 
C 
C#### WCH, 8/1/95. SKIP THIS CHECK FOR IFORM=13 OR 14. 
CWCH, 11/22/99. ADD NEW IFORM=14 AND 15.   
                      IF(IFORM.EQ.13.OR.IFORM.EQ.14) GO TO 2108 
C 
                      IF(I.EQ.1.AND.IFORM.GE.9) THEN 
                    IF(IFORM.EQ.9.OR.IFORM.EQ.11.OR.IFORM.EQ.15) THEN 
                            IF(ABS(THISTO-900.).LT.1.1) GO TO 2108 
                            HIST = 900.0 
                            GO TO 2106 
                            ENDIF 
                         IF(IFORM.EQ.10.OR.IFORM.EQ.12) THEN 
                            IF(ABS(THISTO-3600.).GT.1.1) GO TO 2108 
                            HIST = 3600.0 
                            ENDIF 
 2106                    WRITE(N6,9110) HIST,THISTO 
                         WRITE(*,9110)  HIST,THISTO 
                         STOP 
                         ENDIF 
 2108                 WRITE(ITEMP)      JULDAY,RHOUR, 
     +                                  THISTO,(WANE(J),J=1,MSTA) 
 2110                 CONTINUE 
 2112                 CONTINUE 
                      REWIND JO 
                      REWIND ITEMP 
                      MRAIN = 1000000 
                      WRITE(JO) NSTA,MRAIN,(JSTA(I),I=1,NSTA) 
C#### WCH, 8/93. 
                      HIST = THISTO 
                      GO TO 124 
C======================================================================= 
C      Here, if single rain gage. 
C======================================================================= 
  123                                NSTA = 1 
                      WRITE(N6,2115) NSTA 
                      WRITE(N6,2120) NSTA,ISTA 
                      JSTA(1) = ISTA 
                      REWIND JO 
                      MRAIN = 1000000 
                      WRITE (JO) NSTA,MRAIN,(JSTA(I),I=1,NSTA) 
  124                 CONTINUE 
                      ENDIF 
C======================================================================= 
C     Check file existence of NSCRAT(1). 
C======================================================================= 
      IF(IFILE.EQ.1) THEN 
                     NOUT  = NSCRAT(1) 
                     CALL CKFILE(NOUT) 
                     ENDIF 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP B2 <<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(IFORM.EQ.3) THEN 
                     READ(N5,*,ERR=888) CC,THISTO,METRIC,KUNIT,FIRMAT, 
     +                         CONV,F1,F2,F3,F4,F5,F6,F7 
C#### WCH, 11/12/93 
                     IF(CONV.LT.0.0) THEN 
                          IHH = 1 
                          CONV = -CONV 
                          ELSE 
                          IHH = 0 
                          ENDIF 
                     WRITE(N6,1030) FIRMAT,METRIC,KUNIT,CONV, 
     +                              THISTO,F1,F2,F3,F4,F5,F6,F7 
C#### WCH, 11/12/93 
                     IF(IHH.EQ.0) WRITE (N6,1035) 
                     IF(IHH.EQ.1) WRITE (N6,1036) 
                     THISTO = THISTO*60.0 
C#### WCH, 8/93 
                     IF(HIST.GT.0.0.AND.ABS(HIST-THISTO).GT.0.1) THEN 
                        WRITE(N6,9110) THISTO,HIST 
                        WRITE(*,9110)  THISTO,HIST 
                        STOP 
                        ENDIF 
C#### WCH, 11/12/93 
                     HIST = THISTO 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP B3 <<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
                     READ(N5,*,ERR=888) CC 
                     BACKSPACE N5 
                     NUVAL = 1 
                     IF(CC.EQ.'B3') READ(N5,*,ERR=888) CC,NUVAL 
Cwch, 8/27/03. 
Cwch, 728/04. Move to within IF.  
	               IF(NUVAL.LE.0) THEN 
	                     WRITE (N6,9130) NUVAL 
	                     WRITE  (*,9130) NUVAL 
	                     ENDIF 
                     ENDIF 
C======================================================================= 
C#### WCH, 8/1/95.  ADD IFORM=13. 
CWCH, 11/22/99. ADD IFORM=14 AND 15.  CHANGE TO .GE.13 
      IF(IFORM.EQ.5.OR.IFORM.GE.13) METRIC = 1 
                                    METRIC = METRIC + 1 
C#### WCH, 8/93. 
CCC      THISTO = THISTO * 60.0 
      NEND = 24 
      IF(CONV.EQ.0.0)   CONV = 1.0 
      XCONV  = CONV 
C#### WCH, 4/22/94.  SET UNITS FOR DEPTH FOR IFORM <= 1. 
C#### WCH, 5/25/94.  ALSO FOR IFORM = 4 OR 6. 
      IF(IFORM.LE.1.OR.IFORM.EQ.4.OR.IFORM.EQ.6) KUNIT = 1 
C####################################################################### 
C     WCH, 8/93.  Add option for recent (1993) EarthInfo ASCII hourly 
C       and 15-min precipitation files. 
C     Values of IFORM: 
C                Unprocessed  Processed 
C     15-min.        9            11 
C     Hourly        10            12 
C####################################################################### 
C#### WCH, 8/1/95.  ADD CHECK FOR IFORM = 13. 
      IF(IFORM.GE.9.AND.IFORM.LT.13) THEN 
         IF(IFORM.EQ.9.OR.IFORM.EQ.10) THEN 
            M3 = NSCRAT(3) 
            IF(M3.EQ.0) CALL ERROR(104) 
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).NE.'SCRT3.UF') 
     +      OPEN(M3,FILE=FFNAME(53),FORM='FORMATTED',STATUS='UNKNOWN') 
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).EQ.'SCRT3.UF') 
     +      OPEN(M3,FORM='FORMATTED',STATUS='SCRATCH') 
            ENDIF 
         IF(IFORM.EQ.9.OR.IFORM.EQ.11) THEN 
            M4 = NSCRAT(4) 
            IF(M4.EQ.0) CALL ERROR(155) 
            OPEN(M4,FORM='UNFORMATTED',STATUS='SCRATCH') 
            NEND = 96 
            ENDIF 
         CALL G9RAIN(0,IGO,ILOST,M3,M4) 
         KUNIT = 1 
         ENDIF 
C======================================================================= 
      IF(IFORM.EQ.3) CALL G3RAIN(0,IGO,ILOST) 
      IF(IFORM.LT.9.AND.IFORM.NE.3) CALL GTRAIN(0,IGO,ILOST,M4) 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. ADD IFORM=14 AND 15.  CHANGE TO .GE.13. 
      IF(IFORM.GE.13) CALL GTRAIN(0,IGO,ILOST,M4) 
C####################################################################### 
C     WCH, 8/93.  FOR 15-MIN. DATA, NEED TO USE NSCRAT(4) FOR TEMPORARY 
C       STORAGE OF ONE YEAR'S DATA. 
C======================================================================= 
C#### WCH, 8/1/95 
CWCH, 11/22/99. ADD IFORM = 14 AND 15.  CHANGE TO .GE.13 
      IF((IFORM.LT.9.OR.IFORM.GE.13).AND.ABS(HIST-900.0).LT.0.1) THEN 
            M4 = NSCRAT(4) 
            IF(M4.EQ.0) CALL ERROR(155) 
            OPEN(M4,FORM='UNFORMATTED',STATUS='SCRATCH') 
            NEND = 96 
            ENDIF 
      THISTO = HIST 
      IF(NEND.EQ.96) WRITE(N6,2027) 
C======================================================================= 
C     END OF YEAR OR END OF FILE-COMPUTE SYNOPTIC DATA 
C     FIND NUMBER OF DAYS IN THIS YEAR 
C     SAVE LAST STORM NUMBER AND PRESENT FILE NUMBER 
C======================================================================= 
C      write to 6 to get carriage control 
    7 WRITE(6,911) NEWYR 
      CONV  = XCONV 
      IF(IFORM.NE.3.AND.IFORM.LT.9) CALL GTRAIN(1,IGO,ILOST,M4) 
      IF(IFORM.EQ.3) CALL G3RAIN(1,IGO,ILOST) 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. CHANGE TO .GE.13 
      IF(IFORM.GE.13) CALL GTRAIN(1,IGO,ILOST,M4) 
      IF(IFORM.GE.9.AND.IFORM.LT.13) CALL G9RAIN(1,IGO,ILOST,M3,M4) 
C 
      IF(ILOST.EQ.0) GO TO 7 
C#### WCH, 8/93 
      IF(NEND.EQ.96) REWIND M4 
      NDAYR = KDATE(0,1,NEWYR+1)-KDATE(0,1,NEWYR) 
      MFLAG = 0 
      NOLDS = STORM 
      NDRSA = NDRY 
      NOYRS = NOYRS + 1 
                                     CONV = 0.01 
      IF(IFORM.EQ.3.AND.METRIC.EQ.1) CONV = 0.001 
      IF(IFORM.EQ.3.AND.METRIC.EQ.2) CONV = 0.01 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. TWO NEW AES OPTIONS.  MAKE .GE.13 
      IF(IFORM.EQ.5.OR.IFORM.GE.13)  CONV = 0.1 
C======================================================================= 
C     Write interface file for NWS precipitation data. 
C     Must use this IF-loop for 15-min. data, except for user-defined. 
C======================================================================= 
C#### WCH, 8/1/95.  ADD CHECK FOR IFORM=13. 
CWCH, 11/22/99. INCLUDE AES 15-MIN DATA HERE, IFORM=15. 
      IF(IFORM.LT.3.OR.IFORM.EQ.4.OR.(IFORM.GE.6.AND.IFORM.LT.13) 
     1.OR.IFORM.EQ.15) THEN 
           IREAD   = 0 
           DO 70 J = 1,NDAYR 
           JULDAY  = NEWYR*1000 + J 
C####################################################################### 
C     WCH, 8/93.  SEVERAL CHANGES FOR 15-MIN RAINFALL 
C####################################################################### 
           M4READ  = 0 
           DO 71 K = 1,NEND 
           KK = K 
           IF(NEND.EQ.96) KK = (K-1)/4 + 1 
           IF(HOUR(J,KK).LE.0) GO TO 71 
           IF(NEND.EQ.24) THEN 
              REIN  = FLOAT(HOUR(J,KK))*CONV 
              RHOUR = FLOAT(KK-1)*3600.0 
              WANE(NSTA) = REIN 
              ELSE 
C======================================================================= 
C     Here, for 15-min. data, compute hour and time and read yearly 
C       data from file M4. 
C======================================================================= 
              RHOUR = FLOAT(K-1)*THISTO 
              REIN       = 0.0 
              WANE(NSTA) = 0.0 
              IF(M4READ.EQ.0) THEN 
 3900              READ(M4,END=3940,ERR=950,IOSTAT=IOS) 
     1                         JLDAY,SHOUR,THIST,REIN 
C#### WCH, 4/25/94.  SPEED UP 15-MIN RAINFALL RECOVERY? 
                   IF(JLDAY.EQ.JULDAY.AND.ABS(RHOUR-SHOUR).LT.0.1) 
     1                                               GO TO 3910 
                   IF(JLDAY.LT.JULDAY) GO TO 3900 
                   IF(JLDAY.EQ.JULDAY.AND.(RHOUR-SHOUR).GT.0.1) 
     1                                               GO TO 3900 
                   IF(JLDAY.GT.JULDAY.OR.(JLDAY.EQ.JULDAY.AND. 
     1                    (SHOUR-RHOUR).GT.0.1)) THEN 
                      REIN = 0.0 
                      BACKSPACE M4 
                      ENDIF 
C#### WCH, 4/25/94.  ADD STATMENT 3910. 
 3910              WANE(NSTA) = REIN 
                   ELSE 
                   GO TO 3950 
                   ENDIF 
              ENDIF 
           GO TO 3950 
C======================================================================= 
C     If reach end of file on M4, set M4READ=1, don't read any more and 
C       end this year's rain data at end of day. 
C======================================================================= 
 3940      M4READ = 1 
C======================================================================= 
 3950      IF(JO.GT.0)    THEN 
              IF(MSTA.GT.0)  THEN 
 4000            IF(IREAD.EQ.0) READ(ITEMP,END=4010) JDAY,QHOUR, 
     +                                    THIS,(WAX(I),I=1,MSTA) 
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.EQ.RHOUR) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = REIN 
                    WRITE(JO)  JULDAY,RHOUR,THISTO,(WAX(I),I=1,NSTA) 
                    GO TO 71 
                    ENDIF 
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.LT.RHOUR) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = 0.0 
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA) 
                    GO TO 4000 
                    ENDIF 
                 IF(JDAY.GE.JULDAY) THEN 
                    IREAD     = 1 
                    DO 4020 I = 1,MSTA 
 4020               WANE(I)   = 0.0 
                    WRITE(JO) JULDAY,RHOUR,THISTO,(WANE(I),I=1,NSTA) 
                    GO TO 71 
                    ENDIF 
                 IF(JDAY.LE.JULDAY) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = 0.0 
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA) 
                    GO TO 4000 
                    ENDIF 
 4010            JDAY  = 9999999 
                 QHOUR = 0.0 
                 IREAD = 1 
                 GO TO 4000 
C======================================================================= 
C     Here, just one precip. station (MSTA = 0). 
C======================================================================= 
                 ELSE 
                 WRITE(JO) JULDAY,RHOUR,THISTO,REIN 
                 ENDIF 
C======================================================================= 
C     ENDIF for JO > 0 
C======================================================================= 
              ENDIF 
   71      CONTINUE 
           IF(M4READ.EQ.1) GO TO 701 
   70      CONTINUE 
  701      CONTINUE 
           ENDIF 
C======================================================================= 
C     User defined rainfall. 
C======================================================================= 
      IF(IFORM.EQ.3) THEN 
           IREAD   = 0 
c     write(*,*) NSTORM 
c     read(*,*) junk 
           DO 80 J = 1,NSTORM 
           JULDAY  = NEWYR*1000 + RDAY(J) 
           REIN    = FLOAT(RRAIN(J))*CONV 
           IF(KUNIT.EQ.1)  REIN = REIN*3600.0/THISTO 
           RHOUR                = RTIME(J)*3600.0 
           WANE(NSTA)           = REIN 
           sumrain(nsta) = sumrain(nsta) + rein*THISTO/3600.0 
           IF (RDAY(J).LT.999990) THEN 
           LDAY1 = JULDAY 
           HLAST1 = RHOUR 
           ENDIF 
C======================================================================= 
C    NOTE, PRECIP. ON INTERFACE FILE IS VALUE OF REIN. 
C    PRECIP. USED FOR STATISTICS IS VALUE OF HOUR(). 
C======================================================================= 
           IF(JO.GT.0)    THEN 
              IF(MSTA.GT.0)  THEN 
 5000            IF(IREAD.EQ.0) THEN 
                     READ(ITEMP,END=5010) JDAY,QHOUR, 
     +                                     THIS,(WAX(I),I=1,MSTA) 
                     LDAY2 = JDAY 
                     HLAST2 = QHOUR 
                 ENDIF 
c          write(*,*) j,nstorm 
c          write(*,*) jday,qhour,this,thisto,'-' 
c          write(*,*) julday,rhour 
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.EQ.RHOUR) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = REIN 
                    WRITE(JO)  JULDAY,RHOUR,THISTO,(WAX(I),I=1,NSTA) 
                     do i = 1, msta 
                     sumrain(i) = sumrain(i) + wax(i)*THISTO/3600.0 
                     enddo 
                    GO TO 80 
                    ENDIF 
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.LT.RHOUR) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = 0.0 
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA) 
                    GO TO 5000 
                    ENDIF 
                 IF(JDAY.GE.JULDAY) THEN 
                    IREAD     = 1 
                    DO 5020 I = 1,MSTA 
 5020               WANE(I)   = 0.0 
                    IF (RDAY(J).LT.999990) 
     +              WRITE(JO) JULDAY,RHOUR,THISTO,(WANE(I),I=1,NSTA) 
                    GO TO 80 
                    ENDIF 
                 IF(JDAY.LT.JULDAY) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = 0.0 
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA) 
                    GO TO 5000 
                    ENDIF 
 5010            JDAY  = 9999999 
                 QHOUR = 0.0 
                 IREAD = 1 
                 GO TO 5000 
                 ELSE 
                    IF (RDAY(J).LT.999990) 
     1            WRITE(JO) JULDAY,RHOUR,THISTO,REIN 
                 ENDIF 
              ENDIF 
   80      CONTINUE 
           ENDIF 
C write last day and total rain for IFORM=3 only 
	IF(IFORM.EQ.3) THEN 
           WRITE(N6,8000) LDAY1,HLAST1/60.0/60.0 
           IF (MSTA.GT.0) WRITE(N6,8010) LDAY2,HLAST2/60.0/60.0 
           WRITE(N6,8020) 
           DO I =1, NSTA 
           WRITE(N6,8030) I,SUMRAIN(I) 
           SUMRAIN(I) = 0.0 
           ENDDO 
	ENDIF 
C======================================================================= 
C     AES Canadian rainfall. 
C======================================================================= 
C#### WCH, 8/1/95 
CWCH, 11/22/99. ADD AES 4-DIGIT YEAR, HOURLY OPTION, IFORM=14. 
      IF(IFORM.EQ.5.OR.IFORM.EQ.13.OR.IFORM.EQ.14) THEN 
           IREAD   = 0 
           DO 85 J = 1,NDAYR 
           JULDAY  = NEWYR*1000 + J 
           DO 86 K = 1,24 
           IF(HOUR(J,K).LE.0) GO TO 86 
           REIN  = FLOAT(HOUR(J,K))*CONV 
           KK    = K - 1 
           RHOUR = FLOAT(KK)*3600.0 
           WANE(NSTA)           = REIN 
C======================================================================= 
           IF(JO.GT.0)    THEN 
              IF(MSTA.GT.0)  THEN 
 6000            IF(IREAD.EQ.0) READ(ITEMP,END=6010) JDAY,QHOUR, 
     +                                  THIS,(WAX(I),I=1,MSTA) 
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.EQ.RHOUR) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = REIN 
                    WRITE(JO)  JULDAY,RHOUR,THISTO,(WAX(I),I=1,NSTA) 
                    GO TO 86 
                    ENDIF 
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.LT.RHOUR) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = 0.0 
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA) 
                    GO TO 6000 
                    ENDIF 
                 IF(JDAY.GE.JULDAY) THEN 
                    IREAD     = 1 
                    DO 6020 I = 1,MSTA 
 6020               WANE(I)   = 0.0 
                    WRITE(JO) JULDAY,RHOUR,THISTO,(WANE(I),I=1,NSTA) 
                    GO TO 86 
                    ENDIF 
                 IF(JDAY.LT.JULDAY) THEN 
                    IREAD     = 0 
                    WAX(NSTA) = 0.0 
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA) 
                    GO TO 6000 
                    ENDIF 
 6010            JDAY  = 9999999 
                 QHOUR = 0.0 
                 IREAD = 1 
                 GO TO 6000 
                 ELSE 
                 WRITE(JO) JULDAY,RHOUR,THISTO,REIN 
                 ENDIF 
              ENDIF 
86         CONTINUE 
85         CONTINUE 
           ENDIF 
C======================================================================= 
C======================================================================= 
C     Write yearly summary. 
C======================================================================= 
C======================================================================= 
      IF(IYEAR.EQ.1) THEN 
                     IF(IFORM.EQ.3) THEN 
                                    WRITE(N6,975) TITLE(1),TITLE(2) 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. MAKE .GE.13 
                                    ELSE IF(IFORM.EQ.5.OR.IFORM.GE.13) 
     +                                  THEN 
                                        WRITE(N6,971) TITLE(1),TITLE(2) 
                                    ELSE 
                                    WRITE(N6,970) TITLE(1),TITLE(2) 
                                    ENDIF 
                     KW = 0 
                     II = 0 
CWCH, 11/23/99. Add monthly and annual totals and hours with precip.  
				   DO 811 L = 1,12 
				   MORAIN(L) = 0 
	               MDRAIN(L) = 0 
  811                MHRAIN(L) = 0 
C	Find value of current year. 
				   DO 813 L = 1,366 
				   IF(HOUR(L,27).GT.0) THEN 
						IYR = HOUR(L,27) 
	                    GOTO 814 
					    ENDIF 
  813				   CONTINUE 
  814                DO 81  J = 1,NDAYR 
	               JULDAY = 1000*IYR + J 
	               CALL DATED 
				   NNNDAY = 0 
                     DO 82  K = 1,24 
                     IF(HOUR(J,K).LE.0) GO TO 82 
				   MORAIN(MONTH) = MORAIN(MONTH) + HOUR(J,K) 
	               MHRAIN(MONTH) = MHRAIN(MONTH) + 1 
				   IF(NNNDAY.EQ.0) THEN 
						MDRAIN(MONTH) = MDRAIN(MONTH) + 1 
						NNNDAY = 1 
						ENDIF 
                     KW = KW + 1 
                     II = II + 1 
                     IPRN(KW,1) = HOUR(J,25) 
                     IPRN(KW,2) = HOUR(J,26) 
                     IPRN(KW,3) = HOUR(J,27) 
                     IPRN(KW,4) = K - 1 
                     IPRN(KW,5) = HOUR(J,K) 
                     IF(MOD(II,220).EQ.0) THEN 
                        IF(IFORM.EQ.3) WRITE(N6,975) TITLE(1),TITLE(2) 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. MAKE .GE.13 
                        IF(IFORM.EQ.5.OR.IFORM.GE.13) WRITE(N6,971) 
     +                                            TITLE(1),TITLE(2) 
CWCH, 11/22/99. MAKE .LT.13 
                        IF(IFORM.NE.3.AND.IFORM.NE.5.AND.IFORM.LT.13) 
     +                              WRITE(N6,970) TITLE(1),TITLE(2) 
                        ENDIF 
                     IF(MOD(KW,4).EQ.0) THEN 
                            WRITE(N6,980) ((IPRN(KK,JJ),JJ=1,5),KK=1,4) 
                            KW = 0 
                            ENDIF 
82                   CONTINUE 
81                   CONTINUE 
                     IF(KW.GT.0) WRITE(N6,980) 
     +                          ((IPRN(KK,JJ),JJ=1,5),KK=1,KW) 
Cwch  delete.  Here by mistake.        ANNTOT = NHRAIN*CONV 
	               WRITE(N6,985) IYR 
				   IF(METRIC.EQ.1) WRITE(N6,986)  
	               IF(METRIC.EQ.2) WRITE(N6,987)  
				   ANTOT = 0 
	               MMDAY = 0 
	               MMHR  = 0 
				   DO 816 L = 1,12 
				   MMDAY = MMDAY + MDRAIN(L) 
				   MMHR  = MMHR  + MHRAIN(L) 
				   IF(MORAIN(L).GT.0) THEN 
					   TOTRAIN = FLOAT(MORAIN(L))*CONV 
	                   ANTOT   = ANTOT + TOTRAIN 
					   WRITE(N6,988) L,TOTRAIN,MDRAIN(L),MHRAIN(L) 
	                   ENDIF 
  816				   CONTINUE 
                     WRITE(N6,989) ANTOT,MMDAY,MMHR 
	               MGDAY = MGDAY + MMDAY 
	               MGHR  = MGHR  + MMHR 
                     ENDIF 
C####################################################################### 
C     WCH, 9/7/93. 
C     Skip synoptic analysis if IDECID = 0. 
C======================================================================= 
      IF(IDECID.EQ.0) THEN 
           NEWYR = NEWYR + 1 
           GO TO 115 
           ENDIF 
C======================================================================= 
C     End of year printouts. 
C======================================================================= 
      IF(ISUM.EQ.1.AND.METRIC.EQ.1) WRITE(N6,2030) TITLE(1),TITLE(2) 
      IF(ISUM.EQ.1.AND.METRIC.EQ.2) WRITE(N6,2035) TITLE(1),TITLE(2) 
C======================================================================= 
C     PRESENT CONDITION IS DETERMINED IF ANY PRECIPITATION IS 
C     RECORDED FOR THIS HOUR 
C     PREVIOUS CONDITION AND PRESENT CONDITION DETERMINE CURRENT STATUS 
C     PRCON  AND  COND  CAN BE EITHER 1 OR 2.  THUS  NEXT 
C     WHICH DEFINES THE CURRENT STATUS CAN BE EITHER 1,2,3, OR 4 
C     AS INDICATED IN THE FOLLOWING TABLE 
C 
C                          PREVIOUS CONDITION 
C                             WET       DRY 
C                          (COND=1)  (COND=2) 
C     PRESENT       WET 
C     CONDITION  (PRCON=1)     1         3 
C 
C                   DRY        2         4 
C                (PRCON=2) 
C 
C     IN CODE, DRY = 2, WET = 1 (INTEGER VARIABLES). 
C======================================================================= 
C     NOTE, ALL STATISTICAL AND SUMMARY CALCULATIONS ARE DONE USING 
C       HOURLY DATA.  WHEN RAW DATA ARE AT 15-MIN. INTERVALS, HOURLY 
C       VALUES REPRESENT THE SUM FOR THE HOUR. 
C======================================================================= 
      II       = 0 
      TIMDAY   = 0.0 
      DO 100 J = 1,NDAYR 
      JULDAY   = NEWYR*1000 + J 
      CALL DATED 
C#### WCH, 4/26/94.  JXP = INDICATOR VARIABLE FOR PRINT-OUTS. 
      JXP = 0 
      DO 90  K = 1,24 
      IF(MFLAG.GE.1)     GO TO 46 
      IF(HOUR(J,K).GE.0) GO TO 48 
      IF(IFORM.EQ.2) THEN 
                     IF(HOUR(J,K).EQ.-1) MHDATA = MHDATA + 1 
                     IF(HOUR(J,K).EQ.-2) MSDATA = MSDATA + 1 
                     GO TO 90 
                     ENDIF 
C#### WCH, 8/1/95. 
CWCH, 11/22/99. ALLOW IFORM=14 AND 15. CHANGE TO .GE.13 
      IF(IFORM.EQ.5.OR.IFORM.GE.13) THEN 
                     IF(HOUR(J,K).EQ.-1) MHDATA = MHDATA + 1 
                     IF(HOUR(J,K).EQ.-2) MSDATA = MSDATA + 1 
                     GO TO 90 
                     ENDIF 
C#### WCH, 4/25/94.  CAN HAVE -1 AND -2 FLAGS FOR IFORM = 1 ALSO. 
C     CHANGE IF-STMT TO ALLOW CHECK FOR THESE CASES ALSO. 
C####  46  IF(IFORM.EQ.0.OR.IFORM.EQ.4.OR.IFORM.GE.6) THEN 
  46  IF(IFORM.LE.1.OR.IFORM.EQ.4.OR.IFORM.GE.6) THEN 
                     IF(MFLAG.EQ.0) THEN 
                         IF(HOUR(J,K).EQ.-1) THEN 
                                             MHDATA = MHDATA + 1 
                                             ELSE 
                                             MSDATA = MSDATA + 1 
                                             ENDIF 
                         ENDIF 
                     IF(MSDATA.GT.0) MSDATA = MSDATA + 1 
                     IF(MHDATA.GT.0) MHDATA = MHDATA + 1 
                     MFLAG = MFLAG +1 
                     IF(HOUR(J,K).LE.-1.AND.MFLAG.GT.1) MFLAG = 0 
                     GO TO 90 
                     ENDIF 
  48                       PRCON = 2 
      IF(HOUR(J,K) .GT. 0) PRCON = 1 
      NEXT = (COND-1)*2+PRCON 
C======================================================================= 
C     Continue storm (NEXT=1) 
C======================================================================= 
      IF(NEXT.EQ.1) THEN 
                    DURAT = DURAT + 1 + NDRHR 
                    NDRHR = 0 
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.0) VOLUM = 
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV*THISTO/3600.0 
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.1) VOLUM = 
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV 
                    IF(HOUR(J,K).GT.XINT) XINT = HOUR(J,K) 
                    ENDIF 
C======================================================================= 
C     DRY PERIOD (NEXT=2)-CHECK IF NOL OF CONSECUTIVE DRY HOURS 
C     IS SUFFICIENT TO BE CONSIDERED AS END OF STORM 
C======================================================================= 
      IF(NEXT.EQ.2) THEN 
                    NDRHR = NDRHR + 1 
                    IF(NDRHR.LT.MIT) GO TO 90 
                    STORM = STORM+1 
                    IF(STORM.EQ.1) DURLS = DURAT 
                    DELTA = 0.5*(DURAT+DURLS)+FLOAT(NDRY) 
C======================================================================= 
C                   CHECK IF DELTA IS TO BE IGNORED 
C======================================================================= 
                    IF(STORM.EQ.1)                 GO TO 61 
                    IF(MHDATA.GT.0.OR.MSDATA.GT.0) GO TO 61 
                    GO TO 62 
   61               DELTA = 0.0 
                    DH0   = 1.0E10 
   62               CONTINUE 
                    INTEN = VOLUM/FLOAT(DURAT) 
                    LOC11 = LOC11 + 1 
                    IF(LOC11.GT.LSTORM) THEN 
                                        WRITE(N6,9101) LSTORM 
                                        GO TO 101 
                                        ENDIF 
                    KEY(LOC11,1) = MSTRM 
                    KEY(LOC11,2) = YSTRM 
                    KEY(LOC11,3) = LOC11 
                    X1(LOC11,1)  = DURAT 
                    X1(LOC11,2)  = INTEN 
                    X1(LOC11,3)  = FLOAT(JDAY) 
                    X2(LOC11,1)  = VOLUM 
                    X2(LOC11,2)  = DELTA 
                    X2(LOC11,3)  = FLOAT(JDAY) 
                    XDUR         = DURAT 
                    DH0          = DH0+DELTA-0.5*DURAT 
                    ZINT         = XINT*CONV 
C======================================================================= 
C                   Create an ASCII interface file with storm data. 
C======================================================================= 
                    IF(IFILE.EQ.1) THEN 
C#### WCH, 7/23/96.  ADD HEADER TO ASCII FILE. 
                        IF(STORM.EQ.1) THEN 
                             IF(METRIC.EQ.1) WRITE(NOUT,2023) MIT 
                             IF(METRIC.EQ.2) WRITE(NOUT,2024) MIT 
                             ENDIF 
                        DH1 = DH0 
                        IF(DH0.GE.1E06) DH1 = 0.0 
                        WRITE(NOUT,2025) ISTA,STORM,MSTRM,DSTRM,YSTRM, 
     *                  HSTRM,XDUR,VOLUM,INTEN,ZINT,DH1,MHDATA,MSDATA 
                        ENDIF 
C======================================================================= 
C#### WCH, 4/26/94.  HERE, INCLUDE PRINT OF SPECIAL CODE INDICATOR 
                    IXY = JDATE(DSTRM,MSTRM,YSTRM) 
                    IF(ISUM.EQ.1)  THEN 
                       JXP = 1 
                       IF(DH0.LT.1E06) THEN 
                          WRITE(N6,2020) STORM,MSTRM,DSTRM,YSTRM,HSTRM, 
     * XDUR,VOLUM,INTEN,ZINT,DH0,MHDATA,MSDATA,(ACODE(IXY,JXY),JXY=1,4) 
                          ELSE 
                          WRITE(N6,2021) STORM,MSTRM,DSTRM,YSTRM,HSTRM, 
     * XDUR,VOLUM,INTEN,ZINT,MHDATA,MSDATA,(ACODE(IXY,JXY),JXY=1,4) 
                          ENDIF 
                       II = II + 1 
                       IF(MOD(II,50).EQ.0) THEN 
                        IF(METRIC.EQ.1) WRITE(N6,2030) TITLE(1),TITLE(2) 
                        IF(METRIC.EQ.2) WRITE(N6,2035) TITLE(1),TITLE(2) 
                        ENDIF 
                       ENDIF 
C======================================================================= 
                    JSUM(1) = JSUM(1) + MHDATA 
                    JSUM(2) = JSUM(2) + MSDATA 
                    SUM(2)  = SUM(2)  + VOLUM 
                    XINT    = 0.0 
                    MHDATA  = 0 
                    MSDATA  = 0 
                    DH0     = -0.5*DURAT 
                    NDRY    = NDRHR 
                    NDRHR   = 0 
                    COND    = DRY 
                    DURLS   = DURAT 
                    ENDIF 
C======================================================================= 
C     Beginning of storm  (NEXT=3) 
C======================================================================= 
      IF(NEXT.EQ.3) THEN 
                    MSTRM = HOUR(J,25) 
                    DSTRM = HOUR(J,26) 
                    YSTRM = HOUR(J,27) 
                    JDAY  = JULDAY 
                    HSTRM = K - 1 
                    DURAT = 1 
                    VOLUM = 0.0 
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.0) VOLUM = 
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV*THISTO/3600.0 
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.1) VOLUM = 
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV 
                    IF(HOUR(J,K).GT.XINT) XINT = HOUR(J,K) 
                    NDRHR = 0 
                    COND  = WET 
                    ENDIF 
C======================================================================= 
C     Continuation of dry weather (NEXT=4). 
C======================================================================= 
      IF(NEXT.EQ.4) NDRY = NDRY+1 
   90 CONTINUE 
C####################################################################### 
C#### WCH, 4/26/94.  PRINT SPECIAL CODES INDICATOR IF DESIRED. 
C======================================================================= 
      IF(NEXT.NE.2.AND.KODEPR.EQ.1.AND.JXP.EQ.0) THEN 
          IF(ACODE(J,1).NE.BLANK) 
     1       WRITE(N6,2022) MONTH,NDAY,NEWYR,(ACODE(J,JXY),JXY=1,4) 
          JXP = 0 
          ENDIF 
C#### WCH, 5/25/94.  RESET MFLAG AT END OF EACH DAY TO AVOID CARRY-OVER. 
      MFLAG = 0 
  100 CONTINUE 
C======================================================================= 
C     Update for next year. 
C     Revert to saved storm and record number if less than 2 storms. 
C======================================================================= 
      NEWYR = NEWYR+1 
      IF(STORM-NOLDS.LT.2) THEN 
                           NDRY  = NDRSA 
                           STORM = NOLDS 
                           ENDIF 
      RE = FLOAT(JSUM(1))/(FLOAT(NDAYR)*24.0)*SUM(2) 
C#### WCH, 4/26/94.  DIVIDE SUM(1) BY 100 TO GET INCHES. 
      IF(ISUM.EQ.1.AND.METRIC.EQ.1) WRITE(N6,990) SUM(2),JSUM(1), 
     1   JSUM(2),RE,SUM(1)/100. 
      IF(ISUM.EQ.1.AND.METRIC.EQ.2) WRITE(N6,990) SUM(2),JSUM(1), 
     1   JSUM(2),RE,SUM(1) 
      DO 110  K = 1,2 
      TSUM(K)   = SUM(K)  + TSUM(K) 
      KSUM(K)   = JSUM(K) + KSUM(K) 
      JSUM(K)   = 0 
  110 SUM(K)    = 0 
C======================================================================= 
C     Continue reading/or/start writing. 
C======================================================================= 
C#### WCH, 9/7/93 
  115 IF(IYEND(1).GT.0.0.AND.NEWYR.GT.IYEND(1)) GO TO 49 
      IF(IGO.EQ.0) GO TO 7 
C======================================================================= 
C     If IFORM = 4 or IFORM = 6 a new file may be opened. 
C======================================================================= 
   49 CONTINUE 
      IF(IFORM.EQ.4.OR.IFORM.EQ.6) THEN 
                    READ(N5,*,ERR=888) CC 
                    IF(CC.EQ.'@') THEN 
                                  BACKSPACE N5 
                                  READ(N5,*,ERR=888) CC,IO,NEWFIL 
                                  IGO = 0 
                                  CLOSE(IO) 
                                  OPEN(IO,FILE=NEWFIL,FORM='FORMATTED', 
     +                                                STATUS='UNKNOWN') 
                                  REWIND IO 
C#### WCH, 8/93 
                                  CALL GTRAIN(0,IGO,ILOST,M4) 
                                  IF(IGO.EQ.0) GO TO 7 
                                  ELSE 
C#### WCH, 8/93 
                                  WRITE (N6,9120) 
                                  WRITE (*,9120) 
                                  BACKSPACE N5 
                                  ENDIF 
                     ENDIF 
C####################################################################### 
C     WCH, 9/7/03. 
C     End of Rain Block if IDECID = 0. 
C======================================================================= 
      IF(IDECID.EQ.0) GO TO 600 
C======================================================================= 
C     Write rainfall summary. 
CWCH, 11/23/99. Add total wet days and hours. 
C======================================================================= 
      WRITE(N6,2065) 
      IF(METRIC.EQ.1) WRITE(N6,995) ISTA,MGDAY,MGHR,KSUM(1), 
     1     KSUM(2),TSUM(2),NOYRS 
      IF(METRIC.EQ.2) WRITE(N6,996) ISTA,MGDAY,MGHR,KSUM(1), 
     1     KSUM(2),TSUM(2),NOYRS 
C======================================================================= 
C     End of storm event calculations.  Start printing statistics. 
C======================================================================= 
  101 CONTINUE 
      IF(NOSTAT.GT.0) THEN 
      DO 400 ICOL = 4,1,-1 
      IF(ICOL.LE.2) WRITE(N6,2065) 
      IF (ICOL .EQ. 1) CALL SHELL(KEY,LOC11,LSTORM,3,JK1,JK2) 
      IF(NOSTAT.GT.0) WRITE(N6,2070) NABRK(ICOL) 
      IF(ICOL.LE.2) KEYV = KEY(1,ICOL) 
      IF(ICOL.EQ.1) KEYX = KEY(1,2) 
      IF(ICOL.EQ.2) KEYX = KEY(1,1) 
      IC       = 0 
      DO 300 J = 1,LOC11 
      IF(J.EQ.1)     GO TO 260 
      IF(J.EQ.LOC11) GO TO 240 
C======================================================================= 
C     THERE IS NO KEY CHANGE IN PASSES 3 AND 4. 
C     CHECK FOR CHANGE IN KEY 
C======================================================================= 
      IF (ICOL .GT. 2) GO TO 280 
      IF (KEY(J,ICOL) .EQ. KEYV) GO TO 280 
  240 IC = IC+1 
      IF(ICOL.EQ.1.AND.NOYRS.EQ.1) STAT(5,1) = STAT(5,1) + 1.0 
      DO 250 I = 1,5 
      IF(ICOL.EQ.4) STAT(I,1) = FLOAT(NOYRS) 
      IF(STAT(I,1).LE.0.0) STAT(I,1) = 1.0 
                    STAT(I,5) = STAT(I,2)/STAT(I,1) 
      IF(STAT(I,1).GT.1.0) THEN 
                  STAT(I,6) = SQRT(ABS((STAT(I,6)- 
     *            STAT(I,2)**2/STAT(I,1))/(STAT(I,1)-1.0))) 
                  STAT(I,6) = STAT(I,6)/STAT(I,5) 
                  ELSE 
                  STAT(I,6) = 1.0E20 
                  ENDIF 
  250 CONTINUE 
      IF(ICOL.LE.2) WRITE(N6,2130) KEYV 
      IF(ICOL.NE.3) JJ = 5 
      IF(ICOL.EQ.3) JJ = 4 
      IF(ICOL.EQ.1) JJ = 4 
      DO 255 I = 1,JJ 
      II       = I 
      IF(ICOL.EQ.2.AND.II.EQ.JJ) II = 6 
      IF(STAT(I,6).LT.1.0E05) THEN 
                   WRITE(N6,2080) TITL(II),(STAT(I,M),M=1,6) 
                   ELSE 
                   WRITE(N6,2081) TITL(II),(STAT(I,M),M=1,5) 
                   ENDIF 
  255 CONTINUE 
      IF(ICOL.LE.2) KEYV = KEY(J,ICOL) 
      IF(J.EQ.LOC11) GO TO 300 
  260 DO 270 I  = 1,5 
      STAT(I,1) = 0.0 
      STAT(I,2) = 0.0 
      STAT(I,3) =  1.0E20 
      STAT(I,4) = -1.0E20 
  270 STAT(I,6) = 0.0 
      DATAX     = 0.0 
C======================================================================= 
C     THE THIRD COLUMN OF ARRAY KEY STORES THE ORIGINAL 
C     SEQUENCE NUMBER OF THE STORM INFORMATION BEFORE 
C     THE SWITCH AROUND IN SHELL SORT. 
C======================================================================= 
C     STAT(I,1) = NUMBER 
C     STAT(I,2) = TOTAL 
C     STAT(I,3) = MINIMUM 
C     STAT(I,4) = MAXIMUM 
C     STAT(I,5) = AVERAGE 
C     STAT(I,6) = VARIANCE 
C======================================================================= 
  280 DO 290 I = 1,5 
      JJ       = KEY(J,3) 
      IF(I.LE.2) DATA = X1(JJ,I) 
      IF(I.EQ.3) DATA = X2(JJ,1) 
      IF(I.EQ.4) DATA = X2(JJ,2) 
      IF(I.EQ.5) DATA = X2(JJ,1) 
      IF(DATA.EQ.0.0) GO TO 290 
      STAT(I,2) = STAT(I,2) + DATA 
      STAT(I,6) = STAT(I,6) + DATA*DATA 
      IF(I.NE.5) THEN 
                 STAT(I,1) = STAT(I,1)+1.0 
                 IF(DATA.LT.STAT(I,3)) STAT(I,3) = DATA 
                 IF(DATA.GT.STAT(I,4)) STAT(I,4) = DATA 
                 GO TO 290 
                 ENDIF 
      IF(ICOL.EQ.1.AND.KEY(J,2).EQ.KEYX) GO TO 290 
      IF(ICOL.EQ.2.AND.KEY(J,1).EQ.KEYX) GO TO 290 
      STAT(I,1) = STAT(I,1) + 1.0 
C======================================================================= 
C     Break in year occured or break in month occured. 
C======================================================================= 
      IF(ICOL.EQ.1) KEYX = KEY(J,2) 
      IF(ICOL.EQ.2) KEYX = KEY(J,1) 
      IF(STAT(5,2)-DATAX.LE.0.0) GO TO 290 
      IF(STAT(5,2)-DATAX.LT.STAT(5,3)) STAT(5,3) = STAT(5,2)-DATAX 
      IF(STAT(5,2)-DATAX.GT.STAT(5,4)) STAT(5,4) = STAT(5,2)-DATAX 
      STAT(5,6) = STAT(5,6) + ( STAT(5,2)-DATAX)**2 
      DATAX     = STAT(5,2) 
  290 CONTINUE 
  300 CONTINUE 
  400 CONTINUE 
      ENDIF 
C======================================================================= 
C     Compute and print recurrance interval. 
C     JK - Shell sort key. 
C======================================================================= 
      IF(NOSTAT.GT.0) THEN 
                      DO 500 IVAR = 1,4 
                      IF(IVAR.EQ.1) THEN 
                                    MYTEST = NOSTAT/1000 
                                    NOSTAT = NOSTAT - MYTEST*1000 
                                    IF(MYTEST.EQ.0) GO TO 500 
                                    ENDIF 
                      IF(IVAR.EQ.2) THEN 
                                    MYTEST = NOSTAT/100 
                                    NOSTAT = NOSTAT - MYTEST*100 
                                    IF(MYTEST.EQ.0) GO TO 500 
                                    ENDIF 
                      IF(IVAR.EQ.3) THEN 
                                    MYTEST = NOSTAT/10 
                                    NOSTAT = NOSTAT - MYTEST*10 
                                    IF(MYTEST.EQ.0) GO TO 500 
                                    ENDIF 
                      IF(IVAR.EQ.4.AND.NOSTAT.EQ.0) GO TO 500 
                      IF(IVAR.LE.2) JK4(1) = IVAR 
                      IF(IVAR.GT.2) JK4(1) = IVAR - 2 
                      IF(IVAR.LE.2)CALL SHELR(X1,LOC11,LSTORM,3, 
     +                                        JK4,JK5) 
                      IF(IVAR.GT.2)CALL SHELR(X2,LOC11,LSTORM,3, 
     +                                       JK4,JK5) 
                      IF(NPTS.EQ.0)     NPTS = LOC11 
                      IF(NPTS.GT.LOC11) NPTS = LOC11 
                      IF(NPTS.GT.500)   NPTS = 500 
                      DO 440 I= 1,NPTS 
  440                 XOUT(I) = (FLOAT(NOYRS)+1.0-2.0*A)/(FLOAT(I)-A) 
                      IF(METRIC.EQ.1) WRITE(N6,2170) TITL(IVAR), 
     +                                   VALUE(IVAR),VALUE(IVAR) 
                      IF(METRIC.EQ.2) WRITE(N6,2170) TITL(IVAR), 
     +                                   VALMM(IVAR),VALMM(IVAR) 
                      MPTS     = NPTS/2 
                      TIMDAY   = 0.0 
                      DO 450 I = 1,MPTS 
                      I2       = I + MPTS 
                      IF(IVAR.LE.2) JULDAY   = IFIX(X1(I,3)) 
                      IF(IVAR.GT.2) JULDAY   = IFIX(X2(I,3)) 
                      CALL DATED 
                      M1(1)    = MONTH 
                      D1(1)    = NDAY 
                      Y1(1)    = NYEAR 
                      IF(IVAR.LE.2) JULDAY   = IFIX(X1(I2,3)) 
                      IF(IVAR.GT.2) JULDAY   = IFIX(X2(I2,3)) 
                      CALL DATED 
                      M1(2)    = MONTH 
                      D1(2)    = NDAY 
                      Y1(2)    = NYEAR 
                      IV       = IVAR - 2 
                      IF(IVAR.GT.2) WRITE(N6,2150) I,X2(I,IV),XOUT(I), 
     +                             M1(1),D1(1),Y1(1),I2,X2(I2,IV), 
     +                             XOUT(I2),M1(2),D1(2),Y1(2) 
  450                 IF(IVAR.LE.2) WRITE(N6,2150) I,X1(I,IVAR),XOUT(I), 
     +                             M1(1),D1(1),Y1(1),I2,X1(I2,IVAR), 
     +                             XOUT(I2),M1(2),D1(2),Y1(2) 
  500                 CONTINUE 
                      ENDIF 
C#### WCH, 9/7/93. 
  600 WRITE(*,1010) 
      WRITE(N6,1010) 
      CLOSE (JIN(INCNT)) 
      RETURN 
C======================================================================= 
  888 CALL IERROR 
C####################################################################### 
C     WCH, 10/11/93.  ADDITIONAL ERROR MESSAGE FOR READING SCRATCH 
C       FILE M4 WITH 15-MIN. DATA. 
C======================================================================= 
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY. 
  950 WRITE(N6,9500) M4,JULDAY,JLDAY,SHOUR,THIST,REIN,MOD(IOS,256) 
      WRITE(*,9501) M4,MOD(IOS,256) 
      STOP 
C======================================================================= 
   68 FORMAT(/,10X,A80,/,10X,A80) 
  911 FORMAT('+ Reading rainfall from year : ',I4) 
C#### WCH, 8/1/95.  FILE ERROR MESSAGE. 
  965 FORMAT(' ==> ERROR  JIN DATA INPUT FILE ON UNIT',I3,' IS EMPTY.' 
     1,/,' BE SURE YOU HAVE UNIT PROPERLY DEFINED ON @-LINE.',/, 
     2   ' RUN STOPPED AT BEGINNING OF RAIN BLOCK.') 
  970 FORMAT(//,10X, 
     +' ******************************************',/,10X, 
     +' * Rainfall from Nat. Weather Serv. file  *',/,10X, 
     +' * in units of hundredths of an inch      *',/,10X, 
     +' ******************************************',//, 
     * 10X,A80,/,10X,A80,//,1X,4(2X,'Mo/Dy/Year Hr/ Rn'),/, 
     *                 1X,4(2X,'---------- ------')) 
CWCH, 11/22/99. Minor alteration to title.  
  971 FORMAT(//,10X, 
     +' ********************************************',/,10X, 
     +' * Rainfall from Canadian Met. Centre file, *',/,10X, 
     +' * in units of tenths of a millimeter       *',/,10X, 
     +' ********************************************',//, 
     * 10X,A80,/,10X,A80,//,1X,4(2X,'Mo/Dy/Year Hr/ Rn'),/, 
     *                 1X,4(2X,'---------- ------')) 
  975 FORMAT(//,10X, 
     +' ########################################################',/,10X, 
     +' # Rainfall from user time series in units of           #',/,10X, 
     +' # thousandths of an inch or hundredths of a millimeter #',/,10X, 
     +' # (as defined by the user with parameter METRIC)       #',/,10X, 
     +' ########################################################',//, 
     *10X,A80,/,10X,A80,//,1X,4(2X,'Mo/Dy/Year Hr/ Rn'),/, 
     *                1X,4(2X,'---------- ------')) 
  980 FORMAT(' ',4(1X,2(I2,'/'),I4,I3,'/',I4)) 
CWCH, 11/23/99. Two new formats for annual rain prints. 
  985 FORMAT(/,' **********************************************',/, 
     1         ' * Annual Precipitation Summary for Year',I5,' *',/, 
	2         ' **********************************************',//, 
     3         '   Month  Total    Total Wet  Total Wet',/, 
     4         '          Precip.  Days       Hours') 
  986 FORMAT(  '         (inches)') 
  987 FORMAT(  '          (mm)') 
  988 FORMAT(I7,F8.2,I7,I11) 
  989 FORMAT(  ' --------------------------------------',/, 
     1         ' Annual:',F7.2,I7,I11) 
CWCH, 11/22/99.  Add to 990 Format.  
  990 FORMAT(' Total*',18X,F8.2,20X,I6,I8,/, 
     *' Estimated missing rainfall              ',12X,F6.2,F8.2,/, 
     *' *Note, annual total is incorrect for years with events that', 
     *' span the Dec-Jan boundary.') 
C#### WCH, 8/1/95.  995 AND 996: CHANGE ISTA FORMAT TO A8 FROM I8. 
  995 FORMAT(/, 
     *'      ########################################',/, 
     *'      #   Grand Total Precipitation Summary  #',/, 
     *'      ########################################',//, 
     *'      Precip. summary for station     ',A8,/, 
     *'      Total days with precip.         ',I8,'  days',/, 
     *'      Total hours with precip.        ',I8,'  hours',/, 
     *'      Total missing hours             ',2X,I6,'  hours',/, 
     *'      Total hours of meter malfunction',2X,I6,'  hours',/, 
     *'      Total precipitation             ',F8.2,'  inches',/, 
     *'      Total number of years           ',2X,I6,'  years',/) 
  996 FORMAT(/, 
     *'      ****************************************',/, 
     *'      *   Grand Total Precipitation Summary  *',/, 
     *'      ****************************************',//, 
     *'      Precip. summary for station     ',A8,/, 
     *'      Total days with precip.         ',I8,'  days',/, 
     *'      Total hours with precip.        ',I8,'  hours',/, 
     *'      Total missing hours             ',2X,I6,'  hours',/, 
     *'      Total hours of meter malfunction',2X,I6,'  hours',/, 
     *'      Total precipitation            ',F9.2,'  millimeters',/, 
     *'      Total number of years           ',2X,I6,'  years',/) 
 1000 FORMAT(/,' ***************************************************',/, 
     1        ' * Entry made to the Rain Block                    *',/, 
     2        ' * Created by the University of Florida - 1988     *',/, 
     3        ' * Updated by Oregon State University, March 2000  *',/, 
     4        ' ***************************************************',//) 
 1010 FORMAT(/,' ===> Rain Block ended normally.') 
C#### WCH, 8/1/95.  CHANGE ISTA TO CHARACTER. 
 1021 FORMAT(1X,//, 
     1'      ########################################',/, 
     1'      #  Precipitation Block Input Commands  #',/, 
     1'      ########################################',//, 
     1 5X,'Station, ISTA.........................',A10,//, 
     2 5X,'Beginning date, IYBEG (Yr/Mo/Dy)......', 
     2     2X,I4,'/',I2,'/',I2,//, 
     3 5X,'Ending date, IYEND (Yr/Mo/Dy).........', 
     3     2X,I4,'/',I2,'/',I2,//, 
     4 5X,'Minimum interevent time, MIT..........',I6,//, 
     6 5X,'Number of ranked storms, NPTS.........',I6,//, 
     6 5X,'NWS format, IFORM (See text)..........',I6,//, 
     6 5X,'Print storm summary, ISUM (O-No 1-Yes)',I6,//, 
     6 5X,'Print all rainfall, IYEAR (O-No 1-Yes)',I6,//, 
     6 5X,'Save storm event data on NSCRAT(1)....',I6,/, 
     7 5X,'(IFILE =0 -Do not save, =1 -Save data)',//, 
     8 5X,'IDECID 0 - Create interface file',/, 
     9 5X,'       1 - Create file and analyze',/, 
     1 5X,'       2 - Synoptic analysis..........',I6,//, 
     1 5X,'Plotting position parameter, A........',F6.2,//, 
     1 5X,'Storm event statistics, NOSTAT........',I6,//) 
 1022 FORMAT(1X,//, 
     1'      ########################################',/, 
     1'      #  Precipitation Block Input Commands  #',/, 
     1'      ########################################',//, 
     1 5X,'Station, ISTA.........................',A10,/, 
     2 5X,'Beginning date, IYBEG (Yr/Mo/Dy)......', 
     2     2X,I4,'/',I2,'/',I2,//, 
     3 5X,'Ending date, IYEND (Yr/Mo/Dy).........', 
     3     2X,I4,'/',I2,'/',I2,//, 
     6 5X,'NWS format, IFORM (see text)..........',I6,/, 
     6 5X,'Print storm summary, ISUM (O-NO 1-YES)',I6,/, 
     6 5X,'Print all rainfall, IYEAR (O-NO 1-YES)',I6,/, 
     8 5X,'IDECID 0 - Create interface file',/, 
     9 5X,'       1 - Create file and analyze',/, 
     1 5X,'       2 - Synoptic analysis..........',I6) 
C#### WCH, 4/26/94. 
 1025 FORMAT(/, 
     1 5X,'KODEA (from optional group B0)........',I6,/, 
     2 5X,' = 0, Do not include NCDC cumulative values.',/, 
     3 5X,' = 1, Average NCDC cumulative values.',/, 
     4 5X,' = 2, Use NCDC cumulative value as inst. rain.') 
C#### WCH, 2/27/95.  Typo: accumulated, not accumuated 
 1026 FORMAT(/, 
     1 5X,'KODEPR (from optional group B0).......',I6,/, 
     2 5X,' Print NCDC special codes in event summary:',/, 
     3 5X,' = 0, only on days with events.',/, 
     4 5X,' = 1, on all days with codes present.',/, 
     5 5X,' Codes: A = accumulated value, I = incomplete value,',/, 
     6 5X,'        M = missing value,     O = other code present') 
C#### WCH, 8/1/95.  ADDITIONAL INFO FOR IFORM.GE.13. 
 1027 FORMAT( 
     1 5X,' For current Canadian AES data, I = unadjusted') 
C#### WCH, 7/25/96. 
 1028 FORMAT(/, 
     1 5X,'KOVER (from optional group B0)........',I6,/, 
     2 5X,' = 0, Do not over-write existing rainfall interface file.',/, 
     3 5X,' = 1, Over-write existing file with single new gage data.') 
 1030 FORMAT(1X,//,5X, 
     +' #############################',/,5X, 
     +' # User defined input format #',/,5X, 
     +' #############################',//, 
     + 5X,' User format (FIRMAT)..................',A60,/, 
     + 5X,' I/O units (METRIC) 0 = U.S. customary.',/, 
     + 5X,'                    1 = Metric units...',I6,/, 
     + 5X,' Units of rainfall (KUNIT).............',I6,/, 
     + 5X,' 0 -> Intensity; 1 --> Volume..........',/, 
     + 5X,' Conversion factor (CONV)..............',F6.2,/, 
     + 5X,' Rainfall interval in minutes (THISTO).',F6.2,/, 
     + 5X,' Field position for STATION NUMBER, F1.',I6,/, 
     + 5X,' Field position for YEAR,    F2........',I6,/, 
     + 5X,' Field position for MONTH,   F3........',I6,/, 
     + 5X,' Field position for DAY,     F4........',I6,/, 
     + 5X,' Field position for HOUR,    F5........',I6,/, 
     + 5X,' Field position for MINUTE,  F6........',I6,/, 
     + 5X,' Field position for RAINFALL,F7........',I6) 
C#### WCH, 11/12/93 
 1035 FORMAT (5X,' Hour values to be in range 0 - 23 (CONV > 0)',/) 
 1036 FORMAT (5X,' Hour values to be in range 1 - 24 (CONV < 0)',/) 
C#### WCH, 4/26/94.  FORMATS 2020,2021,2022,2025 
 2020 FORMAT(I5,1X,2(I2,'/'),I4,I3,F7.0,3(1X,F6.2),1X,F6.0,I5,I8, 
     1 5X,4A1) 
 2021 FORMAT(I5,1X,2(I2,'/'),I4,I3,F7.0,3(1X,F6.2),1X, 
     +      ' Undef',I5,I8,5X,4A1) 
 2022 FORMAT(4X,2(I2,'/'),I4,58X,4A1) 
C#### WCH, 7/23/96.  ADD HEADER FOR ASCII FILE WITH EVENT DATA. 
C#### WCH (B. LAZERTE), 10/2/96.  CHANGE FORMAT FOR MIT TO I7, NOT F7.2. 
 2023 FORMAT(' Min. Interevent Time =',I7,' hrs.',/, 
     1 T34,'  Dura-        Avg    Max    Inter- Hours   Hours',/, 
     1'          Event    Date    Start   tion  Volume Inten  Inten  eve 
     2nt  Missing Meter Special',/, 
     3'  Station   No. Mo Da  Yr   Hour   hours inches in/hr  in/hr  hou 
     4rs  Data    Stuck   Codes') 
 2024 FORMAT(' Min. Interevent Time =',I7,' hrs.',/, 
     1 T34,'  Dura-        Avg    Max    Inter- Hours   Hours',/, 
     1'          Event    Date    Start   tion  Volume Inten  Inten  eve 
     2nt  Missing Meter Special',/, 
     3'  Station   No. Mo Da  Yr   Hour   hours   mm   mm/hr  mm/hr  hou 
     4rs  Data    Stuck   Codes') 
C#### WCH, 8/1/95.  CHANGE 2025 FIRST FIELD TO A8 FROM I6. 
C#### WCH, 3/27/00. CHANGE YEAR TO 4-DIGIT FIELD, & FIX HEADERS ABOVE.   
 2025 FORMAT(1X,A8,1X,I5,1X,2(I2,1X),I4,I5,F7.0,3(1X,F6.2), 
     *       1X,F6.0,I7,I8,5X,4A1) 
C#### WCH, 8/93 
 2027 FORMAT(//,' $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$',/, 
     1          ' Note, 15-min. data are being processed, but hourly',/, 
     2          ' print-out, summaries, and statistics are based on ',/, 
     3          ' hourly totals only.  Data placed on interface file',/, 
     4          ' are at correct 15-min. intervals.                 ',/, 
     5          ' $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$') 
C#### WCH, 7/23/96.  CHANGE HEADING FOR INTEREVENT TIME. 
 2030 FORMAT(1H1,/, 
     +' ##########################################################',/, 
     *' #  S  T  O  R  M    E  V  E  N  T    S  U  M  M  A  R  Y #',/, 
     +' ##########################################################',//, 
     +1X,A80,/,1X,A80,//, 
     223X,'Dur-          Ave    Max  Inter- Hours   Hours'/, 
     41X, 'Storm        Start   ', 
     3    'ation Volume Inten  Inten  event  Missing Meter Special'/, 
     51X,' No    Date   Hour   hours inches in/hr  in/hr  hours  Data 
     5 Stuck   Codes',/,1X,' --    ----   ----   ----- ------ -----  --- 
     6--  -----  ----    ----- -------') 
 2035 FORMAT(1H1,/, 
     +' ##########################################################',/, 
     *' #  S  T  O  R  M    E  V  E  N  T    S  U  M  M  A  R  Y #',/, 
     +' ##########################################################',//, 
     +1X,A80,/,1X,A80,//, 
     223X,'Dur-          Ave    Max  Inter- Hours   Hours'/, 
     41X, 'Storm        Start   ', 
     3    'ation Volume Inten  Inten  event  Missing Meter Special'/, 
     51X,' No    Date   Hour   hours millim mm/hr  mm/hr  hours  Data 
     5 Stuck   Codes',/,1X,' --    ----   ----   ----- ------ -----  --- 
     6--  -----  ----    ----- -------') 
 2065 FORMAT(1H1) 
 2070 FORMAT (1X,//,5X,'Rainfall Statistics by ',A6,'(for period of', 
     .' record)'/, 
     .18X,'Number',5X,'Total',3X,'Minimum',3X,'Maximum',3X,'Average', 
     .3X,'Coef-Var',/, 
     .18X,'------',5X,'-----',3X,'-------',3X,'-------',3X,'-------', 
     .3X,'--------') 
 2080 FORMAT(8X,A10,F6.0,1X,F9.2,4(1X,F9.3)) 
 2081 FORMAT(8X,A10,F6.0,1X,F9.2,3(1X,F9.3),' Undefined') 
 2115 FORMAT(//, 
     +' ********************************************************',/, 
     +' *  Precipitation output created using the Rain block   *',/, 
     +' *  Number of precipitation stations...',I9,'        *',/, 
     +' ********************************************************',/) 
 2116 FORMAT(/,' $$$ CAUTION Multiple precip. stations based on non-emp 
     *ty file on unit ',I3,/,' If this is not correct, delete file on un 
     *it ',I3,' before Rain Block run.',/,' Otherwise may lead to incorr 
     *ect Rain Block interface file.'/) 
C#### WCH, 8/1/95.  CHANGE STATION IDs TO CHARACTER. 
 2120 FORMAT(' Location Station Number',/, 
     +       ' -------- --------------',/, 
     +       10(I9,'. ',A13,/)) 
C#### WCH, 7/25/96.  MESSAGE ABOUT OVER-WRITING JOUT. 
 2121 FORMAT(/,' $$$ CAUTION About to over-write non-empty rainfall int 
     1erface file',/, 
     2' on unit',I3,' possibly containing data from',I3,' gage(s).',/, 
     3' This is in accordance with parameter KOVER = 1.') 
 2130 FORMAT(1X,I6) 
 2150 FORMAT(' ',2(I5,2F8.3,3X,2(I2,'/'),I4,5X)) 
 2170 FORMAT(//,1H1,10X,'Return Period(years) for ',A10,///,1X, 
     .2('     ',8X,2X,'Return                  '),/,1X, 
     .2(' Rank',2X,A6,2X,'Period   Mo/Dy/Yr       '),/,1X, 
     .2(' ----',2X,'------',2X,'------   --------       ')) 
 2220 FORMAT(6X,21I5,I9,T2,I5) 
 2240 FORMAT(1X,I4,12(1X,I3)) 
 9101 FORMAT(/,' ===> Error  ',I9,/) 
cim   cim 11/97 write last days in file 
 8000 FORMAT(/,' Last day and hour for this gage          = ' 
     a,I10,F10.3) 
 8010 FORMAT(  ' Last day and hour in input transfer file = ' 
     a,I10,F10.3) 
 8020 FORMAT('    Total Rainfall For Each Gage : ') 
 8030 FORMAT(/,5X,I10,F10.3) 
C#### WCH, 8/93. 
 9110 FORMAT(/,' ===> ERROR. Time interval for new data,',F7.1,/, 
     1 ' sec. does not',/,'     agree with time interval,',F7.1, 
     2 ' sec. of data on unit JOUT with which',/, 
     3 '     new data are to be combined.  Run stopped.') 
 9120 FORMAT(/,' WARNING. Additional data are expected for IFORM = 4 or 
     16 but no @-line is',/,' found in input stream to identify data for 
     2 future years.',/,' Rain Block will stop processing data.') 
Cwch, 8/27/03 
 9130 FORMAT (/,' WARNING NUVAL (LINE B3)= ',I3,', BUT MUST BE > 0.',/, 
     1 ' PROGRAM WILL LIKELY STOP WITH ERROR.',/, 
     2 ' DO NOT SET NUVAL ACCIDENTALLY ON LINE B3.  OMIT B3 INSTEAD.') 
C#### WCH, 10/11/93. 
C#### WCH, 8/4/95.  9500 AND 9501, CHANGE RMFORT TO LAHEY. 
 9500 FORMAT(/,' ERROR READING SCRATCH FILE ON UNIT',I3,' CONTAINING',/, 
     1' YEARLY 15-MIN. PRECIP. TIME SERIES.',/,' SHOULD BE AT APPROX. JU 
     2LIAN DAY',I6,'. PARAMETERS FROM SCRATCH FILE ARE:',/, 
     3' JULIAN DAY =',I6,/,' TIME OF DAY =',F7.1,' SECONDS',/, 
     4' THISTO =',F7.1,' SECONDS',/,' PRECIP =',F7.3,' IN/HR',/, 
     5' LAHEY ERROR NO. =',I5,/,' RUN STOPPED FROM RAIN BLOCK.') 
 9501 FORMAT(' ERROR READING SCRATCH FILE ON UNIT',I3,' CONTAINING',/, 
     1' YEARLY 15-MIN. PRECIP. TIME SERIES.',/,' SEE OUTPUT FILE FOR DET 
     2AILED MESSAGE.',/, 
     3' LAHEY ERROR NO. =',I5,/,' RUN STOPPED FROM RAIN BLOCK.') 
C======================================================================= 
      END 
 
REM File: RDIIREAD.FOR 
 
      SUBROUTINE RDIIREAD(JFLAG,N) 
C     RUNOFF BLOCK 
C     CALLED BY RHYDRO1, CATCH 
C======================================================================= 
C     ROUTINE TO READ INFILTRATION/INFLOW DATA. 
C     WRITTEN BY CHUCK MOORE, CDM, 8/93 
C     EDITED FOR STYLE BY WCH, 8/93 
C     CHANGE 4 OCCURENCES OF IFLAG TO JFLAG AND ADD METRIC VARIABLE 
C       BY INCLUDING DETAIL.INC, RED, 11/29/93. 
C     CHANGE METRIC CALC.  9/8/00 CIM. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'RDII.INC' 
C#### RED, 11/29/93. 
      INCLUDE 'DETAIL.INC' 
C======================================================================= 
C  THIS IS FIRST CALL TO READ GLOBAL DATA F3 LINE 
C======================================================================= 
      IF(JFLAG.EQ.0) THEN 
           TSTEP  = 0.0 
           TSTEP2 = 0.0 
C======================================================================= 
C>>>>>>>>>>>>>>> READ F3 LINE <<<<<<<<<<<<<<< 
C======================================================================= 
           READ(N5,*,ERR=888) CC 
           BACKSPACE(N5) 
           IF(CC.EQ.'F3') THEN 
                READ(N5,*,ERR=888) CC,IIRDII,TSTEP,TSTEP2 
                IRATIOS = NINT(TSTEP/TSTEP2+0.001) 
                IF(AMOD(TSTEP,TSTEP2).NE.0.0) THEN 
                      IF(IRATIOS.LT.1) IRATIOS = 1 
                      TSTEP2 = TSTEP/FLOAT(IRATIOS) 
                      WRITE(N6,6000) TSTEP2 
                      ENDIF 
                ENDIF 
           RETURN 
           ENDIF 
C======================================================================= 
C  THIS IS SECOND CALL TO READ GLOBAL DATA 
C ====================================================================== 
      IF(JFLAG.EQ.1) THEN 
           DO 50 J=1,NTK 
           NRDHYET(J) = 0 
CIM 12 VALUES AND INTIALIZE ALL VALUES 
           DO 50 JJ = 1,12 
           DO 50 I = 1,3 
           RDIIT(J,I,JJ)=0.0 
           RDIIK(J,I,JJ)=0.0 
           DSTORE(J,I,JJ) = 0.0 
           STORAGE(J,I,JJ) = 0.0 
           DREC(J,I,JJ) = 0.0 
  50       CONTINUE 
           NRDII = 0 
C======================================================================= 
C>>>>>>>>>>>>>>> READ F4 LINE <<<<<<<<<<<<<<< 
C======================================================================= 
  100      READ(N5,*,ERR=888) CC 
           BACKSPACE(N5) 
           IF(CC.EQ.'F4') THEN 
                IF(TSTEP.EQ.0.0.OR.TSTEP2.EQ.0.0) THEN 
                     WRITE(N6,*) ' ERROR: F4 CARD FOUND BUT TSTEP', 
     +                 ' SPECIFIED ON F3 CARD EQUALS 0.0' 
                     ENDIF 
                NRDII = NRDII + 1 
                IF(NRDII.GT.NTK) THEN 
                     WRITE(N6,*) ' ERROR - ATTEMPT TO READ MORE THAN ', 
     +                  NTK,' F4 DATA LINES' 
                     STOP 
                     ENDIF 
                READ(N5,*,ERR=888) CC,NRDHYET(NRDII), 
     1            (RDIIT(NRDII,I,1),RDIIK(NRDII,I,1), 
     2            DSTORE(NRDII,I,1),STORAGE(NRDII,I,1), 
     3            DREC(NRDII,I,1),I=1,3) 
                NNTK = NRDII 
cim monthly input of values 
                IF (NRDHYET(NRDII).LT.0) THEN 
                     NRDHYET(NRDII)=-NRDHYET(NRDII) 
                     DO 101 JJ=2,12 
 101                 READ(N5,*,ERR=888) CC, 
     1                 (RDIIT(NRDII,I,JJ),RDIIK(NRDII,I,JJ), 
     2                 DSTORE(NRDII,I,JJ),STORAGE(NRDII,I,JJ), 
     3                 DREC(NRDII,I,JJ),I=1,3) 
                     ELSE 
                     DO 102 I=1,3 
                     do 102 jj=2,12 
                     RDIIT(NRDII,I,JJ) = RDIIT(NRDII,I,1) 
                     RDIIK(NRDII,I,JJ) = RDIIK(NRDII,I,1) 
                     DSTORE(NRDII,I,JJ) = DSTORE(NRDII,I,1) 
                     STORAGE(NRDII,I,JJ) = STORAGE(NRDII,I,1) 
                     DREC(NRDII,I,JJ) = DREC(NRDII,I,1) 
  102                CONTINUE 
                     ENDIF 
CIM MONTHLY 
                GO TO 100 
                ENDIF 
           RETURN 
           ENDIF 
C======================================================================= 
C  THIS IS THE THIRD CALL TO READ SUBBASIN DATA 
C======================================================================= 
      IF(JFLAG.EQ.2) THEN 
C======================================================================= 
C>>>>>>>>>>>>>>> READ H5 LINE <<<<<<<<<<<<<<< 
C======================================================================= 
           READ(N5,*,ERR=888) CC 
           BACKSPACE N5 
           IF(CC.EQ.'H5') THEN 
                READ(N5,*,ERR=888) CC,SEWAREA(N), 
     +                            (RDIIR(N,I,1),I=1,3),ICURVE(N) 
C======================================================================= 
C  CONVERT FROM METRIC, HA TO AC. 
CIM### 9/8/00  DON'T DO IT HERE.  See conversion of Qpeak in RDIIRES 
C======================================================================= 
C                IF(METRIC.EQ.2) SEWAREA(N) = SEWAREA(N)*2.471 
CIM 
                IF(SEWAREA(N).EQ.0.0) THEN 
                     ICURVE(N) = 0 
                     DO 200 I = 1,3 
  200                RDIIR(N,I,1) = 0.0 
                     ENDIF 
                IF (SEWAREA(N).LT.0.0) THEN 
                     SEWAREA(N) = -SEWAREA(N) 
                     DO 201 JJ=2,12 
  201                READ(N5,*,ERR=888) CC,(RDIIR(N,I,JJ),I=1,3) 
                     ELSE 
                     DO 202 JJ=2,12 
                     DO 202 I=1,3 
  202                RDIIR(N,I,JJ) = RDIIR(N,I,1) 
                     ENDIF 
                ENDIF 
           ENDIF 
C======================================================================= 
      RETURN 
C======================================================================= 
  888 CALL IERROR 
C======================================================================= 
 6000 FORMAT(' WARNING - INPUT TSTEP2 NOT EQUAL TO INTEGER FRACTION ', 
     1'OF RAINFALL TIME STEP AND WAS ADJUSTED TO THE NEAREST INTEGER', 
     2' FRACTION'/'  NEW TSTEP2 = ',F10.5) 
      END 
 
REM File: RDIIRES.FOR 
 
      SUBROUTINE RDIIRES 
C     RUNOFF BLOCK 
C     CALLED BY HYDRO 
C ====================================================================== 
C     COMPUTES RDII RESPONSE CURVES FROM RAINFALL 
C     WRITES TO SCRATCH FILE(8) - NEW FOR RUNOFF 
C 
C     WRITTEN BY CHUCK MOORE, CDM, 8/93. 
C     EDITED FOR STYLE BY WCH, 8/93 
C     WCH, 1/4/94.  CORRECTIONS TO RAINFALL TOTAL AND PLACEMENT OF 
C       UHs ON FILE FOR CASE WHEN RAIN ENDS BEFORE SIMULATION ENDS. 
C     WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY. 
C     CIM 9/8/00 Change for metric version.  In this version rainfall 
C       remains in mm and area is hectares.  Conversions are made to 
C       compute flows in cfs. 
C       Also changed JSTA to character*8 to match other programs. 
C       Change time step comparison to not be absolutely equal. 
C       Increase array size. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
      INCLUDE 'RDII.INC' 
      PARAMETER(MAXARRAY=1000) 
      DIMENSION RMAX(NTK,3,12),QPEAK(NTK,3,12),TTKMAX(NTK,3,12), 
     1 ISHIFT(NTK,3,12) 
      DIMENSION ARRAY(NTK,3,MAXARRAY) 
CIM INCREASE HYETOGRAPHS  ~~~~~~~~~ 
CIM CHANGE JSTA TO CHARACTER*8 TO MATCH CHANGES IN RAINBLOCK AND ELSEWHERE  8/10/00 
C      DIMENSION REIN(MAXRG),JSTA(MAXRG),BAIN(MAXRG) 
      DIMENSION REIN(MAXRG),BAIN(MAXRG) 
      CHARACTER*8 JSTA(MAXRG) 
cim      DIMENSION REIN(10),JSTA(10),BAIN(10) 
cim ~~~~~~~~~~ 
      DIMENSION EXCESS(NTK,3),SUMEX(NTK,3) 
      DOUBLE PRECISION SUMEX 
      LOGICAL  INZERO 
      CHARACTER*10 PRT(4,2) 
      DATA PRT /'cfs/ac-in ','in','in/day','ac', 
     1          'cms/ha-mm ','mm','mm/day','ha'/ 
C======================================================================= 
C  FIND MAXIMUM R VALUES 
C======================================================================= 
      INZERO = .TRUE. 
      IULDAY  = JULDAY 
      STIMDAY = TIMDAY 
      TIME    = TZERO 
      NNZERO  = 0 
      SUMOFRS = 0.0 
      CNEXCESS = 0.0 
      ICOUNT=0 
C#### WCH, 1/4/94.  NEW VARIABLE IFEND. 
      IFEND   = 0 
      DO 10 JJ = 1,12 
      DO 10 J = 1,NTK 
      DO 10 I = 1,3 
      SUMEX(J,I)   = 0.0 
      STORAGE(J,I,JJ) = AMIN1(DSTORE(J,I,JJ),STORAGE(J,I,JJ)) 
      STORAGE(J,I,JJ) = AMAX1(0.0,STORAGE(J,I,JJ)) 
      DREC(J,I,JJ)    = DREC(J,I,JJ) / (24.0*60.0*60.0) 
      TTKMAX(J,I,JJ)  = 0.0 
      RMAX(J,I,JJ)    = 0.0 
      DO 10 K = 1,2 
   10 IZERO(J,I,K) = .FALSE. 
      RRMAX        = 0.0 
      RDIIAREA     = 0.0 
      DO 21 J=1,NOW 
      IC = ICURVE(J) 
      IF(IC.GT.0) THEN 
           RDIIAREA = RDIIAREA + SEWAREA(J) 
           DO 20 I=1,3 
           DO 20 JJ=1,12 
           RRMAX = AMAX1(RDIIR(J,I,JJ),RRMAX) 
   20      RMAX(IC,I,JJ) = AMAX1(RDIIR(J,I,JJ),RMAX(IC,I,JJ)) 
           ENDIF 
   21 CONTINUE 
C======================================================================= 
C  RRMAX IS INDICATOR FOR WHETHER I/I CALCULATIONS ARE PERFORMED. 
C======================================================================= 
      IF(RRMAX.EQ.0.0) RETURN 
C======================================================================= 
      WRITE(*,*) 
      WRITE(*,*)  ' Computing RDII response curve from rainfall data.' 
      WRITE(*,*) 
C======================================================================= 
C  CHECK FOR EXISTANCE OF SCRATCH FILE 8 
C======================================================================= 
      NRDII = NSCRAT(8) 
      IF(NRDII.EQ.0) THEN 
           WRITE(N6,*) ' SCRATCH UNIT NUMBER 8 (NSCRAT(8))', 
     1 ' MUST BE NON-ZERO TO PERFORM RDII CALCULATIONS' 
           WRITE(*,*) ' SCRATCH UNIT NUMBER 8 (NSCRAT(8))', 
     1 ' MUST BE NON-ZERO TO PERFORM RDII CALCULATIONS' 
           STOP 
           ENDIF 
C======================================================================= 
      TKMAX = 0.0 
      TMIN  = 999.0 
      DO 25 J=1,NNTK 
      DO 25 I=1,3 
      DO 25 JJ=1,12 
      IF(RDIIT(J,I,JJ).GT.0.0) TMIN = AMIN1(RDIIT(J,I,JJ),TMIN) 
      TTKMAX(J,I,JJ) = AMAX1(RDIIT(J,I,JJ)*(1.0+RDIIK(J,I,JJ)), 
     2 TTKMAX(J,I,JJ)) 
   25 TKMAX = AMAX1(RDIIT(J,I,JJ)*(1.0+RDIIK(J,I,JJ)),TKMAX) 
C 
      TSTEPS  = TSTEP*60.0*60.0 
      TSTEP2S = TSTEP2*60.0*60.0 
      WRITE(N6,6010) TSTEP,TSTEP2 
C======================================================================= 
C  CHECK MAXARRAY 
C======================================================================= 
      NARRAY = INT(TKMAX/TSTEP2)+IRATIOS+1 
      DO 32 J=1,NNTK 
      DO 32 I=1,3 
      DO 32 JJ=1,12 
      ISHIFT(J,I,JJ) = INT(TTKMAX(J,I,JJ)/TSTEP2)+IRATIOS+1 
   32 CONTINUE 
      IF(NARRAY.GT.MAXARRAY) THEN 
           WRITE(N6,6000) NARRAY 
           STOP 
           ENDIF 
      DO 35 K = 1,NNTK 
      DO 35 I = 1,3 
      DO 35 M = 1,MAXARRAY 
   35 ARRAY(K,I,M) = 0.0 
C======================================================================= 
C  COMPUTE QPEAK/(AIR)  THIS IS UNIT QPEAK TO BE MULTIPLIED LATER BY 
C    AREA, RAINFALL, AND R FACTOR TO COMPUTE PEAK FLOW 
C======================================================================= 
      DO 40 J = 1,NNTK 
      DO 40 I = 1,3 
      DO 40 JJ= 1,12 
C======================================================================= 
C  RAIN (INCHES)  AREA (ACRES)  T (HOURS)  Q (CFS) 
C  AREA OF TRIANGULAR UH IS 1 AC-IN. = 1/12 AC-FT. 
C======================================================================= 
      IF(RDIIT(J,I,JJ).GT.0.0) THEN 
           QPEAK(J,I,JJ) = (2.0*43560.0/12.0)/ 
     +       (RDIIT(J,I,JJ)*(1.0+RDIIK(J,I,JJ))*60.0*60.0) 
           ELSE 
           IF(RMAX(J,I,JJ).NE.0.0) THEN 
                WRITE(N6,*) ' T CANNOT EQUAL ZERO WHEN R IS NON-ZERO' 
                WRITE(N6,*) ' RESPONSE CURVE = ',J,' TRIANGLE = ',I 
                WRITE(N6,*) ' MONTH = ',JJ 
                STOP 
                ENDIF 
           ENDIF 
   40 CONTINUE 
C======================================================================= 
C  PRINT DATA FROM F4 LINES. 
C======================================================================= 
      WRITE(N6,6016) PRT(1,METRIC),PRT(2,METRIC),PRT(2,METRIC), 
     1               PRT(3,METRIC) 
      WRITE(N6,6017) PRT(1,METRIC),PRT(2,METRIC),PRT(2,METRIC), 
     1               PRT(3,METRIC) 
      DO 50 J = 1,NNTK 
      DO 50 JJ= 1,12 
      DO 50 I = 1,3 
C======================================================================= 
C  CFS/AC-IN / 362.9956 = CMS/HA-MM 
C======================================================================= 
cim### 9/8/00 
      IF(METRIC.EQ.2) THEN 
      QPP = QPEAK(J,I,JJ)/362.9956 
      else 
      QPP = QPEAK(J,I,JJ) 
      endif 
      IF(I.EQ.1) WRITE(N6,6019) J,NRDHYET(J),JJ,I,RDIIT(J,I,JJ), 
     1 RDIIK(J,I,JJ),TTKMAX(J,I,JJ),QPP,DSTORE(J,I,JJ),STORAGE(J,I,JJ), 
     2 DREC(J,I,JJ)*60.0*60.0*24.0 
      IF(I.GT.1) WRITE(N6,6020) I,RDIIT(J,I,JJ),RDIIK(J,I,JJ), 
     1 TTKMAX(J,I,JJ),QPP,DSTORE(J,I,JJ),STORAGE(J,I,JJ), 
     2 DREC(J,I,JJ)*60.0*60.0*24.0 
C======================================================================= 
C  CONVERT DEPTH PARAMETERS FROM METRIC (MM) TO U.S. (IN.) 
C======================================================================= 
      IF(METRIC.EQ.2) THEN 
CIM### 9/8/00 
CIM these remain in metric 
c           DSTORE(J,I,JJ)  = DSTORE(J,I,JJ)/25.4 
c           STORAGE(J,I,JJ) = STORAGE(J,I,JJ)/25.4 
c           DREC(J,I,JJ)    = DREC(J,I,JJ)/25.4 
C  conversion from cfs/acre-in to cfs/ha-mm for subsequent calculations 
           QPEAK(J,I,JJ) = QPEAK(J,I,JJ)*2.471/25.4 
           ENDIF 
   50 CONTINUE 
C======================================================================= 
C  PRINT SUBCATCHMENT DATA FROM H5 LINES. 
C======================================================================= 
      WRITE(N6,7000) PRT(4,METRIC) 
      DO 60 J = 1,NOW 
      IC = ICURVE(J) 
      IF(IC.GT.0) THEN 
cim### 9/8/00 leave as hectares 
           SEWW = SEWAREA(J) 
c           IF(METRIC.EQ.2) SEWW = SEWW/2.471 
           IF(JCE.EQ.0) WRITE(N6,7010) J,NAMEW(J),IC,SEWW, 
     1                             (JJ,(RDIIR(J,I,JJ),I=1,3),JJ=1,12) 
           IF(JCE.EQ.1) WRITE(N6,7011) J,KAMEW(J),IC,SEWW, 
     1                             (JJ,(RDIIR(J,I,JJ),I=1,3),JJ=1,12) 
           ENDIF 
   60 CONTINUE 
      SEWW = RDIIAREA 
cim### 9/8/00 leave as hectares 
c      IF(METRIC.EQ.2) SEWW = SEWW/2.471 
      WRITE(N6,7015) SEWW,PRT(4,METRIC) 
C======================================================================= 
C  IF IIRDII = 1, USE PREVIOUSLY CALCULATED RESPONSE CURVE. 
C  SKIP UNIT HYDROGRAPH CALCULATIONS. 
C======================================================================= 
      IF(IIRDII.EQ.1) THEN 
           WRITE(N6,7050) NRDII,FFNAME(58) 
           GO TO 210 
           ENDIF 
C======================================================================= 
C  READ RAINFALL TAPE 
C======================================================================= 
      NREIN = NSCRAT(1) 
      REWIND NREIN 
      READ(NREIN,END=777,IOSTAT=IOSS,ERR=777) NSTA,MRAIN, 
     1              (JSTA(I),I=1,NSTA) 
      WRITE(N6,2115)  NSTA 
      WRITE(N6,2120) (I,JSTA(I),I=1,NSTA) 
      READ(NREIN,END=210,IOSTAT=IOSS,ERR=777) JDAY,TMDAY,THISTO, 
     1                                    (BAIN(J),J=1,NSTA) 
      JYEAR = JDAY/1000 
      IF (JYEAR.LT.100) THEN 
      JDAY = JDAY-JYEAR*1000 
      JYEAR = JYEAR + 1900 
      JDAY = JDAY + JYEAR*1000 
      ENDIF 
cim ### 9/8/00  change to have a tolerance of .5 minutes 
c      IF(THISTO.NE.TSTEPS) THEN 
      IF(ABS(THISTO-TSTEPS).GT.30.0) THEN 
           WRITE(N6,*) ' ERROR - RAINFALL TIME STEP IN RAINFALL FILE ', 
     1       'DOES NOT EQUAL RAINFALL TIME STEP SET ON F3 CARD' 
           WRITE(N6,*)  'THISTO = ',THISTO,' Seconds' 
           WRITE(N6,*)  'TSTEPS = ',TSTEPS,' Seconds' 
           STOP 
           ENDIF 
      JOLDAY  = JDAY 
      TOMDAY  = TMDAY 
      JODAY   = JDAY 
      TODAY   = TMDAY 
      TOHISTO = THISTO 
      DO  98 J = 1,NSTA 
   98 REIN(J)  = BAIN(J) 
C#### WCH, 1/3/94.  DON'T BACKSPACE OR GET EXTRA RAIN AFTER FIRST 
C                   TIME STEP. 
C####      BACKSPACE(NREIN) 
      JULDAY = JDAY 
      TIMDAY = TMDAY 
      CALL DATED 
      WRITE(N6,272) MONTH,NDAY,NYEAR,JULDAY,TIMDAY,TIMDAY/3600.0 
CIM  MONTHLY VALUES 
cim here initialize storage(j,i,1) to initial value for starting month 
cim of rainfall record 
      DO 99 J = 1,NTK 
      DO 99 I = 1,3 
   99 STORAGE(J,I,1) = STORAGE(J,I,MONTH) 
      REWIND NRDII 
C======================================================================= 
C  BEGIN LOOPING OVER RAINFALL USING TIME STEP EQUAL TO RAINFALL STEP 
C======================================================================= 
      CNRAIN = 0.0 
  100 CONTINUE 
      IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN 
           JOLDAY  = JDAY 
           TOMDAY  = TMDAY 
           TOHISTO = THISTO 
           DO 101 J = 1,NSTA 
  101      REIN(J)  = BAIN(J) 
C#### WCH, 1/4/94.  NEW END= LOCATION (151, NOT 210). 
           READ(NREIN,END=151,IOSTAT=IOSS,ERR=777) JDAY,TMDAY,THISTO, 
     +                                    (BAIN(J),J=1,NSTA) 
      JYEAR = JDAY/1000 
      IF (JYEAR.LT.100) THEN 
      JDAY = JDAY-JYEAR*1000 
      JYEAR = JYEAR + 1900 
      JDAY = JDAY + JYEAR*1000 
      ENDIF 
cim### 9/8/00  change to have a tolerance of .5 minutes 
      IF(ABS(THISTO-TSTEPS).GT.30.0) THEN 
           WRITE(N6,*) ' ERROR - RAINFALL TIME STEP IN RAINFALL FILE ', 
     1       'DOES NOT EQUAL RAINFALL TIME STEP SET ON F3 CARD' 
           WRITE(N6,*)  'THISTO = ',THISTO,' Seconds' 
           WRITE(N6,*)  'TSTEPS = ',TSTEPS,' Seconds' 
           STOP 
           ENDIF 
c  write to 6 to get carriage control 
           WRITE(6,104) JDAY 
           ELSE 
           CALL NTIME(JOLDAY,TOMDAY,DELTA) 
           IF(ABS(DELTA).GT.(1.0-1.0/FLOAT(IRATIOS))*TOHISTO) THEN 
                DO 105 J = 1,NSTA 
  105           REIN(J) = 0.0 
                ENDIF 
           ENDIF 
C======================================================================= 
C COMPUTE RAINFALL EXCESS AMOUNTS AND ADJUST INITIAL ABSTRACTION STORAGE 
C======================================================================= 
      DO 550 J = 1,NNTK 
      IF(NRDHYET(J).GT.0) THEN 
           IF(REIN(NRDHYET(J)).GT.0.0) THEN 
                RAINFALL = REIN(NRDHYET(J))*TSTEP 
                CNRAIN   = CNRAIN + RAINFALL 
                DO 540 I = 1,3 
                EXCESS(J,I) = RAINFALL-STORAGE(J,I,1) 
                EXCESS(J,I) = AMAX1(EXCESS(J,I),0.0) 
                STORAGE(J,I,1) = STORAGE(J,I,1)-(RAINFALL-EXCESS(J,I)) 
                SUMEX(J,I) = SUMEX(J,I) + EXCESS(J,I) 
  540           CONTINUE 
                ELSE 
C======================================================================= 
C  STORAGE RECOVERS IF NOT RAINING 
C======================================================================= 
                DO 545 I = 1,3 
                EXCESS(J,I) = 0.0 
                STORAGE(J,I,1) = STORAGE(J,I,1)+DREC(J,I,MONTH)*TSTEPS 
                STORAGE(J,I,1) = AMIN1(STORAGE(J,I,1),DSTORE(J,I,MONTH)) 
  545           CONTINUE 
                ENDIF 
           ENDIF 
  550 CONTINUE 
      ICOUNT=ICOUNT+1 
      DO 360 JJ = 1,NOW 
      JT = ICURVE(JJ) 
      IF(JT.GT.0) THEN 
      DO 350 I=1,3 
      SUMOFRS = SUMOFRS+SEWAREA(JJ)*RDIIR(JJ,I,month) 
      CNEXCESS = CNEXCESS + EXCESS(JT,I)*SEWAREA(JJ)*RDIIR(JJ,I,MONTH) 
  350 CONTINUE 
      ENDIF 
  360 CONTINUE 
C======================================================================= 
C  LOOP OF TSTEP2 
C  LOOP OVER UNIT HYDROGRAPHS TO COMPUTE ARRAY VALUES 
C======================================================================= 
      DO 150 J=1,NNTK 
C======================================================================= 
C  LOOP OVER TRIANGLES 
C======================================================================= 
      DO 140 I = 1,3 
      IF(EXCESS(J,I).GT.0.0) THEN 
           IF(RMAX(J,I,MONTH).GT.0.0) THEN 
C====================================================================== 
C  LOOP OVER TIMESTEPS TO FILL ARRAY 
C======================================================================= 
                TRDII = 0.0 
                DO 139 IT = 2,ISHIFT(J,I,MONTH) 
                TRDII = TRDII + TSTEP2 
                IF(TRDII.LE.RDIIT(J,I,MONTH)) THEN 
                     FLOW = QPEAK(J,I,MONTH)*TRDII/RDIIT(J,I,MONTH) 
     +               *EXCESS(J,I) 
                     ELSE 
                     RRATIO = 1.0 - (TRDII-RDIIT(J,I,MONTH))/ 
     +                              (RDIIT(J,I,MONTH)*RDIIK(J,I,MONTH)) 
                     RRATIO = AMAX1(RRATIO,0.0) 
                     FLOW = QPEAK(J,I,MONTH)*RRATIO*EXCESS(J,I) 
                     ENDIF 
                ARRAY(J,I,IT) = ARRAY(J,I,IT)+FLOW 
                IF(FLOW.LE.0.0) GO TO 140 
  139           CONTINUE 
                ENDIF 
           ENDIF 
  140 CONTINUE 
  150 CONTINUE 
C####################################################################### 
C#### WCH, 1/4/93. 
C  PROVIDE NEW CODE FOR SITUATION IN WHICH END OF RAINFALL IS REACHED 
C  WELL BEFORE END OF SIMULATION. 
C======================================================================= 
      GO TO 153 
  151 IFEND = 1 
      IF(TIME.GE.(LONG+TZERO)) GO TO 210 
  153 DO 200 JJJ = 1,IRATIOS 
C======================================================================= 
C  WRITE THIS FLOW TO FILE  (MOSTLY, WRITE JUST NON-ZERO VALUES). 
C  USE ARRAY IZERO TO INDICATE PRESENCE OF NON-ZERO I/I EXCESS VALUE. 
C  IZERO = .TRUE. ==> NON-ZERO EXCESS VALUE TO WRITE. 
C  IZERO = .FALSE. => DON'T WRITE ZERO VALUE OF ARRAY(). 
C======================================================================= 
      IF(NNZERO.GT.0) THEN 
           IF(INZERO) 
     +        WRITE(NRDII) JODAY,TODAY,((IZERO(J,I,2),I=1,3),J=1,NTK) 
           INZERO = .FALSE. 
           WRITE(NRDII) JULDAY,TIMDAY,((IZERO(J,I,1),I=1,3),J=1,NTK) 
           ELSE 
C======================================================================= 
C  WRITE FIRST ZERO VALUE 
C======================================================================= 
           IF(.NOT.INZERO) THEN 
             WRITE(NRDII) JULDAY,TIMDAY,((IZERO(J,I,1),I=1,3),J=1,NTK) 
             INZERO = .TRUE. 
             ENDIF 
           ENDIF 
C======================================================================= 
C  SHIFT ARRAYS 
C======================================================================= 
C#### WCH, 1/4/93.  MOVE TIME CHANGES TO AFTER 160 LOOP FOR CONVENIENCE 
C                   ONLY. 
C 
      NNZERO = 0 
      DO 160 J = 1,NNTK 
      DO 160 I = 1,3 
C======================================================================= 
C  ONLY STORE NON-ZERO I/I EXCESS VALUES (IZERO = .TRUE.). 
C======================================================================= 
      IF(IZERO(J,I,1)) WRITE(NRDII) ARRAY(J,I,1) 
      DO 155 IT = 1,ISHIFT(J,I,MONTH)-1 
  155 ARRAY(J,I,IT) = ARRAY(J,I,IT+1) 
      IZERO(J,I,2)  = IZERO(J,I,1) 
      IZERO(J,I,1)  = (ARRAY(J,I,1).NE.0.0) 
      IF(IZERO(J,I,1)) NNZERO = NNZERO+1 
  160 ARRAY(J,I,ISHIFT(J,I,MONTH)) = 0.0 
C#### WCH, 1/4/94.  TIME CHANGES MOVED TO HERE. 
      JODAY = JULDAY 
      TODAY = TIMDAY 
      CALL STIME(TSTEP2S) 
      TIME   = TIME+TSTEP2S 
  200 CONTINUE 
C####################################################################### 
C#### WCH, 1/4/94 
C  CHECK TO BE SURE ARRAY() IS "FLUSHED" OF ALL NON-ZERO VALUES  AND 
C  A LAST ZERO STORED ON FILE BEFORE QUITTING. 
C======================================================================= 
      IF(IFEND.EQ.1.AND.NNZERO.GT.0) GO TO 151 
      IF(IFEND.EQ.1.AND.NNZERO.LE.0) THEN 
           IFEND = 2 
           GO TO 153 
           ENDIF 
      IF(IFEND.EQ.2) GO TO 210 
C======================================================================= 
C  READ NEXT RAINFALL 
C======================================================================= 
      IF(TIME.LT.(LONG+TZERO)) GO TO 100 
  210 CONTINUE 
C======================================================================= 
C  APPROXIMATE AVERAGE RAIN BY DIVIDING TOTAL BY NUMBER OF UH SETS. 
C======================================================================= 
      CNRAIN = CNRAIN/DBLE(NNTK) 
      JULDAY = IULDAY 
      TIMDAY = STIMDAY 
      CALL DATED 
      REWIND NRDII 
C======================================================================= 
C  READ FIRST TWO VALUES SETTING UP INPUT FILE FOR RDIISHED 
C======================================================================= 
      CALL READNEXT 
      CALL READNEXT 
      DO 300 I = 1,3 
 300  CNTRDII(I) = 0.0 
      SUMOFRS=SUMOFRS/ICOUNT 
      CNEXCESS = CNEXCESS/SUMOFRS 
      RETURN 
C======================================================================= 
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY. 
 777  WRITE(N6,9777) MOD(IOSS,256) 
      STOP 
C======================================================================= 
  104 FORMAT(1H+,' Reading rainfall Julian day',I8) 
  272 FORMAT(/, 
     1' ************************************************',/, 
     2' *      INITIAL RAINFALL RECORD                 *',/, 
     3' ************************************************',//, 
     4' Date (Mo/Day/Year)   = ',T50,I2,'/',I2,'/',I4,/, 
     6' Julian Date  =',T45,5X,I8,/, 
     7' Time of day  =',T45,F13.0,' seconds.',/, 
     8' Time of day  =',T45,F13.2,'   hours.',/) 
 2115 FORMAT(//, 
     +' ***************************************************',/, 
     +' *  Precipitation Interface File Summary           *',/, 
     +' *  Number of precipitation station....',I9,'   *',/, 
     +' ***************************************************',/) 
 2120 FORMAT(' Location Station Number',/, 
     +       ' -------- --------------',/, 
cim### 9/8/00 change rain id to character*8 
c     +       10(I9,'. ',I13,/)) 
     +       10(I9,'. ',5X,A8,/)) 
 6000 FORMAT(' ERROR - ARRAY DIMENSIONS IN RDIIRES NOT SUFFICIENT TO', 
     1' SIMULATE COMPLETE HYDROGRAPH.',/,' EITHER DECREASE TP(1+K) OR ', 
     2'CHANGE PARAMETER STATEMENT IN RDIIRES.',/, 
     3' DIMENSION REQUIRED FOR THIS SIMULATION = ',I5) 
 6010 FORMAT('1 RAINFALL DEPENDENT INFILTRATION/INFLOW (RDII) CALCULATIO 
     1NS',/,' DATA FROM F3 AND F4 LINES FOR COMPUTATION OF UNIT HYDROGRA 
     2PH RESPONSE:',// 
     3 '  TSTEP  = RAINFALL INCREMENT (MUST = HYETOGRAPH TIME INTERVAL,' 
     4,/,12X,'THISTO)   =',F10.3,' HOURS',/, 
     5 '  TSTEP2 = TIME STEP FOR UH RESPONSE (MUST BE INTEGER FRACTION' 
     6,/,12X,'OF TSTEP) =',F10.3,' HOURS') 
 6015 FORMAT(//,' LINE F4 DATA INPUTS FOR TRIANGULAR UNIT HYDROGRAPH NUM 
     1BER ',I2) 
 6016 FORMAT(/, 
     1'  Qpeak   = Peak RDII flow produced by 1 unit of rainfall excess 
     2',/,13X,'over 1 area unit, ',A10,'.',/, 
     3'  DSTORE  = Maximum depression storage to be satified before I/I 
     4begins, ',A2,'.',/, 
     5'  STORAGE = Initial depression storage, ',A2,'.',/, 
     6'  DREC    = DSTORE recovery rate when not raining, ',A6,'.',/, 
     7'  TP      = Time to peak, hr.',/, 
     8'  K       = Ratio, recession time to TP.',/, 
     9'  TB      = Time base = TP*(1+K), hr.') 
 6017 FORMAT(/, 
     1'   UH   HYET MONTH TRIANG. TP     K      TB    Qpeak  DSTORE', 
     2'  STORAGE   DREC',/, 
C                                              cfs/ac-in  in       in    in/day 
     3' SET NO. NO.         NO.   hr            hr  ',A10,1X,A2,7X,A2, 
     4 4X,A6,/, 
     5' ------ ---- ----- ----- ------ ------ ------ -------- -------', 
     6' ------- -------') 
C          1     1      2   3.00   2.00   9.00  33.86877  0.275   0.376   0.084 
 6019 FORMAT(/,3I5,I7,3F7.2,F10.5,F7.3,2F8.3) 
 6020 FORMAT(I22,3F7.2,F10.5,F7.3,2F8.3) 
C 
 7000 FORMAT(//,' SUBCATCHMENT PARAMETERS FROM H5 DATA LINES',//, 
     1' SUBCATCHMENT  USE  SEWERED MONTH RATIOS FOR TRIANGLE NOS.',/, 
     2' SEQ.     ID    UH    AREA             1       2       3',/, 
     3'  NO.     NO.   NO.    ',A2,/, 
     4'----- ------- ----- -------- ----- ------- ------- -------') 
C         4     977     3   4568.93   0.3333  0.3333  0.3333 
 7010 FORMAT(I4,1X,I10,1X,I6,F10.2,I5,F9.4,2F8.4, 
     1       11(/,32X,I5,F9.4,2F8.4)) 
 7011 FORMAT(I4,1X,A10,1X,I6,F10.2,I5,F9.4,2F8.4, 
     1       11(/,32X,I5,F9.4,2F8.4)) 
 7015 FORMAT(19X,'---------',/,' TOT. SEWERED AREA =',F8.2,1X,A2) 
 7050 FORMAT(/,' PARAMETER IIRDII = 1.  SKIP UH RESPONSE CURVE CALCULATI 
     1ONS.',/,' USE RESPONSE HYDROGRAPH STORED ON UNIT',I3,', DOS FILE ' 
     2,A10,/,' DATES ON FILE MUST OVERLAP DATES REQUIRED FOR THIS SIMULA 
     3TION') 
 9777 FORMAT(/,' ===> Error   Reading precipitation time history', 
     1' on the NSCRAT(1) file.',/,' IOSTAT =',I5,' Run stopped from Subr 
     2outine RDIIRES') 
      END 
 
REM File: RDIISHED.FOR 
 
      SUBROUTINE RDIISHED 
C     RUNOFF BLOCK 
C     CALLED BY HYDRO NEAR LINE 353 
C======================================================================= 
C    RDIISHED CREATED AUGUST 1993 BY C. MOORE, CDM 
C    PERFORMS RDII CALCULATIONS FOR BASINS WITH E5 CARDS 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
      INCLUDE 'GRWTR.INC' 
      INCLUDE 'RDII.INC' 
C======================================================================= 
   10 CALL NTIME(JRDDAY(2),RDTIM(2),DEL2) 
CCC      write(6,*) 1,JRDDAY(2),RDTIM(2),DEL2,JULDAY,TIMDAY 
      IF(DEL2.LE.0.0) THEN 
           CALL READNEXT 
           GO TO 10 
           ENDIF 
      CALL NTIME(JRDDAY(1),RDTIM(1),DEL1) 
CCC      write(6,*) 2,JRDDAY(1),RDTIM(1),DEL1,JULDAY,TIMDAY 
      RRATIO = AMAX1(-DEL1/(DEL2-DEL1),0.0) 
      DO 100 J = 1,NOW 
      IF(ICURVE(J).EQ.0.OR.SEWAREA(J).EQ.0.0) GO TO 100 
      JJ    = ICURVE(J) 
      FFLOW = 0.0 
      DO 50 I = 1,3 
      FFFLOW = RDFLOW(JJ,I,1)+RRATIO*(RDFLOW(JJ,I,2)-RDFLOW(JJ,I,1)) 
C======================================================================= 
C     RDFLOW = IN/HR 
C     RDFLOW*SEWAREA = AC-IN/HR = CFS 
C======================================================================= 
      FFFLOW = FFFLOW*SEWAREA(J)*RDIIR(J,I,MONTH) 
      FFLOW  = FFLOW+FFFLOW 
      CNTRDII(I) = CNTRDII(I) + FFFLOW*DMEAN 
   50 CONTINUE 
C======================================================================= 
C     MUST SAVE I/I FLOW SEPARATELY IF WANT TO ISOLATE QUALITY 
C       CONTRIBUTIONS. 
C======================================================================= 
      FLOWII(J) = FFLOW 
  100 CONTINUE 
      END 
 
 
REM File: RHYDRO1.FOR 
 
      SUBROUTINE RHYDRO1 
C	RUNOFF BLOCK 
C	CALLED BY SUBROUTINE RUNOFF NEAR LINE 217 
C======================================================================= 
C     General Input Subroutine of the Runoff Block. 
C     RHYDRO1 updated August 1992. 
C     Updated 12/92 by WCH to include limit for groundwater 
C       non-convergence messages (entered optionally on B2 line). 
C     Call I/I routine, C. Moore, CDM, 8/93. 
C     Metric correction, WCH (RED), 9/23/93.  UNDONE, RED, 12/31/93. 
C     Option for zero evaporation during rainy time steps, WCH (CDM, 
C       Chuck Moore), 10/5/93.  Also slight change to print-out for 
C       IVAP parameter. 
C     Metric correction, WCH (RED), 11/12/93, for print of QFULL. 
C     Correction to print alphanumeric tributary subareas in linkage 
C       table, WCH, 11/30/93. 
C     Fix to use correct Format statement for evaporation in in. or mm 
C       per day, WCH, 4/19/94. 
C     Add check to be sure when reading F1 evap. data, WCH, 12/5/94. 
C     Check for maximum number of connections to channel/pipe/inlets, 
C       WCH, 12/11/96. 
C     Modify to handle subcat to subcat routing.  WCH, 12/20/00. 
C     Add additional printout options.  WCH, 12/20/00. 
C     Minor spacing changes to initial echo output.  WCH, 1/18/01. 
C     Add error message for too-high initial depth.  WCH, 2/7/01 
C     Add error message for same NAMEG and NGTO.  WCH, 2/12/01. 
C     Reinstate correction for 8-digit date entry on B3 line, made 
C      4/11/00 but lost.  WCH, 5/1/02 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
      INCLUDE 'QUALTY.INC' 
      INCLUDE 'GRWTR.INC' 
      INCLUDE 'NEW88.INC' 
      INCLUDE 'NEW89.INC' 
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
CIM   MAXINF  C.Moore B. Cunningham CDM 
      INCLUDE 'MAXINF.INC' 
Cwch, 12/20/00 
	INCLUDE 'OVERLAND.INC' 
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
Cwch, 4/11/00 
      REAL LLONG*8 
C======================================================================= 
      CHARACTER JUNIT(5)*10,GTYPE(4)*9,CTYPE(3)*12 
CIM Modification to table to print 10 characters and digits of id's 4/99 
      CHARACTER GOUT(20)*90,FOR1(2)*90,FOR2(2)*90,FOR3(2)*90,FOR4(2)*90 
C#### WCH, 12/92 
      DIMENSION G(8),GD(8),GR(8) 
      DATA JUNIT/' Seconds',' Minutes',' Hours',' Days',' Yr/Mo/Dy'/ 
      DATA GTYPE/'Trapezoid',' Circular', 
     1           '  Dummy  ','Parabolic'/ 
      DATA CTYPE/' Weir ','V-Notch Weir',' Orifice '/ 
      GOUT(1) = '('' Input   NAMEG: '''// 
     1'3X,'' Drains                         '',' 
      GOUT(2) = '(''Sequen  Channel'''// 
     1'3X,''   to     Channel  Width  Length '',' 
      GOUT(3) = '(''Number    ID # '''// 
     1'3X,''  NGTO:    Type     (ft)   (ft)  '',' 
      GOUT(4) = '(''------  ------------------'''// 
     1','' -------- ------ ------- '',' 
      GOUT(5) = '''  Invert  L Side   R Side  Intial     Max  Mann-   Fu 
     +ll'')' 
      GOUT(6) = '''   Slope   Slope    Slope   Depth   Depth   ings   Fl 
     +ow'')' 
      GOUT(7) = '''  (ft/ft) (ft/ft)  (ft/ft)   (ft)    (ft)    "N"  (cf 
     +s)'')' 
      GOUT(8) = '''  ------- -------- ------- ------- ------- -----  --- 
     +--'')' 
      GOUT(9) = '(''Number    ID # '''// 
     1'3X,''  NGTO:    Type     (m)    (m)   '',' 
      GOUT(10)= '''  (m/m)   (m/m)    (m/m)     (m)     (m)    "N"   (cm 
     +s)'')' 
      GOUT(11)= '('' Input   NAMEG:  Drains   Type of     Crest '',' 
      GOUT(12)= '(''Sequen  Channel   to      Control      Elev.'',' 
      GOUT(13)= '(''Number    ID #   NGTO:   Structure     (ft) '',' 
      GOUT(14)= '(''------  --------------- -----------  ------ '',' 
      GOUT(15)= '''    Discharge   Spillway Width, Notch '')' 
      GOUT(16)= '''  Coefficient  Angle, or Orifice area  '')' 
      GOUT(17)= ''' (ft**1/2)/s)  (ft or ft**2 or degrees)'')' 
      GOUT(18)= ''' ------------  ------------------------'')' 
      GOUT(19)= '(''Number    ID #   NGTO:   Structure     (m) '',' 
      GOUT(20)= '''  (m**1/2)/s)   (m or m**2 or degrees)'')' 
      SOURCE  = 'Runoff Block' 
C======================================================================= 
C     General information. 
C======================================================================= 
C>>>>>>>>>> READ DATA GROUP A1 <<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,TITLE(1) 
      READ(N5,*,ERR=888) CC,TITLE(2) 
      WRITE(N6,14)          TITLE(1),TITLE(2) 
      TITLE(3) = TITLE(1) 
      TITLE(4) = TITLE(2) 
C======================================================================= 
C>>>>>>>> READ DATA GROUP B1 <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,METRIC,ISNOW,NRGAG,INFILM,KWALTY, 
     1                   IVAP,NHR,NMN,NDAY,MONTH,NYEAR,IVCHAN 
      IF (NYEAR.LT.100) NYEAR = NYEAR+1900 
      WRITE(N6,31) ISNOW,NRGAG 
      IF(INFILM.EQ.0) WRITE(N6,32) INFILM 
      IF(INFILM.EQ.1) WRITE(N6,33) INFILM 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      IF(INFILM.EQ.2) WRITE(N6,321) INFILM 
      IF(INFILM.EQ.3) WRITE(N6,331) INFILM 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      IF(KWALTY.EQ.1) WRITE(N6,34) KWALTY 
      IF(KWALTY.EQ.0) WRITE(N6,35) KWALTY 
C#### WCH (CDM, C. MOORE), 10/5/93.  ADD OPTION FOR NO EVAP DURING RAIN. 
      IF(IVAP.LT.0) THEN 
c  if iivap > 0 then no evaporation during rainfall. 
c           < 0 then evaporation is allowed during rainfall. 
c  if abs(iivap) = 1 then evaporation is allowed from channels. 
c                = 2 then evaporation is not allowed from channels. 
           IIVAP = 1 
           IF (IVCHAN.EQ.1) IIVAP = 2 
           IVAP  = -IVAP 
           ELSE 
           IIVAP = -1 
           IF (IVCHAN.EQ.1) IIVAP = -2 
           ENDIF 
      IF(IIVAP.GT.0) WRITE(N6,41) 
      IF(IVCHAN.EQ.1) WRITE(N6,45) 
C 
      IF(IVAP.EQ.0) WRITE(N6,36)   IVAP 
C#### WCH, 10/5/93.  MODIFY IVAP WRITE. 
      IF(IVAP.GE.1.AND.IVAP.LE.3) WRITE(N6,37)   IVAP 
      IF(IVAP.EQ.4) WRITE(N6,42) IVAP 
      WRITE(N6,38) NHR,NMN 
      TZERO = FLOAT(NHR) + FLOAT(NMN)/60.0 
      WRITE (N6,39) TZERO 
      TZERO  = TZERO * 3600.0 
      TIMDAY = TZERO 
      METRIC = METRIC + 1 
      IF(METRIC.EQ.1) WRITE(N6,48) METRIC-1 
      IF(METRIC.EQ.2) WRITE(N6,49) METRIC-1 
C======================================================================= 
C>>>>>>>> READ DATA GROUP B2 <<<<<<<< 
C======================================================================= 
      IPRNGW  = 0 
	NOHEAD  = 0 
	LANDUPR = 0 
Cwch, 12/20/00. Add NOHEAD and LANDUPR 
      READ(N5,*,ERR=888)CC,IPRN(1),IPRN(2),IPRN(3),IPRNGW,NOHEAD,LANDUPR 
      WRITE(N6,40)          IPRN(1),IPRN(2),IPRN(3) 
	WRITE(N6,9072) NOHEAD 
	WRITE(N6,9074) LANDUPR 
      IF(IPRNGW.EQ.0) IPRNGW = 10000 
      WRITE(N6,9070) IPRNGW 
C 
      IPRN(4) = 1 
      IPRN(5) = 1 
      IPRN(6) = 1 
      IPRN(7) = 1 
      IF(IPRN(1).EQ.0) THEN 
                       IPRN(4) = 0 
                       IPRN(5) = 0 
                       IPRN(6) = 0 
                       IPRN(7) = 0 
                       ENDIF 
      IF(IPRN(1).GT.1) THEN 
         I1 = IPRN(1)/1000 
         J2 = IPRN(1) - I1*1000 
         I2 = J2/100 
         J3 = J2 - I2*100 
         I3 = J3/10 
         I4 = J3 - I3*10 
         IF(I1.EQ.2.OR.I2.EQ.2.OR.I3.EQ.2.OR.I4.EQ.2) IPRN(4) = 0 
         IF(I1.EQ.3.OR.I2.EQ.3.OR.I3.EQ.3.OR.I4.EQ.3) IPRN(5) = 0 
         IF(I1.EQ.4.OR.I2.EQ.4.OR.I3.EQ.4.OR.I4.EQ.4) IPRN(6) = 0 
         IF(I1.EQ.5.OR.I2.EQ.5.OR.I3.EQ.5.OR.I4.EQ.5) IPRN(7) = 0 
         ENDIF 
C======================================================================= 
C>>>>>>>> READ DATA GROUP B3 <<<<<<<< 
Cwch, 4/11/00. Read LONG here as double precision (LLONG), but keep 
C     LONG for use in computations.  Need double to get last digit of 
C     8-digit dates when LUNIT = 4.  
C======================================================================= 
      READ(N5,*,ERR=888) CC,WET,WETDRY,DRY,LUNIT,LLONG 
C======================================================================= 
C>>>>>>>> READ DATA GROUP B4 (IF PRESENT) <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC 
      IF(CC.EQ.'B4') THEN 
                   BACKSPACE N5 
                   READ(N5,*,ERR=888) CC,PCTZER,REGEN 
                   ELSE 
                   BACKSPACE N5 
                   ENDIF 
	IF (NDAY+MONTH+NYEAR.EQ.0) THEN 
          NDAY   =     2 
          MONTH  =     8 
          NYEAR  =  1941 
	ENDIF 
c      IF(NDAY.LE.0)   NDAY   =  2 
c      IF(MONTH.LE.0)  MONTH  =  8 
c      IF(NYEAR.LE.0)  NYEAR  = 1941 
      JULDAY = NYEAR*1000 + JDATE(NDAY,MONTH,NYEAR) 
      IDATEZ = JULDAY 
      CALL DATED 
      NBD(1) = NYEAR 
      NBD(2) = MONTH 
      NBD(3) = NDAY 
      NBD(4) = JHR 
      NBD(5) = MINUTE 
      NBD(6) = JSEC 
      IF(NRGAG.EQ.0)    NRGAG  =    1 
      IF(REGEN.LE.0.0)  REGEN  = 0.01 
      IF(PCTZER.EQ.0.0) PCTZER = 25.0 
C======================================================================= 
      WRITE (N6,162)  MONTH,NDAY,NYEAR 
      WRITE (N6,160)  WET,DRY,WETDRY 
Cwch, 4/11/00 
      WRITE (N6,165)  LLONG,JUNIT(LUNIT+1) 
      WRITE (N6,174)  PCTZER 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      IF(INFILM.EQ.0.OR.INFILM.EQ.2) WRITE(N6,180) REGEN 
cim      IF(INFILM.EQ.0) WRITE(N6,180) REGEN 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
Cwch, 4/11/00.  Use LLONG on RHS for these calcs.  
C======================================================================= 
      IF(LUNIT.EQ.1)  LONG = LLONG*60.0 
      IF(LUNIT.EQ.2)  LONG = LLONG*3600.0 
      IF(LUNIT.EQ.3)  LONG = LLONG*86400.0 
      IF(LUNIT.EQ.4)  THEN 
C                      JEND  = IFIX(LONG) 
                      JEND  = IDINT(LLONG) 
                      MYEAR = JEND/10000 
                      MDAY  = JEND - MYEAR*10000 
                      IF (MYEAR.LT.100) MYEAR = MYEAR + 1900 
                      MMNTH = MDAY/100 
                      MDAY  = MDAY - MMNTH*100 
                      JEND  = 1000*MYEAR + JDATE(MDAY,MMNTH,MYEAR) 
                      TMD   = 86400.0 
                      CALL NTIME(JEND,TMD,TDIFF) 
                      LONG  = TDIFF 
                      ENDIF 
C======================================================================= 
C     Read Snow Input Data Groups. 
C======================================================================= 
      IF(ISNOW.GT.0) THEN 
                     WRITE(*,9050) 
                     CALL SNOWIN(0) 
                     ENDIF 
C======================================================================= 
C     Rainfall Intensity Histogram. 
C======================================================================= 
      WRITE(*,9060) 
      CALL MKRAIN 
C======================================================================= 
C>>>>>>>> Read Data Group F1 If IVAP >= 1 <<<<<<<< 
C======================================================================= 
      IF(IVAP.EQ.0) THEN 
                    CDEF     = 0.1 
                    IF(METRIC.EQ.2) CDEF = 3.0 
                    DO 535 I = 1,12 
  535               VAP(I)   = CDEF 
                    IF(METRIC.EQ.1) WRITE(N6,550) (VAP(I),I=1,12) 
                    IF(METRIC.EQ.2) WRITE(N6,555) (VAP(I),I=1,12) 
                    ENDIF 
      IF(IVAP.EQ.1) THEN 
                    READ(N5,*,ERR=888) CC,(VAP(I),I=1,12) 
C#### WCH, 12/5/94.  CHECK FOR PRESENCE OF F1 LINE. 
                    IF(CC.NE.'F1') THEN 
                         CC = 'F1' 
                         GO TO 888 
                         ENDIF 
C#### WCH, 4/19/94.  USE CORRECT FORMAT STATEMENTS FOR IN OR MM/DAY. 
                    IF(METRIC.EQ.1) WRITE(N6,550) (VAP(I),I=1,12) 
                    IF(METRIC.EQ.2) WRITE(N6,555) (VAP(I),I=1,12) 
                    ENDIF 
      IF(IVAP.EQ.2) THEN 
                    READ(N5,*,ERR=888) CC,(VAP(I),I=1,12) 
C#### WCH, 12/5/94.  CHECK FOR PRESENCE OF F1 LINE. 
                    IF(CC.NE.'F1') THEN 
                         CC = 'F1' 
                         GO TO 888 
                         ENDIF 
                    IF(METRIC.EQ.1) WRITE(N6,551) (VAP(I),I=1,12) 
                    IF(METRIC.EQ.2) WRITE(N6,556) (VAP(I),I=1,12) 
                    DO 540 I = 1,12 
  540               VAP(I)   = VAP(I)/PDAYS(I) 
                    ENDIF 
      IF(IVAP.EQ.3) THEN 
                    READ(N5,*,ERR=888) CC,NVAP(1),NVAP(2) 
                    IF (NVAP(1).LE.100) NVAP(1) = NVAP(1) + 1900 
C#### WCH, 12/5/94.  CHECK FOR PRESENCE OF F1 LINE. 
                    IF(CC.NE.'F1') THEN 
                         CC = 'F1' 
                         GO TO 888 
                         ENDIF 
                    IF(NVAP(2).GT.600) CALL ERROR(150) 
                    IF(NVAP(1).LE.00)  CALL ERROR(151) 
C                   IF(NVAP(1).GT.100) CALL ERROR(152) 
                    DO 5300 I  = 1,NVAP(2),12 
                    KK         = I - 1 
                    READ(N5,*,ERR=888) CC,(VAP(K+KK),K=1,12) 
5300                CONTINUE 
                    IF(METRIC.EQ.1) WRITE(N6,5505) 
                    IF(METRIC.EQ.2) WRITE(N6,5506) 
                    ISTYR      = NVAP(1) - 1 
                    DO 5400 I  = 1,NVAP(2),12 
                    ISTYR      = ISTYR   + 1 
                    KK         = I       - 1 
                    WRITE(N6,5510) ISTYR,(VAP(K+KK),K=1,12) 
5400                CONTINUE 
                    DO 5600 I  = 1,NVAP(2),12 
                    DO 5500 K  = 1,12 
                    KK         = K - 1 
5500                VAP(I+KK)  = VAP(I+KK)/PDAYS(K)/CMET(7,METRIC) 
5600                CONTINUE 
                    ENDIF 
C======================================================================= 
C     Convert from in/day or mm/day to ft/sec. 
C======================================================================= 
      IF(IVAP.LE.2) THEN 
                    DO 560 I = 1,12 
560                 VAP(I)   = VAP(I)/CMET(7,METRIC) 
                    ENDIF 
      FOR1(1) = GOUT(1) 
      FOR1(2) = GOUT(5) 
      FOR2(1) = GOUT(2) 
      FOR2(2) = GOUT(6) 
      FOR4(1) = GOUT(4) 
      FOR4(2) = GOUT(8) 
      IF(METRIC.EQ.1) THEN 
                      FOR3(1) = GOUT(3) 
                      FOR3(2) = GOUT(7) 
                      ELSE 
                      FOR3(1) = GOUT(9) 
                      FOR3(2) = GOUT(10) 
                      ENDIF 
C####################################################################### 
C####   C. Moore, 8/93.  Add option to read I/I data. 
C####################################################################### 
C>>>>>>>> Read F3 and F4 lines <<<<<<<< 
C======================================================================= 
C     Look for new F3 line with first call to RDIIREAD 
C======================================================================= 
      CALL RDIIREAD(0,0) 
C======================================================================= 
C     Look for new F4 lines with second call to RDIIREAD 
C======================================================================= 
      CALL RDIIREAD(1,0) 
C======================================================================= 
C     Channel and Pipe Data. 
C======================================================================= 
      DO 562 I = 1,8 
      GD(I)    = 0.0 
  562 GR(I)    = 1.0 
      NOGG     = 0 
      N        = 0 
      WRITE(*,9040) 
Change from 900 to NG 
      DO 660 I = 1,NG 
      N        = N + 1 
C======================================================================= 
C>>>>>>>> Read Data Groups G1 and G2 <<<<<<<< 
C======================================================================= 
      READ (N5,*,ERR=888) CC 
      IF(CC.NE.'G1'.AND.CC.NE.'G2') THEN 
                     BACKSPACE N5 
                     IF(I.EQ.1) WRITE(N6,600) 
                     GO TO 670 
                     ENDIF 
      IF(CC.EQ.'G1') THEN 
                     BACKSPACE N5 
                     IF(JCE.EQ.0) READ(N5,*,ERR=888) 
     +                                 CC,NAMEG(N),NGTO(N),NP,G 
                     IF(JCE.EQ.1) READ(N5,*,ERR=888) 
     +                                 CC,KAMEG(N),KGTO(N),NP,G 
                     IF(NP.GT.4) THEN 
                                 READ(N5,*,ERR=888) CC,WTYPE(N), 
     +                                WELEV(N),WDIS(N),SPILL(N) 
                                 IF(CC.NE.'G2') THEN 
                                    IF(JCE.EQ.0) WRITE(N6,8900) NAMEG(N) 
                                    IF(JCE.EQ.1) WRITE(N6,8901) KAMEG(N) 
                                    CALL ERROR(200) 
                                    ENDIF 
                                 IF(NP.LE.6) NP = NP - 4 
                                 IF(NP.EQ.7) NP =  4 
                                 ENDIF 
                     ENDIF 
      IF(JCE.EQ.0)        THEN 
		IF(NAMEG(N).EQ.-1)  THEN 
                          DO 610 J = 1,8 
  610                     IF(G(J).NE.0.0) GR(J)=G(J) 
                          N = N - 1 
                          GO TO 660 
                          ENDIF 
		IF(NAMEG(N).EQ.-2)  THEN 
                          DO 640 J = 1,8 
  640                     IF(G(J).NE.0.0) GD(J)=G(J) 
                          N = N - 1 
                          GO TO 660 
                          ENDIF 
Cwch, 2/12/01.  Check for same NAMEG and NGTO 
          IF(NAMEG(N).EQ.NGTO(N)) THEN 
	                    WRITE(*,8925) NAMEG(N) 
	                    WRITE(N6,8926) NAMEG(N) 
	                    STOP ' Run stopped from Runoff Block data inpu 
     1t routine, RHYDRO1' 
	                    ENDIF 
          ENDIF 
	IF(JCE.EQ.1)        THEN 
		IF(KAMEG(N).EQ.'-1')THEN 
                          DO 810 J = 1,8 
  810                     IF(G(J).NE.0.0) GR(J)=G(J) 
                          N = N - 1 
                          GO TO 660 
                          ENDIF 
		IF(KAMEG(N).EQ.'-2')THEN 
                          DO 840 J = 1,8 
  840                     IF(G(J).NE.0.0) GD(J)=G(J) 
                          N = N - 1 
                          GO TO 660 
                          ENDIF 
Cwch, 2/12/01.  Check for same KAMEG and KGTO 
          IF(KAMEG(N).EQ.KGTO(N)) THEN 
	                    WRITE(*,8930) KAMEG(N) 
	                    WRITE(N6,8931) KAMEG(N) 
	                    STOP ' Run stopped from Runoff Block data inpu 
     1t routine, RHYDRO1' 
	                    ENDIF 
          ENDIF 
      IF(NP.NE.3) THEN 
                   DO 605 IG = 1,8 
                   IF(G(IG).EQ.0.0) G(IG) = GD(IG) 
  605              G(IG)                  = GR(IG) * G(IG) 
                   ENDIF 
C======================================================================= 
C     Calculate Qfull for Channel or Pipe. 
C======================================================================= 
      IF(NP.NE.3) THEN 
      IF(G(6).LE.0.0) G(6) = 0.014 
      IF(NP.EQ.1) THEN 
             AX = 0.5*(G(4)+G(5))*G(7)**2.0+G(1)*G(7) 
             PW = SQRT(G(4)**2.0+1.0)*G(7)+SQRT(G(5)**2.0+1.0)*G(7)+G(1) 
             ENDIF 
      IF(NP.EQ.2)  THEN 
                   SIN2D0  = 0.5*SIN(2.0*2.62) 
                   AX      = G(1)**2*(2.62-SIN2D0)/4.0 
                   PW      = G(1)*2.62 
                   ENDIF 
      IF(NP.EQ.4)     THEN 
      IF(G(7).GT.0.0) THEN 
                      WIDTH = G(1) 
                      AX    = 0.66666667*WIDTH*G(7) 
                      X     = WIDTH/2.0 
                      AA    = WIDTH**4.0/(64.0*G(7)**2.0) 
                      PW    = 8.0*G(7)/WIDTH**2.0*(X*SQRT(AA+X**2.0) + 
     +                                     AA*LOG(X+SQRT(AA+X**2.0)) - 
     +                                     AA*LOG(SQRT(AA))) 
                     ELSE 
                     AX    = 0.0 
                     PW    = 0.001 
                     ENDIF 
                     ENDIF 
      IF(AX.LT.0.001) AX   = 0.0 
      IF(PW.LE.0.001) PW   = 0.001 
      RAD                  = AX/PW 
      GCON(N)              = 1.486/G(6)*SQRT(G(3)) 
                     QFULL = 0.0 
      IF(RAD.GT.0.0) QFULL = GCON(N)*AX*RAD**0.666666667 
      ELSE 
      QFULL                = 0.0 
      ENDIF 
C#### WCH (RED), 11/12/93. 
      IF(METRIC.EQ.2) QFULL = QFULL/1.486 
C======================================================================= 
C     Print Channel/Pipe data. 
C======================================================================= 
      IF(IPRN(4).EQ.0)   THEN 
      IF(N.EQ.1.OR.MOD(N,50).EQ.0) THEN 
                                   WRITE(N6,620) 
                                   WRITE(N6,FOR1) 
                                   WRITE(N6,FOR2) 
                                   WRITE(N6,FOR3) 
                                   WRITE(N6,FOR4) 
                                   ENDIF 
      IF(JCE.EQ.0) WRITE(N6,630) N,NAMEG(N),NGTO(N),GTYPE(NP), 
     +             G(1),G(2),G(3),G(4),G(5),G(8),G(7),G(6),QFULL 
      IF(JCE.EQ.1) WRITE(N6,631) N,KAMEG(N),KGTO(N),GTYPE(NP), 
     +             G(1),G(2),G(3),G(4),G(5),G(8),G(7),G(6),QFULL 
      ENDIF 
C======================================================================= 
Cwch, 2/7/01  Check that initial depth not greater than channel max. 
C======================================================================= 
      IF(NP.NE.2.OR.NP.NE.3.OR.NP.NE.6) THEN 
	     IF(G(8).GT.G(1)) THEN 
	        IF(JCE.EQ.0) WRITE(N6,9925) NAMEG(N),G(8),G(1) 
	        IF(JCE.EQ.1) WRITE(N6,9926) KAMEG(N),G(8),G(1) 
	        G(8) = G(1) 
	       ELSEIF(NP.NE.3.AND.G(8).GT.G(7)) THEN 
	        IF(JCE.EQ.0) WRITE(N6,9930) NAMEG(N),G(8),G(7) 
	        IF(JCE.EQ.1) WRITE(N6,9931) KAMEG(N),G(8),G(7) 
	        G(7) = G(1) 
	       ENDIF 
	     ENDIF 
C======================================================================= 
C     Transfer data and convert units. 
C======================================================================= 
      NPG(N)    = NP 
      GWIDTH(N) = G(1)*CMET(1,METRIC) 
      GLEN(N)   = G(2)*CMET(1,METRIC) 
      GS1(N)    = G(4) 
      GS2(N)    = G(5) 
      DFULL(N)  = G(7)*CMET(1,METRIC) 
      IF(G(8).LE.0.0.AND.NP.EQ.4) G(8) = 0.0001 
      GDEPTH(N) = G(8)*CMET(1,METRIC) 
C======================================================================= 
C     For circular pipes, Dfull is in radians. 
C     2.62=Half angle of wetted perimeter at maximum flow. 
C======================================================================= 
      IF(NP.EQ.2) THEN 
                  DFULL(N)  = 2.62 
                  IF(GDEPTH(N).GE.GWIDTH(N)/2.0) THEN 
                               TH9 = GDEPTH(N) -  GWIDTH(N)/2.0 
                               GDEPTH(N) =  3.1415927 
     +                                    - ACOS(TH9/(GWIDTH(N)/2.0)) 
                               ENDIF 
                  IF(GDEPTH(N).LT.GWIDTH(N)/2.0) THEN 
                               TH9 =  GWIDTH(N)/2.0 - GDEPTH(N) 
                               GDEPTH(N) =  ACOS(TH9/(GWIDTH(N)/2.0)) 
                               ENDIF 
                  ENDIF 
      NOGG = 1 
  660 CONTINUE 
  670 NOG = N-1 
C======================================================================= 
C     Write control structure data. 
C======================================================================= 
      IF(IPRN(4).EQ.0) THEN 
      FOR1(1) = GOUT(11) 
      FOR1(2) = GOUT(15) 
      FOR2(1) = GOUT(12) 
      FOR2(2) = GOUT(16) 
      FOR4(1) = GOUT(14) 
      FOR4(2) = GOUT(18) 
      IF(METRIC.EQ.1) THEN 
                      FOR3(1) = GOUT(13) 
                      FOR3(2) = GOUT(17) 
                      ELSE 
                      FOR3(1) = GOUT(19) 
                      FOR3(2) = GOUT(20) 
                      ENDIF 
      I        = 0 
      DO 680 N = 1,NOG 
      IF(WTYPE(N).EQ.-1) GO TO 680 
      I = I + 1 
      IF(I.EQ.1.OR.MOD(I,50).EQ.0) THEN 
                                   WRITE(N6,625) 
                                   WRITE(N6,FOR1) 
                                   WRITE(N6,FOR2) 
                                   WRITE(N6,FOR3) 
                                   WRITE(N6,FOR4) 
                                   ENDIF 
      N1 = WTYPE(N) + 1 
C#### WCH (RED), 9/93.  METRIC CORRECTION FOR WELEV. 
C#### RED (WCH), 12/31/93.  UNDO CORRECTION.  UNNECESSARY BECAUSE 
C####                       CONVERTED WELEV AFTER WRITE STATEMENTS. 
      IF(JCE.EQ.0) WRITE(N6,635) N,NAMEG(N),NGTO(N), 
     +             CTYPE(N1),WELEV(N),WDIS(N),SPILL(N) 
      IF(JCE.EQ.1) WRITE(N6,636) N,KAMEG(N),KGTO(N), 
     +             CTYPE(N1),WELEV(N),WDIS(N),SPILL(N) 
C####################################################################### 
C MOVE NEXT THREE STATEMENTS TO HERE TO CONVERT PARAMETERS AFTER 
C  PRINT-OUT. WCH, 8/28/92 
C####################################################################### 
      WELEV(N) = WELEV(N)*CMET(1,METRIC) 
      IF(WTYPE(N).EQ.2) SPILL(N) = SPILL(N)*CMET(1,METRIC)**2.0 
C####################################################################### 
C CORRECT ANGLE (SPILL) TO INPUT UNITS OF DEGREES.  WCH, 8/28/92 
C####################################################################### 
      IF(WTYPE(N).EQ.1) SPILL(N) =TAN(SPILL(N)/2.0*3.14159/180) 
 680  CONTINUE 
      ENDIF 
C======================================================================= 
C     Set up channel connectivity tables. 
C======================================================================= 
      INLETS = 0 
      IF(NOG.GT.0) THEN 
                   DO 720 N     = 1,NOG 
                   NN           = NOG + INLETS 
                   DO 690 NGOTO = 1,NN 
                   IF(JCE.EQ.0.AND.NGTO(N).EQ.NAMEG(NGOTO)) GO TO 700 
                   IF(JCE.EQ.1.AND.KGTO(N).EQ.KAMEG(NGOTO)) GO TO 700 
  690              CONTINUE 
C======================================================================= 
C                  Create dummy channels as needed 
C======================================================================= 
                   INLETS = INLETS + 1 
                   NGOTO  = NOG    + INLETS 
                   IF(NGOTO.GT.NG) CALL ERROR(13) 
                   IF(JCE.EQ.0) NAMEG(NGOTO) = NGTO(N) 
                   IF(JCE.EQ.1) KAMEG(NGOTO) = KGTO(N) 
                   NPG(NGOTO)    = 3 
                   NGTOI(INLETS) = NGOTO 
  700              CONTINUE 
                   DO 710 J = 1,NCP 
CIM### 9/8/00 trap for more than NCP gutters entering another gutter 
                   IF ((J.EQ.NCP).AND.(NGTOG(J,NGOTO).NE.0)) then 
                       write(*,*) 'warning more than',ncp, 
     1                 ' gutters entering a junction' 
                       if (JCE.EQ.0) then 
                           write(*,701) NAMEG(NGOTO) 
                           else 
                           write(8,702) KAMEG(NGOTO) 
                           endif 
  701 FORMAT(' RECEIVING GUTTER ',i10) 
  702 FORMAT(' RECEIVING GUTTER ',A10) 
                       STOP 'TOO MANNY GUTTERS ENTERING ANOTHER GUTTER' 
                       ENDIF 
CIM 
                   IF(NGTOG(J,NGOTO).GT.0) GO TO 710 
                   NGTOG(J,NGOTO) = N 
                   GO TO 720 
  710              CONTINUE 
C#### WCH, 12/11/96.  ADD ERROR MESSAGE HERE IF EXCEED NCP CONNECTIONS. 
                   IF(JCE.EQ.0) WRITE(N6,8910) NCP,NAMEG(NGOTO),NAMEG(N) 
                   IF(JCE.EQ.1) WRITE(N6,8911) NCP,KAMEG(NGOTO),KAMEG(N) 
                   WRITE (N6,8912) NCP 
                   WRITE (*,8912) NCP 
                   STOP 'See error message in output file.' 
  720              CONTINUE 
                   ENDIF 
C======================================================================= 
C     Read subcatchment information from Subroutine CATCH. 
C======================================================================= 
      WRITE(*,9010) 
      CALL CATCH(TRIBA) 
C======================================================================= 
C     Set up connectivity tables. 
C 
Cwch, 12/20/00.  Do not add inlet if subcat flow goes to another subcat. 
C     If IFLOWP(N).ge.3, outflow is to another subcatchment.  
C======================================================================= 
      DO 940 N     = 1,NOW 
	IF(IFLOWP(N).GE.3) GO TO 940 
      NN           = NOG + INLETS 
      DO 910 NGOTO = 1,NN 
      IF(JCE.EQ.0.AND.NGTO(N).EQ.NAMEG(NGOTO)) GO TO 920 
      IF(JCE.EQ.1.AND.KGTO(N).EQ.KAMEG(NGOTO)) GO TO 920 
  910 CONTINUE 
C======================================================================= 
C     Identify additional inlets. 
C======================================================================= 
      INLETS        = INLETS+1 
      NGOTO         = NOG + INLETS 
CIM### 9/8/00 ADDED CHECK FOR NGOTO HERE ALSO 
                   IF(NGOTO.GT.NG) CALL ERROR(13) 
      IF(JCE.EQ.0) NAMEG(NGOTO)  = NGTO(N) 
      IF(JCE.EQ.1) KAMEG(NGOTO)  = KGTO(N) 
      NPG(NGOTO)    = 3 
      NGTOI(INLETS) = NGOTO 
      IF(NGOTO.GT.NG) CALL ERROR(13) 
  920 CONTINUE 
C======================================================================= 
C     Channel connection. 
C======================================================================= 
      DO 930 J = 1,NCP 
      IF(NWTOG(J,NGOTO).GT.0) GO TO 930 
      NWTOG(J,NGOTO) = N 
      GO TO 940 
  930 CONTINUE 
C#### WCH, 12/11/96.  ADD ERROR MESSAGE HERE IF EXCEED NCP CONNECTIONS. 
      IF(JCE.EQ.0) WRITE(N6,8920) NCP,NAMEG(NGOTO),NAMEW(N) 
      IF(JCE.EQ.1) WRITE(N6,8921) NCP,KAMEG(NGOTO),KAMEW(N) 
      WRITE (N6,8912) NCP 
      WRITE (*,8912) NCP 
      STOP ' See error message in output file.' 
  940 CONTINUE 
C======================================================================= 
Cwch, 12/20/00. Here perform similar connectivity effort for  
C     subcatchment to subcatchment flow.  
C======================================================================= 
	ICERR = 0 
      DO 946 N     = 1,NOW 
	IF(IFLOWP(N).LE.2) GO TO 946 
		DO NNN = 1,NOW 
		NWTOTO = NNN 
          IF(JCE.EQ.0.AND.NGTO(N).EQ.NAMEW(NNN)) GO TO 944 
          IF(JCE.EQ.1.AND.KGTO(N).EQ.KAMEW(NNN)) GO TO 944 
          ENDDO 
C======================================================================= 
C  Here, error, no matching name for NGTO. 
C======================================================================= 
	IF(JCE.EQ.0) WRITE(N6,9900) NGTO(N),NAMEW(N) 
	IF(JCE.EQ.1) WRITE(N6,9901) KGTO(N),KAMEW(N) 
	WRITE (*,9905) 
	ICERR = 1 
	GO TO 946 
C======================================================================= 
C  Establish connectivity with Subcat.  
C======================================================================= 
  944	DO 945 J = 1,NCP 
	IF(NWTOW(J,NWTOTO).GT.0) GO TO 945 
      NWTOW(J,NWTOTO) = N 
      GO TO 946 
  945 CONTINUE 
C======================================================================= 
C  Error, exceed NCP dimension. 
C======================================================================= 
      IF(JCE.EQ.0) WRITE(N6,9920) NCP,NAMEW(NWTOTO) 
      IF(JCE.EQ.1) WRITE(N6,9921) NCP,KAMEW(NWTOTO) 
      WRITE (N6,8912) NCP 
      WRITE (*,8912) NCP 
      ICERR = 1 
  946 CONTINUE 
	IF(ICERR.EQ.1) THEN 
		STOP ' Error in subcat to subcat connectivity.  See output fil 
     +e.' 
	    ENDIF 
C======================================================================= 
C     Print connectivity summary. 
C======================================================================= 
      WRITE(N6,950) 
      IF(NOG.GT.0) THEN 
                   WRITE(N6,960) 
                   DO 1100 J = 1,NOG 
                   IF(MOD(J,25).EQ.0) THEN 
                                      WRITE(N6,950) 
                                      WRITE(N6,960) 
                                      ENDIF 
                   DO 990 N = 1,NCP 
                   IF(NGTOG(N,J)) 980,1000,980 
  980              INUM    = NGTOG(N,J) 
                   IF(JCE.EQ.0) NGTO(N) = NAMEG(INUM) 
                   IF(JCE.EQ.1) KGTO(N) = KAMEG(INUM) 
  990              CONTINUE 
 1000              N = N-1 
                   IF(JCE.EQ.0.AND.N.LE.0) WRITE(N6,1030) NAMEG(J) 
                   IF(JCE.EQ.1.AND.N.LE.0) WRITE(N6,1031) KAMEG(J) 
                   IF(JCE.EQ.0.AND.N.GT.0) WRITE(N6,1170) 
     +                                     NAMEG(J),(NGTO(K),K=1,N) 
                   IF(JCE.EQ.1.AND.N.GT.0) WRITE(N6,1171) 
     +                                     KAMEG(J),(KGTO(K),K=1,N) 
                   DO 1060 N = 1,NCP 
                   IF(NWTOG(N,J)) 1050,1070,1050 
 1050              INUM    = NWTOG(N,J) 
                   IF(JCE.EQ.0) NGTO(N) = NAMEW(INUM) 
                   IF(JCE.EQ.1) KGTO(N) = KAMEW(INUM) 
 1060              CONTINUE 
 1070              N = N-1 
                   IF(N.EQ.0) WRITE(N6,1090) 
                   IF(JCE.EQ.0.AND.N.GT.0) WRITE(N6,1095)(NGTO(K),K=1,N) 
                   IF(JCE.EQ.1.AND.N.GT.0) WRITE(N6,1096)(KGTO(K),K=1,N) 
 1100              CONTINUE 
                   ENDIF 
      WRITE(N6,1120) 
C----------------------------------------------------------------------- 
      DO 1180 I = 1,INLETS 
      N         = NGTOI(I) 
      JG        = 0 
      JW        = 10 
      DO 1160 J = 1,NCP 
      IF(NGTOG(J,N).NE.0) THEN 
                          JG       = JG+1 
                          INUM     = NGTOG(J,N) 
                          IF(JCE.EQ.0) NGTO(JG) = NAMEG(INUM) 
                          IF(JCE.EQ.1) KGTO(JG) = KAMEG(INUM) 
                          ENDIF 
      IF(NWTOG(J,N).NE.0) THEN 
                          JW       = JW+1 
                          INUM     = NWTOG(J,N) 
                          IF(JCE.EQ.0) NGTO(JW) = NAMEW(INUM) 
                          IF(JCE.EQ.1) KGTO(JW) = KAMEW(INUM) 
                          ENDIF 
 1160 CONTINUE 
      IF(JCE.EQ.0.AND.JG.EQ.0) WRITE(N6,1030) NAMEG(N) 
      IF(JCE.EQ.1.AND.JG.EQ.0) WRITE(N6,1031) KAMEG(N) 
      IF(JCE.EQ.0.AND.JG.GT.0) WRITE(N6,1170) NAMEG(N),(NGTO(J),J=1,JG) 
      IF(JCE.EQ.1.AND.JG.GT.0) WRITE(N6,1171) KAMEG(N),(KGTO(J),J=1,JG) 
      IF(JW.EQ.10) WRITE(N6,1090) 
      IF(JCE.EQ.0.AND.JW.GT.10) WRITE(N6,1095) (NGTO(J),J=11,JW) 
C#### WCH, 11/30/93.  CHANGE NGTO TO KGTO HERE. 
      IF(JCE.EQ.1.AND.JW.GT.10) WRITE(N6,1096) (KGTO(J),J=11,JW) 
 1180 CONTINUE 
C======================================================================= 
C     Read information to control inlets saved and printed. 
C======================================================================= 
      NSAVE     = INLETS 
      DO 1190 J = 1,INLETS 
      N         = NGTOI(J) 
      IF(JCE.EQ.0) ISAVE(J) = NAMEG(N) 
 1190 IF(JCE.EQ.1) KSAVE(J) = KAMEG(N) 
      IF(JCE.EQ.0) WRITE(N6,1200) INLETS,(ISAVE(K),K=1,INLETS) 
      IF(JCE.EQ.1) WRITE(N6,1201) INLETS,(KSAVE(K),K=1,INLETS) 
C======================================================================= 
C     Set up header for subsurface information to be graphed. 
C======================================================================= 
C     IF(NSVGW.GT.0) THEN 
C                    LKOUN  = 0 
C                    DO 1206 JF = 1,NOGWSC 
C                    IF(NSCSFG(JF).EQ.0) GO TO 1206 
C                    LKOUN         = LKOUN+1 
C                    NSSVFG(LKOUN) = NSCSFG(JF) 
C1206                CONTINUE 
C                    ENDIF 
C======================================================================= 
C     Snow melt data for each catchment. 
C======================================================================= 
      IF(ISNOW.GT.0) THEN 
                     WRITE(*,9030) 
                     CALL SNOWIN(1) 
                     ENDIF 
      RETURN 
  888 CALL IERROR 
C======================================================================= 
   14 FORMAT(//,20X,A80,//,20X,A80,/) 
   31 FORMAT(//,1X,'Snowmelt parameter - ISNOW.......................', 
     2 T57,I5,// ,1X,'Number of rain gages - NRGAG.....................' 
     4 ,T57,I5) 
   32 FORMAT(/,' Horton infiltration equation used - INFILM.......', 
     1 T57,I5) 
   33 FORMAT (/,1X,'Green-Ampt infiltration equation used - INFILM...', 
     1 T57,I5) 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  321 FORMAT(/,' Horton infiltration equation used - INFILM.......', 
     1 T57,I5,/, 
     2' Maximum infiltration volume is limited to RMAXINF input on ', 
     3' subcatchment lines.  Infiltration volume regenerates during ', 
     4' non rainfall periods.') 
  331 FORMAT (/,1X,'Green-Ampt infiltration equation used - INFILM...', 
     1 T57,I5,/, 
     2' Maximum infiltration volume is limited to RMAXINF input on ', 
     3' subcatchment lines.  Does not regenerate. ') 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
   34 FORMAT(/,1X,'Quality is simulated - KWALTY....................', 
     1 T57,I5) 
   35 FORMAT (/,1X,'Quality is not simulated - KWALTY................', 
     1 T57,I5) 
   36 FORMAT(/,1X,'Default evaporation rate used - IVAP.............', 
     1  T57,I5) 
   37 FORMAT(/,1X,'Read evaporation data on line(s) F1 (F2) - IVAP..', 
     1  T57,I5) 
   38 FORMAT(/,1X,'Hour of day at start of storm - NHR..............', 
     1 T57,I5,//,1X,'Minute of hour at start of storm - NMN...........', 
     2 T57,I5) 
   39 FORMAT(/,' Time TZERO at start of storm (hours).............', 
     1 F11.3) 
   40 FORMAT(/,' Runoff input print control...',T57,I5, 
     1      //,' Runoff graph plot control....',T57,I5, 
     2      //,' Runoff output print control..',T57,I5) 
C#### WCH, 10/5/93. 
   41 FORMAT(/,1X,'IVAP is negative.  Evaporation will be set to zero' 
     1 ,/,'     during time steps with rainfall.') 
   45 FORMAT(/,1x,'IVCHAN equals 1.  Evaporation is not allowed from ' 
     1,' channels or conduits.') 
C#### WCH, 10/5/93. 
   42 FORMAT(/,1X,'Input evaporation data on NSCRAT(3) from the',/, 
     1           ' Temp Block - IVAP................................', 
     2  T57,I5) 
   48 FORMAT(/,' Use U.S. Customary units for most I/O - METRIC...', 
     1 T57,I5) 
   49 FORMAT(/,' Use Metric units for I/O - METRIC................', 
     1 T57,I5,/,'  ===> Ft-sec units used in all internal computations') 
  162 FORMAT (/,' Month, day, year of start of storm is: ', 
     1 12X,2(I2,'/'),I4) 
  160 FORMAT(/,1X, 
     +  'Wet time step length (seconds).......',T52,F10.0,//,1X, 
     +  'Dry time step length (seconds).......',T52,F10.0,//,1X, 
     +  'Wet/Dry time step length (seconds)...',T52,F10.0) 
  165 FORMAT(/,1X,'Simulation length is......',T52,F10.1,A10) 
  174 FORMAT(/,' Percent of impervious area with zero detention', 
     .       ' depth',3X,F5.1) 
CIM### 9/8/00 modify format to include space 
  180 FORMAT(/,1X,'Horton infiltration model being used',/,' Rate for ', 
     1'regeneration of infiltration = REGEN * DECAY' 
     1,/,' DECAY is read in for each subcatchment',/, 
     2   ' REGEN = ............................................' 
     3   ,T52,F10.5,/,1H1) 
  550 FORMAT(/, 
     +'   #############################',/, 
     +'   #        Data Group F1      #',/, 
     +'   # Evaporation Rate (in/day) #',/, 
     +'   #############################',//, 
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV 
     +.  DEC.',/, 
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  --- 
     +-  ----',/,12F6.2) 
  551 FORMAT(/, 
     +'   ##############################',/, 
     +'   #        Data Group F1       #',/, 
     +'   # Evaporation Rate (in/month)#',/, 
     +'   ##############################',//, 
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV 
     +.  DEC.',/, 
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  --- 
     +-  ----',/,12F6.2) 
  555 FORMAT(/, 
     +'   #############################',/, 
     +'   #        Data Group F1      #',/, 
     +'   # Evaporation Rate (mm/day) #',/, 
     +'   #############################',//, 
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV 
     +.  DEC.',/, 
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  --- 
     +-  ----',/,12F6.2) 
  556 FORMAT(/, 
     +'   ###############################',/, 
     +'   #        Data Group F1        #',/, 
     +'   # Evaporation Rate (mm/month) #',/, 
     +'   ###############################',//, 
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV 
     +.  DEC.',/, 
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  --- 
     +-  ----',/,12F6.2) 
  600 FORMAT(//, 
     +' ************************************************',/, 
     +' *          No Channel or Pipe Network          *',/, 
     +' ************************************************',//) 
  620 FORMAT(/,1H1,/ 
     +' *********************************************************',/, 
     +' *         C H A N N E L  A N D  P I P E  D A T A        *',/, 
     +' *********************************************************',/) 
  625 FORMAT(/,1H1,/ 
     +' **********************************************************',/, 
     +' *       C O N T R O L  S T R U C T U R E   D A T A       *',/, 
     +' **********************************************************',/) 
  630 FORMAT(1X,I3,1X,I10,1X,I10,1X,A9,F6.1,F8.1,F10.4, 
     1                             F9.4,F8.4,2F8.1,F8.4,1PE9.2) 
  631 FORMAT(1X,I3,1X,A10,1X,A10,1X,A9,F6.1,F8.1,F10.4, 
     1                             F9.4,F8.4,2F8.1,F8.4,1PE9.2) 
  635 FORMAT(1X,I3,1X,I10,1X,I10,1X,A12,F7.1,F12.3,5X,F12.4) 
  636 FORMAT(1X,I3,1X,A10,1X,A10,1X,A12,F7.1,F12.3,5X,F12.4) 
Cwch, 12/20/00 
  950 FORMAT(/,1H1,/ 
     1' *********************************************************',/, 
     2' *    Arrangement of Subcatchments and Channel/Pipes     *',/, 
     3' *********************************************************',/, 
     4' * See second subcatchment output table for connectivity *',/, 
     5' * of subcatchment to subcatchment flows.                *',/, 
     6' *********************************************************') 
  960 FORMAT(//,4X,'Channel',/,4X,'or Pipe') 
 1030 FORMAT(1X,I10,5X,'No Tributary Channel/Pipes') 
 1031 FORMAT(1X,A10,5X,'No Tributary Channel/Pipes') 
 1090 FORMAT(    16X,'No Tributary Subareas.....') 
 1095 FORMAT(    16X,'Tributary Subareas........',5(1X,I10)) 
 1096 FORMAT(    16X,'Tributary Subareas........',5(1X,A10)) 
 1120 FORMAT(//,2X,'   INLET') 
 1170 FORMAT(1X,I10,5X,'Tributary Channel/Pipes...',5(1X,I10)) 
 1171 FORMAT(1X,A10,5X,'Tributary Channel/Pipes...',5(1X,A10)) 
 1200 FORMAT(//, 
     1' ***********************************************************',/, 
     2' * Hydrographs will be stored for the following',I4,' INLETS *', 
     3/,' ***********************************************************', 
     4 /,(5X,6I10)) 
 1201 FORMAT(//, 
     1' ***********************************************************',/, 
     2' * Hydrographs will be stored for the following',I4,' INLETS *', 
     3/,' ***********************************************************', 
     4 /,(1X,6A10)) 
 5505 FORMAT(/, 
     1'   ###############################',/, 
     2'   #        Data Group F2        #',/, 
     3'   # Evaporation Rate (in/month) #',/, 
     4'   ###############################',//, 
     5'  Year  Jan.  Feb.  Mar.  Apr.  May   June  July  Aug.  Sep.  Oct 
     6.  Nov. Dec.',/, 
     7'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  --- 
     8   ---- ----') 
 5506 FORMAT(/, 
     +'   ###############################',/, 
     +'   #        Data Group F2        #',/, 
     +'   # Evaporation Rate (mm/month) #',/, 
     +'   ###############################',//, 
     1'  Year  Jan.  Feb.  Mar.  Apr.  May   June  July  Aug.  Sep.  Oct 
     2.  Nov. Dec.',/, 
     1'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  --- 
     2-  ---- ----') 
 5510 FORMAT(I6,12F6.2) 
 8900 FORMAT(/,' ===> Error   There was no G2 data line for Channel/Pi 
     +pe number ',I10,/) 
 8901 FORMAT(/,' ===> Error   There was no G2 data line for Channel/Pi 
     +pe name ',A10,/) 
C#### WCH, 12/11/96. 
 8910 FORMAT(/,' ERROR MAXIMUM OF',I3,' CHANNEL/PIPE CONNECTIONS TO ANO 
     1THER',/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',I10,/, 
     2' BY CHANNEL/PIPE',I10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C 
     3ONNECTIONS.') 
 8911 FORMAT(/,' ERROR MAXIMUM OF',I3,' CHANNEL/PIPE CONNECTIONS TO ANO 
     1THER',/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',A10,/, 
     2' BY CHANNEL/PIPE',A10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C 
     3ONNECTIONS.') 
 8912 FORMAT(' Run stopped due to exceeding maximum no. connections, NCP 
     1 =',I3) 
 8920 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO A' 
     1,/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',I10,/, 
     2' BY SUBCATCHMENT',I10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C 
     3ONNECTIONS.') 
 8921 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO A' 
     1,/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',A10,/, 
     2' BY SUBCATCHMENT',A10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C 
     3ONNECTIONS.') 
Cwch, 2/12/01. 
 8925 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name ( 
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',I10) 
 8926 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name ( 
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',I10,/, 
	2' Run stopped from Runoff Block input routine RHYDRO1.') 
 8930 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name ( 
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',A10) 
 8931 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name ( 
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',A10,/, 
	2' Run stopped from Runoff Block input routine RHYDRO1.') 
C 
 9010 FORMAT(/,' Reading subcatchment information.') 
 9030 FORMAT(/,' Reading subcatchment snowmelt information.') 
 9040 FORMAT(/,' Reading channel/pipe information.') 
 9050 FORMAT(/,' Reading snowmelt information.') 
 9060 FORMAT(/,' Reading rainfall information.') 
C##### WCH, 12/92 
 9070 FORMAT(/,' Limit number of groundwater convergence messages to ', 
     +I5,' (if simulated)') 
Cwch, 12/20/00.  
 9072 FORMAT(/,1X,'Print headers every 50 lines - NOHEAD (0=yes, 1=no)', 
     1 T57,I5) 
 9074 FORMAT(/,1X,'Print land use load percentages -LANDUPR (0=no, 1=yes 
     1)',T57,I5) 
Cwch, 12/20/00 
 9900 FORMAT(' ERROR CANNOT FIND CORRESPONDING SUBCATCHMENT ',I10,' (NG 
     1TO) FOR',/, 
	2' SURFACE FLOW FROM SUBCATCHMENT ',I10,'. RUN WILL STOP.') 
 9901 FORMAT(' ERROR CANNOT FIND CORRESPONDING SUBCATCHMENT ',A10,' (NG 
     1TO) FOR',/, 
	2' SURFACE FLOW FROM SUBCATCHMENT ',A10,'. RUN WILL STOP.') 
 9905 FORMAT (' Error Run will stop due to connectivity error.') 
 9920 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO ANO 
     1THER',/, 
     2' SUBCATCHMENT EXCEEED FOR SUBCATCHMENT',I10,/, 
     4' MUST REDUCE THE NUMBER OF SURFACE CONNECTIONS TO THIS SUBCAT.') 
 9921 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO ANO 
     1THER',/, 
     2' SUBCATCHMENT EXCEEED FOR SUBCATCHMENT',A10,/, 
     4' MUST REDUCE THE NUMBER OF SURFACE CONNECTIONS TO THIS SUBCAT.') 
Cwch, 2/7/01 
 9925 FORMAT(' WARNING FOR PIPE ',I10,' INITIAL DEPTH ',F7.2,' > DIAMET 
     1ER ',F7.2,'. SET = DIAMETER AND CONTINUE.') 
 9926 FORMAT(' WARNING FOR PIPE ',A10,' INITIAL DEPTH ',F7.2,' > DIAMET 
     1ER ',F7.2,'. SET = DIAMETER AND CONTINUE.') 
 9930 FORMAT(' WARNING FOR CHANNEL ',I10,' INITIAL DEPTH ',F7.2,' > MAX 
     1 ',F7.2,'. SET = MAX AND CONTINUE.') 
 9931 FORMAT(' WARNING FOR CHANNEL ',A10,' INITIAL DEPTH ',F7.2,' > MAX 
     1 ',F7.2,'. SET = MAX AND CONTINUE.') 
C======================================================================= 
      END 
 
REM File: ROUTE.FOR 
 
      SUBROUTINE ROUTE(DELQ,WSLOPE) 
C     TRANSPORT BLOCK 
C     CALLED BY DWLOAD NEAR LINE 170 
C               INITAL NEAR LINE 195 
C               TRANS NEAR LINE 511 
C======================================================================= 
C     ROUTING SUBPROGRAM FOR FLOW THROUGH SEWER ELEMENTS. 
C     IN THE PROGRAM, ALPHA REPRESENTS NORMALIZED AREA, A/AFULL. 
C                     PSI AND PS REPRESENT NORMALIZED FLOW, Q/QFULL. 
C======================================================================= 
C     UPDATED SEPTEMBER 1981 BY W.C.H. AND S.J.N. 
C     UPDATED SEPTEMBER 1988 BY R.E.D. 
C     UPDATED SEPTEMBER 1989 BY R.E.D. 
C     UPDATED AUGUST 1993 BY CHARLES I. MOORE, CDM, ANNANDALE, VA FOR 
C       INSTALLATION OF TYPE 26 TABULAR FLOW DIVIDER.  INSTALLED BY 
C       WCH. 
C     CHECK ON VALUE OF DH, 9/23/93.  WCH (RED). 
C     USE STORE() INSTEAD OF STORL() FOR BACKWATER ELEMENT, WCH, 10/6/93. 
C     ADD PROBABLY UNNECESSARY CHECK ON RANGE FOR L, WCH, 10/6/93. 
C     SET DEFALUT VALUE FOR QO2(M) BEFORE IF STMT, RED, 12/31/93. 
C     Changes to have additional level of detail in TRANSPORT irregular 
C       section calculations.  CIM 9/8/00 
C     Use QCURVE(4), not (3), for flow. No change to QCURV2. WCH, 7/6/01. 
C     Use parameter QMINRTE for minimum flow for flow routing. Also 
C       go through same extra effort for power function channels, types 
C       14 and 15 as for natural channels, type 16 since all can have 
C       IDETAIL = 1. WCH 3/14/02.  
C     Move a couple of error prints to better location. WCH (LR),  
C       6/11/02. 
C     Correction to QCURVE2 index. WCH (CIM), 7/20/04. 
C======================================================================= 
C     MEANING OF A AND Q ARRAY DIMENSIONS, E.G., A(M,1,2): 
C     A OR Q(CHANNEL,1-UPSTREAM 2-DOWNSTREAM, 
C                    1-START OF TIME STEP 2-END OF TIME STEP) 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'NAMES.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEW81.INC' 
      INCLUDE 'TST.INC' 
      INCLUDE 'FLODAT.INC' 
      INCLUDE 'FSPLIT.INC' 
CIM### 9/8/00 add NEWTR 
      INCLUDE 'NEWTR.INC' 
      DIMENSION QI(NET),QO(NET),WELL1(NET),WELL2(NET),PUMP(NET), 
     +          QO1(NET),QO2(NET) 
      CHARACTER BMJ*10 
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2)),(PUMP(1),DIST(1)) 
      EQUIVALENCE (QO1(1),QMAX(1)),(QO2(1),QFULL(1)) 
      EQUIVALENCE (WELL1(1),SLOPE(1)),(WELL2(1),ROUGH(1)) 
      DATA WT/0.60/,WD/0.60/ 
      DATA NUMERR/0/ 
Cwch 3/14/02. Set flows and areas to zero for Q < 0.00001 cfs.  
      DATA QMINRTE/1E-5/ 
C======================================================================= 
C     USE GENERALIZED WEIGHTS OF TIME AND SPACE DERIVATIVES OF 
C     CONTINUITY EQUATION. 
C     WT = WEIGHT ON TIME DERIVATIVE. 
C     WD = WEIGHT ON SPATIAL DERIVATIVE. 
C          THESE CONSTANTS APPEAR IN DEFINITIONS OF C1(M) AND C2. 
C     NOTE, WT  = WD = 0.50 CORRESPOND TO ORIGINAL VERSION OF TRANSPORT MODEL. 
C           WT  = WD = 0.55 APPEAR TO GIVE BEST ATTENUATION OF HYDROGRAPHS. 
C     M         = ELEMENT NUMBER 
C     KLASS(NTPE) = 1 FOR CONDUIT WITH FUNCTIONAL Q-A RELATIONSHIP. 
C     KLASS(NTPE) = 2 FOR CONDUIT WITH TABULAR Q-A RELATIONSHIP. 
C     KLASS(NTPE) = 3 FOR ELEMENT OTHER THAN CONDUIT. 
C                   COMPUTE TOTAL HEAD SLOPE AND ASSOCIATED PARAMETERS. 
C     KFULL = 1 IF CONDUIT IS FULL AT UPSTREAM END. 
C     KFULL = 2 IF CONDUIT IS NOT FULL AT UPSTREAM END. 
C======================================================================= 
      NTPE   = NTYPE(M) 
      K      = KLASS(NTPE) 
C======================================================================= 
C     PRINT OF ERRORS STOPS WHEN NUMBER OF ERRORS EXCEED 50 
C======================================================================= 
      IF(NUMERR.EQ.50.AND.NPRINT.GT.0) THEN 
                                        NUMERR = NUMERR + 1 
                                        WRITE(N6,930) 
                                        ENDIF 
C======================================================================= 
C     NO ITERATIONS REQUIRED FOR CONDUITS WITH SURCHARGED FLOW. 
C     NO ITERATIONS REQUIRED FOR CONDUITS WITH SUPER-CRITICAL FLOW. 
C======================================================================= 
      IF(K.LE.2)     THEN 
           IF(KFULL.EQ.1) THEN 
                  C1(M)   = AFULL(M)/QFULL(M)*DXDT(M)*WT/WD 
                  QMAX(M) = P4(M)*QFULL(M) 
                  WSLOPE  = SLOPE(M) 
                  DELQ    = 0.0 
                  ELSE 
                  IF(SCF(M).NE.GNO) THEN 
                            ITER    = 0 
                            WSLOPE  = SLOPE(M) 
                            DELQ    = 0.0 
                            ELSE 
C======================================================================= 
C                           NON-SUPERCRITICAL FLOW 
C======================================================================= 
                            IF(ITER.LE.NITER) THEN 
                               QOLD = QFULL(M) 
                               A1   = A(M,1,1)/AFULL(M) 
                               A2   = A(M,2,1)/AFULL(M) 
                               DV   = (VEL(Q(M,1,1),A(M,1,1))**2 - 
     +                                 VEL(Q(M,2,1),A(M,2,1))**2) 
     +                                /DIST(M)/64.4 
                               WSLOPE = SLOPE(M) + P2(M)*(DEPTH(A1) - 
     +                                  DEPTH(A2)) + DV 
                               ELSE 
                               A1 = A(M,1,2)/AFULL(M) 
                               A2 = A(M,2,2)/AFULL(M) 
                               DV = (VEL(Q(M,1,2),A(M,1,2))**2 - 
     +                               VEL(Q(M,2,2),A(M,2,2))**2) 
     +                              /DIST(M)/64.4 
                               WSLOPE = SLOPE(M) + P2(M)*(DEPTH(A1) - 
     +                                  DEPTH(A2)) + DV 
                               ENDIF 
C======================================================================= 
                            IF(WSLOPE.LE.SLOPE(M)) WSLOPE = SLOPE(M) 
                                                OMEGA = 0.50 
                            IF(ITER.GT.NITER+3) OMEGA = 0.33 
                            QFULL(M) = P1(M)*SQRT(WSLOPE) 
                            QFULL(M) = (1.0-OMEGA)*QOLD+OMEGA*QFULL(M) 
                            DELQ     = ABS(QFULL(M)-QOLD) 
                            QOLD     = QFULL(M) 
                            IF(DELQ.LT.EPSIL*QFULL(M)) ITER = 0 
                            IF(ITER-NITER.GE.NITER-1)  ITER = 0 
                            C1(M)   = AFULL(M)/QFULL(M)*DXDT(M)*WT/WD 
                            QMAX(M) = P4(M)*QFULL(M) 
                            ENDIF 
C======================================================================= 
                  ENDIF 
           ENDIF 
C======================================================================= 
C     ROUTINE FOR CONDUIT WITH FUNCTIONAL Q-A RELATIONSHIP. 
C     FIND NEW UPSTREAM AREA. 
C======================================================================= 
      IF(K.EQ.1) THEN 
Cwch 3/14/02.  Use QMINRTE for minimum flow for routing, not 1E-20.  
      IF(QI(M).EQ.0.0.AND.Q(M,2,1).LE.QMINRTE) THEN 
                                               A(M,2,2) = 0.0 
                                               Q(M,2,2) = 0.0 
                                               RETURN 
                                               ENDIF 
      IF(KFULL.EQ.1) THEN 
                     A(M,1,2) = AFULL(M) 
                     ELSE 
                     C2    = -Q(M,1,2)/QFULL(M) 
                     ALPHA = A(M,1,1)/AFULL(M) 
                     CALL NEWTON(ALPHA,PS,0.0,C2,KFLAG) 
                     IF(KFLAG.EQ.2) THEN 
                              NUMERR = NUMERR + 1 
                              IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN 
                                 IF(JCE.EQ.0) WRITE(N6,910) 
     +                                        TIME,N,NOE(M),A(M,1,1) 
                                 IF(JCE.EQ.1) WRITE(N6,911) 
     +                                        TIME,N,KOE(M),A(M,1,1) 
                                 ENDIF 
                              ALPHA = A(M,1,1)/AFULL(M) 
                              ENDIF 
                     A(M,1,2) = ALPHA*AFULL(M) 
                     ENDIF 
C======================================================================= 
C     ASSIGN VALUES TO CONSTANTS AND SOLVE FOR DOWNSTREAM Q AND A. 
C======================================================================= 
      C2    = (1.0-WD)*Q(M,2,1)-(1.0-WD)*Q(M,1,1)-WD*Q(M,1,2) 
      C2    = C2 + DXDT(M)*((1.0-WT)*A(M,1,2) - 
     +                      (1.0-WT)*A(M,1,1)-WT*A(M,2,1)) 
      C2    = C2/QFULL(M)/WD 
      ALPHA = A(M,2,1)/AFULL(M) 
C======================================================================= 
C     DOWNSTREAM Q AND A MAY NOW BE CALCULATED. 
C======================================================================= 
      CALL NEWTON(ALPHA,PS,C1(M),C2,KFLAG) 
      IF(KFLAG.EQ.1) THEN 
                     A(M,2,2) = ALPHA*AFULL(M) 
                     Q(M,2,2) = PS*QFULL(M) 
                     RETURN 
                     ENDIF 
C======================================================================= 
C     DETERMINE REASON FOR NON-CONVERGENCE. 
C     THEN USE DEFAULT OPTIONS TO DETERMINE Q AND A. 
C 
C     SEE IF LINE-C1*ALPHA-C2 INTERSECTS Q-A CURVE. 
C     CONTINUITY EQUATION TRIES TO FORCE Q.GT.QMAX. 
C     LET DOWNSTREAM FLOW BE QFULL UNLESS UPSTREAM Q IS GT QFULL. 
C======================================================================= 
      NUMERR = NUMERR + 1 
      IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN 
         WRITE(N6,900) 
         IF(JCE.EQ.0) WRITE(N6,901) TIME,NOE(M),QFULL(M),AFULL(M), 
     +                DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1), 
     +                A(M,1,2),A(M,2,1),ALPHA,PS,C2,N 
         IF(JCE.EQ.1) WRITE(N6,1901) TIME,KOE(M),QFULL(M),AFULL(M), 
     +                DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1), 
     +                A(M,1,2),A(M,2,1),ALPHA,PS,C2,N 
         ENDIF 
      IF((-C1(M)*ALFMAX(NTPE)-C2).GT.P4(M)) THEN 
Cwch, 6/11/02. (LR)  Error print should be here, not after ELSE below. 
C     Also, don't need another addition to error count? 
         IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,903) 
C                                  NUMERR = NUMERR + 1 
         IF(Q(M,1,2).GT.QFULL(M)) THEN 
                                  Q(M,2,2) = Q(M,1,2) 
                                  A(M,2,2) = A(M,1,2) 
                                  ELSE 
                                  Q(M,2,2) = QFULL(M) 
                                  A(M,2,2) = AFULL(M) 
                                  ENDIF 
         RETURN 
         ELSE 
C======================================================================= 
C     CONTINUITY EQUATION TRIES TO FORCE Q. LT. ZERO. 
C     LET DOWNSTREAM FLOW BE ZERO. 
C======================================================================= 
         IF(C2.GT.0.0) THEN 
                       NUMERR = NUMERR + 1 
                       IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,904) 
                       Q(M,2,2) = 0.0 
                       A(M,2,2) = 0.0 
                       RETURN 
                       ENDIF 
C======================================================================= 
C     REASON FOR NON-CONVERGENCE UNDETERMINED. 
C     LET NEW Q AND A EQUAL VALUES AT PREVIOUS TIME STEP. 
C======================================================================= 
         IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,902) 
                   NUMERR   = NUMERR + 1 
                   A(M,2,2) = A(M,2,1) 
                   Q(M,2,2) = Q(M,2,1) 
                   RETURN 
                   ENDIF 
      ENDIF 
C======================================================================= 
C     END OF IF-REALM FOR CONDUITS WITH FUNCTIONAL Q-A RELATIONSHIP. 
C 
C     ROUTINE FOR CONDUITS WITH TABULAR Q-A RELATIONSHIP. 
C======================================================================= 
      IF(K.EQ.2)   THEN 
Cwch 3/14/02.  Use QMINRTE for minimum flow for routing, not 1E-20.  
                   IF(QI(M).EQ.0.0.AND.Q(M,2,1).LE.QMINRTE) THEN 
                                               A(M,2,2) = 0.0 
                                               Q(M,2,2) = 0.0 
                                               RETURN 
                                               ENDIF 
Cwch, 3/14/02. Also need this for power function channels.  
           IF(NTPE.LE.16.AND.NTPE.GE.14) THEN 
                   KK     = NQC(M) 
                   DALPHA = 0.04 
                   MMM    = 26 
CIM### 9/8/00 CIMDETAIL detail cal for irregular sections 
                   IF(IDETAIL.EQ.1) THEN 
                        DALPH2 = 0.0016 
CIM MM = 26 + 26 -2 DUPLICATES (1 AND 26) 
                        MMM    = 50 
                        ENDIF 
                   ELSE    types other than 16 
                   DALPHA = ANORM(NTPE,2) - ANORM(NTPE,1) 
                   MMM    = MM(NTPE) 
                   ENDIF 
C======================================================================= 
C     CALCULATE UPSTREAM AREA. 
C======================================================================= 
           IF(KFULL.EQ.1) THEN 
                     A(M,1,2) = AFULL(M) 
                     ELSE 
                     PS = Q(M,1,2)/QFULL(M) 
                     CALL FINDA(PS,A(M,1,2)) 
                     ENDIF 
C======================================================================= 
C     CALCULATE DOWNSTREAM Q AND A. 
C======================================================================= 
                                    ISIGN =  1 
           IF(A(M,1,2).LE.A(M,1,1)) ISIGN = -1 
           ICHK = 1 
           I    = IOLD(M) 
           C2   = (1.0-WD)*Q(M,2,1)-(1.0-WD)*Q(M,1,1)-WD*Q(M,1,2) 
           C2   = C2 + DXDT(M)*((1.0-WT)*A(M,1,2) - 
     +                     (1.0-WT)*A(M,1,1) - WT*A(M,2,1)) 
           C2   = C2/QFULL(M)/WD 
C======================================================================= 
C     CALCULATE SLOPE OF LINE SEGMENT I OF Q-A CURVE. 
Cwch, 3/14/02.  Also do IDETAIL stuff for power function channels.  
C======================================================================= 
C     For parabolic, power function, and natural channels, NTPE=16. 
C     From Sub GETCUR: 
C     QCURVE(1)  = hydraulic radius 
C     QCURVE(2)  = area 
C     QCURVE(3)  = top width 
C     QCURVE(4)  = flow 
C     For detail at low water: 
C     QCURVE2(1) = hydraulic radius 
C     QCURVE2(2) = area 
C     QCURVE2(3) = flow 
C======================================================================= 
  120      IF(NTPE.LE.16.AND.NTPE.GE.14) THEN 
                   KK    = NQC(M) 
CIM### 9/8/00 DETAIL  First is normal case for type 16 
                 IF(IDETAIL.EQ.0) THEN 
                   SLUPE = (QCURVE(KK,4,I+1) - QCURVE(KK,4,I))/DALPHA 
                 ELSE  IDETAIL = 1 
CIM REFINED ESTIMATE FOR LOW FLOW 
                   IF (I.GE.26) THEN 
                    ICIM = I-24 
                    SLUPE = (QCURVE(KK,4,ICIM+1) - QCURVE(KK,4,ICIM)) 
     1                      /DALPHA 
                   ELSE 
                    SLUPE = (QCURV2(KK,3,I+1) - QCURV2(KK,3,I))/DALPH2 
                   ENDIF 
                 ENDIF IDETAIL 
CIM### 9/8/00 DETAIL 
                   ELSE      this is types other than 16 
                   SLUPE = (QNORM(NTPE,I+1) - QNORM(NTPE,I))/DALPHA 
                   ENDIF 
           IF(SLUPE+C1(M).EQ.0.0) GO TO 130 
C======================================================================= 
C     COMPUTE ALPHA CORRESPONDING TO INTERSECTION OF LINE SEGMENT 
C     I OF Q-A CURVE WITH LINE -C1*ALPHA-C2. 
C     CHECK TO SEE IF ALPHA IS IN PROPER RANGE. 
Cwch, 3/14/02.  Also do extra stuff for power function channels.  
C======================================================================= 
           IF(NTPE.LE.16.AND.NTPE.GE.14) THEN 
                KK    = NQC(M) 
CIM### 9/8/00 DETAIL FIRST IS NORMAL CASE FOR IDETAIL = 0 
                IF (IDETAIL.EQ.0) THEN 
                  ALPHA = (-QCURVE(KK,4,I)-C2+SLUPE*FLOAT(I-1)*0.04) / 
     +                                     (SLUPE + C1(M)) 
                  ELSE 
cim  refined low flow estimates 4/96 
                  IF (I.GE.26) THEN 
                    ICIM = I-24 
              ALPHA = (-QCURVE(KK,4,ICIM)-C2+SLUPE*FLOAT(ICIM-1)*0.04) / 
     +                                     (SLUPE + C1(M)) 
                    ELSE 
CIM Here, should use 3, not 4. 
C                ALPHA = (-QCURV2(KK,4,I)-C2+SLUPE*FLOAT(I-1)*0.0016) / 
Cwch 7/20/04 
                ALPHA = (-QCURV2(KK,3,I)-C2+SLUPE*FLOAT(I-1)*0.0016) / 
     +                                     (SLUPE + C1(M)) 
                    ENDIF 
                  ENDIF 
                ELSE    Types other than 16 
                ALPHA = (-QNORM(NTPE,I)-C2+SLUPE*ANORM(NTPE,I))/ 
     1                                                    (SLUPE+C1(M)) 
                ENDIF 
           IF(ALPHA.GT.1.0.OR.ALPHA.LT.0.0) GO TO 125 
           L  =  IFIX(ALPHA/DALPHA) + 1 
           IF(NTPE.LE.16.AND.NTPE.GE.14) THEN 
                IF(L.GT.25) L = 25 
                KK    = NQC(M) 
CIM### 9/8/00 DETAIL 
                IF(L.GE.2.OR.IDETAIL.EQ.0) THEN 
                  PS    = QCURVE(KK,4,L) + (ALPHA - FLOAT(L-1)*0.04 )/ 
     1                   DALPHA * (QCURVE(KK,4,L+1) - QCURVE(KK,4,L)) 
                  ELSE   DETAILED FOR LOWER PORTION OF CURVE 
                  L2 = IFIX(ALPHA/DALPH2) + 1 
              PS    = QCURV2(KK,3,L2) + (ALPHA - FLOAT(L2-1)*0.0016 )/ 
     1                DALPH2 * (QCURV2(KK,3,L2+1) - QCURV2(KK,3,L2)) 
                  ENDIF 
                ELSE   types other than 16 
C#### WCH, 10/6/93.  CHECK RANGE ON L.  IF AT MAX, USE QFULL. 
                IF(L.LT.MMM) THEN 
                    PS    = QNORM(NTPE,L) + (ALPHA-ANORM(NTPE,L))/DALPHA 
     1                          * (QNORM(NTPE,L+1) - QNORM(NTPE,L)) 
                    ELSE 
                    PS    = QNORM(NTPE,MMM) 
                    ENDIF 
                ENDIF 
           IF(ABS(PS+C1(M)*ALPHA+C2).LE.EPSIL) GO TO 150 
C======================================================================= 
C     TRY NEXT LINE SEGMENT. 
C======================================================================= 
  125      I = I+ISIGN 
  126      IF(I.GT.0.AND.I.LT.MMM) GO TO 120 
C======================================================================= 
C     CONDITION FOR ICHK = 2 
C======================================================================= 
           IF(ICHK.EQ.2) THEN 
                NUMERR = NUMERR + 1 
                IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN 
                     WRITE(N6,900) 
                     IF(JCE.EQ.0) WRITE(N6,901)TIME,NOE(M),QFULL(M), 
     1                 AFULL(M),DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1), 
     2                 A(M,1,1),A(M,1,2),A(M,2,1),ALPHA,PS,C2,N 
                     IF(JCE.EQ.1) WRITE(N6,1901)TIME,KOE(M),QFULL(M), 
     1                 AFULL(M),DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1), 
     2                 A(M,1,1),A(M,1,2),A(M,2,1),ALPHA,PS,C2,N 
                     ENDIF 
                IF((-C1(M)*ALFMAX(NTPE)-C2).GT.P4(M)) THEN 
Cwch, 6/11/02. (LR)  Error print should be here, not after ELSE below. 
                     IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,903) 
                     IF(Q(M,1,2).GT.QFULL(M)) THEN 
                          Q(M,2,2) = Q(M,1,2) 
                          A(M,2,2) = A(M,1,2) 
                          ELSE 
                          Q(M,2,2) = QFULL(M) 
                          A(M,2,2) = AFULL(M) 
                          NUMERR = NUMERR + 1 
                          ENDIF 
                     RETURN 
                     ELSE 
                     IF(C2.GT.0.0) THEN 
                          IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,904) 
                          Q(M,2,2) = 0.0 
                          A(M,2,2) = 0.0 
                          NUMERR = NUMERR + 1 
                          RETURN 
                          ENDIF 
                     IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,902) 
                     A(M,2,2) = A(M,2,1) 
                     Q(M,2,2) = Q(M,2,1) 
                     NUMERR = NUMERR + 1 
                     RETURN 
                     ENDIF 
                ENDIF 
C======================================================================= 
C     END OF ICHK = 2 CONDITIONAL STATEMENTS 
C======================================================================= 
C     IF I HAS REACHED ZERO OR MMM START AT IOLD AND GO OTHER WAY 
C======================================================================= 
           ISIGN = -ISIGN 
           I     = IOLD(M)+ISIGN 
           ICHK  = 2 
           GO TO 126 
C======================================================================= 
C     LINE-C1*ALPHA-C2 AND LINE SEGMENT ARE PARALLEL. 
C     CHECK TO SEE IF THEY ARE CO-LINEAR. 
C======================================================================= 
  130      IF(NTPE.LE.16.AND.NTPE.GE.14) THEN 
                KK = NQC(M) 
CIM### 9/8/00 DETAIL Normal calculations were IDETAIL = 0 
              IF(IDETAIL.EQ.0) THEN 
                IF(ABS(C2+QCURVE(KK,4,I)-SLUPE*FLOAT(I-1)*.04).GT.EPSIL) 
     1                                                         GO TO 125 
                ALPHA = QCURVE(KK,2,I) + DALPHA/2.0 
                L     = IFIX(ALPHA/DALPHA) + 1 
                PS    = QCURVE(KK,4,L) + (ALPHA - FLOAT(I-1)*0.04)/ 
     1                DALPHA * (QCURVE(KK,4,L+1) - QCURVE(KK,4,L) ) 
             ELSE    This is detailed caculations section 
                IF (I.GE.26) THEN 
                ICIM = I-24 
          IF(ABS(C2+QCURVE(KK,4,ICIM)-SLUPE*FLOAT(ICIM-1)*.04).GT.EPSIL) 
     1                                                         GO TO 125 
                ALPHA = QCURVE(KK,2,ICIM) + DALPHA/2.0 
                L     = IFIX(ALPHA/DALPHA) + 1 
                ELSE 
                ICIM = I 
          IF(ABS(C2+QCURV2(KK,3,I)-SLUPE*FLOAT(I-1)*.0016).GT.EPSIL) 
     1                                                         GO TO 125 
                ALPHA = QCURV2(KK,2,I) + DALPH2/2.0 
                L2    = IFIX(ALPHA/DALPH2) + 1 
                ENDIF 
                IF (L.GE.2) THEN 
                PS = QCURVE(KK,4,L) + (ALPHA - FLOAT(ICIM-1)*0.04)/ 
     1               DALPHA * (QCURVE(KK,4,L+1) - QCURVE(KK,4,L)) 
                ELSE 
                PS = QCURV2(KK,3,L2) + (ALPHA - FLOAT(ICIM-1)*0.0016)/ 
     1                DALPH2 * (QCURV2(KK,3,L2+1) - QCURV2(KK,3,L2) ) 
                ENDIF 
                ENDIF   End of detailed calculations 
                ELSE  types other than 16 
              IF(ABS(C2 + QNORM(NTPE,I) - SLUPE*ANORM(NTPE,I)).GT.EPSIL) 
     1                                                         GO TO 125 
                ALPHA = ANORM(NTPE,I)    + DALPHA/2.0 
                L     = IFIX(ALPHA/DALPHA) + 1 
                PS    = QNORM(NTPE,L)    + (ALPHA-ANORM(NTPE,L))/DALPHA 
     +                       * (QNORM(NTPE,L+1) - QNORM(NTPE,L)) 
                ENDIF 
 150       IOLD(M) = I 
C======================================================================= 
C     IF VERY LOW FLOW, OBTAIN REFINED CALCULATION FOR CIRCULAR PIPE 
C======================================================================= 
           IF(ALPHA.LT.0.04.AND.NTPE.EQ.1) THEN 
               CALL NEWTON(ALPHA,PS,C1(M),C2,KFLAG) 
               IF(KFLAG.EQ.1) THEN 
                              A(M,2,2) = ALPHA*AFULL(M) 
                              Q(M,2,2) = PS*QFULL(M) 
                              RETURN 
                              ENDIF 
               IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN 
                    WRITE(N6,900) 
               IF(JCE.EQ.0) WRITE(N6,901)TIME,NOE(M),QFULL(M),AFULL(M), 
     +                      DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1), 
     +                      A(M,1,2),A(M,2,1),ALPHA,PS,C2,N 
               IF(JCE.EQ.1) WRITE(N6,1901)TIME,KOE(M),QFULL(M),AFULL(M), 
     +                      DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1), 
     +                      A(M,1,2),A(M,2,1),ALPHA,PS,C2,N 
                    NUMERR = NUMERR + 1 
                    ENDIF 
               IF((-C1(M)*ALFMAX(NTPE)-C2).GT.P4(M)) THEN 
                    IF(Q(M,1,2).GT.QFULL(M)) THEN 
                                        Q(M,2,2) = Q(M,1,2) 
                                        A(M,2,2) = A(M,1,2) 
                                        ELSE 
                                        IF(NPRINT.GE.1.AND.NUMERR. 
     +                                            LT.50) WRITE(N6,903) 
                                        Q(M,2,2) = QFULL(M) 
                                        A(M,2,2) = AFULL(M) 
                                        NUMERR = NUMERR + 1 
                                        ENDIF 
                    RETURN 
                    ELSE 
                    IF(C2.GT.0.0) THEN 
                             IF(NPRINT.GE.1.AND. 
     +                                 NUMERR.LT.50) WRITE(N6,904) 
                             Q(M,2,2) = 0.0 
                             A(M,2,2) = 0.0 
                             NUMERR   = NUMERR + 1 
                             RETURN 
                             ENDIF 
                    IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,902) 
                    A(M,2,2) = A(M,2,1) 
                    Q(M,2,2) = Q(M,2,1) 
                    NUMERR = NUMERR + 1 
                    RETURN 
                    ENDIF 
               ENDIF 
           A(M,2,2) = ALPHA * AFULL(M) 
           Q(M,2,2) =    PS * QFULL(M) 
           RETURN 
           ENDIF 
C=================================================================== 
C	END OF IF-REALM FOR CHANNELS WITH FUNCTIONAL Q-A RELATIONSHIP. 
C=================================================================== 
C 
C=========> ELEMENT IS NOT A CONDUIT. 
C 
C==================================================================== 
      NGOTO = NTPE - 18 
C==================================================================== 
C     ERROR ===> CONDUITS SHOULD BE KLASS 1 OR 2  (NTPE < 19) 
C==================================================================== 
      IF(NGOTO.LT.1) THEN 
                     QO(M)  = QI(M) 
                     NUMERR = NUMERR + 1 
                     IF(NPRINT.GT.0.AND.NUMERR.LT.50) WRITE(N6,905) M 
                     RETURN 
                     ENDIF 
C==================================================================== 
C     MANHOLE ===> SIMPLY TRANSLATE FLOW WITH NO TIME DELAY (NTPE = 19) 
C==================================================================== 
      IF(NGOTO.EQ.1) THEN 
                     QO(M) = QI(M) 
                     RETURN 
                     ENDIF 
C==================================================================== 
C     LIFT STATION ===> PUMPS ASSUMED TO BE PUMPING AT CONSTANT RATE 
C     FORCE MAIN ASSUMED TO REMAIN FULL AT ALL TIMES RESULTING IN NO 
C     VOLUME IN WET WELL INITIALLY IS HALF THE CAPACITY(GEOM1). 
C     TIME DELAY.  (NTPE = 20) 
C==================================================================== 
      IF(NGOTO.EQ.2) THEN 
                     WELL2(M) = WELL2(M) + QI(M)*DT 
                     IF(WELL2(M).GE.GEOM1(M)) THEN 
                             IF(WELL2(M).GE.PUMP(M)*DT) THEN 
                                         QO(M)    = PUMP(M) 
                                         WELL2(M) = WELL2(M)-PUMP(M)*DT 
                                         GEOM2(M) = 1.0 
                                         RETURN 
                                         ELSE 
                                         QO(M)    = WELL2(M)/DT 
                                         WELL2(M) = 0.0 
                                         GEOM2(M) = 0.0 
                                         RETURN 
                                         ENDIF 
                     ENDIF 
                     IF(GEOM2(M).LE.0.0) THEN 
                             QO(M)    = 0.0 
                             GEOM2(M) = 0.0 
                             RETURN 
                             ELSE 
                             IF(WELL2(M).GE.PUMP(M)*DT) THEN 
                                         QO(M)    = PUMP(M) 
                                         WELL2(M) = WELL2(M)-PUMP(M)*DT 
                                         GEOM2(M) = 1.0 
                                         RETURN 
                                         ELSE 
                                         QO(M)    = WELL2(M)/DT 
                                         WELL2(M) = 0.0 
                                         GEOM2(M) = 0.0 
                                         RETURN 
                                         ENDIF 
                             ENDIF 
                     ENDIF 
C==================================================================== 
C     ROUTINE FOR TYPE 21 AND TYPE 24 FLOW DIVIDERS. 
C     TYPE 21 MAY BE USED FOR A SIMPLE OVERFLOW STRUCTURE. 
C     TYPE 24 MAY BE USED WITH A CUNNETTE SECTION DOWNSTREAM. 
C==================================================================== 
      IF(NGOTO.EQ.3.OR.NGOTO.EQ.6) THEN 
                     QO(M) = QI(M) 
                     IF(GEOM1(M).GT.0.0)   THEN 
                          IF(QI(M).LE.GEOM1(M)) THEN 
                                            QO1(M) = QI(M) 
                                            QO2(M) = 0.0 
                                            ELSE 
                                            QO1(M) = GEOM1(M) 
                                            QO2(M) = QI(M)-GEOM1(M) 
                                            ENDIF 
                          ELSE 
C==================================================================== 
C     MODIFICATION MADE 9/26/89 TO ALLOW GEOM1(M) TO INDICATE 
C     A PIPE THAT WILL ONLY ALLOW QFULL(M) TO PASS TO GEOM3(M). 
C==================================================================== 
                          L      = GEOM3(M) 
                          BMJ    = KGEOM(M) 
                          NEXRAM = NIN(L,BMJ) 
                          IF(QI(M).LE.QFULL(NEXRAM)) THEN 
                                            QO1(M) = QI(M) 
                                            QO2(M) = 0.0 
                                            ELSE 
                                            QO1(M) = QFULL(NEXRAM) 
                                            QO2(M) = QI(M)-QFULL(NEXRAM) 
                                            ENDIF 
                          ENDIF 
                     RETURN 
                     ENDIF 
C==================================================================== 
C     STORAGE ELEMENT. ADAPTED FROM STORAGE/TREATMENT BLOCK. 
C==================================================================== 
      IF(NGOTO.EQ.4) THEN 
                     KSTOR = KSTORE(M) 
                     QINST = QI(M) 
                     CALL TSTORG 
                     QO1(M) = QOUST1 
                     QO2(M) = QOUST2 
                     QO(M)  = QOUST1 + QOUST2 
                     RETURN 
                     ENDIF 
C==================================================================== 
C     ROUTINE FOR TYPE 23 FLOW DIVIDER. 
C     USE WITH SIDE WEIR OR OTHER WEIR TYPE DIVERSION. 
C     DIST  = MAX FLOW WITHOUT FLOW OVER WEIR. 
C     SLOPE = MAXIMUM FLOW THROUGH WHOLE STRUCTURE. 
C     ROUGH = WEIR CONSTANT TIMES WEIR LENGTH. 
C     GEOM1 = WEIR HEIGHT. 
C     GEOM2 = DEPTH IN STRUCTURE AT TIME OF MAXIMUM FLOW. 
C     GEOM3 = DOWNSTREAM EXT. ELE. NUM. INTO WHICH GOES UNDIVERTED FLOW. 
C             FLOW OVER WEIR IS THE DIVERTED FLOW. 
C==================================================================== 
      IF(NGOTO.EQ.5) THEN 
                     QO(M) = QI(M) 
                     IF(QI(M).GT.SLOPE(M).AND.JCE.EQ.0) WRITE(N6,920) 
     +                                     TIME,NOE(M),QI(M) 
                     IF(QI(M).GT.SLOPE(M).AND.JCE.EQ.1) WRITE(N6,921) 
     +                                     TIME,KOE(M),QI(M) 
                     IF (QI(M).LE.DIST(M)) THEN 
                                           QO2(M) = 0.0 
                                           QO1(M) = QI(M) 
                                           RETURN 
                                           ENDIF 
                     DH     = (QI(M)-DIST(M))/(SLOPE(M)-DIST(M)) * 
     +                                        (GEOM2(M)-GEOM1(M)) 
C#### WCH (RED), 9/93.  CHECK FOR LARGE ENOUGH VALUE OF DH. 
C#### RED (WCH), 12/31/93.  SET DEFAULT VALUE FOR QO2(M)  (= 0.0). 
                                       QO2(M) = 0.0 
                     IF(DH.GT.1.0E-10) QO2(M) = ROUGH(M)*DH*SQRT(DH) 
                     QO1(M) = QI(M) - QO2(M) 
                     QO1(M) = AMAX1(QO1(M),DIST(M)) 
                     QO2(M) = QI(M) - QO1(M) 
                     RETURN 
                     ENDIF 
C==================================================================== 
C     ROUTINE FOR BACKWATER ELEMENT. 
C     ELEMENT ACTS AS FLOW DIVIDER. 
C     GEOM3 = ELEMENT NUMBER OF DOWNSTREAM STORAGE UNIT. 
C 
C     IF BACKWATER EXTENDS ALL THE WAY UP TO ELEMENT, 
C     THEN WHOLE FLOW IS DIVERTED TO STORAGE ELEMENT. 
C     ASSUME LENGTH OF BACKWATER IS PROPORTIONAL TO SQRT OF STORAGE 
C     VOLUME. 
C==================================================================== 
      IF(NGOTO.EQ.7) THEN 
               QO(M)  = QI(M) 
               L      = GEOM3(M) 
               BMJ    = KGEOM(M) 
               L      = NIN(L,BMJ) 
               KSTOR  = KSTORE(L) 
               MINT   = MINTS(KSTOR) 
C#### WCH, 10/6/93.  CHANGE STORL() TO STORE(). 
               QO1(M) = QI(M)*SQRT(STORE(KSTOR)/TSTORE(KSTOR,MINT)) 
               IF(QO1(M).GT.QI(M)) QO1(M) = QI(M) 
               QO2(M) = QI(M) - QO1(M) 
               RETURN 
               ENDIF 
C####################################################################### 
C      WCH, 8/93. 
C      ROUTINE FOR TABULAR DIVERSION  NTYPE = 26 
C      WRITTEN BY CHUCK MOORE, CDM, 8/93 
C======================================================================= 
      IF(NGOTO.EQ.8) THEN 
         QO(M) = QI(M) 
         KIN   = KINOUT(M) 
         DO 400 IM=1,NSPLIT(KIN) 
         INEXT = IM 
         IF (SPLITIN(KIN,IM).GE.QI(M)) GO TO 405 
  400    CONTINUE 
C======================================================================= 
C  PRINT WARNING IF INFLOW EXCEEDS MAXIMUM TABULAR VALUE. 
C======================================================================= 
         WRITE(N6,940) TIME,N 
         IF(JCE.EQ.0) WRITE(N6,1030) NOE(M) 
         IF(JCE.EQ.1) WRITE(N6,1031) KOE(M) 
         WRITE(N6,1035) QI(M),SPLITIN(KIN,NSPLIT(KIN)) 
         UNDIV = SPLITOUT(KIN,NSPLIT(KIN)) 
         GO TO 410 
  405    IF(INEXT.EQ.1) THEN 
            UNDIV = SPLITOUT(KIN,INEXT) 
            ELSE 
            RRATIO = (QI(M)-SPLITIN(KIN,INEXT-1))/ 
     1             (SPLITIN(KIN,INEXT)-SPLITIN(KIN,INEXT-1)) 
            UNDIV = SPLITOUT(KIN,INEXT-1) + 
     1      RRATIO*(SPLITOUT(KIN,INEXT)-SPLITOUT(KIN,INEXT-1)) 
            ENDIF 
  410    DIVERT = QI(M) - UNDIV 
         QO1(M) = UNDIV 
         QO2(M) = DIVERT 
         RETURN 
      ENDIF 
C####################################################################### 
C      WCH, 4/99 
C      ROUTINE FOR QUALITY FLOW SPLITTER NTYPE = 27 
C==================================================================== 
C       SIMPLY TRANSLATE FLOW WITH NO TIME DELAY 
C       SAME AS MANHOLE(NTPE = 19) 
C==================================================================== 
      IF(NGOTO.EQ.9) THEN 
                     QO(M) = QI(M) 
                     RETURN 
                     ENDIF 
C==================================================================== 
  900 FORMAT(/,' ===> ITERATION FOR DOWNSTREAM FLOW HAS NOT CONVERGED.', 
     +/,'      Q(CHANNEL,1-UPSTREAM 2-DOWNSTREAM,1-START 2-END)',/,3X 
     1,'TIME  ELEMENT  QFULL  AFULL  DXDT  Q(M,1,1) Q(M,1,2) Q(M,2,1) A( 
     2M,1,1) A(M,1,2) A(M,2,1)  ALPHA     PS     C2 TIME STEP') 
  901 FORMAT(1PE8.2,I10,0PF9.1,F7.2,F7.1,3F9.2,3F9.3,3F7.3,I10) 
 1901 FORMAT(1PE8.2,A10,0PF9.1,F7.2,F7.1,3F9.2,3F9.3,3F7.3,I10) 
  902 FORMAT(/,' ===> REASON FOR NON-CONVERGENCE UNDETERMINED. USE Q,A V 
     +ALUES AT PREVIOUS TIME STEP.') 
  903 FORMAT(/,' ===> CONTINUITY EQN TRIES TO FORCE Q.GT.QMAX. USE QFULL 
     + UNLESS UPSTREAM Q.GT.QFULL - THEN USE UPSTREAM VALUE.') 
  904 FORMAT(/,' ===> CONTINUITY EQN TRIES TO FORCE Q < 0.0   USE', 
     +         ' ZERO FLOW.') 
  905 FORMAT(/,' ===> ERROR  CONDUITS SHOULD BE CLASS 1 OR 2. M= ',I5) 
  910 FORMAT(/,' ===> WARNING   NEWTON UNABLE TO FIND AREA GIVEN FLOW. 
     + TIME = ',F7.1,', TIME STEP=',I3,/, 
     +'       EXT. ELE. NUM.=',I8,', USE OLD UPSTREAM AREA = ',F6.2) 
  911 FORMAT(/,' ===> WARNING   NEWTON UNABLE TO FIND AREA GIVEN FLOW. 
     + TIME = ',F7.1,', TIME STEP=',I3,/, 
     +'       EXT. ELE. NUM.= ',A10,', USE OLD UPSTREAM AREA = ',F6.2) 
  920 FORMAT(/,' ===> WARNING . TIME = ',E14.7,' ELEMENT',I9, 
     +  '      MAX FLOW TO TYPE 23 DIVIDER EXCEEDED. INFLOW = ',E14.7) 
  921 FORMAT(/,' ===> WARNING . TIME = ',E14.7,' ELEMENT ',A10, 
     +  '      MAX FLOW TO TYPE 23 DIVIDER EXCEEDED. INFLOW = ',E14.7) 
  930 FORMAT(/,' ====> ALLOWABLE ERRORS IN ROUTE EXCEEDED.',/, 
     +         ' ====> PRINTOUT OF ERRORS ENDED.') 
C#### WCH (CDM), 8/93. 
  940 FORMAT(' WARNING - INFLOW TO TYPE 26 FLOW DIVIDER EXCEEDS MAXIMUM 
     1INFLOW SPECIFIED IN TABLE.',/,' TIME =',F7.1,' SEC., TIME STEP =' 
     2 ,I5) 
 1030 FORMAT(' TABULAR FLOW SPLIT ELEMENT # ',I10) 
 1031 FORMAT(' TABULAR FLOW SPLIT ELEMENT # ',A10) 
 1035 FORMAT('+',40X,', INFLOW = ',F10.3,' CFS, MAXIMUM IN TABLE = ', 
     1 F10.3,' CFS.') 
C======================================================================= 
      END 
 
REM File: SNOW.FOR 
 
      SUBROUTINE SNOW(TA,SMIMED,J,K,II,RIN,RINE,ASC,WINDY,KOMPUT) 
C     RUNOFF BLOCK 
C     CALLED BY WSHED NEAR LINE 254, 266, 278, 290 
C======================================================================= 
C     This subroutine adds/deletes water from snow pack, performs 
C       redistribution of snow, calls AREAL and MELT, and routes  
C       liquid water through snow pack. 
C     Updated 4/7/94 by WCH to indicate if snow is present in  
C       catchment.  Put new variable KWIKSN in SUBCAT.INC.   
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
C======================================================================= 
C     Add new snow to snow pack. 
C======================================================================= 
      IF(RIN.LT.0.0) WSNOW(II,J) = WSNOW(II,J)-RIN*DELT 
      IF(WSNOW(II,J).LE.0.0) RETURN 
C####################################################################### 
C#### WCH, 4/7/94.  Here, indicate presence of snow in order to set 
C       WET time step in Sub. HYDRO. 
C======================================================================= 
      KWIKSN = 1 
C 
      IF(K.EQ.2.OR.K.EQ.4) GO TO 110 
C======================================================================= 
C     Can redistribute snow (e.g., plow) off subareas 1 and 3 for  
C     continuous simulation (ISNOW=2).  This is only done once since 
C     only call Sub. SNOW once for subareas 1 and 3. 
C======================================================================= 
      IF(ISNOW.EQ.2) GO TO 105 
C======================================================================= 
C     If ISNOW = 1 and there is no new snow (RIN >= 0), RETURN. 
C     Else, there is snow on "normally bare" area.  It is all immediately 
C     melted at statement 115.  
C======================================================================= 
      IF(RIN.GE.0.0) RETURN 
      IF(RIN.LT.0.0) GO TO 115 
C======================================================================= 
C     IMPERVIOUS AREA WITH DEPRESSION STORAGE (K=1). 
C     PERFORM SNOW CALCS ONLY FOR ISNOW=2 (CONTINUOUS MELT). 
C     NORMALLY WITH NO SNOW BUT MAY HAVE UP TO WEPLOW FT WATER EQUIV. 
C 
C     CHECK FOR REDISTRIBUTION OF SNOW (PLOWING). 
C     Arrive here only for subarea 1 or 3 and for continuous simulation. 
C======================================================================= 
  105 IF(WSNOW(3,J).LT.WEPLOW(J)) GO TO 110 
      EXC = WSNOW(3,J)-WEPLOW(J) 
C======================================================================= 
C     MOVE EXCESS SNOW TO: 
C        OTHER IMPERVIOUS IN SUBCATCHMENT, 
C        (FRACTIONS HAVE BEEN MULTIPLIED BY (WAR(1,J)+WAR(3,J))/WAR(KX,JX) 
C        EARLIER.) 
C======================================================================= 
      WSNOW(1,J) = WSNOW(1,J)+SFRAC(1,J)*EXC 
C======================================================================= 
C     PERVIOUS IN SUBCATCHMENT, 
C======================================================================= 
      WSNOW(2,J) = WSNOW(2,J)+SFRAC(2,J)*EXC 
C======================================================================= 
C     PERVIOUS IN LAST SUBCATCHMENT, 
C======================================================================= 
      WSNOW(2,NOW) = WSNOW(2,NOW)+SFRAC(3,J)*EXC 
C======================================================================= 
C     OUT OF SYSTEM, (KEEP TALLY ON THIS QUANTITY), 
C======================================================================= 
      CNT(9) = CNT(9) + SFRAC(4,J)*EXC 
C======================================================================= 
C        CONVERT TO IMMEDIATE MELT. 
C======================================================================= 
      SMIMED     = SFRAC(5,J)*EXC/DELT 
      WSNOW(3,J) = WEPLOW(J) 
C======================================================================= 
C     SNOW MELT CALCULATIONS FOR ALL AREAS. 
C======================================================================= 
  110 SMELT = 0.0 
      RI    = RINE 
C======================================================================= 
C     Upon entering this subroutine, RINE = rain, if raining, or 
C     zero if snowing.  
C     CEASE SNOW CALCS WHEN AMT LT 0.001 IN. (0.00008 FT). 
C======================================================================= 
      IF(WSNOW(II,J).GT.0.00008) GO TO 120 
  115 SMIMED      = SMIMED + (WSNOW(II,J) + FW(II,J))/DELT 
      WSNOW(II,J) = 0.0 
      FW(II,J)    = 0.0 
      IF(ISNOW.EQ.2) COLDC(II,J) = 0.0 
      ASC = 0.0 
      RETURN 
C======================================================================= 
C     DETERMINE FRACTION OF AREA THAT IS SNOW COVERED = ASC. 
C======================================================================= 
  120                           ASC = 1.0 
      IF(ISNOW.EQ.1.AND.K.EQ.2) ASC = SNCP(J) 
      IF(ASC.LE.0.0) RETURN 
C 
      IF(ISNOW.NE.2) GO TO 130 
      IF(K.EQ.2) CALL AREAL(WSNOW(II,J),SI(II,J),NEWSNO(II,J),ASC, 
     1                  AWE(II,J),SBA(II,J),SBWS(II,J),RIN,ADCP,DELT) 
C 
      IF(K.EQ.4) CALL AREAL(WSNOW(II,J),SI(II,J),NEWSNO(II,J),ASC, 
     1                  AWE(II,J),SBA(II,J),SBWS(II,J),RIN,ADCI,DELT) 
C 
C     DETERMINE MELT RATE (FT/SEC) = SMELT. 
C     MELT RETURNS SMELT, IF MELT OCCURS, OR ELSE ADDS TO COLD CONTENT. 
C 
                     DHM = DH(II,J) 
  130 IF(ISNOW.EQ.1) DHM = DHMAX(II,J) 
      IF(WSNOW(II,J).GT.0.0) CALL MELT(DHM,TBASE(II,J),RIN,TA,DELT, 
     1SMELT,COLDC(II,J),ATI(II,J),WINDY,ASC,WSNOW(II,J),KOMPUT) 
C======================================================================= 
      IF(SMELT.LE.0.0) RETURN 
C======================================================================= 
C     ROUTE MELT THROUGH SNOW PACK. 
C     Return snowmelt to Sub. WSHED through RI, in COMMON "Detail.inc" 
C======================================================================= 
                            RI = SMELT*DELT*ASC 
      IF(RI.GT.WSNOW(II,J)) RI = WSNOW(II,J) 
      WSNOW(II,J) = WSNOW(II,J) - RI 
      FW(II,J)    = FW(II,J) + RI + RINE*DELT 
      RI          = FW(II,J) - FWFRAC(II)*WSNOW(II,J) 
      IF(RI.LT.0.0) RI = 0.0 
      FW(II,J)         = FW(II,J) - RI 
      RI               = RI / DELT 
      RETURN 
      END 
 
 
REM File: STATS.FOR 
 
      SUBROUTINE STATS 
C======================================================================= 
C                 STATISTICAL ANALYSIS BLOCK WRITTEN BY 
C 
C                           DONALD J. POLMANN 
C                   ENVIRONMENTAL ENGINEERING SCIENCES 
C                         UNIVERSITY OF FLORIDA 
C                         GAINESVILLE,  FLORIDA 
C       JULY 1981         (UPDATED JANUARY 1983) 
C       OCTOBER 1985      (REVISED BY BOB DICKINSON) 
C       OCTOBER 1988      (REVISED BY BOB DICKINSON) 
C       MAY     1989      (REVISED BY BOB DICKINSON) 
C       SEPTEMBER 1990    (REVISED BY LAURA TERRELL, CDM) 
C       December 1990     (REVISED BY BOB DICKINSON) 
C       December 1992     (Zero divide check, WCH) 
C       July 1993         WCH. Labels for return period in years, 
C                           and miscellaneous format corrections. 
C                         Use average and max flow values of cfs 
C                           and cms, not cf/hr or m^3/hr. 
C                         Make sure tables are sorted before plotting. 
C                         Warn about small return periods. 
C       November 1993     Correction for metric conversions and make 
C                         summations consistent with other blocks 
C                         regarding time step averaging, WCH. 
C       2/27/95, WCH.     Mysterious correction to read arrays 
C                         IEVNTB, TEVNTB again off NOUT because they 
C                         are somehow corrupted earlier, prior to 
C                         sorting, resulting in wrong date assigned 
C                         to ranked data. 
C       8/1/95, WCH.      To correspond to Rain Block change, change 
C                         rainfall station ID, LOCRN, to character. 
C       8/7/95, WCH.      Add check for requested ending date before 
C                         first date on interface file. 
C       7/22/96, WCH.     Correct computation of rainfall interevent 
C                         times (was THISTO too great). 
C       7/23/96, WCH.     Correct computation of flow etc. duration 
C                         and interevent times.  Correct print-out of 
C                         interevent time for flows etc. (was off by 
C                         one line).  Add fix to catch first flow etc. 
C                         event when it starts before time MIT. 
C                         Add event number to event print out.  Add 
C                         message explaining duration and interevent 
C                         calculation for hydrographs.  Print all 
C                         concentrations with G-format.  Improve 
C                         print-out of KTSEQS.  Print correct 
C                         definition of JCUBE. 
C       7/29/96, WCH.     Additional initialization.  Otherwise, 
C                         parameter METRIC was incremented on successive 
C                         STATS runs, if slash delimeter (nul input) 
C                         was used on B1 input line 
C       8/7/96, WCH.      Correction for event separation. 
C      10/2/96, WCH.      Remove extra BACKSPACE in error routine. 
C       6/3/97, CIM.      Add check for zero TRIBA for JCUBE=0 option. 
C       9/8/00, CIM.      Modify to check against KTIME instead of KREAD. 
C     11/24/03, WCH.      Fix computation for avg. flow for depth/time. 
C======================================================================= 
C     THE STATS BLOCK WILL PERFORM STATISTICAL ANALYSES ON EVENTS OF 
C     STORMWATER FLOW AT ONE CHOSEN LOCATION.  THE OPTIONS AVAILABLE 
C     INCLUDE A TABLE OF MAGNITUDE,   RETURN PERIOD AND FREQUENCY, A 
C     GRAPH OF MAGNITUDE VS. RETURN PERIOD, A GRAPH OF MAGNITUDE VS. 
C     FREQUENCY, AND THE FIRST THREE MOMENTS OF THE EVENT DATA.  ANY 
C     OR ALL OF THESE OPTIONS CAN BE CHOSEN FOR ANY OR ALL OF FIVE 
C     RAINFALL PARAMETERS (VOLUME, AVERAGE INTENSITY, PEAK INTENSITY, 
C     EVENT DURATION, AND INTEREVENT DURATION).  ANY 
C     OR  ALL OF THESE OPTIONS CAN BE CHOSEN FOR ANY OR  ALL OF FIVE 
C     FLOW PARAMETERS (TOTAL FLOW,  AVERAGE FLOW,  PEAK FLOW,  EVENT 
C     DURATION,  INTEREVENT DURATION)  AND FIVE POLLUTANT PARAMETERS 
C     (TOTAL LOAD,  AVERAGE LOAD,  PEAK LOAD,  FLOW WEIGHTED AVERAGE 
C     CONCENTRATION,PEAK CONCENTRATION). THE FLOW/POLLUTANT DATA ARE 
C     SEPARATED INTO EVENTS ON THE BASIS OF FLOW RATE WHETHER OR NOT 
C     ANY STATISTICAL  OPTIONS ARE SELECTED FOR FLOW.   FROM ZERO TO 
C     TEN POLLUTANTS MAY BE ANALYZED. 
C======================================================================= 
C     THE  STATS BLOCK  MAY BE CALLED AFTER ANY BLOCK THAT GENERATES 
C     AN INTERFACE FILE OF FLOW AND POLLUTANT DATA.  BESIDES INSTAN- 
C     TANEOUS VALUES FOR FLOW RATE,  THE FILE MAY CONTAIN  UP TO TEN 
C     POLLUTANTS.  THE NUMBER OF LOCATIONS IN THE FILE IS LIMITED TO 
C     200.  THE NUMBER OF TIME STEPS IS NOT DIRECTLY CONSTRAINED BUT 
C     THE NUMBER OF EVENTS THAT CAN BE SORTED AND ANALYZED IS LIMIT- 
C     ED TO 4000. THE NUMBER OF EVENTS IN A GIVEN TIME SERIES IS DE- 
C     PENDENT ON THE USER-DEFINED MINIMUM INTEREVENT TIME. THIS LIM- 
C     IT OF 4000  EVENTS CAN BE EXTENDED (OR DECREASED)  BY THE USER 
C     BY ALTERING THE PARAMETER STATEMENT FOR LIMIT (E.G., 
C     LIMIT=4000) IN STCOM.INC, CONTAINING THE STATS BLOCK 
C     COMMON GROUPS. 
C======================================================================= 
C     THE  STATS BLOCK  INCLUDES THE SUBROUTINES 'STATS',  'SBTABL', 
C     'MOMENT',   'SORT',  'POINTS',  AND 'STBLOCK'.  OTHER SWMM SUB- 
C     ROUTINES CALLED INCLUDE 'CURVE'. 
C======================================================================= 
C 
C     ATTENTION VAX PROGRAMMERS:  YOU MAY ENCOUNTER AN OUTPUT OVERFLOWS 
C     RECORD ERROR BECAUSE OF THE LENGTH OF THE FORMAT STATEMENT 
C     (I.E., 3550).  A SOLUTION TO THIS MAY BE TO MODIFY THE FDL FILE 
C     ASSOCIATED WITH YOUR OUTPUT FILE TO INCREASE RECORD LENGTH. 
C 
C======================================================================== 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'LAB.INC' 
      INCLUDE 'STCOM.INC' 
C======================================================================= 
CIM CHANGE DIMENSIONS FROM 10 TO MQUAL 
      DIMENSION FLOWP(5),POLLP(MQUAL,5),Q(NIE),POLL(MQUAL,NIE), 
     1          PCONV(MQUAL),IFPAR(5),IPPAR(MQUAL,5),ISFLOW(10,6), 
     1          ISPOLL(MQUAL,5,5) 
C#### WCH, 7/21/93. INCREASE DIMENSION OF RPHOR TO 3. 
CIM INCREASE HYDROGRAPHS  ~~~~~~~~~~~~~~~~~~~~~~~ 
      DIMENSION RPHOR(3),PHOR(2),VRTITL(15),SICONV(9,2),JSTA(MAXRG) 
CIM  CHANGE TO WRITE ALL PARAMETERS 
      DIMENSION PEMC(MQUAL),PLOAD(MQUAL),PLSUM(MQUAL) 
cim      DIMENSION RPHOR(3),PHOR(2),VRTITL(15),SICONV(9,2),JSTA(10) 
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
      REAL MIT 
C#### WCH, 7/21/93. MAKE NEWLAB BE 8 BYTES TO AGREE WITH ENGLAB. 
      CHARACTER RPTITL*30,PTITL*30,BLANK*10,PHOR*30, 
     1          BMJ*10,KOCRQ*10,RPHOR*30,VRTITL*10,NEWLAB(4)*8, 
     2          COND*3,OLD*3,QUAN(3)*8,OTHER(4)*8,PAA(MQUAL)*8 
C#### WCH, 8/1/95. CHANGE PRECIP. STATION ID TO CHARACTER AND 3 MORE. 
      CHARACTER*8 JSTA, BLANK1*1,TRYLOC*8,TRYSTA*8 
C======================================================================= 
      DATA SICONV/9*1.0,3*25.4,3*0.4536,3*28.32/ 
      DATA RPTITL/'Magnitude vs. Return period'/ 
      DATA PTITL /'Magnitude  vs.  Frequency  '/ 
C#### WCH, 7/21/93.  ADD LABEL FOR YEARS. 
      DATA RPHOR/' Base 10 Log of Return period',' (Log months)  ', 
     +                                           ' (Log years)   '/ 
      DATA PHOR/'  Percent of occurrences less', 
     +          'than/equal to given magnitude'/ 
      DATA VRTITL/' Total  Q ',' Avg   Q  ', 
     +            '  Peak  Q ',' Duration ', 
     +            'Interevent','Total load', 
     +            ' Avg load ','Peak load ', 
     +            ' Avg conc.','Peak conc.', 
     +            ' Total V  ','Avg  int. ', 
     +            ' Peak int.', 
     +            ' Duration ','Interevent'/ 
      DATA QUAN/'Quantity','Quan/hr ','Quan/hr '/ 
      DATA OTHER/'ft3*unit','cfs*unit','lit*unit','l/s*unit'/ 
C#### WCH, 8/1/95.  ADD SINGLE BLANK. 
      DATA BLANK/'          '/,BMJ/'          '/,BLANK1/' '/ 
C#### WCH, 7/21/93.  UNITS OF CFS AND CMS AND 8 BYTES. 
      DATA NEWLAB/'feet^3  ',' cfs    ','meter^3 ','m^3/sec '/ 
C======================================================================= 
C     Label the graphs in Subroutine Curve. 
C======================================================================= 
      VERT1  = BLANK 
      VERT2  = BLANK 
      VERT3  = BLANK 
      INCNT  = INCNT  + 1 
      IOUTCT = IOUTCT + 1 
      LAST   = JIN(INCNT) 
      NOUT   = JOUT(IOUTCT) 
      IF(LAST.LE.0) CALL ERROR(130) 
      IF(NOUT.LE.0) CALL ERROR(131) 
      WRITE(*,34) 
      WRITE(N6,34) 
C======================================================================= 
C     Open all input/output files for the Statistics Block. 
C======================================================================= 
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR. 
     +      FFNAME(INCNT).EQ.'JIN.UF')) 
     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND. 
     +      FFNAME(INCNT).NE.'JIN.UF') 
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR. 
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF')) 
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND. 
     +      FFNAME(25+IOUTCT).NE.'JIN.UF') 
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
C======================================================================= 
      REWIND (NOUT) 
      REWIND (LAST) 
C======================================================================= 
C     Initialize several variables and arrays. 
C======================================================================= 
      COND       = 'DRY' 
      OLD        = 'DRY' 
C#### WCH, 8/1/95.  INITIALIZE LOCRN. 
      LOCRN      = '        ' 
C#### WCH, 7/29/96.  INITIALIZE ADDITIONAL VARIABLES. 
      METRIC     = 0 
      ISTART     = 0 
      TSTART     = 0. 
      IEND       = 0 
      TEND       = 0. 
      INLOG      = 0 
      JCUBE      = 0 
      MIT        = 0 
      BASE       = 0. 
      EBASE      = 0. 
      LOCRQ      = 0 
      KOCRQ      = '        ' 
      LLOCRN     = 0 
      NPR        = 0 
      NPOINT     = 0 
      LRET       = 0 
      A          = 0. 
C 
      NNEND      = 0 
      NEXIT      = 0 
      IPEVNT     = 0 
      IDATEZ     = 0 
      DRYTS      = 0.0 
      TZERO      = 0.0 
      HSEC       = 3600.0 
      DO 5 I     = 1,5 
      IFPAR(I)   = 0 
    5 FLOWP(I)   = 0.0 
      DO 6 I     = 1,5 
      DO 6 J     = 1,MQUAL 
      POLLP(J,I) = 0.0 
    6 IPPAR(J,I) = 0 
C======================================================================= 
C >>>>Read Data Group A1 <<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,ISTART,TSTART,IEND,TEND,INLOG,JCUBE,JNEG 
      JYEAR = ISTART/10000 
      IF ((ISTART.GT.0).AND.(JYEAR.LT.100)) THEN 
      ISTART = ISTART - JYEAR*10000 
      JYEAR = JYEAR + 1900 
      ISTART = ISTART + JYEAR*10000 
      ENDIF 
      JYEAR = IEND/10000 
      IF ((IEND.GT.0).AND.(JYEAR.LT.100)) THEN 
      IEND = IEND - JYEAR*10000 
      JYEAR = JYEAR + 1900 
      IEND = IEND + JYEAR*10000 
      ENDIF 
C======================================================================= 
C>>>>>>>>>> Read Data Group B1 <<<<<<<<<<<<<<<<< 
C======================================================================= 
C#### WCH, 8/1/95. 
C     LOCRN CHANGED TO CHARACTER.  INSTALL AN ERROR CHECK IN CASE 
C     USER MISTAKENLY PUTS IT IN AS INTEGER.  IF SO, CONVERT TO CHARCT. 
C     MAY NOT NEED THIS FOR LAHEY  LAHEY APPARENTLY READS CHARACTER 
C     VARIABLES CORRECTLY EVEN IF NOT INCLUDED IN QUOTES 
C======================================================================= 
      IF(JCE.EQ.0) THEN 
                   READ(N5,*,ERR=885) CC,MIT,BASE,EBASE,LOCRQ, 
     +                                LOCRN,NPR,NPOINT,METRIC,LRET,A 
                   GO TO 15 
  885              BACKSPACE N5 
C#### WCH (B. LAZERTE), 10/2/96.  REMOVE EXTRA BACKSPACE. 
C####                   BACKSPACE N5 
                   READ(N5,*,ERR=888) CC,MIT,BASE,EBASE,LOCRQ, 
     +                                LLOCRN,NPR,NPOINT,METRIC,LRET,A 
                   IF(LLOCRN.EQ.0) LOCRN = ' ' 
                   IF(LLOCRN.GT.0) WRITE(LOCRN,'(I8)') LLOCRN 
                   WRITE(N6,9040) LLOCRN 
                   ELSE 
                   READ(N5,*,ERR=886) CC,MIT,BASE,EBASE,KOCRQ, 
     +                                LOCRN,NPR,NPOINT,METRIC,LRET,A 
                   IF(KOCRQ.NE.' ') LOCRQ = 1 
                   GO TO 15 
  886              BACKSPACE N5 
                   BACKSPACE N5 
                   READ(N5,*,ERR=888) CC,MIT,BASE,EBASE,KOCRQ, 
     +                                LLOCRN,NPR,NPOINT,METRIC,LRET,A 
                   IF(LLOCRN.EQ.0) LOCRN = ' ' 
                   IF(LLOCRN.GT.0) WRITE(LOCRN,'(I8)') LLOCRN 
                   WRITE(N6,9040) LLOCRN 
                   IF(KOCRQ.NE.' ') LOCRQ = 1 
                   ENDIF 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(LOCRN.GT.0) INLOG = 0 
   15 IF(LOCRN.EQ.'0') LOCRN = ' ' 
      IF(LOCRN.NE.' ') INLOG = 0 
cim process all 
      IF (KOCRQ.EQ.'-1') LOCRQ = -1 
      LLOCRQ = LOCRQ 
      IF (LOCRQ.LT.0) THEN 
      LOCRQ = 1 
      WRITE(N6,8005) 
      ENDIF 
cim all 
      WRITE(N6,92) MIT,NPOINT,METRIC,LRET,A,INLOG,JCUBE,JNEG 
      METRIC = METRIC + 1 
      IF(LOCRQ.GT.0.AND.JCUBE.GT.0) THEN 
                                    ENGLAB(1) = NEWLAB(1) 
                                    ENGLAB(2) = NEWLAB(2) 
                                    ENGLAB(3) = NEWLAB(2) 
                                    SILAB(1)  = NEWLAB(3) 
                                    SILAB(2)  = NEWLAB(4) 
                                    SILAB(3)  = NEWLAB(4) 
                                    ENDIF 
C======================================================================= 
C>>>>>>> Read Data Group B2 <<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,KSEQ,KTERM,KTSEQS 
      WRITE(N6,93)          KSEQ,KTERM,KTSEQS 
C======================================================================= 
C >>>>>>>  Read Data Group B3 <<<<<<<<<<<<<<< 
C======================================================================= 
      IF(NPR.GT.0) READ(N5,*,ERR=888) CC,(IPOLRQ(K),K=1,NPR) 
C======================================================================= 
C >>>>>>>>>>> Read Data Group C1 <<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(LOCRQ.GT.0) THEN 
                     CALL INFACE(1,LAST) 
cim check for zero triba 
                     IF(TRIBA.LE.0.0.AND.JCUBE.EQ.0) THEN 
                     WRITE(N6,*) 'ERROR - TRIBA EQUALS ZERO,', 
     +                           ' CANNOT USE JCUBE = 0' 
                     WRITE(N6,*) '        SET JCUBE = 1' 
                     STOP ' ZERO TRIBA' 
                     ENDIF 
                     READ(N5,*,ERR=888) CC,(ISFLOW(1,J),J=1,5) 
                     DO 200 J = 1,5 
                     I1 = ISFLOW(1,J)/1000 
                     J2 = ISFLOW(1,J) - I1*1000 
                     I2 = J2/100 
                     J3 = J2 - I2*100 
                     I3 = J3/10 
                     I4 = J3 - I3*10 
                     ISFLOW(2,J) = I1 
                     ISFLOW(3,J) = I2 
                     ISFLOW(4,J) = I3 
                     ISFLOW(5,J) = I4 
                     IF(I1.EQ.1.OR.I2.EQ.1.OR.I3.EQ.1.OR.I4.EQ.1) 
     +                                              IFPAR(J) = 1 
  200                CONTINUE 
                     ENDIF 
C======================================================================= 
C >>>> Read Data Group D1 <<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(NPR.GT.0) THEN 
                   DO 250 J = 1,NPR 
                   READ(N5,*,ERR=888) CC,(ISPOLL(J,1,K),K=1,5) 
                   DO 275 K = 1,5 
                   I1 = ISPOLL(J,1,K)/1000 
                   J2 = ISPOLL(J,1,K) - I1*1000 
                   I2 = J2/100 
                   J3 = J2 - I2*100 
                   I3 = J3/10 
                   I4 = J3 - I3*10 
                   ISPOLL(J,2,K)  = I1 
                   ISPOLL(J,3,K)  = I2 
                   ISPOLL(J,4,K)  = I3 
                   ISPOLL(J,5,K)  = I4 
                   IF(I1.EQ.1.OR.I2.EQ.1.OR.I3.EQ.1.OR.I4.EQ.1) 
     +                                          IPPAR(J,K) = 1 
  275              CONTINUE 
  250              CONTINUE 
                   ENDIF 
C======================================================================= 
C >>>>>>>>>>> Read Data Group E1 <<<<<<<<<<<<<<<<<<< 
C======================================================================= 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(LOCRN.GT.0) THEN 
      IF(LOCRN.NE.' ') THEN 
                     REWIND (LAST) 
                     READ(LAST,ERR=9070) NSTA,MRAIN,(JSTA(I),I=1,NSTA) 
                     WRITE(N6,2115)  NSTA 
                     WRITE(N6,2120) (I,JSTA(I),I=1,NSTA) 
C======================================================================= 
C#### WCH, 8/1/95.  INORDINATE HASSEL TO COMPARE CHARACTER VARIABLES 
C     BECAUSE DON'T KNOW WHERE NON-BLANK CHARACTERS ARE IN FIELD. 
C     TRYLOC WILL BE RIGHT-ADJUSTED VALUE OF LOCRN, THAT IS, PUSH 
C     NON-BLANK CHARACTERS OF LOCRN TO RIGHT OF 8-CHARACTER FIELD. 
C     FUNCTION NBLANK() GIVES POSITION OF LAST NON-BLANK CHARACTER. 
C     CAUTION  FUNCTION NBLANK() MAY BE LAHEY-SPECIFIC. 
C     // OPERATOR IN LINE 230 IS CONCATENATION OPERATOR FOR CHARACTER 
C     VARIABLES.  BLANKS WILL BE "ADDED" ON LEFT, WITH EXTRA CHARACTERS 
C     (BEYOND 8-CHARACTER FIELD WIDTH) LOST TO RIGHT.  THESE LOST 
C     CHARACTERS ARE SUPPOSED TO BE BLANKS 
C======================================================================= 
c  nblank is lahey 
c                     NCLEN = 8 - NBLANK(LOCRN) 
c  len_trim is digital visual fortran 
                     NCLEN = 8 - LEN_TRIM(LOCRN) 
                     TRYLOC = LOCRN 
                     IF(NCLEN.GT.0) THEN 
                          DO 230 I = 1,NCLEN 
  230                     TRYLOC = BLANK1//TRYLOC 
                          ENDIF 
                     DO 290 I = 1,NSTA 
                     TRYSTA = JSTA(I) 
c nblank is lahey 
c                     NCLEN = 8 - NBLANK(JSTA(I)) 
c  len_trim is digital visual fortran 
                     NCLEN = 8 - LEN_TRIM(JSTA(I)) 
                     IF(NCLEN.GT.0) THEN 
                          DO 240 K = 1,NCLEN 
  240                     TRYSTA = BLANK1//TRYSTA 
                          ENDIF 
                     IF(TRYLOC.EQ.TRYSTA) THEN 
                                          MSTA = I 
                                          GO TO 295 
                                          ENDIF 
  290                CONTINUE 
C#### WCH, 8/7/95.  ENHANCE ERROR MESSAGE. 
                     WRITE(N6,9030) LOCRN,JSTA(NSTA) 
C#### WCH, 10/19/95.  ASSIGN VALUE OF MSTA 
                     MSTA = NSTA 
  295                CONTINUE 
                     READ(N5,*,ERR=888) CC,(ISFLOW(6,J),J=1,5) 
                     DO 300 J = 1,5 
                     I1 = ISFLOW(6,J)/1000 
                     J2 = ISFLOW(6,J) - I1*1000 
                     I2 = J2/100 
                     J3 = J2 - I2*100 
                     I3 = J3/10 
                     I4 = J3 - I3*10 
                     ISFLOW(7,J)  = I1 
                     ISFLOW(8,J)  = I2 
                     ISFLOW(9,J)  = I3 
                     ISFLOW(10,J) = I4 
                     IF(I1.EQ.1.OR.I2.EQ.1.OR.I3.EQ.1.OR.I4.EQ.1) 
     +                                              IFPAR(J) = 1 
  300                CONTINUE 
                     NPR = 0 
                     ENDIF 
C======================================================================= 
C     Set up pollutant conversions. 
C======================================================================= 
      IF(NPR.GT.0) THEN 
                   DO 350 K = 1,MQUAL 
                   PAA(K)   = BLANK 
                   IF(K.GT.NPR) GO TO 350 
                   JJ       = IPOLRQ(K) 
                   IF(METRIC.EQ.1) THEN 
C======================================================================= 
C        16018.93 is equal to 0.0353157 ft/l * 453592.4 mg/lb 
C        3.53157E-2 = ft3/l = 1/28.31605 
C======================================================================= 
                           PCONV(JJ) = 16018.93 
                           PAA(K)    = ENGLAB(6) 
                           IF(NDIM(JJ).EQ.1) PCONV(JJ) = 3.53157E-2 
                           IF(NDIM(JJ).EQ.1) PAA(K)    = QUAN(1) 
                           IF(NDIM(JJ).GE.2) PAA(K)    = OTHER(2) 
                           ELSE 
                           PCONV(JJ) = 1000.0 
                           PAA(K)    = SILAB(6) 
                           IF(NDIM(JJ).EQ.1) PAA(K)    = QUAN(1) 
                           IF(NDIM(JJ).EQ.1) PCONV(JJ) = 0.001 
                           IF(NDIM(JJ).GE.2) PAA(K)    = OTHER(4) 
                           ENDIF 
                   IF(NDIM(JJ).GE.2) PCONV(JJ) = 1.0 
  350              CONTINUE 
                   ENDIF 
C======================================================================= 
C     Summarize input data. 
C======================================================================= 
      WRITE(N6,100) ISTART,TSTART,IEND,TEND 
      TSTART = TSTART * 3600.0 
      TEND   = TEND   * 3600.0 
      IF(ISTART.GT.0) THEN 
                      NYEAR  = ISTART/10000 
                      NDAY   = ISTART - NYEAR*10000 
                      MONTH  = NDAY/100 
                      NDAY   = NDAY - MONTH*100 
                      IF(NDAY.EQ.0)   NDAY = 1 
                      IF(NDAY.GT.31)  NDAY = 1 
                      IF(MONTH.EQ.0)  MONTH = 1 
                      IF(MONTH.GT.12) MONTH = 1 
                      ISTART = 1000*NYEAR + JDATE(NDAY,MONTH,NYEAR) 
                      ENDIF 
      IF(IEND.GT.0) THEN 
                    NYEAR  = IEND/10000 
                    NDAY   = IEND - NYEAR*10000 
                    MONTH  = NDAY/100 
                    NDAY   = NDAY - MONTH*100 
                    IF(NDAY.EQ.0)   NDAY = 12 
                    IF(NDAY.GT.31)  NDAY = 12 
                    IF(MONTH.EQ.0)  MONTH = 12 
                    IF(MONTH.GT.12) MONTH = 12 
                    IEND   = 1000*NYEAR + JDATE(NDAY,MONTH,NYEAR) 
                    ENDIF 
      IF(LOCRQ.GT.0) THEN 
                     JULDAY = IDATEZ 
                     TIMDAY = TZERO 
                     ENDIF 
      WRITE(N6,101) ISTART,TSTART,IEND,TEND 
C======================================================================= 
      IF((ISTART.EQ.0.AND.TSTART.EQ.0.0).OR.(IEND.EQ.0.AND.TEND. 
     +        EQ.0.0)) WRITE(N6,102) 
      WRITE(N6,105) MIT 
      IF(JCE.EQ.0) WRITE(N6,110)  LOCRQ 
      IF(JCE.EQ.1) WRITE(N6,1110) KOCRQ 
      WRITE(N6,111) LOCRN 
      MIT         = MIT*3600.0 
      IF(METRIC.EQ.1) THEN 
                      WRITE(N6,113) 
                      WRITE(N6,112) NPR,BASE,EBASE 
                      ELSE 
                      WRITE(N6,115) 
                      WRITE(N6,1112) NPR,BASE,EBASE 
                      ENDIF 
C======================================================================= 
C     Print pollutants requested, by number, to indicate 
C     correct/incorrect choices by user. 
C======================================================================= 
      IF(NPR.GT.0) WRITE(N6,114) (IPOLRQ(I),I=1,NPR) 
C======================================================================= 
C     Print matrices indicating Stat options for flow and pollutants. 
C======================================================================= 
      IF(LOCRQ.GT.0) WRITE(N6,118) ((ISFLOW(I,J),J=1,5),I=2,5) 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(LOCRN.GT.0) WRITE(N6,119) ((ISFLOW(I,J),J=1,5),I=7,10) 
      IF(LOCRN.NE.' ') WRITE(N6,119) ((ISFLOW(I,J),J=1,5),I=7,10) 
      IF(NPR.GT.0) THEN 
                   DO 130 J = 1,NPR 
                   KK       = IPOLRQ(J) 
                   WRITE(N6,120) PNAME(KK),((ISPOLL(J,I,K),K=1,5),I=2,5) 
130                CONTINUE 
                   ENDIF 
C======================================================================= 
C     Find the position on the interface file of the requested number. 
C======================================================================= 
      KK = MSTA 
CIM  CHANGE TO LOOP THROUGH ALL LOCATIONS IF LOCRQ IS LESS THAN ZERO 6/97 
CIM  OR KOCRQ is '-1' 
CIM 
      ILOCRQ = 0 
8100  ILOCRQ = ILOCRQ + 1 
      IF (LLOCRQ.LT.0) THEN 
      IF (ILOCRQ.GT.1) THEN 
C======================================================================= 
C     Initialize several variables and arrays. 
C======================================================================= 
      COND       = 'DRY' 
      OLD        = 'DRY' 
      NNEND      = 0 
      NEXIT      = 0 
      IPEVNT     = 0 
      IDATEZ     = 0 
      DRYTS      = 0.0 
      TZERO      = 0.0 
      DO 8105 I     = 1,5 
 8105 FLOWP(I)   = 0.0 
      DO 8106 I     = 1,5 
      DO 8106 J     = 1,MQUAL 
      POLLP(J,I) = 0.0 
 8106 CONTINUE 
      REWIND (LAST) 
      REWIND (NOUT) 
      CALL INFACE(1,LAST) 
      ENDIF 
      IF (JCE.EQ.0) THEN 
         LOCRQ = NLOC(ILOCRQ) 
         WRITE(N6,2110) LOCRQ 
      ELSE 
         KOCRQ = KAN(ILOCRQ) 
         WRITE(N6,2111) KOCRQ 
      ENDIF 
      ENDIF 
CIM  <:) 
      IF(LOCRQ.GT.0) THEN 
                     DO 140 J = 1,LOCATS 
                     IF(JCE.EQ.0.AND.LOCRQ.EQ.NLOC(J)) GO TO 145 
                     IF(JCE.EQ.1.AND.KOCRQ.EQ.KAN(J))  GO TO 145 
140                  CONTINUE 
                     IF(JCE.EQ.0) WRITE(N6,142) LOCRQ 
                     IF(JCE.EQ.1) WRITE(N6,143) KOCRQ 
                     RETURN 
145                  KK = J 
                     ENDIF 
C======================================================================= 
C     Initialize read counter to zero. 
C     Initialize event counter to zero. 
C     Used to find first date/time on file. 
C     If zero value for starting date/time is chosen. 
C     Initialize time counter to one.  Used to set T1 
C     (Beginning of elapsed time for the period of analysis) 
C======================================================================= 
      NEVNTS = 0 
      KREAD  = 0 
      KTIME  = 1 
      TIME   = TZERO 
C#### WCH, 11/30/93. 
      ITEST  = 0 
      DLAST  = 0.0 
C======================================================================= 
C     Read flow (THEN) or rainfall (ELSE) interface files. 
C======================================================================= 
      WRITE(N6,375) 
      WRITE(*,911) 
      WRITE(*,913) 
cim   need to write to 6 not * to get carriage control on writes to console 
      WRITE(6,914) NEVNTS + 1 
  400 IF(LOCRQ.GT.0) THEN 
                     IF(NQUAL.EQ.0) READ(LAST,END=2005) 
     +                  JULDAY,TIMDAY,DELTA,(Q(K),K=1,LOCATS) 
                     IF(NQUAL.GT.0) READ(LAST,END=2005) JULDAY,TIMDAY, 
     +                  DELTA,(Q(K),(POLL(J,K),J=1,NQUAL),K=1,LOCATS) 
c      Write(n6,*) JULDAY,TIMDAY,DELTA,(Q(K),K=1,LOCATS) 
      JYEAR = JULDAY/1000 
      IF (JYEAR.LT.100) THEN 
      JULDAY = JULDAY - JYEAR*1000 
      JYEAR = JYEAR + 1900 
      JULDAY = JULDAY + JYEAR*1000 
      ENDIF 
                     ELSE 
                     JDAY  = JULDAY 
                     TMDAY = TIMDAY 
C#### WCH, 7/22/96.  SAVE OLD THISTO TO SUBTRACT TO GET INTEREVENT TIME. 
                     THISLD = THISTO 
                     READ(LAST,END=2005,ERR=9070) JULDAY,TIMDAY, 
     +                                   THISTO,(Q(K),K=1,NSTA) 
      JYEAR = JULDAY/1000 
      IF (JYEAR.LT.100) THEN 
      JULDAY = JULDAY - JYEAR*1000 
      JYEAR = JYEAR + 1900 
      JULDAY = JULDAY + JYEAR*1000 
      ENDIF 
                     ENDIF 
      KREAD = KREAD + 1 
C======================================================================= 
C#### WCH, 8/7/95.  ADD CHECK FOR MIS-MATCH OF DATES. 
C======================================================================= 
      IF(KREAD.EQ.1) THEN 
           IF(IEND.EQ.0) GO TO 405 
           IF(JULDAY.LT.IEND) GO TO 405 
           IF(JULDAY.EQ.IEND.AND.TIMDAY.LT.TEND) GO TO 405 
C======================================================================= 
C     Here, starting time on file is later than end time requested 
C     on input.  Print error message and return. 
C======================================================================= 
           WRITE(N6,9455) JULDAY,LAST,IEND 
           WRITE(*,9455)  JULDAY,LAST,IEND 
           RETURN 
           ENDIF 
C 
  405 IF(LOCRQ.GT.0.AND.DELTA.EQ.0.0) GO TO 400 
C======================================================================= 
C     Check for ending date/time. 
C======================================================================= 
      IF(JULDAY.EQ.IEND.AND.TIMDAY.GT.TEND.AND.IEND.NE.0) GO TO 2000 
      IF(JULDAY.GT.IEND.AND.IEND.NE.0)                    GO TO 2000 
C======================================================================= 
C     Check for default value for starting date/time. 
C======================================================================= 
      IF(ISTART.EQ.0.AND.TSTART.EQ.0.0) GO TO 410 
C======================================================================= 
C     Find desired starting date/time on interface file. 
C======================================================================= 
      IF(JULDAY.LT.ISTART) GO TO 400 
      IF(JULDAY.LE.ISTART.AND.TIMDAY.LT.TSTART) GO TO 400 
C======================================================================= 
C     Establish starting point for period of analysis. 
C======================================================================= 
  410 IF(KTIME.EQ.1) THEN 
                     T1    = TIME 
                     JDAY  = JULDAY 
                     TMDAY = TIMDAY 
C#### 8/1/95.  LOCRN NOW CHARACTER. 
C####                     IF(LOCRN.GT.0) THEN 
                     IF(LOCRN.NE.' ') THEN 
                                    IDATEZ = JULDAY 
                                    TZERO  = TIMDAY 
C#### WCH, 7/22/96. 
                                    THISLD = THISTO 
                                    ENDIF 
                     ENDIF 
C#### 8/1/95.  LOCRN NOW CHARACTER. 
C####                     IF(LOCRN.GT.0) THEN 
      IF(LOCRN.NE.' ') THEN 
                     CALL NTIME(JDAY,TMDAY,DELT) 
                     DELTA = -DELT 
                     ENDIF 
      TOLD  = TIME 
      TIME  = TIME + DELTA 
C======================================================================= 
C     Caution in interpretting DELTA:  For flows etc. off interface 
C     file, DELTA is time step >prior< to current time (TIME).  That is, 
C     DELTA "looks backwards."  For rainfall interface file, DELTA is 
C     time since last rain >began< and also looks backwards. 
C======================================================================= 
C#### WCH, 11/30/93.  MAKE SUMMATIONS CONSISTENT WITH OTHER BLOCKS. 
C                     USE DELT FOR MULTIPLICATION FOR VOLUMES/LOADS IF 
C                     PREVIOUS TIME STEP WAS DRY.  OTHERWISE, USE 
C                     AVERAGE DELT = DMEAN. 
C======================================================================= 
      IF(LOCRQ.GT.0) THEN 
           DMEAN = 0.5 * (DELTA + DLAST) 
           IF(ITEST.EQ.0) DMEAN = DELTA 
           DLAST = DELTA 
           ITEST = 0 
           IF(Q(KK).GT.0.0) ITEST = 1 
           ELSE 
           DMEAN = DELTA 
           ENDIF 
C 
      CALL DATED 
C======================================================================= 
C     Print starting date/time if default value is chosen. 
C     Establish starting point for period of analysis. 
C======================================================================= 
CIM### 2/6/2000 I think that this next line should look at KTIME not KREAD 
C      IF(KREAD.EQ.1) THEN 
      IF(KTIME.EQ.1) THEN 
                     IEVNTB(1) = JULDAY 
                     TEVNTB(1) = TIMDAY/3600.0 
                     WRITE(N6,415) JULDAY,TIMDAY 
                     T1        = TZERO 
                     ENDIF 
      KTIME = KTIME + 1 
C======================================================================= 
C     Separate time series into events.  Event consists of at least 
C     one wet time step; interevent is a dry period at least as long 
C     as the minimum interevent time chosen. 
C======================================================================= 
C     If Q = 0.0, Time step is dry;  If Q > 0, Time step is wet. 
C======================================================================= 
C     Rainfall interface file. 
C======================================================================= 
C#### 8/1/95.  LOCRN NOW CHARACTER. 
C####                     IF(LOCRN.GT.0) THEN 
      IF(LOCRN.NE.' ') THEN 
                     NEXT = 1 
C======================================================================= 
C     If satisfy the following IF-statement, then have new event. 
C     Note that rainfall interface file is assumed to contain only 
C     non-zero values.  Thus, every record on interface file is either 
C     a new event or a continuation of an existing event.  There are no 
C     dry rainfall periods. 
C 
C#### WCH, 7/22/96.  DELTA IS TIME BETWEEN >START< OF TWO RAINFALL 
C     INCREMENTS.  THUS, ACTUAL INTEREVENT TIME IS DELTA - THISLD. 
C     THISLD = THISTO FOR PREVIOUS RAINFALL VALUE. 
C 
C     Note, for rainfall, interevent time, FLOWP(5), looks forward from 
C     event that will be placed on the scatch file. 
C======================================================================= 
C####                     IF(TIME-TOLD.GE.MIT) THEN 
                     IF(TIME-TOLD-THISLD.GE.MIT) THEN 
                                          NEXT     = 2 
                                          BACKSPACE LAST 
                                          FLOWP(4) = DURAT 
C#### WCH, 7/22/96. 
C####                                          FLOWP(5) = DELTA 
                                          FLOWP(5) = DELTA - THISLD 
                                          ENDIF 
                     IF(DELTA.EQ.0.0) NEXT = 3 
                     ENDIF 
C======================================================================= 
C     Flow and water quality interface file. 
C======================================================================= 
      IF(LOCRQ.GT.0) THEN 
	           IF(JNEG.EQ.0) THEN 
                     IF(Q(KK).GT.BASE) THEN 
                                       COND = 'WET' 
                                       ELSE 
                                       COND = 'DRY' 
                                       ENDIF 
	           ELSE 
                     IF(Q(KK).LT.BASE) THEN 
                                       COND = 'WET' 
                                       ELSE 
                                       COND = 'DRY' 
                                       ENDIF 
	           ENDIF 
                     IF(OLD.EQ.'WET'.AND.COND.EQ.'WET')   NEXT = 1 
                     IF(OLD.EQ.'WET'.AND.COND.EQ.'DRY')   NEXT = 2 
                     IF(OLD.EQ.'DRY'.AND.COND.EQ.'WET')   NEXT = 3 
                     IF(OLD.EQ.'DRY'.AND.COND.EQ.'DRY')   NEXT = 4 
C#### WCH, 7/23/96.  MISSING FIRST EVENT IF IT STARTS BEFORE TIME MIT. 
C####                     IF(NEXT.EQ.3.AND.DRYTS+DELTA.LT.MIT) NEXT = 1 
C#### WCH, 8/7/96.  STILL DIDN'T GET IT RIGHT.  SHOULD NOT ADD DELTA. 
C     OTHERWISE, SEPARATING EVENTS AT MIT-1. 
C####     IF(NEVNTS.GT.0.AND.NEXT.EQ.3.AND.DRYTS+DELTA.LT.MIT) NEXT = 1 
          IF(NEVNTS.GT.0.AND.NEXT.EQ.3.AND.DRYTS.LT.MIT) NEXT = 1 
                     IF(MIT.EQ.0.0)                       NEXT = 3 
                     OLD = COND 
                     ENDIF 
 1350 CONTINUE 
C======================================================================= 
C     Previous condition is wet; new condition is wet; 
C     Continue the event; increment event duration. 
C======================================================================= 
      IF(NEXT.EQ.1) THEN 
                    IF(LOCRQ.GT.0) THEN 
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA. 
                             FLOWP(1) = FLOWP(1) + Q(KK)*DMEAN 
C#### WCH, 7/21/93.  USE UNITS OF CFS OR CMS, NOT PER HOUR 
C                            IF(Q(KK)*HSEC.GT.FLOWP(3)) 
C    +                                    FLOWP(3) = Q(KK)*HSEC 
                             IF(Q(KK).GT.FLOWP(3)) 
     +                                    FLOWP(3) = Q(KK) 
                             ENDIF 
C#### 8/1/95.  LOCRN NOW CHARACTER. 
C####                    IF(LOCRN.GT.0) FLOWP(1) = FLOWP(1) + 
                    IF(LOCRN.NE.' ') FLOWP(1) = FLOWP(1) + 
     +                              Q(KK)*THISTO/3600.0 
                    DURAT = DURAT + DELTA 
                    DRYTS = 0.0 
                    ENDIF 
C======================================================================= 
C     Flow parameter 1 is Total flow. 
C     Flow parameter 2 is Average flow. 
C     Flow parameter 3 is Peak flow. 
C     Flow parameter 4 is Event duration. 
C     Flow parameter 5 is Interevent duration. 
C======================================================================= 
C     Previous condition is wet; new condition is dry. 
C======================================================================= 
      IF(NEXT.EQ.2) THEN 
C#### WCH, 7/23/96.  PUT THIS BEFORE ADDING NEW DELTA, OTHERWISE DURAT 
C     IS TOO LONG. 
                    IF(LOCRQ.GT.0) FLOWP(4) = DURAT 
                    DURAT    = DURAT + DELTA 
                    DRYTS    = DELTA 
                    ENDIF 
C======================================================================= 
C     Previous condition is dry; new condition is wet ==> new event. 
C======================================================================= 
      IF(NEXT.EQ.3) THEN 
                                 NEVNTS = NEVNTS + 1 
cim   need to write to 6 not * to get carriage control on writes to console 
                    WRITE(6,914) NEVNTS 
                    IPEVNT         = 0 
                    IEVNTB(NEVNTS) = NYEAR*10000 + MONTH*100 + NDAY 
                    TEVNTB(NEVNTS) = TIMDAY/3600.0 
                    DURAT          = DELTA 
                    FLOWP(4)       = DURAT 
                    IF(LOCRQ.GT.0) THEN 
C#### WCH, 7/23/96.  INTEREVENT TIME TOO GREAT WITH THIS. 
C####                                   DRYTS    = DRYTS+DELTA 
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA. 
                                   FLOWP(1) = Q(KK)*DMEAN 
C#### WCH, 7/21/93 
C                                  FLOWP(3) = Q(KK)*DELTA 
                                   FLOWP(3) = Q(KK) 
C======================================================================= 
C     Note, for flow etc., interevent time, FLOWP(5), looks backwards 
C     from event that will be placed on scratch file. 
C======================================================================= 
                                   FLOWP(5) = DRYTS 
                                   ENDIF 
C#### 8/1/95.  LOCRN NOW CHARACTER. 
C####                     IF(LOCRN.GT.0) THEN 
                    IF(LOCRN.NE.' ') THEN 
                                   FLOWP(1) = Q(KK)*THISTO/3600.0 
                                   FLOWP(3) = Q(KK) 
                                   DURAT    = THISTO 
                                   FLOWP(4) = DURAT 
                                   ENDIF 
                    DRYTS    = 0.0 
                    IF(MIT.EQ.0.0.AND.LOCRQ.GT.0) THEN 
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA. 
                                   FLOWP(1) = Q(KK)*DMEAN 
C#### WCH, 7/21/93 
C                                  FLOWP(2) = FLOWP(1) 
C                                  FLOWP(3) = FLOWP(1) 
                                   FLOWP(2) = Q(KK) 
                                   FLOWP(3) = Q(KK) 
                                   FLOWP(4) = DURAT 
                                   ENDIF 
C#### 8/1/95.  LOCRN NOW CHARACTER. 
C####                    IF(MIT.EQ.0.0.AND.LOCRN.GT.0) THEN 
                    IF(MIT.EQ.0.0.AND.LOCRN.NE.' ') THEN 
                                   IF(THISTO.EQ.0.0) THISTO = 1.0 
                                   FLOWP(1) = Q(KK)*THISTO/3600.0 
                                   FLOWP(2) = FLOWP(1) 
                                   FLOWP(3) = FLOWP(1) 
                                   FLOWP(4) = DURAT 
                                   ENDIF 
                    ENDIF 
C======================================================================= 
C      Previous condition is dry. 
C      New condition is dry.        Extend interevent time. 
C======================================================================= 
      IF(NEXT.EQ.4) THEN 
                    DRYTS = DRYTS + DELTA 
                    IF(DRYTS.LT.MIT) DURAT = DURAT + DELTA 
                    ENDIF 
C======================================================================= 
C     Calculation of pollutant parameters. 
C     If condition is dry, pollutant parameters will be unchanged. 
C======================================================================= 
C     Pollutant Parameter 1 is Total Load 
C                         2 is Average Load 
C                         3 is Peak Load 
C                         4 is Flow Weighted Average Concentration = 
C                               Event Mean Concentration (EMC) 
C                         5 is Peak Concentration 
C======================================================================= 
      IF(NEXT.EQ.2.OR.NEXT.EQ.4) GO TO 1500 
      IF(NPR.EQ.0) GO TO 1500 
      DO 1400 K = 1,NPR 
      JJ        = IPOLRQ(K) 
C======================================================================= 
C     Special exception to routine if MIT = 0. 
C======================================================================= 
       IF(MIT.EQ.0) THEN 
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA. 
                    POLLP(K,1) = POLL(JJ,KK)*DMEAN 
                    POLLP(K,2) = POLLP(K,1) 
                    POLLP(K,3) = POLLP(K,1) 
                    IF(Q(KK).NE.0.0) POLLP(K,4) = POLL(JJ,KK)/Q(KK) 
                    IF(Q(KK).EQ.0.0) POLLP(K,4) = POLL(JJ,KK) 
                    POLLP(K,5) = POLLP(K,4) 
                    ELSE 
                    TEAK       = POLL(JJ,KK) 
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA. 
                    POLLP(K,1) = POLLP(K,1) + POLL(JJ,KK)*DMEAN 
                    IF(Q(KK).EQ.0.0) Q(KK)  = 1.0 
                    IF(TEAK*HSEC.GT.POLLP(K,3))  POLLP(K,3) = TEAK*HSEC 
                    IF(TEAK/Q(KK).GT.POLLP(K,5)) POLLP(K,5) = TEAK/Q(KK) 
                    ENDIF 
1400  CONTINUE 
C======================================================================= 
C     If dry period criterion has not been met, read next time step. 
C======================================================================= 
1500  IF(NNEND.EQ.0) THEN 
         IF(LOCRQ.GT.0.AND.DRYTS.LT.MIT) GO TO 1700 
         IF(IPEVNT.EQ.1)                 GO TO 1700 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####         IF(LOCRN.GT.0.AND.NEXT.NE.2)    GO TO 1700 
         IF(LOCRN.NE.' '.AND.NEXT.NE.2)    GO TO 1700 
         IPEVNT = 1 
         ENDIF 
C======================================================================= 
C     If first event has not yet been reached, continue reading. 
C======================================================================= 
      IF(NEVNTS.EQ.0) GO TO 1700 
C======================================================================= 
C     Otherwise, convert parameters to desired units and write event 
C     information to off-line file. 
C======================================================================= 
      IF(LOCRQ.GT.0) THEN 
C#### WCH, 11/30/93.  METRIC CORRECTION.  LEAVE FLTOT WITH METRIC 
C                     UNITS IF USED. DON'T MULT BY QCONV. 
            FLTOT    = FLOWP(1) 
            IF(JCUBE.EQ.0) THEN 
C#### WCH, 11/30/93.  HERE, CONVERT FLTOT TO CUBIC FEET, THEN TO DEPTH. 
C	Factor 3630 ft3/ac-in. = 43560 ft2/ac / 12 in/ft. 
C     Area, TRIBA is in acres, even when using metric units.  
C     In both statements below, SICONV = 25.4 mm/in for metric.  
               FLOWP(1) = FLTOT*QCONV*SICONV(1,METRIC)/(3630.0*TRIBA) 
C#### WCH, 7/21/93.  MULTIPLY BY 3600 TO GET DEPTH/HOUR. 
               FLOWP(3) = FLOWP(3)*QCONV*SICONV(3,METRIC)/(3630.0*TRIBA) 
     *                 *3600.0 
               ENDIF 
            FLOWP(4) = FLOWP(4)/3600.0 
            FLOWP(5) = FLOWP(5)/3600.0 
C#### WCH, 12/92  CHECK FOR ZERO DIVIDE BY FLOWP(4) 
              IF(ABS(FLOWP(4)).LT.1E-20) THEN 
                 FLOWP(2) = 0.0 
                 ELSE 
C#### WCH, 7/21/93. DIVIDE BY 3600. TO GET CFS OR CMS. 
Cwch, 11/24/03.  But only do this for JCUBE = 1.  Otherwise, need to 
C     divide inches or mm by hours, not seconds.  
                 IF(JCUBE.EQ.1) FLOWP(2) = FLOWP(1)/FLOWP(4)/3600.0 
                 IF(JCUBE.EQ.0) FLOWP(2) = FLOWP(1)/FLOWP(4) 
                 ENDIF 
            ENDIF 
C======================================================================= 
C     If statements added to test if total event flow is less than 
C     EBASE, the flow threshold input in line B1.  If total flow is 
C     less than EBASE, the event will not be included in the analysis. 
C     Note, if JCUBE = 1, and flows etc. are analyzed, then test against 
C     volume, not depth. 
C======================================================================= 
cim change below to abs(flowp(1) for negative flow events. 
      IF(ABS(FLOWP(1)).LT.EBASE.OR.FLOWP(4).LE.0.0) THEN 
          IF(NNEND.EQ.1) THEN 
                         IF(FLOWP(1).EQ.0.) GO TO 1619 
                         ENDIF 
          NEVNTS = NEVNTS - 1 
          GO TO 1619 
          ENDIF 
C======================================================================= 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(LOCRN.GT.0) THEN 
      IF(LOCRN.NE.' ') THEN 
                     FLOWP(4) = FLOWP(4)/3600.0 
                     FLOWP(5) = FLOWP(5)/3600.0 
                     IF(FLOWP(4).EQ.0.0) FLOWP(4) = 1.0 
                     FLOWP(2) = FLOWP(1)/FLOWP(4) 
                     ENDIF 
C======================================================================= 
C     Unit conversions for pollutant parameters.  For U.S. units, 
C        PCONV(1) = 16018.93 is equal to 0.03531 ft3/l * 453592.4 mg/lb 
C        Divide cuft*mg/l by 16016.35 to get pounds. 
C     For metric units, PCONV(1) = 1000. Divide cum*mg/l by 1000 to 
C        get kg. 
C     NDIM   METRIC   PCONV 
C       0      1      16018.93 
C       0      2      1000. 
C       1      1      0.0353157 
C       1      2      0.001 
C       2     1 & 2    1.0 
C======================================================================= 
C#### WCH, 11/30/93.  Can consolidate three loops into one. 
C======================================================================= 
      IF(NPR.GT.0) THEN 
           DO 1540 K = 1,NPR 
           JJ        = IPOLRQ(K) 
           IF(FLTOT.NE.0.0) POLLP(K,4) = POLLP(K,1)/FLTOT 
           IF(FLTOT.LE.0.0) POLLP(K,4) = 0.0 
           POLLP(K,1) = POLLP(K,1)/PCONV(JJ) 
           POLLP(K,2) = POLLP(K,1)/FLOWP(4) 
           POLLP(K,3) = POLLP(K,3)/PCONV(JJ) 
1540       CONTINUE 
C#### WCH, 11/30/93.  HERE, OLD LOOPS 1560 AND 1580 HAVE BEEN DELETED. 
           ENDIF 
C======================================================================= 
C     Write event information to off-line file. 
C======================================================================= 
      WRITE(NOUT)  IEVNTB(NEVNTS),TEVNTB(NEVNTS),(FLOWP(I),I=1,5) 
      IF(NPR.GT.0) WRITE(NOUT) ((POLLP(K1,J),J=1,5),K1=1,NPR) 
C======================================================================= 
C     If end of period of analysis or end of interface file, 
C     has been reached, go to event analysis. 
C======================================================================= 
1619  IF(NNEND.EQ.1) GO TO 2025 
C======================================================================= 
C     After writing event info, set appropriate parameters to zero. 
C======================================================================= 
      DO 1620 I1   = 1,3,2 
      FLOWP(I1)    = 0.0 
1620  CONTINUE 
      DO 1640 K2   = 1,NPR 
      DO 1630 I2   = 1,5,2 
      POLLP(K2,I2) = 0.0 
1630  CONTINUE 
1640  CONTINUE 
C======================================================================= 
C     Read another time step, provided that number of events has not 
C     reached its maximum value. 
C======================================================================= 
1700  IF(NEVNTS.LT.LIMIT) GO TO 400 
C======================================================================= 
C     If event maximum reached, check for termination of program; 
C     Iftermination not desired, begin event analysis. 
C======================================================================= 
      IF(KTERM.EQ.0) GO TO 1975 
C======================================================================= 
C     Otherwise, terminate program; first check for printing of series. 
C======================================================================= 
      WRITE(N6,1750) LIMIT,JULDAY,TIMDAY 
      IF(KTSEQS.GT.0) THEN 
                      WRITE(N6,1760) LIMIT 
                      NEXIT = 1 
                      GO TO 3400 
                      ENDIF 
      WRITE(N6,1790) 
      RETURN 
C======================================================================= 
C     T2 represents the end of the period of analysis. 
C======================================================================= 
1975  T2 = TIME 
      GO TO 2010 
C======================================================================= 
C     Print last date/time on interface file. 
C======================================================================= 
2000  T2       = TIME - DELTA 
      FLOWP(4) = DURAT 
      NEXT     = 1 
      WRITE(N6,1950) JULDAY,TIMDAY 
      GO TO 2010 
2005  T2       = TIME 
      IF(NEVNTS.EQ.0) THEN 
                      NEVNTS = 1 
                      WRITE(*,914) NEVNTS 
                      ENDIF 
      IF(NPR.GT.0)    THEN 
                      DO 3005 K   = 1,NPR 
                      JJ          = IPOLRQ(K) 
                      POLL(JJ,KK) = 0.0 
3005                  CONTINUE 
                      ENDIF 
      Q(KK)    = 0.0 
      FLOWP(4) = DURAT 
      NEXT     = 1 
      WRITE(N6,1950) JULDAY,TIMDAY 
C======================================================================= 
C     The elapsed time from the beginning to the end of the period of 
C     analysis is the difference between T2 and T1.  A rounded value for 
C     the number of months in this period can be found using 730.5 as the 
C     average number of hours per month.  NOMOS will be used to find the 
C     return period for an event of a given magnitude. 
C======================================================================= 
2010  IF(LRET.EQ.1) THEN 
                    NOMOS = INT(((T2-T1)/3600.0)/730.5  + 0.5) 
                    WRITE(N6,2020) NOMOS 
C#### WCH, 7/22/93. WARNING FOR T FOR LOW NUMBER OF MONTHS. 
                    IF(NOMOS.LT.1) WRITE(N6,2022) 
                    ELSE 
                    NOMOS = INT(((T2-T1)/3600.0)/8760.0 + 0.5) 
                    WRITE(N6,2021) NOMOS 
C#### WCH, 7/22/93. WARNING FOR T FOR LOW NUMBER OF YEARS. 
                    IF(NOMOS.LT.1) WRITE(N6,2023) 
                    ENDIF 
      NNEND = 1 
      GO TO 1350 
2025  WRITE(N6,2030) NEVNTS 
C======================================================================= 
C     Print message if needed. 
C======================================================================= 
      IF(NEVNTS.EQ.0) THEN 
                      WRITE(N6,2040) 
                      RETURN 
                      ENDIF 
      IF(NEVNTS.NE.LIMIT) GO TO 3300 
      WRITE(N6,2035) LIMIT 
C======================================================================= 
C     Check option to print sequential series; If so, Rewind NOUT and 
C     print date, time, flow volume, duration, interevent duration. 
C======================================================================= 
3300  IF(KSEQ.EQ.0) GO TO 4040 
3400  WRITE(N6,3500) 
C#### WCH, 7/23/96.  ADD DEFINITION OF DURATION AND INTEREVENT TIME FOR 
C     HYDROGRAPHS. 
      IF(LOCRQ.GT.0) WRITE(N6,3501) 
      WRITE(*,912) 
      IF(LOCRQ.GT.0) THEN 
             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3570) 
             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3580) 
             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3575) 
             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3585) 
	       IF(NPR.GT.0) THEN 
	       WRITE(N6,3549) '|<- EMC ----',('------------',K=1,NPR-2), 
     +	   '---------->|','<-TOT LOAD -',('------------',K=1,NPR-2), 
     +	   '---------->|' 
             WRITE(N6,3550) (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR) 
	         IF (METRIC.EQ.1) THEN 
	            WRITE(N6,3551) ENGLAB(1),ENGLAB(5),ENGLAB(5), 
     +                           (PUNIT(K),K=1,NPR), 
     +                           (PAA(K),K=1,NPR) 
	         ELSE 
	            WRITE(N6,3551) SILAB(1),SILAB(5),SILAB(5), 
     +                           (PUNIT(K),K=1,NPR), 
     +                           (PAA(K),K=1,NPR) 
	         ENDIF 
	        WRITE(N6,3552) ('  ----------',K=1,NPR*2) 
	       ENDIF 
c             IF(NPR.GT.0.AND.METRIC.EQ.1) WRITE(N6,3550) 
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR), 
c     +                       ENGLAB(1),ENGLAB(5),(PUNIT(K),K=1,NPR), 
c     +                       (PAA(K),K=1,NPR) 
c             IF(NPR.GT.0.AND.METRIC.EQ.2) WRITE(N6,3550) 
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR), 
c     +                       SILAB(1),SILAB(5),(PUNIT(K),K=1,NPR), 
c     +                       (PAA(K),K=1,NPR) 
             ELSE 
             IF(METRIC.EQ.1) WRITE(N6,3560) 
             IF(METRIC.EQ.2) WRITE(N6,3565) 
             ENDIF 
      REWIND (NOUT) 
      FLWSUM    = 0.0 
c 
c      P1LSUM    = 0.0 
c      P2LSUM    = 0.0 
c      P3LSUM    = 0.0 
c      P4LSUM    = 0.0 
c      P5LSUM    = 0.0 
      DO IP =1,NPR 
	PLSUM(IP) = 0.0 
	ENDDO 
C#### WCH, 7/23/96.  CHANGE FROM FFF5 = 0 TO FF5 = 0. 
      FF5       = 0.0 
      DO 3900 I = 1,NEVNTS 
      READ(NOUT,END=4040) I1,T1,(FLOWP(I2),I2=1,5) 
      IF(NPR.GT.0) READ (NOUT) ((POLLP(K1,J),J=1,5),K1=1,NPR) 
      FF1       = FLOWP(1) 
      FF4       = FLOWP(4) 
C======================================================================= 
C#### WCH, 7/23/96.  For rain, must save interevent time for next print, 
C     but not for flow. 
C======================================================================= 
      IF(LOCRQ.GT.0) THEN 
                   FFF5 = FLOWP(5) 
                   ELSE 
                   FFF5 = FF5 
                   ENDIF 
      FF5       = FLOWP(5) 
      IF(NPR.GT.0) THEN 
c                   P1EMC     = POLLP(1,4) 
c                   P2EMC     = POLLP(2,4) 
c                   P3EMC     = POLLP(3,4) 
c                   P4EMC     = POLLP(4,4) 
c                   P5EMC     = POLLP(5,4) 
c                   P1LOAD    = POLLP(1,1) 
c                   P2LOAD    = POLLP(2,1) 
c                   P3LOAD    = POLLP(3,1) 
c                   P4LOAD    = POLLP(4,1) 
c                   P5LOAD    = POLLP(5,1) 
      DO IP = 1,NPR 
	  PEMC(IP) = POLLP(IP,4) 
	  PLOAD(IP) = POLLP(IP,1) 
        PLSUM(IP) = PLSUM(IP) + POLLP(IP,1) 
	ENDDO 
c                   P1LSUM    = P1LSUM + POLLP(1,1) 
c                   P2LSUM    = P2LSUM + POLLP(2,1) 
c                   P3LSUM    = P3LSUM + POLLP(3,1) 
c                   P4LSUM    = P4LSUM + POLLP(4,1) 
c                   P5LSUM    = P5LSUM + POLLP(5,1) 
                   ENDIF 
      FLWSUM    = FLWSUM + FLOWP(1) 
C#### WCH, 7/23/96.  ADD EVENT ID NUMBER TO THESE PRINTS. 
      IF(LOCRQ.GT.0.AND.NPR.GT.0) 
c     +               WRITE(N6,3700) I,I1,T1,FF1,FF4,P1EMC,P2EMC,P3EMC, 
c     +               P4EMC,P5EMC,P1LOAD,P2LOAD,P3LOAD,P4LOAD,P5LOAD 
     +                 WRITE(N6,3700)  I,I1,T1,FF1,FF4,FFF5, 
     +				                 (PEMC(IP),IP=1,NPR), 
     +								 (PLOAD(IP),IP=1,NPR) 
      IF(LOCRQ.GT.0.AND.NPR.EQ.0) WRITE(N6,3701) I,I1,T1,FF1,FF4,FFF5 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(LOCRN.GT.0) WRITE(N6,3700) I1,T1,FF1,FF4,FFF5 
      IF(LOCRN.NE.' ') WRITE(N6,3701) I,I1,T1,FF1,FF4,FFF5 
C======================================================================= 
C  ELIMINATE INTERMEDIATE PRINTOUT 
c      IF(MOD(I,60).EQ.0) THEN 
c         WRITE(N6,3875) 
c         IF(LOCRQ.GT.0) THEN 
c             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3570) 
c             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3580) 
c             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3575) 
c             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3585) 
c             IF(NPR.GT.0.AND.METRIC.EQ.1) WRITE(N6,3550) 
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR), 
c     +                       ENGLAB(1),ENGLAB(5),(PUNIT(K),K=1,NPR), 
c     +                       (PAA(K),K=1,NPR) 
c             IF(NPR.GT.0.AND.METRIC.EQ.2) WRITE(N6,3550) 
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR), 
c     +                       SILAB(1),SILAB(5),(PUNIT(K),K=1,NPR), 
c     +                       (PAA(K),K=1,NPR) 
c             ELSE 
c             IF(METRIC.EQ.1) WRITE(N6,3560) 
c             IF(METRIC.EQ.2) WRITE(N6,3565) 
c             ENDIF 
c         ENDIF 
3900  CONTINUE 
C======================================================================= 
C     Check if program should be terminated after printing 
C     series; rewind off-line file; proceed with event 
C     analysis for flow parameters. 
C======================================================================= 
4040  CONTINUE 
        REWIND (NOUT) 
      IF(KSEQ.GT.0.AND.LOCRQ.GT.0) THEN 
C#### WCH, 11/30/93.  PRINT TOTAL LOADS FOR U.S. AND METRIC. 
c               IF(NPR.GT.0) WRITE(N6,6024) P1LSUM,P2LSUM,P3LSUM, 
c     +                                         P4LSUM, P5LSUM 
               IF(NPR.GT.0) THEN 
	         WRITE(N6,6022) 
	         WRITE(N6,6023) ('            ',IP = 1,NPR) 
			 WRITE(N6,6024) (PLSUM(IP),IP=1,NPR) 
	         ENDIF 
               IF (JCE.EQ.0) THEN 
                 IF(METRIC.EQ.1) WRITE(N6,6025) LOCRQ,FLWSUM,ENGLAB(1) 
                 IF(METRIC.EQ.2) WRITE(N6,6025) LOCRQ,FLWSUM,SILAB(1) 
                 ELSE 
                 IF(METRIC.EQ.1) WRITE(N6,6026) KOCRQ,FLWSUM,ENGLAB(1) 
                 IF(METRIC.EQ.2) WRITE(N6,6026) KOCRQ,FLWSUM,SILAB(1) 
               ENDIF 
               ENDIF 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(KSEQ.GT.0.AND.LOCRN.GT.0) THEN 
      IF(KSEQ.GT.0.AND.LOCRN.NE.' ') THEN 
               IF(METRIC.EQ.1) WRITE(N6,6030) LOCRN,FLWSUM,ENGLAB(1) 
               IF(METRIC.EQ.2) WRITE(N6,6030) LOCRN,FLWSUM,SILAB(1) 
               ENDIF 
      IF(NEXIT.EQ.1) RETURN 
      DO 4100 N = 1,NEVNTS 
C#### WCH, 2/27/95. READ IEVNTB,TEVNTB AGAIN TO AVOID CORRUPTED VALUES? 
      READ(NOUT,END=4140) IEVNTB(N),TEVNTB(N),(PARAM(N,I),I=1,5) 
C####      READ(NOUT,END=4140) I1,T1,(PARAM(N,I),I=1,5) 
      IF(NPR.GT.0) READ(NOUT) ((PDUM,J=1,5),K1=1,NPR) 
4100  CONTINUE 
4140  CONTINUE 
      DO 4600 J = 1,5 
      IF(IFPAR(J).EQ.0) GO TO 4600 
                     JMB = 1 
                     J1  = 1 
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER. 
C####      IF(LOCRN.GT.0) THEN 
      IF(LOCRN.NE.' ') THEN 
                     JMB = 6 
                     J1  = J + 10 
                     ENDIF 
C======================================================================= 
C     Sort data if table or graph requested and generate/print table. 
C======================================================================= 
      IF(ISFLOW(JMB+1,J).EQ.1) THEN 
                               CALL SORT(J) 
                               CALL SBTABL(J,0,NOMOS) 
                               ENDIF 
C======================================================================= 
C     If graph of return period not desired, go to next option. 
C     Call curve to make graph of return period. 
C======================================================================= 
      IF(ISFLOW(JMB+2,J).EQ.1) THEN 
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO. 
      IF(ISFLOW(JMB+1,J).NE.1) CALL SORT(J) 
                               CALL POINTS(J,1,NOMOS) 
                               HTITLE(1) = RPTITL 
                               HTITLE(2) = BLANK 
                               HORIZ(1)  = RPHOR(1) 
C#### WCH, 7/21/93. PRINT CORRECT UNITS FOR RETURN PERIOD. 
                               IF(LRET.EQ.1) HORIZ(2)  = RPHOR(2) 
                               IF(LRET.EQ.0) HORIZ(2)  = RPHOR(3) 
                               VERT1     = VRTITL(J) 
                               IF(METRIC.EQ.2)  THEN 
                                                VERT2 = SILAB(J) 
                                                ELSE 
                                                VERT2 = ENGLAB(J) 
                                                ENDIF 
                               CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ) 
                               ENDIF 
C======================================================================= 
C     If graph of frequency not desired, go to next option. 
C======================================================================= 
      IF(ISFLOW(JMB+3,J).EQ.1) THEN 
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO. 
      IF(ISFLOW(JMB+1,J).NE.1.AND.ISFLOW(JMB+2,J).NE.1) CALL SORT(J) 
                               CALL POINTS(J,2,NOMOS) 
                               HTITLE(1) = PTITL 
                               HTITLE(2) = BLANK 
                               HORIZ(1)  = PHOR(1) 
                               HORIZ(2)  = PHOR(2) 
                               VERT1     = VRTITL(J) 
                               IF(METRIC.EQ.2) THEN 
                                               VERT2 = SILAB(J) 
                                               ELSE 
                                               VERT2 = ENGLAB(J) 
                                               ENDIF 
                               CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ) 
                               ENDIF 
C======================================================================= 
C     If moments desired call moments. 
C======================================================================= 
      IF(ISFLOW(JMB+4,J).EQ.1) THEN 
                IF(INLOG.GT.0) THEN 
                               WRITE(N6,6037) 
                               WRITE(N6,6038) 
                               ELSE 
                               WRITE(N6,6035) 
                               WRITE(N6,6036) 
                               ENDIF 
                CALL MOMENT(J,0) 
                ENDIF 
4600  CONTINUE 
C======================================================================= 
C     Statistical analysis for pollutants. 
C======================================================================= 
      IF(NPR.EQ.0) GO TO 6000 
C======================================================================= 
C     Read off-line file for pollutant requested. 
C======================================================================= 
      DO 5300 K = 1,NPR 
      REWIND (NOUT) 
      JJ        = IPOLRQ(K) 
      DO 4750 N = 1,NEVNTS 
      READ(NOUT,END=4760) I1,T1,(QDUM,I=1,5) 
      IF(NPR.GT.0) THEN 
                   READ(NOUT) ((POLLP(K1,J),J=1,5),K1=1,NPR) 
                   PARAM(N,1) = POLLP(K,1) 
                   PARAM(N,2) = POLLP(K,2) 
                   PARAM(N,3) = POLLP(K,3) 
                   PARAM(N,4) = POLLP(K,4) 
                   PARAM(N,5) = POLLP(K,5) 
                   ENDIF 
4750  CONTINUE 
4760  CONTINUE 
      DO 5200 J = 1,5 
      J1        = J + 5 
      IF(IPPAR(K,J).EQ.0) GO TO 5200 
C======================================================================= 
C     Generate and print table. 
C======================================================================= 
      IF(ISPOLL(K,2,J).EQ.1) THEN 
                             CALL SORT(J) 
                             CALL SBTABL(J,JJ,NOMOS) 
                             ENDIF 
C======================================================================= 
C     If graph of return period not desired, go to next option. 
C======================================================================= 
      IF(ISPOLL(K,3,J).EQ.1) THEN 
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO. 
      IF(ISPOLL(K,2,J).NE.1) CALL SORT(J) 
                             CALL POINTS(J,1,NOMOS) 
                             HTITLE(1) = RPTITL 
                             HTITLE(2) = BLANK 
                             HORIZ(1)  = RPHOR(1) 
C#### WCH, 7/21/93. PRINT CORRECT UNITS FOR RETURN PERIOD. 
                               IF(LRET.EQ.1) HORIZ(2)  = RPHOR(2) 
                               IF(LRET.EQ.0) HORIZ(2)  = RPHOR(3) 
                             VERT1     = VRTITL(J1) 
                             IF(METRIC.EQ.2) THEN 
                                             VERT2 = SILAB(J1) 
                                             ELSE 
                                             VERT2 = ENGLAB(J1) 
                                             ENDIF 
                             IF(NDIM(JJ).EQ.1.AND.J.LE.3) THEN 
                                              VERT2 = QUAN(J) 
                                              ENDIF 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND. 
     +                              METRIC.EQ.1) VERT2 = OTHER(1) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND. 
     +                              METRIC.EQ.2) VERT2 = OTHER(3) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND. 
     +                              METRIC.EQ.1) VERT2 = OTHER(2) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND. 
     +                              METRIC.EQ.2) VERT2 = OTHER(4) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND. 
     +                              METRIC.EQ.1) VERT2 = OTHER(2) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND. 
     +                              METRIC.EQ.2) VERT2 = OTHER(4) 
                             IF(J.GE.4)       THEN 
                                              VERT2 = PUNIT(JJ) 
                                              ENDIF 
                             CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ) 
                             ENDIF 
C======================================================================= 
C     If graph of frequency not desired, go to next option. 
C======================================================================= 
      IF(ISPOLL(K,4,J).EQ.1) THEN 
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO. 
      IF(ISPOLL(K,2,J).NE.1.AND.ISPOLL(K,3,J).NE.1) CALL SORT(J) 
                             CALL POINTS(J,2,NOMOS) 
                             HTITLE(1) = PTITL 
                             HTITLE(2) = BLANK 
                             HORIZ(1)  = PHOR(1) 
                             HORIZ(2)  = PHOR(2) 
                             VERT1     = VRTITL(J1) 
                             IF(METRIC.EQ.2) THEN 
                                             VERT2 = SILAB(J1) 
                                             ELSE 
                                             VERT2 = ENGLAB(J1) 
                                             ENDIF 
                             IF(NDIM(JJ).EQ.1.AND.J.LE.3) THEN 
                                              VERT2 = QUAN(J) 
                                              ENDIF 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND. 
     +                              METRIC.EQ.1) VERT2 = OTHER(1) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND. 
     +                              METRIC.EQ.2) VERT2 = OTHER(3) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND. 
     +                              METRIC.EQ.1) VERT2 = OTHER(2) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND. 
     +                              METRIC.EQ.2) VERT2 = OTHER(4) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND. 
     +                              METRIC.EQ.1) VERT2 = OTHER(2) 
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND. 
     +                              METRIC.EQ.2) VERT2 = OTHER(4) 
                             IF(J.GE.4)       THEN 
                                              VERT2 = PUNIT(JJ) 
                                              ENDIF 
                             CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ) 
                             ENDIF 
C======================================================================= 
C     Call moment subroutine for pollutant parameter (N,J); Print out. 
C======================================================================= 
5000  CONTINUE 
      IF(ISPOLL(K,5,J).EQ.1) THEN 
                IF(INLOG.GT.0) THEN 
                               WRITE(N6,6037) 
                               WRITE(N6,6038) 
                               ELSE 
                               WRITE(N6,6035) 
                               WRITE(N6,6036) 
                               ENDIF 
                CALL MOMENT(J,JJ) 
                ENDIF 
5200  CONTINUE 
5300  CONTINUE 
6000  WRITE(N6,6050) 
      IF (LLOCRQ.LT.0.AND.ILOCRQ.LT.LOCATS) GO TO 8100 
      RETURN 
9070  WRITE(N6,9080) 
      RETURN 
C======================================================================= 
34    FORMAT(//, 
     1' ######################################',/, 
     1' # Entry made to the Stats Block      #',/, 
     1' # Statistical Analysis Block written #',/, 
     1' #   by the University of Florida.    #',/, 
     1' #   Last updated Dec. 1996 at OSU.   #',/, 
     1' # See data examples or STATS.DOC for #',/, 
     1' # information on new parameters not  #',/, 
     1' # included in User''s Manual.         #',/, 
     1' ######################################',/) 
C#### WCH, 7/21/93.  SLIGHT CHANGE FOR PRINT OF LRET. 
C#### WCH, 7/23/96.  CORRECT DEFINITION OF JCUBE FOR VOLUMES. 
92    FORMAT(1X,/, 
     1'      ####################################',/, 
     1'      #      Stats Block input commands  #',/, 
     1'      ####################################',//, 
     1 1X,'Minimum interevent time (hours).......',F10.2,/, 
     1 1X,'NPOINT (number of printed events).....',I10,/, 
     1 1X,'METRIC (0-U.S. Customary, 1-Metric)...',I10,//, 
     1 1X,'LRET (return period units, 0=yr, 1=mo)',I10,/, 
     1 1X,'A (plotting position parameter).......',F10.3,/, 
     1 1X,'Calculate logarithmic moments.(INLOG).',I10,//, 
     1 1X,'Use inch or millimeter flow JCUBE = 0,',/, 
     1 1X,'or ft^3 or m^3 flow values  JCUBE = 1.',I10,/ 
	1 1X,'Process positive flow events JNEG = 0,',/, 
	1 1x,'or negative flow events      JNEG = 1,',I10,/) 
C    1 1X,'Use storm event definition  JSEA  = 0,',/, 
C    1 1X,' or monthly events          JSEA  = 1,',/, 
C    1 1X,' or seasonal events         JSEA  = 2.',I10,/) 
C#### WCH, 7/23/96.  MODIFY THIRD LINE. 
   93 FORMAT( 
     1 1X,'Print sequential series (KSEQ)..............',I10,/, 
     1 1X,'Terminate program parameter (KTERM).........',I10,/, 
     1 1X,'Print series if reach event limit (KTSEQS)..',I10,/) 
  100 FORMAT(//, 
     +' ##################################################',/, 
     +' #  The period of time for which the statistical  #',/, 
     +' #              analysis is being performed is:   #',/, 
     +' ##################################################',//, 
     +'  Starting date...............',I8,'  Starting time...',F5.2, 
     +' hours',/, 
     +'  Ending date.................',I8,'  Ending time.....',F5.2, 
     +' hours') 
C#### WCH, 7/21/93.  ALTER FORMAT FOR OUTPUT OF SECONDS. 
101   FORMAT(//, 
     1' ##################################################',/, 
     1' #  The period of time for which the statistical  #',/, 
     1' #              analysis is being performed is:   #',/, 
     1' ##################################################',//, 
     1'  Starting Julian date........',I8,'  Starting time...',F6.0, 
     1' seconds',/, 
     1'  Ending Julian date..........',I8,'  Ending time.....',F6.0, 
     1' seconds') 
102   FORMAT(/, 
     1' ===> A zero starting date indicates that the analysis ',/, 
     2'      commences at the beginning of the record.  A zero ',/, 
     3'      ending date indicates that the analysis continues to',/, 
     4'      the end of the record.') 
105   FORMAT(/,' The minimum interevent time has been defined as ',F9.2, 
     1         ' hours.') 
110   FORMAT(/, 
     1' ******************************************************',/, 
     2' * The flow location number requested for Statistical *',/, 
     3' * Analysis is: ',I10,'                            *',/, 
     4' ******************************************************') 
1110  FORMAT(/, 
     1' ******************************************************',/, 
     2' * The flow location requested for Statistical        *',/, 
     3' * Analysis is: ',A10,'                            *',/, 
     4' ******************************************************') 
2110   FORMAT(/, 
     1' ******************************************************',/, 
     2' * The following analysis is for location number :    *',/, 
     3' * ',I10,'                                         *',/, 
     4' ******************************************************') 
2111  FORMAT(/, 
     1' ******************************************************',/, 
     2' * The following analysis is for location number :    *',/, 
     3' * ',A10,'                                         *',/, 
     4' ******************************************************') 
C#### WCH, 8/1/95.  CHANGE I7 TO A8. 
111   FORMAT(/, 
     1' ******************************************************',/, 
     2' * The rain location number requested for Statistical *',/, 
     3' * Analysis is: ',A8,'                               *',/, 
     4' ******************************************************') 
112   FORMAT(/, 
     1' The number of quality parameters',/, 
     2' requested for statistical analysis is..',I10,/, 
     3' The base flow to separate events is....',F10.4,' cfs.',/, 
     4' Threshold event flow inches (cfs)......',F10.4,/) 
1112  FORMAT(/, 
     1' The number of quality parameters',/, 
     2' requested for statistical analysis is..',I10,/, 
     3' The base flow to separate events is....',F10.4,' cms.',/, 
     4' Threshold event flow millimeters (cms).',F10.4,/) 
113   FORMAT(/,' U.S. customary units are used in input/output.') 
115   FORMAT(/,' Metric units are used in input/output.') 
114   FORMAT(/,' The pollutants requested for this run, ',/, 
     1' identified by number, are as follows: ',99I3) 
118   FORMAT(//, 
     1' ############################################',/, 
     1' #  The statistical options requested for   #',/, 
     1' #       flow rate are indicated by "1"     #',/, 
     1' ############################################',//, 
     241X,'   Total Flow  Average Flow     Peak Flow  Event Duratn  Inte 
     2revent Duratn',/, 
     341X,'  ------------ -------------  -----------  ------------  ---- 
     3-------------',/, 
     4' Table of return period and frequency',T40,5I14,/, 
     5' Graph of return period',T40,5I14,/, 
     5' Graph of frequency',T40,5I14,/,' Moments',T40,5I14) 
119   FORMAT(/, 
     1' ############################################',/, 
     1' #  The statistical options requested for   #',/, 
     1' #       rainfall are indicated by "1"      #',/, 
     1' ############################################',//, 
     241X,'  Total Volume Average Inten  Peak Intens  Event Duratn  Inte 
     2revent Duratn',/, 
     341X,'  ------------ -------------  -----------  ------------  ---- 
     3-------------',/, 
     4' Table of return period and frequency',T40,5I14,/, 
     5' Graph of return period',T40,5I14,/, 
     5' Graph of frequency',T40,5I14,/,' Moments',T40,5I14) 
120   FORMAT(//, 
     1' ####################################################',/, 
     1' #  The statistical options requested for           #',/, 
     1' #  quality parameter ',A8,' are indicated by "1" #',/, 
     1' ####################################################',//, 
     143X,'Total Load  Average Load     Peak Load Flow Wtd Conc     Peak 
     1 Conc',/, 
     143X,'----------  ------------     --------- -------------     ---- 
     1-----',/, 
     4' Table of return period and frequency',T40,5I14,/, 
     5' Graph of return period',T40,5I14,/, 
     5' Graph of frequency',T40,5I14,/,' Moments',T40,5I14) 
142   FORMAT(/,' ===> Error  The location number requested was',/, 
     +         '      not found on the interface file.',/, 
     +         '      Location ',I10,' not found on interface file',/, 
     +         '      execution of Stats block terminated.') 
143   FORMAT(/,' ===> Error  The location number requested was',/, 
     +         '      not found on the interface file.',/, 
     +         '      Location ',A10,' not found on interface file',/, 
     +         '      execution of Stats block terminated.') 
334   FORMAT(//, 
     +' ***********************************************************',/, 
     +' *  Precipitation input was created using the Rain block   *',/, 
     +' *  NWS Precipitation station....',I9,'                 *',/, 
     +' ***********************************************************') 
375   FORMAT(//,' ===> Program execution continuing.  Data will be ',/, 
     +'      read from the interface file and separated into events.') 
415   FORMAT(/,' ===> The first date and time on the interface file',/, 
     1         '      are ',I7,' and ',F9.2,' seconds',/) 
911   FORMAT(/,' Reading interface file.') 
912   FORMAT(/,' Computing statistics.') 
913   FORMAT(/,' Reading event  #',/) 
914   FORMAT('+',I16) 
C   next format not used 
C1610  FORMAT(I6,F5.2,5G10.4,10(5G10.4)) 
1750  FORMAT(/,' ===>  Number of events has reached ',I5,'.',/, 
     1 '       execution has been terminated.',/, 
     2 '       last date and time read are ',I7,1X,F5.2,' hours') 
1760  FORMAT(/,' ===> A table of the first ',I5,' events will be',/, 
     +                                          ' printed.') 
1790  FORMAT(/,' ===> As you requested, no output is provided.') 
1950  FORMAT(/,' ===> End of interface file reached.',//, 
     1         ' ===> Last Julian date and time read ',/, 
     2         '      are ',I7,' and ',F9.2,' seconds',//, 
     3         ' ===> Program continuing with analysis of events.') 
2020  FORMAT(/,' ===> The number of months within the period of',/, 
     1'      analysis rounded to the nearest month, is ',I6,'.') 
2021  FORMAT(/,' ===> The number of years within the period of',/, 
     1'      analysis rounded to the nearest year,  is ',I6,'.') 
C#### WCH, 7/22/93 
2022  FORMAT(/,' ###> WARNING. The rounded number of months is < 1.',/ 
     1,'      Computed return periods are likely to be meaningless.') 
2023  FORMAT(/,' ###> WARNING. The rounded number of years is < 1.',/ 
     1,'      Computed return periods are likely to be meaningless.') 
2030  FORMAT(/,' ===> The number of events within the period of',/, 
     1'      analysis is                               ',I6,'.') 
2035  FORMAT(/,' ===> Error  The maximum number of events has been', 
     +' reached.',/, 
     +'               No further time steps can be read.',/, 
     +'               The program is continuing with an analysis',/, 
     +'               of the first ',I5,' events.') 
2040  FORMAT(/,' ===> Error ') 
2115  FORMAT(//, 
     +' ********************************************************',/, 
     +' *  Precipitation output created using the Rain block   *',/, 
     +' *  Number of precipitation stations...',I9,'        *',/, 
     +' ********************************************************',/) 
C#### WCH, 8/1/95.  CHANGE I13 TO A13 
 2120 FORMAT(' Location Station number',/, 
     +       ' -------- --------------',/, 
     +       10(I9,'. ',A13,/)) 
 3500 FORMAT('1',/,15X,27(1H#),/,15X,'Sequential Series of Events', 
     +           /,15X,27(1H#),/) 
 3501 FORMAT(' Note: SWMM hydrographs are instantaneous values at', 
     1' given time.',/, 
     +' Event duration is from first non-zero flow to trailing', 
     +' hydrograph zero.',/, 
     +' Interevent duration is from trailing hydrograph zero to next', 
     +' non-zero flow') 
c     +' (not printed when quality is printed).',/) 
C#### WCH, 7/23/96.  ADD EVENT NO. TO THIS PRINT-OUT AND FIX UNITS FMT. 
 3549 FORMAT(27X,'Flow      Event  Interevent',2X,99(A12)) 
C     +'|<----------------------------EMC------------------------->|', 
C     +'<----------------------Total Load----------------------->|') 
 3550 FORMAT(' Event',12X,'Time   Volume   Duration    Duration', 
     +99(4X,A8)) 
 3551 FORMAT('   No.   Date    (hour)',1X,A8,2X,A8,4X,A8, 
     +99(4X,A8)) 
 3552 FORMAT('  ----   ----    ------ --------  --------   ---------', 
     +99(A12)) 
c     +'   ---------  ----------  ----------   ---------   ---------', 
c     +'   ---------   ---------  ---------   ---------') 
C#### WCH, 7/23/96.  ALTER 3560-3585 FOR EVENT NO. PRINT-OUT. 
3560  FORMAT('                            Rain      Event  Interevent' 
     + ,/, 
     +     ' Event           Time     Volume   Duration    Duration',/, 
     +     '   No.   Date   (hour)   (inches)   (hours)     (hours)',/, 
     +     '  ----   ----   ------  --------    -------     -------') 
3565  FORMAT('                            Rain      Event  Interevent' 
     + ,/, 
     +     ' Event           Time     Volume   Duration    Duration',/, 
     +     '   No.   Date   (hour)      (mm)    (hours)     (hours)',/, 
     +     '  ----   ----   ------  --------    -------     -------') 
3570  FORMAT('                            Flow      Event  Interevent' 
     + ,/, 
     +     ' Event           Time     Volume   Duration    Duration',/, 
     +     '   No.   Date   (hour)   (inches)   (hours)     (hours)',/, 
     +     '  ----   ----   ------  --------    -------     -------') 
3575  FORMAT('                            Flow      Event  Interevent' 
     + ,/, 
     +     ' Event           Time     Volume   Duration    Duration',/, 
     +     '   No.   Date   (hour)      (mm)    (hours)     (hours)',/, 
     +     '  ----   ----   ------  --------    -------     -------') 
3580  FORMAT('                            Flow      Event  Interevent' 
     + ,/, 
     +     ' Event           Time     Volume   Duration    Duration',/, 
     +     '   No.   Date   (hour)   ( ft^3 )   (hours)     (hours)',/, 
     +     '  ----   ----   ------  --------    -------     -------') 
3585  FORMAT('                            Flow      Event  Interevent' 
     + ,/, 
     +     ' Event           Time     Volume   Duration    Duration',/, 
     +     '   No.   Date   (hour)  (meter^3)   (hours)     (hours)',/, 
     +     '  ----   ----   ------  --------    -------     -------') 
C#### WCH, 7/23/96.  ADD EVENT NO. AND CHANGE EMC ETC. PRINTS TO 
C     G-FORMAT, FROM F-FORMAT. 
3700  FORMAT(I4,2X,I8,1X,F8.2,1X,1PG9.3,0PF9.2,F12.2,99(3X,1PG9.3)) 
C#### WCH, 7/23/96.  ADD FORMAT FOR EVENT NO. PRINT-OUT. 
3701  FORMAT(I4,2X,I8,F8.2,2X,1PG9.3,0PF9.2,F12.2) 
3875  FORMAT('1',/,15X,40(1H#),/,15X, 
     1'Sequential Series of Events  (continued)',/,15X,40(1H#),/) 
C#### WCH, 8/7/95.  THIS FORMAT NOT USED?? 
C#### 4050  FORMAT(11X,5G10.4) 
6022  FORMAT('      Total Loads (see to right)--->:', 
     1'                 ',$) 
6023  FORMAT(A12,$) 
6024  FORMAT(3X,1PG9.3,99(3X,G9.3)) 
6025  FORMAT(//, 
     1' ************************************************************',/, 
     2' * Total Flow at location ',I10,'is ',1PG11.4,' ',A9,'*',/, 
     3' ************************************************************', 
     4//) 
6026  FORMAT(//, 
     1' ************************************************************',/, 
     2' * Total Flow at location ',A10,'is ',1PG11.4,' ',A9,'*',/, 
     3' ************************************************************', 
     4//) 
C#### WCH, 8/1/95.  CHANGE I9 TO A9 FOR STATION ID. 
6030  FORMAT(//, 
     1' ************************************************************',/, 
     2' * Total Rain at location ',A9,' is ',1PG11.4,' ',A9,' *',/, 
     3' ************************************************************', 
     4//) 
6035  FORMAT(/,88(1H#),/,'  Moments',/,88(1H#)) 
6037  FORMAT(/,90(1H#),/, 
     1'  Moments (Log-Normal [natural log] Distribution)',/,90(1H#)) 
6036  FORMAT(/, 
     1' Constituent            Event                            Standard 
     1    Coef. of   Coef. of',/, 
     2'    Analyzed        Parameter        Mean    Variance   Deviation 
     2   Variation   Skewness',/, 
     3'  ----------  ---------------    --------    --------   --------- 
     3   ---------  ---------') 
6038  FORMAT(/, 
     1'  Constituent           Event <-----Logarithmic------>   <------- 
     1-----------Arithmetic-------------->',/, 
     2'     Analyzed       Parameter        Mean   Std. dev.        Mean 
     2   Std. dev.  C. of var.     Median',/, 
     3'  ------------  -------------   ---------   ---------    -------- 
     3   ---------  ----------  ---------') 
6050  FORMAT(/,' ===>  Stats Block terminated normally.') 
C#### WCH, 8/1/95.  CHANGE I9 TO A9 AND ENHANCE ERROR MESSAGE. 
 9030 FORMAT(/,' WARNING Rainfall location (LOCRN)......... ',A8,/, 
     + ' is not located on the rainfall interface file.',/, 
     + ' Stats continues, using last station on rainfall interface file 
     += ',A8,/,' Possible cause is mis-match of alphanumeric station IDs 
     +.',/,' Try inputting LOCRN in exactly the same form as ISTA was in 
     +put in the Rain Block,',/,' including leading/trailing blanks.') 
C#### WCH, 8/1/95.  NEW ERROR MESSAGE. 
 9040 FORMAT(/,' ==> WARNING  Rainfall station ID, LOCRN, should be inp 
     1ut as alphanumeric',/,' value (8/1/95).  Your integer input =',I9, 
     2 ' entered successfully',/,' and converted to alphanumeric value, 
     3but please use correct',/,' alphanumeric format in future.') 
C#### WCH, 8/7/95. 
 9455 FORMAT(' ERROR BEGINNING JULIAN DATE =',I9,' ON UNIT',I3,' IS LAT 
     +ER THAN',/, 
     + ' REQUESTED ENDING JULIAN DATE =',I9,' ENTERED ON A1 LINE.',/, 
     + ' (DATES INCLUDE CONSIDERATION OF TIME OF DAY.)',/, 
     + ' STATS BLOCK ENDED.  RETURN TO MAIN PROGRAM.') 
 9080 FORMAT(/,' ===> Error reading rainfall interface file.') 
CIM  PROCESS ALL FILES 
 8005 FORMAT('LOCRQ ENTERED AS NEGATIVE NUMBER. ALL FLOW LOCATIONS IN', 
     +' THE INTERFACE FILE WILL BE PROCESSED') 
C======================================================================= 
 888  CALL IERROR 
      END 
 
REM File: STIME.FOR 
 
      SUBROUTINE STIME(DELTA) 
C####################################################################### 
C     JULDAY = JULIAN DAY 
C     TIMDAY = TIME OF DAY IN SECONDS 
C     DELTA  = NEW TIME STEP IN SECONDS 
C####################################################################### 
      INCLUDE 'STIMER.INC' 
      NYEAR = JULDAY/1000 
      IF (NYEAR.LT.100) THEN 
           JULDAY = JULDAY - NYEAR*1000 
           NYEAR = NYEAR + 1900 
           JULDAY = JULDAY + NYEAR*1000 
           ENDIF 
      TIMDAY = TIMDAY + DELTA 
 100  IF(TIMDAY.GE.86400.0) THEN 
                TIMDAY = TIMDAY - 86400.0 
                JULDAY = JULDAY + 1 
                IDAY   = JULDAY - 1000*(JULDAY/1000) 
                IF(MOD(NYEAR,4).EQ.0.AND.IDAY.EQ.367.OR. 
     +             MOD(NYEAR,4).NE.0.AND.IDAY.EQ.366) THEN 
                                         NYEAR  = NYEAR + 1 
                                         JULDAY = NYEAR*1000 + 1 
                                         ENDIF 
                CALL DATED 
                ENDIF 
      IF(TIMDAY.GE.86400.0) GO TO 100 
      RETURN 
      END 
 
 
REM File: STRT.FOR 
 
      SUBROUTINE STRT 
C======================================================================= 
C     STORAGE/TREATMENT MODEL  -- JUNE 1981. (UPDATED JANUARY 1988) 
C 
C     MODEL WRITTEN BY STEPHAN J. NIX 
C     UPDATED AND MODIFIED BY ROBERT E. DICKINSON 
C                      ENVIRONMENTAL ENGINEERING SCIENCES 
C                      UNIVERSITY OF FLORIDA 
C                      GAINESVILLE, FLORIDA 32611 
C     CURRENT (12/94) PHONE : 813-886-7724 AT XP SOFTWARE 
C     UPDATE HEADER, 5/93 BY WCH AT OREGON STATE UNIVERSITY 
C     ROB JAMES AND WCH, 8/4/93.  FIX METRIC CONVERSION WHILE 
C       WRITING TO INTERFACE FILE. 
C     WCH (RED), 9/23/93.  CHANGE A FORMAT FROM 2A4 TO A8. 
C     WCH, 12/5/94.  CHANGE SEVERAL FORMATS TO MOVE OUTPUT TO LEFT 
C       AND ADD PRINT-OUT OF PRINT AND DATE/TIME VARIABLES. 
C     WCH, 2/27/95.  CORRECT PRINT-OUTS OF POLLUTANT NAME, UNITS. 
C     WCH, 7/7/95.  CORRECT METRIC PRINT-OUT OF TRIBA. 
C     WCH, 7/7/95.  MAKE CORRECTIONS FOR METRIC CONVERSION ON INTERFACE 
C       FILE. 
C     CIM  4/99 MODIFIED TO INCREASE NUMBER OF CONSTITUENT FROM 10 
C          TO MQUAL. 
C     WCH 4/18/02. ERROR MESSAGE FOR INCOMPATIBLE $ANUM. 
C     WCH, 11/24/03.  Used POLL1 twice and spoiled linear interpolation. 
C       Correction suggested by Raymond He, Clarifica Inc. 
C       Do not need all the metric conversions off the interface file 
C       Eliminate. 
C======================================================================= 
C     NOTE, WHEN METRIC OPTION IS USED, THE S/T BLOCK USES METRIC UNITS 
C       INTERNALLY. 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'S1.INC' 
C======================================================================= 
CIM   CHANGE 3 to MQUAL 
CIM	CHANGE 10 TO MQUAL 
      DIMENSION ANS(2),IPOLL(MQUAL),PCAR(MQUAL),PCAR1(MQUAL),TEMP(12), 
     1ALPHA(2) 
Cwch, 11/24/03. Add POLL2() for printing at statement 6730. 
      DIMENSION POLC(MQUAL),POLCL(MQUAL),POLL(MQUAL,NIE), 
     1POLL1(MQUAL,NIE),POLL2(MQUAL,NIE) 
      DIMENSION SPG(MQUAL),VIS(12),QO1(NIE),QO(NIE) 
C#### WCH, 2/27/95.  NEED THREE TEMPORARY ARRAYS FOR POLLUTANTS. 
      DIMENSION PNAMET(MQUAL), PUNITT(MQUAL), NDIMT(MQUAL) 
      CHARACTER PNAMET*8, PUNITT*8 
C 
      CHARACTER ANS*3,SOUR(3)*40,DMON(12)*4,PDUM1*2,ALPHA*80 
      DATA ANS/' NO','YES'/ 
      DATA DMON/' JAN',' FEB',' MAR',' APR',' MAY','JUNE','JULY',' AUG', 
     1          'SEPT',' OCT',' NOV',' DEC'/,PDUM1/'TO'/ 
C======================================================================= 
C     Define statement function for linear interpolation. 
C======================================================================= 
      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1) 
C======================================================================= 
      SOUR(1) = 'EXTERNAL FILE' 
      SOUR(2) = 'INPUT ON LINE J1' 
      SOUR(3) = 'INPUT ON LINE J1 AND EXTERNAL FILE' 
C======================================================================= 
      WRITE(*,150) 
      WRITE(N6,150) 
      LOCATS = 1 
      KDT    = 0 
      IPT    = 0 
      INCNT  = INCNT  + 1 
      IOUTCT = IOUTCT + 1 
      LAST   = JIN(INCNT) 
      NEXT   = JOUT(IOUTCT) 
C======================================================================= 
C     Open all input/output files for the Storage/Treatment Block. 
C======================================================================= 
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR. 
     +      FFNAME(INCNT).EQ.'JIN.UF')) 
     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND. 
     +      FFNAME(INCNT).NE.'JIN.UF') 
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR. 
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF')) 
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND. 
     +      FFNAME(25+IOUTCT).NE.'JIN.UF') 
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
C======================================================================= 
C     MULTIPLY FLOWS ON INTERFACE FILE BY QCONV TO OBTAIN CFS. 
C     QCONV IS INPUT FROM PRIOR BLOCKS OR ELSE ALTERED LATER IF 
C       METRIC OPTION IS USED. 
C======================================================================= 
      QCONV  = 1.0 
      WRITE(*,9500) 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP A1  <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,TITLE(1) 
      READ(N5,*,ERR=888) CC,TITLE(2) 
      ALPHA(1) = TITLE(1) 
      ALPHA(2) = TITLE(2) 
      TITLE(3) = TITLE(1) 
      TITLE(4) = TITLE(2) 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP B1  <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,NOTAPE,JNS,NDT,DS,NU,NP,ICOST,METRIC,TRIBA 
      METRIC = METRIC + 1 
C#### WCH, 7/7/95.  TRIBA ALWAYS IN ACRES. 
      IF(METRIC.EQ.2) TRIBA = TRIBA*2.471 
C 
      IF(NOTAPE.EQ.1) THEN 
                      NLOC(1) = JNS 
                      JS      = 1 
                      ENDIF 
      IF(NU.LE.0)    NU    = 1 
      IF(ICOST.GT.1) ICOST = 1 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP C1 AND C2  <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,IDATE,TIME,ISUM,IDET,NPR 
      JYEAR = IDATE/10000 
      IF (JYEAR.LT.100) THEN 
       IDATE = IDATE-JYEAR*10000 
       JYEAR = JYEAR + 1900 
       IDATE = IDATE+JYEAR*10000 
       ENDIF 
      IF(ISUM.GT.2) ISUM=2 
      TZERO    = TIME*3600.0 
      TIMDAY   = TZERO 
      TIME     = TZERO 
      TCAR1    = TIME/3600.0 
      QCAR1    = 0.0 
	DO IP = 1,NP 
	PCAR1(IP) = 0.0 
c      PCAR1(1) = 0.0 
c      PCAR1(2) = 0.0 
c      PCAR1(3) = 0.0 
	ENDDO 
      NYEAR   = IDATE/10000 
      NDAY    = IDATE - NYEAR*10000 
      MONTH   = NDAY/100 
      NDAY    = NDAY - MONTH*100 
      IF(NDAY.LE.0) NDAY   = 2 
      IF(MONTH.LE.0) MONTH = 8 
      IF(NYEAR.LT.0) NYEAR = 1941 
CIM ### 9/8/00 for some reason I changed above to this 
C      IF (NDAY+MONTH+NYEAR.EQ.0) THEN 
C      NDAY = 2 
C      MONTH = 8 
C      NYEAR = 1941 
C      ENDIF 
      JULDAY               = 1000*NYEAR + JDATE(NDAY,MONTH,NYEAR) 
      CALL DATED 
      NBD(1) = NYEAR 
      NBD(2) = MONTH 
      NBD(3) = NDAY 
      NBD(4) = JHR 
      NBD(5) = MINUTE 
      NBD(6) = JSEC 
      JDAY   = JULDAY 
      TMDAY  = TIMDAY 
C======================================================================= 
C#### WCH, 12/5/94.  MOVE ECHO OF B1-C1 DATA TO HERE (FROM STMT 3000). 
C     ALSO, ADD ECHO OF PRINT CONTROL INPUT DATA. 
C#### WCH, 12/5/94.  ADD NOTAPE, INITIAL JULIAN DAY, DURATION TO 
C       PRINT-OUT. 
C======================================================================= 
      WRITE(N6,3010) NOTAPE,SOUR(NOTAPE+1) 
      WRITE(N6,3020)  JNS,NDT,DS,NU,ANS(ICOST+1),MONTH,NDAY,NYEAR, 
     1                JULDAY,JHR,MINUTE,JSEC 
C======================================================================= 
C#### WCH, 12/5/94.  Include print of ending Julian date. 
C     Calculate ending Julian day. 
C======================================================================= 
      DUR    = FLOAT(NDT)*DS 
      CALL NDATE(DUR,JEND,TMEND) 
      DURTON = FLOAT(NDT)*DS/3600. 
      WRITE (N6,3019) DURTON,JEND,TMEND/3600. 
C#### WCH, 12/5/94.  ECHO INPUT PRINT PARAMETERS. 
      IF(ISUM.EQ.1) WRITE (N6,3021) 
      IF(ISUM.EQ.2) WRITE (N6,3022) 
      IF(ISUM.EQ.0) WRITE (N6,3023) 
      IF(IDET.EQ.0) WRITE (N6,3024) 
      DURTON  = FLOAT(IDET)*DS/60. 
      IF(IDET.GT.0) WRITE (N6,3025) IDET,DURTON 
C 
C======================================================================= 
C#### WCH, 12/5/94.  CHECK FOR IDET > 0 AND NPR = 0 AND ALLOW FOR 
C     INPUTTING 0,0 FOR ISTART AND IEND AS IN RUNOFF BLOCK M2 LINES. 
C======================================================================= 
      IF(IDET.GT.0.AND.NPR.EQ.0) THEN 
           WRITE (N6,3026) 
           NPR = 1 
           ENDIF 
C======================================================================= 
C>>>>>>>> READ DATA GROUP C2 <<<<<<<< 
C======================================================================= 
      IF(IDET.GT.0) READ(N5,*,ERR=888) CC,(ISTART(L),IEND(L),L=1,NPR) 
      DO L=1,NPR 
      JYEAR = ISTART(L)/10000 
      IF ((ISTART(L).GT.0).AND.(JYEAR.LT.100)) THEN 
        ISTART(L) = ISTART(L)-JYEAR*10000 
        JYEAR = JYEAR + 1900 
        ISTART(L) = ISTART(L)+JYEAR*10000 
        ENDIF 
      JYEAR = IEND(L)/10000 
      IF ((IEND(L).GT.0).AND.(JYEAR.LT.100)) THEN 
        IEND(L) = IEND(L)-JYEAR*10000 
        JYEAR = JYEAR + 1900 
        IEND(L) = IEND(L)+JYEAR*10000 
        ENDIF 
      ENDDO 
C======================================================================= 
      DO 1000 L = 1,NPR 
C======================================================================= 
C#### WCH, 12/5/94.  ALLOW 0,0 ENTRY ON SINGLE C2 LINE FOR PRINTING 
C     FOR ENTIRE SIMULATION, AS IN RUNOFF BLOCK M2 LINES. 
C======================================================================= 
      IF(NPR.EQ.1.AND.ISTART(1).EQ.0.AND.IEND(1).EQ.0) THEN 
           WRITE (N6,3027) 
           ISTART(1) = JULDAY 
           IEND(1)   = JEND 
           GO TO 1000 
           ELSE 
           IF(L.EQ.1) WRITE (N6,3028) 
           WRITE (N6,3029) L,ISTART(L),IEND(L) 
           ENDIF 
C 
      N1        = ISTART(L)/10000 
      N3        = ISTART(L) - N1*10000 
      N2        = N3/100 
      N3        = N3 - N2*100 
      ISTART(L) = 1000*N1 + JDATE(N3,N2,N1) 
      N1        = IEND(L)/10000 
      N3        = IEND(L) - N1*10000 
      N2        = N3/100 
      N3        = N3 - N2*100 
      IEND(L)  = 1000*N1 + JDATE(N3,N2,N1) 
 1000 CONTINUE 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP D1  <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,(E(NM),NM=1,12) 
      IF(NP.EQ.0) GO TO 2000 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP E1  <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,(IPOLL(IP),NDIM(IP),IPART(IP), 
     1                       PNAME(IP),PUNIT(IP),IP=1,NP) 
      DO 1420 IP = 1,NP 
      IPT        = IPT+IPART(IP) 
      IF(NOTAPE.EQ.1) IPOLL(IP) = IP 
 1420 CONTINUE 
C======================================================================= 
C>>>>>>>>  READ DATA GROUPS E2 AND E3  <<<<<<<< 
C======================================================================= 
      IF(IPT.LE.0) GO TO 2000 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP E2 <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,NVS,NNR 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP E3 <<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,(RAN(KJ,1),RAN(KJ,2),KJ=1,NNR) 
      IF(NVS.GT.0) THEN 
                   DO 1450 KJ = 1,NNR 
 1450              VS(KJ) = (RAN(KJ,1)+RAN(KJ,2))/2.0 
                   ELSE 
C======================================================================= 
C>>>>>>>>  READ DATA GROUPS E4 AND E5  <<<<<<<< 
C======================================================================= 
                   READ(N5,*,ERR=888) CC,(SPG(KJ),KJ=1,NNR) 
                   READ(N5,*,ERR=888) CC,(TEMP(NM),NM=1,12) 
                   DO 1470 NM = 1,12 
                   IF(METRIC.EQ.1) VIS(NM)=8.46E-4/(TEMP(NM)+10.0) 
 1470              IF(METRIC.EQ.2) VIS(NM)=0.78596/(1.8*TEMP(NM)+42.0) 
                   ENDIF 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP E6  <<<<<<<< 
C======================================================================= 
      DO 1495 IP = 1,NP 
      IF(IPART(IP).LE.0) GO TO 1495 
      READ(N5,*,ERR=888) CC,(PSD(IP,KJ),KJ=1,NNR) 
      TOTPSD     = 0.0 
      DO 1485 KJ = 1,NNR 
 1485 TOTPSD     = TOTPSD+PSD(IP,KJ) 
      IF(TOTPSD.LT.0.99999.OR.TOTPSD.GT.1.00001) THEN 
                                     WRITE(N6,1490) IPOLL(IP) 
                                     STOP 
                                     ENDIF 
 1495 CONTINUE 
C======================================================================= 
C     READ INPUT INTERFACE FILE HEADER INFORMATION 
C======================================================================= 
 2000 IF(NOTAPE.NE.1) CALL INFACE(1,LAST) 
C======================================================================= 
Cwch, 4/18/02.  Add error check for incompatible JCE. 
C	Allow program to continue but warn of impending error.  
C======================================================================= 
      IF(NJCE.NE.JCE) THEN 
		WRITE(N6,4005)  
	    WRITE(*,4005) 
	    ENDIF 
C 
      IF(NP.GT.0) THEN 
C#### WCH, 2/27/95.  NEED TO SET UP CORRECT NAME, UNITS, NDIM FROM 
C     POSITION OF POLLUTANT ON FILE ==> IPOLL(). 
C     EASIEST WAY IS TO SAVE TEMPORARILY INCOMING NAME, UNITS, NDIM. 
                  DO 2260 IP = 1,NQUAL 
                  PNAMET(IP) = PNAME(IP) 
                  PUNITT(IP) = PUNIT(IP) 
 2260             NDIMT(IP)  = NDIM(IP) 
C 
                  DO 2270 IP = 1,NP 
c                  IF(IP.GT.NP) GO TO 2270 
C#### WCH, 2/27/95.  GIVE CORRECT NAME, UNIT, DIMENSIONS TO POLLUTANTS. 
                  IPX = IPOLL(IP) 
                  PNAME(IP) = PNAMET(IPX) 
                  PUNIT(IP) = PUNITT(IPX) 
                  NDIM(IP)  = NDIMT(IPX) 
C 
                  IF(METRIC.EQ.1) THEN 
                            PCONV(IP) = 16017.0 
                            IF(NDIM(IP).EQ.1) PCONV(IP)=3.5315E-2 
                            ELSE 
                            PCONV(IP) = 1000.0 
                            IF(NDIM(IP).EQ.1) PCONV(IP)=0.001 
                            ENDIF 
                  IF(NDIM(IP).GE.2) PCONV(IP) = 1.0 
 2270             CONTINUE 
                  ENDIF 
C======================================================================= 
C     WRITE THE OUTPUT INTERFACE HEADER INFORMATION 
C======================================================================= 
      IF(NEXT.GT.0) THEN 
C#### WCH, 8/4/93. SET QCONV FOR METRIC IF S/T IS FIRST BLOCK RUN. 
                    IF(METRIC.EQ.2.AND.NOTAPE.EQ.1) QCONV=CMET(8,2) 
                    REWIND NEXT 
                    SOURCE   = 'S/T BLOCK' 
                    TITLE(3) = ALPHA(1) 
                    TITLE(4) = ALPHA(2) 
                    WRITE(NEXT) LOCATS,NP 
                    WRITE(NEXT) (NLOC(JJS),JJS=1,LOCATS) 
                    CALL INFACE(2,NEXT) 
                    ENDIF 
C======================================================================= 
C      LOCATE INPUT INTERFACE NODE LOCATIONS 
C======================================================================= 
 2500 IF(NOTAPE.NE.1) THEN 
                      DO 2550 JS = 1,LOCATS 
                      IF(NLOC(JS).EQ.JNS) GO TO 3000 
 2550                 CONTINUE 
                      WRITE(N6,2570) JNS,LAST 
                      STOP 
                      ENDIF 
C======================================================================= 
C#### WCH, 12/5/94.  MOVE LINES B1-C2 I/O ECHO PRINTS TO EARLIER SPOT. 
C# 3000 WRITE(N6,3010) SOUR(NOTAPE+1) 
C#      WRITE(N6,3020)  JNS,NDT,DS,NU,ANS(ICOST+1),MONTH,NDAY,NYEAR,JHR, 
C#     +                MINUTE,JSEC 
 3000 IF(METRIC.EQ.1) WRITE(N6,3030) TRIBA 
C#### WCH, 7/7/95.  CORRECT METRIC PRINT-OUT OF TRIBA.  CONVERT TO HA. 
      IF(METRIC.EQ.2) WRITE(N6,3040) TRIBA/2.471 
      WRITE(N6,3060) NP 
      IF(NP.GT.0) THEN 
                  DO 3070 IP = 1,NP 
C#### WCH, 12/5/94.  ADD PRINT OF IPART(). 
 3070             WRITE(N6,3080)IP,PNAME(IP),PUNIT(IP),IPART(IP), 
     1                    ANS(IPART(IP)+1) 
                  ENDIF 
C 
      IF(METRIC.EQ.1) WRITE(N6,3110) 
      IF(METRIC.EQ.2) WRITE(N6,3120) 
      WRITE(N6,3130) (DMON(NM),NM=1,12),(E(NM),NM=1,12) 
C 
      IF(IPT.LE.0) GO TO 4000 
      IF(NVS.LE.0) WRITE(N6,3210) 
      IF(NVS.GT.0) WRITE(N6,3220) 
      WRITE(N6,3230) (RAN(KJ,1),KJ=1,NNR) 
      IF(NVS.LE.0) WRITE(N6,3240) (PDUM1,KJ=1,NNR) 
      IF(METRIC.EQ.1.AND.NVS.GT.0) WRITE(N6,3250) (PDUM1,KJ=1,NNR) 
      IF(METRIC.EQ.2.AND.NVS.GT.0) WRITE(N6,3255) (PDUM1,KJ=1,NNR) 
      WRITE(N6,3230) (RAN(KJ,2),KJ=1,NNR) 
      IF(NVS.EQ.0) WRITE(N6,3260) (SPG(KJ),KJ=1,NNR) 
      DO 3280 IP = 1,NP 
 3280 WRITE(N6,3290) PNAME(IP),(PSD(IP,KJ),KJ=1,NNR) 
C 
 3300 IF(NVS.GT.0)   GO TO 4000 
      WRITE(N6,3350) (DMON(NM),NM=1,12) 
      IF(METRIC.EQ.1) WRITE(N6,3370)(TEMP(NM),NM=1,12),(VIS(NM),NM=1,12) 
      IF(METRIC.EQ.2) WRITE(N6,3390)(TEMP(NM),NM=1,12),(VIS(NM),NM=1,12) 
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
 4000 WRITE(*,9510) 
      CALL STRDAT 
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
      QOL     = 0.0 
      QCARL   = 0.0 
C#### WCH, 7/7/95.  QO(JS) is used twice.  Define new variable to keep 
C       separate. 
      QOJS    = 0.0 
C 
      QO(JS)  = 0.0 
      QO1(JS) = 0.0 
      IF(NP.GT.0) THEN 
                  DO 6010 IP = 1,NP 
 6010             POLCL(IP)  = 0.0 
                  ENDIF 
C======================================================================= 
C     MAIN TIME LOOP 
C======================================================================= 
      WRITE(*,23) NDT,JEND 
      DO 9000 KDT = 1,NDT 
C####      WRITE(*,22)   KDT 
      TIME        = TIME + DS 
      TIMEHR      = TIME/3600.0 
      CALL STIME(DS) 
      CALL DATED 
C#### WCH, 12/5/94.  MOVE WRITE TO HERE AND ADD JULIAN DAY. 
C***WCH, 9/27/99. WRITE TO UNIT 6 TO GET CARRIAGE CONTROL. 
C      WRITE(*,22)   KDT,JULDAY 
      WRITE(6,22)   KDT,JULDAY 
      IF(NP.GT.0) THEN 
                  DO 6110 IP  = 1,NP 
                  POLC(IP)    = 0.0 
                  PCRC(IP)    = 0.0 
 6110             PCTP(IP)    = 0.0 
                  ENDIF 
C======================================================================= 
C>>>>>>>>  READ DATA GROUP J1  <<<<<<<< 
C======================================================================= 
      IF(NOTAPE.GE.1) THEN 
 7050           IF(TIMEHR.GT.TCAR1) THEN 
                   TCAR = TCAR1 
                   QCAR = QCAR1 
                   IF(NP.GT.0) THEN 
						DO IP = 1,NP 
	                    PCAR(IP) = PCAR1(IP) 
	                    ENDDO 
c                               PCAR(1) = PCAR1(1) 
c                               PCAR(2) = PCAR1(2) 
c                               PCAR(3) = PCAR1(3) 
                               READ(N5,*,ERR=888) CC,TCAR1,QCAR1, 
     +                                        (PCAR1(IP),IP=1,NP) 
                               ELSE 
                               READ(N5,*,ERR=888) CC,TCAR1,QCAR1 
                               ENDIF 
                   IF(TCAR1.LT.TIMEHR) GO TO 7050 
                   ENDIF 
                QCARD = QLINTP(QCAR,QCAR1,TCAR,TCAR1,TIMEHR) 
                IF(NP.GT.0) THEN 
                            DO 6210 IP = 1,NP 
                            QQ1      = QCAR*PCAR(IP) 
                            QQ2      = QCAR1*PCAR1(IP) 
                            POLC(IP) = QLINTP(QQ1,QQ2,TCAR,TCAR1,TIMEHR) 
 6210                       CONTINUE 
                            ENDIF 
                ENDIF 
C======================================================================= 
C     READ INTERFACE FILE FLOWS AND LOADS 
C     During interpolation, 
C     Begin interface file dt			End interface file dt 
C     Flow:      QOJS()					     QO1() 
C     Pollutant  POLL()						 POLL1() 
C======================================================================= 
      IF(NOTAPE.NE.1) THEN 
 6400 IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN 
C#### WCH, 7/7/95.  HERE, USE NEW VARIABLE QOJS FOR OLD INFLOW. 
C####          QO(JS)    = QO1(JS) 
           QOJS = QO1(JS) 
C 
           IF(NP.GT.0) THEN 
                DO 4520 J  = 1,NP 
 4520           POLL(J,JS) = POLL1(J,JS) 
                ENDIF 
C======================================================================= 
C     On interface file, flow has units of cfs or cms, depending on 
C     parameter METRIC.  
C     Load has units of concentration*cfs or concentration*cms, also 
C     depending on METRIC. 
C     If METRIC = 2, QCONV = 35.3... ft3/m3. 
Cwch, 11/24/03. 
C     Since S/T uses metric units direction, should not need any 
C     conversions 
C======================================================================= 
           IF(NQUAL.EQ.0) READ(LAST,END=999) JDAY,TMDAY,DELTA, 
     +                                  (QO1(J),J=1,LOCATS) 
           IF(NQUAL.GT.0) READ(LAST,END=999) JDAY,TMDAY,DELTA, 
     +                    (QO1(J),(POLL1(IP,J),IP=1,NQUAL),J=1,LOCATS) 
           GO TO 2995 
  999      QO(JS)      = 0.0 
C#### WCH, 7/7/95 
           QOJS        = 0.0 
C 
           QO1(JS)     = 0.0 
           DO 2990  J  = 1,NQUAL 
           POLL1(J,JS) = 0.0 
           POLL(J,JS)  = 0.0 
 2990      CONTINUE 
           WRITE(N6,9200) TIME/3600.0 
           JDAY       = 9999999 
           TMDAY      = 0.0 
 2995      CONTINUE 
           TREF = TIMEHR 
           CALL NTIME(JDAY,TMDAY,TFILE) 
           IF(TFILE.LT.0.0) GO TO 6400 
           TFILE = TFILE/3600.0 
Cwch, 11/24/03. Eliminate back and forth conversions from metric. 
C           IF(NQUAL.GT.0.AND.NP.GT.0) THEN 
C                DO 6410 IP   = 1,NP 
C                IPX          = IPOLL(IP) 
C======================================================================= 
C     If METRIC = 2, internal flows are in cms and loads are cms*concen. 
C     Thus, multiply by 2.8317E-2 because will multiply by QCONV later. 
C     QCONV = 35.314667 cfs/cms = 1 / 0.28317E-2 when metric flows are on 
C     interface file.  Thus, interface flows and loads are converted 
C     properly whether in cfs or cms. 
C======================================================================= 
C                IF(METRIC.EQ.2) POLL1(IPX,JS) = 
C     +                                POLL1(IPX,JS)*2.8317E-2 
C 6410           POLL1(IPX,JS) = POLL1(IPX,JS)*QCONV 
C                ENDIF 
C======================================================================= 
C     If METRIC = 2 (metric units), QO1 has units of cms/35...  in line 
C     below.  But flow is multiplied by QCONV = 35...  later below 
C     and converted back to cms. 
C======================================================================= 
C           IF(METRIC.EQ.2) QO1(JS) = QO1(JS)*2.8317E-2 
           ENDIF 
C======================================================================= 
      THR = TIMEHR - TREF 
C#### WCH, 7/7/95.  HERE, USE NEW VARIABLE QOJS. 
C####      QQ1 = QO(JS) 
      QQ1 = QOJS 
      QQ2 = QO1(JS) 
Cwch, 11/24/03. Eliminate metric conversion with QCONV. 
C      IF(TFILE.EQ.0.0) QOO = QQ2*QCONV 
C      IF(TFILE.GT.0.0) QOO = QLINTP(QQ1,QQ2,0.0,TFILE,THR)*QCONV 
      IF(TFILE.EQ.0.0) QOO = QQ2 
      IF(TFILE.GT.0.0) QOO = QLINTP(QQ1,QQ2,0.0,TFILE,THR) 
C======================================================================= 
C     AT THIS POINT, QOO SHOULD HAVE UNITS OF CFS OR CMS, APPROPRIATELY. 
C======================================================================= 
      IF(NP.GT.0) THEN 
                  DO 4530 IP = 1,NP 
                  IPX        = IPOLL(IP) 
                  QQ1        = POLL(IPX,JS) 
                  QQ2        = POLL1(IPX,JS) 
C####################################################################### 
C#### WCH, 7/7/95.  ONE CONVERSION TOO MANY??  POLL1 AND POLL SHOULD 
C     ALREADY BE IN UNITS OF FLOW*CONC WHERE FLOW IS CFS OR CMS OR 
C     WHATEVER UNITS ARE ON INTERFACE FILE.  DON'T MULTIPLY AGAIN 
C     BY QCONV (= 35... FOR METRIC=2). 
C======================================================================= 
C####                  IF(TFILE.EQ.0.0) POLC(IP) = POLC(IP) + QQ2*QCONV 
C####                  IF(TFILE.GT.0.0) POLC(IP) = POLC(IP) + 
C####     +                         QLINTP(QQ1,QQ2,0.0,TFILE,THR)*QCONV 
                  IF(TFILE.EQ.0.0) POLC(IP) = POLC(IP) + QQ2 
                  IF(TFILE.GT.0.0) POLC(IP) = POLC(IP) + 
     +                         QLINTP(QQ1,QQ2,0.0,TFILE,THR) 
C 
 4530             CONTINUE 
                  ENDIF 
      ENDIF 
C======================================================================= 
C     Calculate average flow over the time interval. 
C     QQTP = will have units of cfs or cms appropriately. 
C======================================================================= 
      QQTP  = (QCARD + QCARL + QOO + QOL)/2.0 
C======================================================================= 
C     Save old flow values. 
C======================================================================= 
      QCARL = QCARD 
      QOL   = QOO 
C======================================================================= 
C     CALCULATE AVERAGE CONCENTRATION OVER THE TIME INTERVAL 
C======================================================================= 
      IF(NP.GT.0) THEN 
                  DO 6470 IP = 1,NP 
                  IPX        = IPOLL(IP) 
C###################################################################### 
C#### WCH, 7/7/95.  DON'T CONVERT AGAIN HERE.  POLL(JS) = POLL1(JS) 
C     JUST BEFORE READING INTERFACE FILE.  SHOULD BE OK. 
C     TO GET AVG. CONC., SHOULD BE DIVIDING CFS*CONC / CFS OR 
C     CMS*CONC / CMS. 
C======================================================================= 
C####           IF(METRIC.EQ.2) POLL(IPX,JS) = POLL(IPX,JS)*2.8317E-2 
                  IF(QQTP.GT.0.0) PCTP(IP)     = (POLC(IP) + POLCL(IP)) 
     +                                                     / (2.0*QQTP) 
                  POLCL(IP) = POLC(IP) 
 6470             CONTINUE 
                  ENDIF 
C======================================================================= 
C     COMPUTE SETTLING VELOCITIES (TO LABEL 6580).  THIS ROUTINE 
C     WAS DEVELOPED BY M.B. SONNEN, SEPTEMBER 1977. 
C======================================================================= 
      IF(IPT.LE.0.OR.NVS.GT.0)      GO TO 6600 
      IF(LTM.EQ.MONTH.AND.KDT.GT.1) GO TO 6600 
      IF(METRIC.EQ.2) VIS(MONTH) = VIS(MONTH)/929.03 
      DO 6580 KJ = 1,NNR 
      PSIZE      = (RAN(KJ,1)+RAN(KJ,2))/(2.0*304800.0) 
      IF(SPG(KJ).LT.1.0) SPG(KJ) = 1.0 
      CON1   = (4.0/3.0)*PSIZE*32.2*(SPG(KJ)-1.0) 
      CD     = 0.34 
      VS(KJ) = SQRT(CON1/CD) 
      R      = VS(KJ)*PSIZE/VIS(MONTH) 
      IF(R.GT.3000.0) GO TO 6580 
      CD     = 1.0 
      VS(KJ) = SQRT(CON1/CD) 
      R      = VS(KJ)*PSIZE/VIS(MONTH) 
      IF(R.GT.100.0) GO TO 6510 
      CD     = 10.0 
      VS(KJ) = SQRT(CON1/CD) 
      R      = VS(KJ)*PSIZE/VIS(MONTH) 
      IF(R.GT.2.0) GO TO 6510 
      CD     = 200.0 
      VS(KJ) = SQRT(CON1/CD) 
      R      = VS(KJ)*PSIZE/VIS(MONTH) 
      IF(R.GT.0.1) GO TO 6510 
      GO TO 6570 
 6510 KN = 0 
 6520 KN = KN+1 
      R  = VS(KJ)*PSIZE/VIS(MONTH) 
      IF(R.LT.0.1) GO TO 6570 
      F = CD-(24.0*VIS(MONTH)/PSIZE)/VS(KJ)-(3.0*(VIS(MONTH)/PSIZE)** 
     1    0.5)/VS(KJ)**0.5-0.34 
      IF(ABS(F).LT.0.005*CD) GO TO 6580 
      IF(KN.GT.1)            GO TO 6530 
      FL = F 
      IF(ABS(FL).LT.0.0049)      GO TO 6580 
 6530 IF(ABS(F).GT.10.0*ABS(FL)) GO TO 6540 
                      CD1 = CD-F 
      IF(CD1.LT.0.34) CD1 = 0.34 
      CD     = CD1 
      VS(KJ) = SQRT(CON1/CD) 
      IF(KN.LT.10) GO TO 6520 
 6540 WRITE(N6,6550) RAN(KJ,1),RAN(KJ,2) 
      STOP 
 6570 VS(KJ) = (32.2/18.0)*(SPG(KJ)-1.0)*PSIZE**2.0/VIS(MONTH) 
 6580 CONTINUE 
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
 6600 CALL CONTRL 
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
 6700 IF(NEXT.GT.0) THEN 
C#### ROB JAMES (BY WCH), 8/4/93.  REMOVE THIS CONVERSION IN ORDER 
C####   TO PLACE METRIC FLOWS (M^3/SEC) ON INTERFACE FILE. 
CC      IF(METRIC.EQ.2) QQRC = QQRC/2.8317E-2 
C======================================================================= 
C     HERE, ASSIGN OUTFLOW FROM PLANT TO QO(JS) AND SET FLOWS AT OTHER 
C     NODES ON INTERFACE FILE TO THEIR INFLOW VALUES. 
C======================================================================= 
           QO(JS)    = QQRC 
           DO 6720 J = 1,LOCATS 
           IF(J.EQ.JS) GO TO 6720 
           QO(J)     = QO1(J) 
 6720      CONTINUE 
           IF(NP.GT.0) THEN 
                  DO 6730 IP   = 1,NP 
Cwch, 11/24/03.  Need new POLL variable since here we change meaning 
C     from value saved for interpolation. 
C 6730             POLL1(IP,JS) = PCRC(IP)*QQRC 
C                  WRITE(NEXT) JULDAY,TIMDAY,DS,(QO(J),(POLL1(IP,J), 
 6730             POLL2(IP,JS) = PCRC(IP)*QQRC 
                  WRITE(NEXT) JULDAY,TIMDAY,DS,(QO(J),(POLL2(IP,J), 
     1                        IP=1,NP),J=1,LOCATS) 
                  ELSE 
                  WRITE(NEXT) JULDAY,TIMDAY,DS,(QO(J),J=1,LOCATS) 
                  ENDIF 
           ENDIF 
 9000 CONTINUE 
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
      IF(ICOST.GT.0) CALL STCOST 
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
      WRITE(*,8050) 
      WRITE(N6,8050) 
C======================================================================= 
C#### WCH, 12/5/94.  Alter 22 and 23 to add Julian dates. 
   22 FORMAT('+',I19,I22) 
   23 FORMAT(/,' Beginning loop through',I7,' time steps.',/, 
     1         ' End at Julian date:',I8,/, 
     2         ' Current time step #   Current Julian date ',/) 
  150 FORMAT(/,' ###########################################',/, 
     1         ' # Entry made to Storage/Treatment Block.  #',/, 
     2         ' # Storage/Treatment model written by the  #',/, 
     3         ' # University of Florida, June 1981.       #',/, 
     4         ' # Last updated July 1995 at Oregon St. U. #',/, 
     5         ' ###########################################',/) 
 1490 FORMAT(/,' ===> ERROR  THE PARTICLE SIZE OR V 
     1ELOCITY DISTRIBUTION FOR POLLUTANT ',I1,' DOES NOT SUM TO 1.0.',/, 
     232X,'SIMULATION TERMINATED.') 
 2570 FORMAT(/,' ===> ERROR  THE SELECTED EXTERNAL', 
     1' ELEMENT NUMBER, ',I4,' IS NOT AVAILABLE FROM',/,32X,'DATA-SET. ' 
     2,I3,'.  SIMULATION TERMINATED.') 
C#### WCH, 12/5/94.  ADD PRINT OF NOTAPE. 
 3010 FORMAT(/,1X,'VALUE OF NOTAPE           :',I10,//, 
     1         1X,'INPUT DATA SOURCE         :',2X,A40) 
C#### WCH, 12/5/94.  NEW 3019 FORMAT. 
 3019 FORMAT(/,1X,'SIMULATION DURATION, HOURS:',F10.3,//, 
     1         1X,'ENDING JULIAN DATE        :',I10,//, 
     1         1X,'ENDING TIME OF DAY        :',F10.3,' HOURS') 
C#### WCH, 12/5/94.  CHANGE A BUNCH OF LEADING 10X SPACES TO 1X. THIS 
C     IS EQUIVALENT TO SUBTRACTING 9 LEADING SPACES IN MANY PLACES. 
C#### WCH, 12/5/94.  ADD STARTING JULIAN DATE. 
 3020 FORMAT(/,1X,'EXTERNAL ELEMENT NUMBER   :',I10,//, 
     1         1X,'NUMBER OF TIME STEPS      :',I10,//, 
     2         1X,'TIME STEP SIZE,SECONDS    :',F10.1,//, 
     3         1X,'NUMBER OF S/T UNITS       :',I10,//, 
     4         1X,'COST MODEL USED?          :',7X,A3,//, 
     5         1X,'STARTING DATE             :',4X,I2,'/',I2,'/',I4,//, 
     6         1X,'STARTING JULIAN DATE      :',I10,//, 
     7         1X,'STARTING TIME             :',2X,I3,':',I3,':',I3) 
C#### WCH, 12/5/94.  NEW 3021 - 3029 FORMATS. 
 3021 FORMAT(/,1X,'PRINT ANNUAL AND TOTAL SUMMARIES (ISUM = 1)') 
 3022 FORMAT(/,1X,'PRINT MONTHLY, ANNUAL AND TOTAL SUMMARIES (ISUM = 2) 
     1 ') 
 3023 FORMAT(/,1X,'PRINT TOTAL SIMULATION SUMMARY ONLY (ISUM = 0)') 
 3024 FORMAT(/,1X,'IDET = 0. NO DETAILED (TIME STEP) PRINT-OUTS.') 
 3025 FORMAT(/,1X,'DETAILED PRINT-OUT EVERY',I4,' (IDET) TIME STEPS = EV 
     1ERY',F8.2,'MIN.') 
 3026 FORMAT(/,1X,'WARNING. IDET > 0 AND NPR = 0.  PROGRAM WILL TRY TO R 
     1EAD AT LEAST ONE C2 LINE.') 
 3027 FORMAT(/,1X,'ZERO VALUES FOR ISTART, IEND (LINE C2).  PRINT FOR EN 
     1TIRE SIMULATION.') 
 3028 FORMAT(/,' TIME INTERVALS FOR DETAILED PRINT-OUTS (LINE C2):',/, 
     1 ' NUMBER     ISTART      IEND',/, 
     2 '          YR-MO-DAY  YR-MO-DAY') 
 3029 FORMAT(I5,I13,I11) 
C 
 3030 FORMAT(//,1X,'INPUT/OUTPUT UNITS        :   U.S. CUSTOMARY',//, 
     1          1X,'TRIBUTARY AREA, ACRES     :',F10.1) 
C#### WCH, 12/5/94.  CHANGE METRIC AREA TO HECTARES. 
 3040 FORMAT(//,1X,'INPUT/OUTPUT UNITS        :      METRIC',//, 
     1          1X,'TRIBUTARY AREA, HECTARES  :',F10.1) 
 3060 FORMAT(/,1X,'NUMBER OF POLLUTANTS      :',I10) 
 3080 FORMAT(/,1X,'POLLUTANT ',I1,'               :',4X,A8,//, 
     1         6X,'UNITS                :',4X,A8,/, 
     2         6X,'IPART                :',I10,/, 
     3         6X,'PART. SIZE/VEL. USED?:',7X,A3) 
 3110 FORMAT(//,10X,'MONTHLY EVAPORATION RATES, IN/DAY') 
 3120 FORMAT(//,10X,'MONTHLY EVAPORATION RATES, MM/DAY') 
 3130 FORMAT(/,1X,12(2X,A4,2X),//,1X,12(2X,F5.3,1X)) 
 3210 FORMAT(//,1X,'PARTICLE SIZES AND POLLUTANT FRACTIONS',//) 
 3220 FORMAT(//,1X,'SETTLING VELOCITIES AND POLLUTANT FRACTIONS',//) 
 3230 FORMAT(1X,10(1X,E9.3)) 
 3240 FORMAT(1X,'RANGE IN MICRONS    ',10(6X,1A2,2X)) 
 3250 FORMAT(1X,'RANGE IN FEET/SEC   ',10(6X,A2,2X)) 
 3255 FORMAT(1X,'RANGE IN CM/SEC     ',10(6X,A2,2X)) 
 3260 FORMAT(/,1X,'SPECIFIC GRAVITY    ',10(2X,F8.3)) 
C#### WCH (RED), 9/23/93.  CHANGE 2A4 TO A8. 
 3290 FORMAT(/,1X,'FRAC. OF ',A8,3X,10(5X,F5.3)) 
 3350 FORMAT(//,1X,'MONTHLY WATER TEMPERATURES AND KINEMATIC VISCOSITIES 
     1',//,21X,12(2X,1A4,2X)) 
 3370 FORMAT(/,1X,'TEMPERATURE, DEG. F ',12(2X,F4.1,2X),//,1X, 
     1            'VISCOSITY, SQ FT/SEC',12(1X,E7.2)) 
 3390 FORMAT(/,1X,'TEMPERATURE, DEG. C ',12(2X,F4.1,2X),//,1X, 
     1            'VISCOSITY, SQ CM/SEC',12(1X,E7.2)) 
Cwch, 4/18/02. 
 4005 FORMAT(/,' ERROR SAME ALPHANUMERIC OPTION ($ANUM) WAS NOT USED IN 
     1 ST/TREAT',/,' AS IN BLOCK THAT CREATED INTERFACE FILE.',/, 
	2' PROGRAM CONTINUES BUT UNPREDICTABLE ERROR WILL SOON RESULT.') 
C#### WCH, 12/5/94. ELIMINATE UNUSED 6311 FORMAT. 
 6550 FORMAT(/,' ===> WARNING  THE SETTLING VELOCITY 
     1 ROUTINE HAS NOT CONVERGED FOR THE RANGE',/,36X,F8.1,' TO ',F8.1, 
     2' MICRONS.  SIMULATION TERMINATED.') 
 8050 FORMAT(/,' ===> Storage/Treatment simulation ended normally.') 
CWCH, 11/11/99. INCREASE FIELD WITH FOR NUMBER OF HOURS. 
 9200 FORMAT(/,' ===> WARNING  END OF INPUT FILE REACHED AT TIME = ', 
     +         F10.1,' HOURS.',/, 
     +'                 SIMULATION CONTINUES WITH ZERO INFLOW.',/) 
 9500 FORMAT(/,' Reading general data and control information.') 
 9510 FORMAT(/,' Reading Storage/Treatment unit information.') 
C======================================================================= 
      RETURN 
  888 CALL IERROR 
      END 
 
REM File: swmm_WCH44_combined_1.FOR 
 
ECHO is off.
REM File: AREAL.FOR  
ECHO is off.
      SUBROUTINE AREAL(WSNOW,SI,NEWSNO,ASC,AWE,SBA,SBWS,RIN,ADC,DELT)  
C     RUNOFF BLOCK  
C     CALLED BY SNOW NEAR LINES 87 and 90  
C=======================================================================  
C  
C     FOR UF SNOW MELT ROUTINES, THIS ROUTINE FINDS FRACTION OF AREA  
C        COVERED BY SNOW (ASC).  
C     DEVELOPED JULY 1, 1977, BY W. HUBER AND UPDATED OCT. 4, 1977.  
C     USE ANDERSON'S NWS REPORT METHODS FOR HANDLING NEW SNOW.  
C     USES AREAL DEPLETION CURVE IN ARRAY ADC, (FOR VALUES OF ASC).  
C  
C     Fix computation when just moving down regular curve with no new  
C       snow.  WCH, 1/23/04.  
C=======================================================================  
      DIMENSION ADC(10)  
C  
      IF(WSNOW.LT.SI) GO TO 10  
C  
C     HERE IF COMPLETE SNOW COVERAGE FOR AREA.  
C  
      NEWSNO = 0  
      ASC    = 1.0  
      RETURN  
   10 IF(WSNOW.GT.0.0) GO TO 20  
C  
C     HERE IF NO SNOW.  
C  
      NEWSNO = 0  
      ASC    = 0.0  
      RETURN  
C=======================================================================  
C     "Normal" or easiest case is no new snow (either dry or rain), and  
C     operating on regular (not temporary) depletion curve.  We know  
C     we're not on temporary depletion curve if NEWSNO = 0.  
C     The statement below should be strictly RIN.LT.0, since if dry or   
C     rain, can just move down regular curve.    
C=======================================================================  
Cwch 1/23/04 Change IF as indicated above.  
C   20 IF(RIN.LE.0.0.OR.NEWSNO.EQ.1) GO TO 30  
   20 IF(RIN.LT.0.0.OR.NEWSNO.EQ.1) GO TO 30  
C  
C      HERE IF DESCENDING DOWN DEPLETION CURVE.  
C      Here if RIN >= 0 (rain or dry) *and* NEWSNO = 0 (not operating  
C      on temporary depletion curve).    
C  
      AWESI = WSNOW/SI  
C  
C     USE SUBROUTINE FINDSC FOR LINEAR INTERPOLATION.  
C  
Cwch 1/23/04.  Where did it go??  
C     Must call FINDSC   
      CALL FINDSC(AWESI,ASC,ADC)  
C***********************************************************************  
      NEWSNO = 0  
      RETURN  
C  
   30 IF(RIN.GE.0.0) GO TO 40  
C  
C     HERE IF NEW SNOW HAS FALLEN WHILE ON DEPLETION CURVE.  
C     MUST SET UP NEW PARAMETERS FOR TEMPORARY LINEAR DEPLETION CURVE.  
C     PARAMETER NEWSNO INDICATES NEW SNOW ON PARTIALLY BARE GROUND.  
C     If NEWSNO = 1, means start out on temporary depletion curve.   
C     If NEWSNO = 0, operate on regular depletion curve.   
C  
C     FIND AMOUNT OF SNOW PRESENT AT LAST TIME STEP  
C  
                     AWE = (WSNOW+RIN*DELT)/SI  
      IF(AWE.LE.0.0) AWE = 0.0  
C  
      CALL FINDSC(AWE,SBA,ADC)  
C***********************************************************************  
C  
                      SBWS = AWE - RIN * 0.75 * DELT / SI  
      IF(SBWS.GT.1.0) SBWS = 1.0  
      ASC    = 1.0  
      NEWSNO = 1  
      RETURN  
C  
C     HERE IF ON TEMPORARY DEPLETION CURVE, but no new snow.  
C  
   40 AWESI = WSNOW/SI  
      IF(AWESI.GE.AWE) GO TO 50  
C  
C     HERE IF HAVE MOVED BACK TO REGULAR DEPLETION CURVE.  
C  
      CALL FINDSC(AWESI,ASC,ADC)  
C***********************************************************************  
C  
      NEWSNO = 0  
      RETURN  
   50 IF(AWESI.LT.SBWS) GO TO 60  
C  
C     HERE IF STILL HAVE 100 % COVER OF NEW SNOW.  
C  
      ASC    = 1.0  
      NEWSNO = 1  
      RETURN  
C  
C     HERE IF ON TEMPORARY LINEAR DEPLETION CURVE.  
C  
   60 ASC = SBA+(1.0-SBA)/(SBWS-AWE)*(AWESI-AWE)  
      NEWSNO = 1  
      RETURN  
      END  
ECHO is off.
REM File: CIRCLE.FOR  
ECHO is off.
      SUBROUTINE CIRCLE(ALPHA,PS,DN,ID)  
C     TRANSPORT BLOCK  
C     CALLED BY FINDA NEAR LINE 41  
C=======================================================================  
C     ROUTINE TO COMPUTE HYDRAULIC ELEMENTS OF CIRCULAR PIPE.  
C                USES NEWTON-RAPHSON ITERATION TO FIND THETA.  
C     PARABOLIC STARTING GUESS VALID ONLY FOR THETA < 1.3 RADIANS,  
C                                        (ALPHA < 0.04, PSI < 0.015).  
C     WEAKER STARTING GUESSES FOR HIGHER VALUES COULD CONCEIVABLY  
C                                         CAUSE CONVERGENCE PROBLEMS.  
C     UPDATED (NEW COMMON) BY W.C.H., SEPTEMBER 1981.  
C     Modified by A.H.Elliot, Nat. Inst. Water Atm. Res, NZ, 29/6/00 to   
C     improve convergence for large theta.  Added to SWMM44gu by   
C     WCH, 8/10/00.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
C=======================================================================  
C     ALPHA = A/AFULL  
C     PS    = PSI = Q/QFULL  
C     DN    = DEPTH/DIAMETER  
C     THETA = SUBTENDED ANGLE  
C  
C     ID = 1, GIVEN ALPHA, COMPUTE THETA THEN PSI.  
C     ID = 2, GIVEN ALPHA, COMPUTE THETA THEN DN.  
C     ID = 3, GIVEN PSI,   COMPUTE THETA THEN ALPHA.  
C=======================================================================  
      IF(ID.LE.2) THEN  
         IF(ALPHA.LE.0.0.OR.ALPHA.GE.1.0) GO TO 200  
         IF(ALPHA.LE.1.0E-5)              GO TO 400  
C=======================================================================  
C     FIRST CALCULATE THETA GIVEN ALPHA.  
C     USE PARABOLIC APPROXIMATION FOR FIRST GUESS FOR ALPHA < 0.04  
C=======================================================================  
         THETA = 0.031715 - 12.79384 * ALPHA + 8.28479 * SQRT(ALPHA)  
         IF(ALPHA.GT.0.04) THETA = 1.2 + 5.08 * (ALPHA - 0.04) / 0.96  
         TH1 = THETA  
         AP  = 6.283185 * ALPHA  
C=======================================================================  
         DO 20 K = 1,40  
         D       = - (AP - THETA + SIN(THETA)) / (1 - COS(THETA))  
C     Modification by AHE, NIWA 29/6/00 to improve convergence for   
C     large theta  
	   IF(D>1) D=SIGN(1.,D)  
         THETA   = THETA - D  
         IF(ABS(D).LE.0.0001) GO TO 40  
   20    CONTINUE  
C=======================================================================  
C     IF NO CONVERGENCE, USE FIRST GUESS.  
C=======================================================================  
         THETA = TH1  
         WRITE(N6,35) ID,ALPHA,THETA  
C=======================================================================  
C     CALCULATE PSI.  
C=======================================================================  
   40    IF(ID.NE.2) THEN  
                  PS = (THETA - SIN(THETA)) ** 1.666667 /  
     +                 6.283185 / THETA ** .66667  
C=======================================================================  
C                 CALCULATE NORMALIZED DEPTH.  
C=======================================================================  
                  ELSE  
                  DN = (1.0 - COS(THETA / 2.0)) / 2.0  
                  ENDIF  
C=======================================================================  
C     END OF ID LE 2  
C=======================================================================  
         RETURN  
         ENDIF  
C=======================================================================  
C     START OF ID EQ 3  
C=======================================================================  
      IF(PS.LE.0.0.OR.PS.GE.1.0) GO TO 300  
      IF(PS.LE.1.0E-6)           GO TO 500  
C=======================================================================  
C        FIRST COMPUTE THETA GIVEN PSI.  
C        USE PARABOLIC APPROXIMATION FOR FIRST GUESS FOR PS < 0.015  
C=======================================================================  
      THETA = 0.12103 - 55.5075 * PS + 15.62254 * SQRT(PS)  
      IF(PS.GT.0.015) THETA = 1.2 + 1.94 * (PS - 0.015) / 0.485  
      IF(PS.GT.0.5)   THETA = 3.14 + 1.03 * (PS - 0.5) / 0.4  
      IF(PS.GT.0.90)  THETA = 4.17 + 1.12 * (PS - 0.90) / 0.176  
      TH1   = THETA  
      AP    = 6.283185 * PS  
C=======================================================================  
      DO 120 K = 1,40  
      THETA    = ABS(THETA)  
      TT       = THETA - SIN(THETA)  
      TT23     = TT ** 0.666667  
      T3       = THETA ** 0.333333  
      D        = AP * THETA / T3 - TT * TT23  
      D        = D/(AP*.666667/T3-1.666667*TT23*(1.0-COS(THETA)))  
      THETA    = THETA - D  
      IF(ABS(D).LE.0.0001) GO TO 140  
 120  CONTINUE  
C=======================================================================  
C     IF NO CONVERGENCE, USE FIRST GUESS.  
C=======================================================================  
      THETA = TH1  
      WRITE(N6,35) ID,PS,THETA  
C=======================================================================  
C     CALCULATE ALPHA  
C=======================================================================  
  140 ALPHA = (THETA - SIN(THETA)) / 6.283185  
      RETURN  
C=======================================================================  
  200 IF(ALPHA.GE.1.0) THEN  
                       PS    = 1.0  
                       DN    = 1.0  
                       ELSE  
                       PS    = 0.0  
                       DN    = 0.0  
                       ENDIF  
      RETURN  
C=======================================================================  
  300 IF(PS.GE.1.0) THEN  
                    ALPHA = 1.0  
                    ELSE  
                    ALPHA = 0.0  
                    ENDIF  
      RETURN  
C=======================================================================  
C     FOR SMALL ALPHA (HENCE THETA), USE EXPANSION FOR SIN & COSINE.  
C=======================================================================  
  400 THETA          = (37.69911 * ALPHA) ** 0.33333  
      IF(ID.EQ.1) PS = THETA ** 4.33333 / 124.4797  
      IF(ID.EQ.2) DN = THETA ** 2 / 16.0  
      RETURN  
C=======================================================================  
C     FOR SMALL PS (HENCE THETA), USE EXPANSION FOR SIN & COSINE.  
C=======================================================================  
  500 THETA = (124.4797 * PS) ** 0.2307692  
      ALPHA = THETA ** 3 / 37.69911  
      RETURN  
C=======================================================================  
   35 FORMAT(/,' ===>  WARNING  NO CONVERGENCE IN SUBROUTINE CIRCLE.  
     1. ID =',I8,'   ALPHA OR PSI =',1PE15.7,'   THETA1 =',1PE15.7,/)  
C=======================================================================  
      END  
ECHO is off.
REM File: CLINEDVS.FOR  
ECHO is off.
      SUBROUTINE CLINEDVS  
c2013 USE DFLIB  
C=======================================================================  
C   Option for command line input of file names.  
C   Written by Chuck Moore of CDM, 8/93.  
C=======================================================================  
C   This subroutine uses RMFortran-specific functions ARGC and ARGV to  
C     return number of arguments on command line (including .EXE file)  
C     and character values of the arguments, respectively.  
C   For Lahey Fortran, must include Function ARGC to accomplish same  
C     task.  
C=======================================================================  
C     WCH, 10/2/96.  Declare FPOS as integer to avoid Watcom compiler  
C       errors.  (Bruce LaZerte)  
C   Modified for Digital Visual Fortran  
C   CIM 6/97  
C=======================================================================  
      INCLUDE 'CLNAME.INC'  
      CHARACTER*128 FNAME  
      CHARACTER*1 FIRSTCH  
      INTEGER*2 I,IFIL  
C  
      INAMES=0  
      IFIL = NARGS()  
      NNAMES=0  
      IF (IFIL.EQ.1) RETURN  
C=======================================================================  
C   Note that program name is first name recognized; hence, ARGC always  
C     > 0.  
C=======================================================================  
      DO 100 I= 1,IFIL-1  
      CALL GETARG (I,FNAME)  
      FIRSTCH=FNAME  
C=======================================================================  
C   Allow for RM Fortran switch options to be included on command line.  
C=======================================================================  
      IF (FIRSTCH.EQ.'/')   GO TO 100  
       NNAMES=NNAMES+1  
       CNAMES(NNAMES) = FNAME  
100    CONTINUE  
      RETURN  
      END  
ECHO is off.
REM File: COMB1.FOR  
ECHO is off.
      SUBROUTINE COMB1(ICOMB)  
C	COMBINE BLOCK  
C=======================================================================  
C     COMB1 does the analysis for ICOMB options 3, 5, 6 and 7.  
C     WCH, 11/30/93.  Fix units for quality totals and modify time step  
C       multiplication during summations.   
C     WCH, 8/1/95.  Change precip. station ID to character.  
C     WCH, 7/25/96.  Add option to create ASCII rainfall interface file.  
C=======================================================================  
      INCLUDE 'TAPES.INC'   
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'COMB.INC'  
C#### WCH, 8/1/95.  MAKE JSTA A CHARACTER VARIABLE.  
C####      DIMENSION JSTA(10),PCONV(10),SUMM(11)  
CIMT change dimensions from 10 to MQUAL, and 11 to MQUAL+1  
      DIMENSION PCONV(MQUAL),SUMM(MQUAL+1)  
C#### WCH, 7/25/96.  
      CHARACTER*128 NEWFIL  
cred  up the number of rainfall stations to 2000 from 10 - 6/22/01  
      CHARACTER JOHNNY*10,NOTED(3)*10,MOTED(3)*10  
      DATA NOTED/'  Pounds  ',' Quantity ',' Unit*cf  '/  
C#### WCH, 11/30/93.  CHANGE TO:             Unit*cum and Unit*cf.  
      DATA MOTED/' Kilograms',' Quantity ',' Unit*cum '/  
      DATA JOHNNY/' ---------'/  
C=======================================================================  
C#### WCH, 7/25/96.  Open formatted file on JOUT (= NEXT).  
C=======================================================================  
      IF(ICOMB.EQ.7.or.ICOMB.EQ.12) THEN  
               INQUIRE(NEXT,NAME=NEWFIL)  
               CLOSE(NEXT)  
               OPEN(NEXT,FILE=NEWFIL,FORM='FORMATTED',STATUS='UNKNOWN')  
               ENDIF  
      IF(ICOMB.EQ.10) THEN  
             INQUIRE(LAST,NAME=NEWFIL)  
             CLOSE(LAST)  
             OPEN(LAST,FILE=NEWFIL,FORM='UNFORMATTED',STATUS='UNKNOWN')  
             INQUIRE(NEXT,NAME=NEWFIL)  
             CLOSE(NEXT)  
c2013        OPEN(NEXT,FILE=NEWFIL,FORM='binary',STATUS='UNKNOWN')  
             ENDIF  
      IF(ICOMB.EQ.11) THEN  
             INQUIRE(LAST,NAME=NEWFIL)  
             CLOSE(LAST)  
c2013        OPEN(LAST,FILE=NEWFIL,FORM='binary',STATUS='UNKNOWN')  
             INQUIRE(NEXT,NAME=NEWFIL)  
             CLOSE(NEXT)  
             OPEN(NEXT,FILE=NEWFIL,FORM='UNFORMATTED',STATUS='UNKNOWN')  
             ENDIF  
      IF(ICOMB.EQ.8.or.ICOMB.EQ.14) THEN  
               INQUIRE(LAST,NAME=NEWFIL)  
               CLOSE(LAST)  
               OPEN(LAST,FILE=NEWFIL,FORM='FORMATTED',STATUS='UNKNOWN')  
               ENDIF  
C=======================================================================  
C===> Read interface file headers (ICOMB=3)  
C=======================================================================  
      IF(ICOMB.EQ.3) THEN  
                     IF(LAST.GT.0) CALL INFACE(1,LAST)  
                     RETURN  
                     ENDIF  
C=======================================================================  
C===> Read file headers and calculate simple statistics (ICOMB=5).  
C=======================================================================  
      IF(ICOMB.EQ.5) THEN  
                     METRIC = 1  
                     XTIME  = 0.0  
                     IF(LAST.GT.0) CALL INFACE(1,LAST)  
                     IF(QCONV.NE.1.0) METRIC = 2  
                     DO 7990 I = 1,LOCATS  
C=======================================================================  
C#### WCH, 11/30/93. Fix U.S. conversion factors.  
C                        MULT BY SEC AND  
C     NDIM  CONC  LOAD     CONVERT TO    PCONV   
C       0   MG/L CFS*MG/L     LB        62.425E-6 = 28.316*2.2046/1E6       
C       1    X/L CFS*X/L       X         28.316  
C       2     X  CFS*X       CF*X         1.0  
C=======================================================================  
                     IF(NQUAL.GT.0) THEN  
                         DO 7995 J  = 1,NQUAL  
                            IF(METRIC.EQ.1) THEN  
                               PCONV(J) = 62.425E-6  
                               IF(NDIM(J).EQ.1) PCONV(J) = 28.316  
                               ELSE  
C=======================================================================  
C#### WCH, 11/30/93.  Fix metric conversion factors.  
C                        MULT BY SEC AND  
C     NDIM  CONC  LOAD     CONVERT TO        PCONV   
C       0   MG/L CMS*MG/L     KG             0.001  
C       1    X/L CMS*X/L       X             1000.  
C       2     X  CMS*X       CUM*X            1.0  
C=======================================================================  
                               PCONV(J) = 0.001  
                               IF(NDIM(J).EQ.1) PCONV(J) = 1000.0  
                               ENDIF  
                         IF(NDIM(J).GE.2) PCONV(J) = 1.0  
 7995                    POLL2(J,I) = 0.0  
                         ENDIF  
 7990                QO2(I)    = 0.0  
C=======================================================================  
C                    Read the interface file.  
C=======================================================================  
                     ITEST     = 0  
                     DELT1     = 0.0  
                     DO 8888 K = 1,1000000  
                     IF(NQUAL.LE.0) READ(LAST,END=8100) JDAY,TMDAY,  
     +                              DELT2,(QO1(I),I=1,LOCATS)  
                     IF(NQUAL.GT.0) READ(LAST,END=8100) JDAY,TMDAY,  
     +                              DELT2,(QO1(I),(POLL1(J,I),  
     +                              J=1,NQUAL),I=1,LOCATS)  
                     JYEAR = JDAY/1000  
                     IF (JYEAR.LT.100) THEN  
                     JDAY = JDAY-JYEAR*1000  
                     JYEAR = JYEAR + 1900  
                     JDAY = JDAY + JYEAR*1000  
                     ENDIF  
C=======================================================================  
C                    Calculate cumulative volumes and loads  
C                    using trapezoidal integration.  
C=======================================================================  
                     XTIME         = XTIME + DELT2  
C=======================================================================  
C#### WCH, 11/30/93  
C   Because time steps are variable from the Runoff Block there is the  
C   possibility of a long, DRY time step, at end of which is a non-zero  
C   runoff value although wouldn't expect this to happen.  (Would  
C   expect zero at the end of DRY, followed by a WET time step and a  
C   non-zero value.  However, this doesn't always happen.)  Thus:  
C   Whenever a non-zero flow follows a zero flow, use the time step  
C   associated with the non-zero flow for that time step only.  This  
C   will usually mean that the first non-zero flow will be multiplied  
C   by WET to get the volume, not DRY or WETDRY.  For continuous flows,  
C   use average of old and new time step as before.  
C=======================================================================  
C   First, check to see if there is flow during this time step, then  
C   use average or just new DELT2, depending on whether there was flow  
C   last time step (ITEST = 1).  
C=======================================================================  
                     DO 8003 I = 1,LOCATS  
                     IF(QO1(I).NE.0.0) THEN  
                          POOP = 0.5*(DELT1 + DELT2)  
                          IF(ITEST.EQ.0) POOP = DELT2  
                          GO TO 8004  
                          ENDIF  
 8003                CONTINUE  
C=======================================================================  
C   Here no flow, so skip calculations.  
C=======================================================================  
                     ITEST = 0  
                     GO TO 8888  
C#### WCH, 11/30/93.  DON'T THINK SHOULD MULT DT BY 2 HERE.  
C####                     IF(ITEST.EQ.0) POOP = 2.0*DELT2  
 8004                ITEST         = 1  
                     DO 8000 I     = 1,LOCATS  
                     IF(NQUAL.GT.0) THEN  
                        DO 8005 J  = 1,NQUAL  
C#### WCH, 11/30/93.  MULT BY PCONV JUST ONCE, LATER.  
 8005                   POLL2(J,I) = POLL2(J,I)+POLL1(J,I)*POOP  
                        ENDIF  
C#### WCH, 11/30/93          IF(QO1(I).NE.0.0) ITEST = 1  
                     QO2(I)        = QO2(I) + QO1(I)*POOP  
 8000                CONTINUE  
                     DELT1         = DELT2  
C#### WCH, 11/30/93          IF(ITEST.EQ.0) DELT1 = 0.0  
 8888                CONTINUE  
 8100                CONTINUE  
C=======================================================================  
C                    Write junction/inlet/manhole summaries.  
C=======================================================================  
                     NPOINT = K - 1  
                                    IEND = 1  
                     IF(NQUAL.GT.0) IEND = NQUAL + 1  
                     IF(NQUAL.EQ.0) WRITE(N6,8290)  
                     IF(NQUAL.GT.0) WRITE(N6,8290) (PNAME(J),J=1,NQUAL)  
                     IF(METRIC.EQ.1.AND.NQUAL.EQ.0) WRITE(N6,8295)  
                     IF(METRIC.EQ.1.AND.NQUAL.GT.0) WRITE(N6,8295)  
     +                            (NOTED(NDIM(J)+1),J=1,NQUAL)  
                     IF(METRIC.EQ.2.AND.NQUAL.EQ.0) WRITE(N6,8296)  
                     IF(METRIC.EQ.2.AND.NQUAL.GT.0) WRITE(N6,8296)  
     +                            (MOTED(NDIM(J)+1),J=1,NQUAL)  
                     WRITE(N6,8297) (JOHNNY,J=1,IEND)  
                     XT        = XTIME/3600.0  
CIMT change upper limit of loop from 11 to MQUAL + 1  
                     DO 8190 I = 1,MQUAL+1  
 8190                SUMM(I)   = 0.0  
                     DO 8200 I = 1,LOCATS  
                     IF(NQUAL.GT.0) THEN  
                                    DO 8205 J  = 1,NQUAL  
C#### WCH, 11/30/93.  DO QUALITY CONVERSIONS HERE.  
                                    POLL2(J,I) = POLL2(J,I) * PCONV(J)  
 8205                               SUMM(J+1)  = SUMM(J+1) + POLL2(J,I)  
                                    ENDIF  
                     SUMM(1)   = SUMM(1) + QO2(I)  
                     IF(XTIME.EQ.0.0) THEN  
                                      XTIME = 1.0  
                                      WRITE(N6,8301)  
                                      ENDIF  
                     IF(JCE.EQ.0.AND.NQUAL.EQ.0) WRITE(N6,8300) NLOC(I),  
     +                                             QO2(I)/XTIME,QO2(I)  
                     IF(JCE.EQ.0.AND.NQUAL.GT.0) WRITE(N6,8300) NLOC(I),  
     +                        QO2(I)/XTIME,QO2(I),(POLL2(J,I),J=1,NQUAL)  
                     IF(JCE.EQ.1.AND.NQUAL.EQ.0) WRITE(N6,8305) KAN(I),  
     +                                             QO2(I)/XTIME,QO2(I)  
                     IF(JCE.EQ.1.AND.NQUAL.GT.0) WRITE(N6,8305) KAN(I),  
     +                       QO2(I)/XTIME,QO2(I),(POLL2(J,I),J=1,NQUAL)  
 8200                CONTINUE  
C=======================================================================  
C                    Write the overall summary.  
C=======================================================================  
                     WRITE(N6,8310) (JOHNNY,J=1,IEND)  
C#### WCH, 11/30/93.  CHECK FOR ZERO AREA. NOTE, TRIBA ALWAYS IN ACRES.  
                     TERRA = 0.0  
                     IF(TRIBA.GT.0.0) TERRA = SUMM(1)/(3630.0*TRIBA)  
     1                                         *QCONV  
                     IF(METRIC.EQ.2) TERRA = 25.4*TERRA  
                     IF(NQUAL.EQ.0) WRITE(N6,8315) TERRA,SUMM(1)  
                     IF(NQUAL.GT.0) WRITE(N6,8315) TERRA,SUMM(1),  
     +                              (SUMM(J+1),J=1,NQUAL)  
                     WRITE(N6,8311) (JOHNNY,J=1,IEND)  
                     IF(METRIC.EQ.1.AND.NQUAL.EQ.0) WRITE(N6,8316)  
                     IF(METRIC.EQ.1.AND.NQUAL.GT.0) WRITE(N6,8316)  
     +                            (NOTED(NDIM(J)+1),J=1,NQUAL)  
                     IF(METRIC.EQ.2.AND.NQUAL.EQ.0) WRITE(N6,8317)  
                     IF(METRIC.EQ.2.AND.NQUAL.GT.0) WRITE(N6,8317)  
     +                            (MOTED(NDIM(J)+1),J=1,NQUAL)  
                     WRITE(N6,8320) XT,NPOINT  
                     RETURN  
                     ENDIF  
C=======================================================================  
C===> Read Rain Block interface file (ICOMB = 6 or 7)  
C=======================================================================  
      IF(ICOMB.ge.6.and.ICOMB.le.11) THEN  
              	   call combine_rain(ICOMB)  
                     RETURN  
                     ENDIF  
      IF(ICOMB.ge.12) THEN  
              	   call combine_temp(ICOMB)  
                     RETURN  
                     ENDIF  
C=======================================================================  
C#### WCH, 8/1/95.  CHANGE I13 TO A13.  
 2120 FORMAT(' Location Station number',/,  
     +       ' -------- --------------',/,  
     +       10(I9,'. ',A13,/))  
 8290 FORMAT(/,  
     +' ################################################',/  
     +' #   Simple flow statistics from interface file #',/,  
     +' ################################################',//,  
     +'  Location #   Mean Flow  Total Flow ',99(2X,A8,2X))  
 8295 FORMAT('                  cfs      cubic ft. ',  
     +    10(2X,A10))  
 8296 FORMAT('                  cms     cubic met. ',  
     +    10(2X,A10))  
 8297 FORMAT('  ----------   ---------',11(2X,A10))  
 8301 FORMAT(/,' ===> Error  Total time was 0.0 hours.')  
 8300 FORMAT(1X,I10,1X,F12.5,11(1PE12.4))  
 8305 FORMAT(2X,A10,F12.5,11(1PE12.4))  
 8310 FORMAT(  
     +'  ----------  ----------',11(2X,A10))  
 8311 FORMAT(  
     +'                --------',11(2X,A10))  
 8315 FORMAT(' Total       ',F11.4,11(1PE12.4))  
 8316 FORMAT('                  inches   cubic ft. ',  
     +    10(2X,A10))  
 8317 FORMAT('             millimeters  cubic met. ',  
     +    10(2X,A10))  
 8320 FORMAT(//,' Total simulation time ===> ',F20.4,' hours',//,  
     +          ' Total number of steps ===> ',10X,I10)  
 9500 FORMAT(/,' ===> Error   This file is probably not a Rain',  
     +' or Temp Block interface file.')  
C=======================================================================  
      END  
ECHO is off.
REM File: COMBIN.FOR  
ECHO is off.
      SUBROUTINE COMBIN  
C	COMBINE BLOCK  
C=======================================================================  
C     Rewritten   June 1988 by R. Dickinson  
C     Updated      May 1989 by R.E.D.  
C     Updated November 1990 by Laura Terrell, CDM  
C     Updated December 1990 by R.E.D.  
C     Updated   August 1992 by WCH and May 1993 by RED  
C     Add error message, WCH, 8/93.  
C     Make combine and collate options compatible with alphanumeric   
C       labels and minor format changes, WCH, 11/19/93.  
C     Add option for printing concentrations instead of loads on   
C       ASCII file, WCH, 11/23/93.  
C     Create readable ASCII version of rainfall interface file, WCH,   
C       7/25/96.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'COMB.INC'  
C=======================================================================  
      CHARACTER KODEOT*10  
      INTEGER   SECOND,FIRST,ILAG  
C#####'#################################################################  
C REMOVE DOUBLE PRECISION FROM DELT, DELT1, DELT2,   WCH, 8/28/92  
C     DOUBLE PRECISION DELT, DELT1,DELT2,DIFF,TDIFF  
C AND FROM DIFF, TDIFF,  RED 5/28/93  
cred  make diff and tdiff double precision - 6/5/2003  
CRED  DOUBLE PRECISION DIFF,TDIFF  
C#######################################################################  
      LOGICAL*1 OK1,OK2  
C=======================================================================  
C     This subroutine has six main objectives:  
C  
C     ICOMB      => IF = 0, COLLATE OPTION  
C                   IF = 1, COMBINE OPTION  
C                   IF = 2, EXTRACT (AND OPTIONALLY RENUMBER)  
C                           NODES FROM A SINGLE INPUT FILE.  
C                   IF = 3, READ FILE HEADER  
C                   IF = 4, CREATE ASCII FILE FROM BINARY INTERFACE FILE  
C                   IF = 5, CALCULATE THE SIMPLE STATISTICS (SUMS) OF  
C                           AN INTERFACE FILE  
C                   IF = 6, CALCULATE THE SIMPLE STATISTICS (SUMS) OF  
C                           A RAIN BLOCK INTERFACE FILE  
C#### WCH, 7/25/96.   
C                   IF = 7, SAME AS 6, PLUS CREATE ASCII FILE OF   
C                           RAINFALL INTERFACE FILE.    
C                   IF = 8, CALCULATE THE SIMPLE STATISTICS (SUMS) OF  
C                           A temp BLOCK INTERFACE FILE  
C                   IF = 9, SAME AS 6, PLUS CREATE ASCII FILE OF   
C                           Temperature INTERFACE FILE.    
C=======================================================================  
C     Define statement function for linear interpolation.  
C=======================================================================  
CIM ITS NOT USED  
CIM      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1)  
C=======================================================================  
      WRITE(N6,10)  
      WRITE(*,10)  
C=======================================================================  
C     Initialization.  
C=======================================================================  
      INCNT      = INCNT  + 1  
      IOUTCT     = IOUTCT + 1  
      LAST       = JIN(INCNT)  
      NEXT       = JOUT(IOUTCT)  
      SECOND     = NSCRAT(1)  
      IF(LAST.LE.0) CALL ERROR(100)  
C=======================================================================  
C     Open files for the Combine Block.  
C=======================================================================  
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR.  
     +      FFNAME(INCNT).EQ.'JIN.UF'))  
     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND.  
     +      FFNAME(INCNT).NE.'JIN.UF')  
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
C#### WCH, 7/25/96.  CHECK FOR POSSIBLE FILE FORM MIS-MATCH, BECAUSE  
C     JOUT MIGHT BE USED FOR FORMATTED FILE.  
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR.  
     +   FFNAME(25+IOUTCT).EQ.'JIN.UF')) THEN  
            OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH')  
            ELSE        
            CALL FILECK(JOUT(IOUTCT),FFNAME(25+IOUTCT),'UNFORMATTED')  
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND.  
     +   FFNAME(25+IOUTCT).NE.'JIN.UF')  
     +   OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED',  
     +   STATUS='UNKNOWN',ACCESS='SEQUENTIAL')  
            ENDIF  
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).NE.'SCRT1.UF') OPEN(NSCRAT(1),  
     +             FILE=FFNAME(51),FORM='UNFORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).EQ.'SCRT1.UF') OPEN(NSCRAT(1),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(NSCRAT(7).gt.0) then  
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).NE.'SCRT7.UF') OPEN(NSCRAT(7),  
     +             FILE=FFNAME(57),FORM='UNFORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).EQ.'SCRT7.UF') OPEN(NSCRAT(7),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
	 endif  
C=======================================================================  
C     Data initialization.  
C=======================================================================  
C#### WCH, 11/23/93  
      IPOLLU     = 0  
CIMT  Change upper range from 10 to MQUAL  
      DO 8 J     = 1,MQUAL  
      NDIM(J)    = 0  
      NDIM2(J)   = 0  
      PNAM1(J)   = ' '  
      PNAM2(J)   = ' '  
      PUNIT(J)   = ' '  
      PUNIT2(J)  = ' '  
      PUNIT1(J)  = ' '  
      NDIM1(J)   = 0  
      DO 8 I     = 1,NIE  
      CPOLL(J,I) = 0.0  
      POLL1(J,I) = 0.0  
      POLL2(J,I) = 0.0  
      POLL3(J,I) = 0.0  
      POLD1(J,I) = 0.0  
      POLD2(J,I) = 0.0  
      IF(J.GT.1) GO TO 8  
      QO1(I)     = 0.0  
      QO2(I)     = 0.0  
      QO3(I)     = 0.0  
      QQO(I)     = 0.0  
      QOLD1(I)   = 0.0  
      QOLD2(I)   = 0.0  
      INPOS1(I)  = 0  
      INPOS2(I)  = 0  
      JCOMB(I)   = 0  
    8 CONTINUE  
C=======================================================================  
C>>>>>READ DATA GROUP A1<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,ICOMB  
      WRITE(N6,71) ICOMB  
      IF(NEXT.LE.0.AND.ICOMB.LT.2) CALL ERROR(101)  
C#### WCH, 7/25/96.  
C####      IF(NEXT.LE.0.AND.ICOMB.EQ.4) CALL ERROR(101)  
      IF(NEXT.LE.0.AND.(ICOMB.EQ.4.OR.ICOMB.EQ.7)) CALL ERROR(101)  
      IF(NEXT.LE.0.AND. ICOMB.EQ.8)                CALL ERROR(101)  
C=======================================================================  
      IF(ICOMB.EQ.3.OR.ICOMB.GT.4) THEN  
                                   CALL COMB1(ICOMB)  
                                   WRITE(N6,9000)  
ECHO is off. 
		                         WRITE(*,9000)  
                                   RETURN   
                                   ENDIF  
C=======================================================================  
C     End of Combine Block if ICOMB = 3, 5, 6 or 7.   
C=======================================================================  
C     Read remaining Combine Block input.  
C=======================================================================  
C>>>>>READ DATA GROUP B1<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,TITLE(3)  
      READ(N5,*,ERR=888) CC,TITLE(4)  
      WRITE(N6,660)         TITLE(3),TITLE(4)  
C=======================================================================  
C>>>>>READ DATA GROUP B2<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
C     NODEOT => Node number for output.  
C     KODEOT => Node name   for output.  
C#### WCH, 11/23/93.  
C     NPOLL  => Number of pollutants to be placed on new file.  
C     If NPOLL < 0, then for ICOMB = 4, print concentrations on ASCII  
C       file, not loads.  
C=======================================================================  
      IF(JCE.EQ.0) THEN  
                   READ(N5,*,ERR=888) CC,NODEOT,NPOLL  
C#### WCH, 11/23/93.  
                   IF(NPOLL.LT.0) THEN  
                      IPOLLU = 1  
                      NPOLL = -NPOLL  
                      ENDIF  
C#### WCH, 11/19/93.  OUTPUT DATA SET = JOUT, NOT JIN  
                   WRITE(N6,410)         NODEOT,JOUT(IOUTCT),NPOLL  
                   ELSE  
C#### WCH, 8/2/93. ADD ADDITIONAL ERROR MESSAGE.  GO TO 887.  
                   READ(N5,*,ERR=887) CC,KODEOT,NPOLL  
C#### WCH, 11/23/93.  
                   IF(NPOLL.LT.0) THEN  
                      IPOLLU = 1  
                      NPOLL = -NPOLL  
                      ENDIF  
                   WRITE(N6,411)         KODEOT,JOUT(IOUTCT),NPOLL  
                   ENDIF  
	IF (NPOLL.GT.MQUAL) THEN  
	WRITE(N6,*) 'ERROR *** NPOLL IS GREATER THAN MAXIMUM ALLOWED.'  
	STOP 'ERROR *** NPOLL IS GREATER THAN MAXIMUM ALLOWED.'  
	ENDIF  
C#### WCH, 11/23/93  
      IF(ICOMB.EQ.4.AND.NPOLL.GT.0) THEN  
           IF(IPOLLU.EQ.0) WRITE(N6,415)  
           IF(IPOLLU.EQ.1) WRITE(N6,416)  
           ENDIF  
C=======================================================================  
C>>>>>READ DATA GROUP B3<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(NPOLL.GT.0) THEN  
                     READ(N5,*,ERR=888) CC,(NPOS1(J),NPOS2(J),J=1,NPOLL)  
                     WRITE(N6,420)       (J,NPOS1(J),NPOS2(J),J=1,NPOLL)  
                     ENDIF  
C=======================================================================  
C>>>>>READ DATA GROUP C1<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,NUMX,NUMR  
      WRITE(N6,430)         NUMX,NUMR  
C=======================================================================  
C>>>>>READ DATA GROUP C2<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(NUMX.GT.0) THEN  
              IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,(NODEX(I),I=1,NUMX)  
C#### WCH, 8/2/93. ADD ADDITIONAL ERROR MESSAGE.  GO TO 887.  
              IF(JCE.EQ.1) READ(N5,*,ERR=887) CC,(KODEX(I),I=1,NUMX)  
              WRITE(N6,440)  
              IF(JCE.EQ.0) WRITE(N6,450) (NODEX(I),I=1,NUMX)  
              IF(JCE.EQ.1) WRITE(N6,451) (KODEX(I),I=1,NUMX)  
              ENDIF  
C=======================================================================  
C>>>>>READ DATA GROUP C3<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(NUMR.GT.0) THEN  
              IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,(NODER(I),I=1,NUMR)  
C#### WCH, 8/2/93. ADD ADDITIONAL ERROR MESSAGE.  GO TO 887.  
              IF(JCE.EQ.1) READ(N5,*,ERR=887) CC,(KODER(I),I=1,NUMR)  
              WRITE(N6,445)  
              IF(JCE.EQ.0) WRITE(N6,450) (NODER(I),I=1,NUMR)  
              IF(JCE.EQ.1) WRITE(N6,451) (KODER(I),I=1,NUMR)  
              ENDIF  
C=======================================================================  
C     Extract and renumber an interface file (ICOMB=2).  
C=======================================================================  
      IF(ICOMB.EQ.2.AND.NUMX.EQ.0) CALL ERROR(102)  
      IF(ICOMB.EQ.2) THEN  
               CALL INFACE(1,LAST)  
C=======================================================================  
C     Transfer information to file NEXT.  
C=======================================================================  
               REWIND NEXT  
               WRITE(NEXT) NUMX,NQUAL  
               IF(JCE.EQ.0.AND.NUMR.GT.0) WRITE(NEXT)(NODER(I),I=1,NUMX)  
               IF(JCE.EQ.0.AND.NUMR.EQ.0) WRITE(NEXT)(NODEX(I),I=1,NUMX)  
               IF(JCE.EQ.1.AND.NUMR.GT.0) WRITE(NEXT)(KODER(I),I=1,NUMX)  
               IF(JCE.EQ.1.AND.NUMR.EQ.0) WRITE(NEXT)(KODEX(I),I=1,NUMX)  
               SOURCE = 'COMBINE BLOCK'  
               CALL INFACE(2,NEXT)  
C=======================================================================  
C     Read input interface file information.  
C=======================================================================  
  50           IF(NQUAL.LE.0) READ(LAST,END=90) JDAY,TMDAY,  
     +                        DELT,(QO1(I),I=1,LOCATS)  
               IF(NQUAL.GT.0) READ(LAST,END=90) JDAY,TMDAY,  
     +                  DELT,(QO1(I),(POLL1(J,I),J=1,NQUAL),I=1,LOCATS)  
                   IF(JDAY.EQ.99999) JDAY = 9999999  
                   JYEAR = JDAY/1000  
                   IF (JYEAR.LT.100) THEN  
                   JDAY = JDAY - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JDAY = JDAY + JYEAR*1000  
                   ENDIF  
C=======================================================================  
C     Extract only selected nodes.  
C=======================================================================  
               DO 55 J = 1,LOCATS  
               DO 60 K = 1,NUMX  
               IF(JCE.EQ.0.AND.NODEX(K).EQ.NLOC(J)) THEN  
                                           QO2(K) = QO1(J)  
                                           IF(NQUAL.GT.0) THEN  
                                           DO 70 KK    = 1,NQUAL  
   70                                      POLL2(KK,K) = POLL1(KK,J)  
                                           ENDIF  
                                           ENDIF  
               IF(JCE.EQ.1.AND.KODEX(K).EQ.KAN(J)) THEN  
                                           QO2(K) = QO1(J)  
                                           IF(NQUAL.GT.0) THEN  
                                           DO 75 KK    = 1,NQUAL  
   75                                      POLL2(KK,K) = POLL1(KK,J)  
                                           ENDIF  
                                           ENDIF  
   60          CONTINUE  
   55          CONTINUE  
C=======================================================================  
C     Write output file information.  
C=======================================================================  
               IF(NQUAL.EQ.0) WRITE(NEXT) JDAY,TMDAY,  
     +                        DELT,(QO2(I),I=1,NUMX)  
               IF(NQUAL.GT.0) WRITE(NEXT) JDAY,TMDAY,  
     +            DELT,(QO2(I),(POLL2(J,I),J=1,NQUAL),I=1,NUMX)  
               GO TO 50  
  90           WRITE(N6,9000)  
               WRITE(*,9000)  
               RETURN  
               ENDIF  
C=======================================================================  
C     End of ICOMB = 2 option.  
C=======================================================================  
      IF(ICOMB.EQ.4) THEN  
                     CALL COMB2(ICOMB)  
                     WRITE(N6,9000)  
                     WRITE(*,9000)  
                     RETURN  
                     ENDIF  
C=======================================================================  
C     End of ICOMB = 4 option.  
C=======================================================================  
C     COLLATE (ICOMB=0) and COMBINE (ICOMB=1) options are left.  
C     The pollutant names and units are saved from the first  
C     data-set and written on the output data-set.  
C=======================================================================  
C     LOCAT1 = Total number of inlets on first input data set.  
C     LOCAT2 = Total number of inlets on second input data set.  
C     NQ1    = Total number of water quality constituents on 1st data set  
C     NQ2    = Total number of water quality constituents on 2nd data set  
C=======================================================================  
C     Read file headers from file # 2.  
C=======================================================================  
      IF(SECOND.LE.0) CALL ERROR(103)  
      WRITE(N6,9005)  
      CALL INFACE(1,SECOND)  
      LOCAT2   = LOCATS  
      NQ2      = NQUAL  
      DO 210 I = 1,LOCAT2  
C#### WCH, 11/19/93.  FIX FOR ALPHA LABELS.  
      IF(JCE.EQ.0) THEN  
           JUNC2(I) = NLOC(I)  
           ELSE  
           KUNC2(I) = KAN(I)  
           ENDIF  
      IF(NQ2.GT.0) THEN  
                   DO 220 J  = 1,NQ2  
                   PNAM2(J)  = PNAME(J)  
                   PUNIT2(J) = PUNIT(J)  
  220              NDIM2(J)  = NDIM(J)  
                   ENDIF  
  210 CONTINUE  
C=======================================================================  
C     Add the tributary areas together in variable TRIBBA.  
C=======================================================================  
      TRIBBA = 0.0  
      TRIBBA = TRIBBA + TRIBA  
C=======================================================================  
C     Read file headers from file # 1.  
C=======================================================================  
      IF(LAST.LE.0) CALL ERROR(103)  
      WRITE(N6,9010)  
      CALL INFACE(1,LAST)  
      LOCAT1   = LOCATS  
      NQ1      = NQUAL  
      DO 230 I = 1,LOCAT1  
C#### WCH, 11/19/93.  FIX FOR ALPHA LABELS.  
      IF(JCE.EQ.0) THEN  
           JUNC1(I) = NLOC(I)  
           ELSE  
           KUNC1(I) = KAN(I)  
           ENDIF  
      IF(NQ1.GT.0) THEN  
                   DO 240 J  = 1,NQ1  
                   PNAM1(J)  = PNAME(J)  
                   PUNIT1(J) = PUNIT(J)  
  240              NDIM1(J)  = NDIM(J)  
                   ENDIF  
  230 CONTINUE  
      TRIBA  = TRIBBA + TRIBA  
C=======================================================================  
C     Determine the names of the quality constituents on the new  
C     interface file.  The names will be duplicates of the names on  
C     the first input file except for the case in which  
C     NPOS1(KPOLL) equals zero, in which case the names will be copied  
C     from the second input file.    
C=======================================================================  
      IF(NPOLL.GT.0) THEN  
                     DO 470 KPOLL = 1,NPOLL  
                     IF(NPOS1(KPOLL).LE.0) GO TO 460  
                     K1           = NPOS1(KPOLL)  
                     PNAME(KPOLL) = PNAM1(K1)  
                     PUNIT(KPOLL) = PUNIT1(K1)  
                     NDIM(KPOLL)  = NDIM1(K1)  
                     GO TO 470  
  460                K2 = NPOS2(KPOLL)  
C=======================================================================  
C     Error if both NPOS1 and NPOS2 = 0.  
C=======================================================================  
                     IF(K2.LE.0) GO TO 2200  
                     PNAME(KPOLL)   = PNAM2(K2)  
                     PUNIT(KPOLL)   = PUNIT2(K2)  
                     NDIM(KPOLL)    = NDIM2(K2)  
  470                CONTINUE  
                     ENDIF  
C=======================================================================  
C     Read the first line of the two interface files.  
C=======================================================================  
      IF(NQ1.EQ.0) THEN  
                   READ(LAST) JULDAY,TIMDAY,DELT1,(QO1(I),I=1,LOCAT1)  
                   IF(JULDAY.EQ.99999) JULDAY = 9999999  
                   JYEAR = JULDAY/1000  
				 IF (JYEAR.LT.100) THEN  
                   JULDAY = JULDAY - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JULDAY = JULDAY + JYEAR*1000  
                   ENDIF  
                   ELSE  
                   READ(LAST) JULDAY,TIMDAY,DELT1,  
     +                        (QO1(I),(POLL1(J,I),J=1,NQ1),I=1,LOCAT1)  
                   IF(JULDAY.EQ.99999) JULDAY = 9999999  
                   JYEAR = JULDAY/1000  
                   IF (JYEAR.LT.100) THEN  
                   JULDAY = JULDAY - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JULDAY = JULDAY + JYEAR*1000  
                   ENDIF  
                   JDAY3   = JULDAY  
                   if(timday.gt.86400.0) timday = 0.0  
	             TIMDAY3 = TIMDAY  
                   ENDIF  
      IF(NQ2.EQ.0) THEN  
                   READ(SECOND) JDAY2,TMDAY2,DELT2,(QO2(I),I=1,LOCAT2)  
                   IF(JDAY.EQ.99999) JDAY = 9999999  
                   JYEAR = JDAY2/1000  
                   IF (JYEAR.LT.100) THEN  
                   JDAY2 = JDAY2 - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JDAY2 = JDAY2 + JYEAR*1000  
                   ENDIF  
                   ELSE  
                   READ(SECOND) JDAY2,TMDAY2,DELT2,  
     +                          (QO2(I),(POLL2(J,I),J=1,NQ2),I=1,LOCAT2)  
                   IF(JDAY2.EQ.99999) JDAY2 = 9999999  
                   JYEAR = JDAY2/1000  
                   IF (JYEAR.LT.100) THEN  
                   JDAY2 = JDAY2 - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JDAY2 = JDAY2 + JYEAR*1000  
                   ENDIF  
                   if(tmday2.gt.86400.0) tmday2 = 0.0  
	             JDAY4   = JDAY2  
	             TIMDAY4 = TMDAY2  
                   ENDIF  
C=======================================================================  
C     Determine TZERO and IDATEZ for the new interface file.  
C=======================================================================  
      CALL NTIME(JDAY2,TMDAY2,DIFF)  
    make this double precision - 6/5/2003  
      IF(DIFF.GE.0.0) THEN  
                      TZERO  = TIMDAY  
                      FIRST  = 1  
                      IDATEZ = JULDAY  
                      ENDIF  
      IF(DIFF.LT.0.0) THEN  
                      TZERO  = TMDAY2  
                      FIRST  = 2  
                      IDATEZ = JDAY2  
                      ENDIF  
C=======================================================================  
C     If ICOMB equals 0 and the collate option is requested, it is  
C     necessary to interleave the file locations from input files  
C     one and two.  If the two files include identical location  
C     numbers in their inlet arrays, the flow and quality constituent  
C     values (loads = flow x concentration) will be added together for   
C     those locations.  If the inlet number appears in only one file,   
C     the flow and quality constituent values will be transfered   
C     intact to the new interface file.  
C=======================================================================  
C    The new interface file's location numbers will be arranged in the  
C    following order:  First --> locations (inlets) in both input files  
C                      Second -> locations in file one not   
C                                already transfered  
C                      Third --> locations in file two not  
C                                already transfered  
C========================================================================  
C     NPOSIT    = INLET position on the new interface file.  
C     INPOS1    = INLET position on input file 1 corresponding  
C                 to NPOSIT position on the new interface file.  
C     INPOS2    = INLET position on input file 2 corresponding  
C                 to NPOSIT position on the new interface file.  
C     JUNC1     = INLET array from input file 1.  
C     JUNC2     = INLET array from input file 2.  
C     NLOC      = INLET array for the new interface file.  
C     LOCATS    = Number of inlets on both files 1 and 2.  
C=======================================================================  
C     Find the INLET locations that are on both interface files.  
C=======================================================================  
      NPOSIT         = 0  
      DO 575 I       = 1,LOCAT1  
      DO 550 N       = 1,LOCAT2  
C#### WCH, 11/19/93  
      IF(JCE.EQ.0.AND.JUNC1(I).NE.JUNC2(N)) GO TO 550  
      IF(JCE.EQ.1.AND.KUNC1(I).NE.KUNC2(N)) GO TO 550  
      NPOSIT         = NPOSIT + 1  
      INPOS1(NPOSIT) = I  
      INPOS2(NPOSIT) = N  
C#### WCH, 11/19/93  
      IF(JCE.EQ.0) NLOC(NPOSIT)   = JUNC1(I)  
      IF(JCE.EQ.1) KAN(NPOSIT)    = KUNC1(I)  
      GO TO 575  
  550 CONTINUE  
  575 CONTINUE  
C=======================================================================  
C     Find the INLET locations that are only on interface file # 1.  
C=======================================================================  
      LOCATS         = NPOSIT  
      DO 625  I      = 1,LOCAT1  
      DO 600  N      = 1,LOCATS  
C#### WCH, 11/19/93  
      IF(JCE.EQ.0.AND.NLOC(N).EQ.JUNC1(I)) GO TO 625  
      IF(JCE.EQ.1.AND.KAN(N).EQ.KUNC1(I))  GO TO 625  
  600 CONTINUE  
      NPOSIT         = NPOSIT + 1  
C#### WCH, 11/19/93  
      IF(JCE.EQ.0) NLOC(NPOSIT) = JUNC1(I)  
      IF(JCE.EQ.1) KAN(NPOSIT)  = KUNC1(I)  
      INPOS1(NPOSIT) = I  
      INPOS2(NPOSIT) = 0  
  625 CONTINUE  
C=======================================================================  
C     Find the INLET locations that are only on interface file # 2.  
C=======================================================================  
      LOCATS         = NPOSIT  
      DO 675 I       = 1,LOCAT2  
      DO 650 N       = 1,LOCATS  
C#### WCH, 11/19/93  
      IF(JCE.EQ.0.AND.NLOC(N).EQ.JUNC2(I)) GO TO 675  
      IF(JCE.EQ.1.AND.KAN(N).EQ.KUNC2(I))  GO TO 675  
  650 CONTINUE  
      NPOSIT         = NPOSIT + 1  
C#### WCH, 11/19/93  
      IF(JCE.EQ.0) NLOC(NPOSIT) = JUNC2(I)  
      IF(JCE.EQ.1) KAN(NPOSIT)  = KUNC2(I)  
      INPOS1(NPOSIT) = 0  
      INPOS2(NPOSIT) = I  
  675 CONTINUE  
      LOCATS         = NPOSIT  
C=======================================================================  
C     Now create another tester array - JCOMB(200)  
C         If JCOMB = 1 then both files one and two have an inlet  
C                      corresponding to NPOSIT on the new interface file  
C         If JCOMB = 2 then only the first file has an inlet  
C                      corresponding to NPOSIT on the new interface file  
C         If JCOMB = 3 then only the second file has an inlet  
C                      corresponding to NPOSIT on the new interface file  
C=======================================================================  
      DO 700 NPOSIT = 1,LOCATS  
      IF(INPOS1(NPOSIT).GT.0.AND.INPOS2(NPOSIT).GT.0) JCOMB(NPOSIT) = 1  
      IF(INPOS1(NPOSIT).GT.0.AND.INPOS2(NPOSIT).LE.0) JCOMB(NPOSIT) = 2  
      IF(INPOS1(NPOSIT).LE.0.AND.INPOS2(NPOSIT).GT.0) JCOMB(NPOSIT) = 3  
  700 CONTINUE  
C=======================================================================  
C     The next statements (and the later summation) are essentially  
C     the only difference between the Combine option and the Collate  
C     option.  The Combine and Collate options have the same input  
C     requirements except that for Combine, the sumation sequence  
C     sums all the flows and loads from all input locations (inlets)  
C     and outputs these summations at location NODEOT.  
C=======================================================================  
      IF(ICOMB.EQ.1) THEN  
                     KPOSIT  = 1  
C=======================================================================  
C     Offer a default output location ID.  
C=======================================================================  
                     IF(NODEOT.LE.0)   NODEOT =  12345  
                     IF(KODEOT.EQ.' ') KODEOT = '12345'  
                     IF(JCE.EQ.0) NLOC(1) = NODEOT  
                     IF(JCE.EQ.1)  KAN(1) = KODEOT  
                     LOCATS  = 1  
                     ENDIF  
C=======================================================================  
C     Write the header information on the new interface file.  
C=======================================================================  
      IF(NEXT.GT.0) THEN  
                    REWIND NEXT  
                    WRITE(NEXT) LOCATS,NPOLL  
                    IF(JCE.EQ.0) WRITE(NEXT) (NLOC(I),I=1,LOCATS)  
                    IF(JCE.EQ.1) WRITE(NEXT)  (KAN(I),I=1,LOCATS)  
                    SOURCE = 'COMBINE BLOCK'  
                    WRITE(N6,9015)  
                    CALL INFACE(2,NEXT)  
                    CALL INFACE(1,NEXT)  
                    ENDIF  
C=======================================================================  
C     DO-loop for reading all input data.  
C=======================================================================  
      XTIM1      = 0.0  
      XTIM2      = 0.0  
      DELT1      = 0.0  
      DELT2      = 0.0  
	OK1        = .FALSE.  
      OK2        = .FALSE.  
C##### WCH, 5/28/93.  CHANGE DABS TO ABS  
      DIFF       = ABS(DIFF)  
      ILAG       = 1  
      J1LAG      = 0  
      J2LAG      = 0  
      IF(FIRST.EQ.1)  OK1 = .TRUE.  
      IF(FIRST.EQ.2)  OK2 = .TRUE.  
      IF(DIFF.EQ.0.0) OK2 = .TRUE.  
C=======================================================================  
C     Initialize arrays CPOLL and QQO for each time step.  
cred  allow for more time steps in the interface file   
cred  this used to be 1000000 - 5/6/01  
C=======================================================================  
      DO 999 KDT = 1,10000000  
      DO 750   K = 1,LOCATS  
      DO 740   L = 1,NPOLL  
  740 CPOLL(L,K) = 0.0  
  750 QQO(K)     = 0.0  
C=======================================================================  
C     Read the two input files.  
C=======================================================================  
      IF(FIRST.EQ.2.AND.XTIM2.GE.DIFF) OK1 = .TRUE.  
      IF(FIRST.EQ.1.AND.XTIM1.GE.DIFF) OK2 = .TRUE.  
C=======================================================================  
      IF(JULDAY.NE.9999999.AND.OK1) THEN  
      IF(ILAG.NE.2) THEN  
                   IF(NQ1.EQ.0) READ(LAST,END=1000) JULDAY,TIMDAY,DELT1,  
     +                                 (QO1(I),I=1,LOCAT1)  
                   IF(NQ1.GT.0) READ(LAST,END=1000) JULDAY,TIMDAY,DELT1,  
     +                         (QO1(I),(POLL1(J,I),J=1,NQ1),I=1,LOCAT1)  
                   if(julday.lt.jday3) julday = jday3  
				 if(jday3.eq.0) jday3 = julday  
	             if(timday.gt.86400.0) timday = 0.0  
                   IF(delt1.le.0.0) delt1 = timday - timday3  
	             timday = timday3 + delt1  
	             if(timday.gt.86400.0) then  
				    timday = timday3 + delt1 - 86400.0  
	                if(julday.eq.jday3)  julday  = julday  + 1  
	                else  
	                if(julday.gt.jday3) julday = jday3  
	                endif  
				 timday = anint(timday)  
				 jday3   = julday  
                   timday3 = timday  
                   IF(JULDAY.EQ.99999) JULDAY = 9999999  
                   JYEAR = JULDAY/1000  
                   IF (JYEAR.LT.100) THEN  
                   JULDAY = JULDAY - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JULDAY = JULDAY + JYEAR*1000  
                   ENDIF  
                   ELSE  
                   DO 744 I   = 1,LOCAT1  
                   QO1(I)     = QO3(I)  
                   DO 743 J   = 1,NQ1  
                   POLL1(J,I) = POLL3(J,I)  
  743              CONTINUE  
  744              CONTINUE  
                   ENDIF  
      DELT = DELT1  
      ENDIF  
C=======================================================================  
      IF(JDAY2.NE.9999999.AND.OK2) THEN  
      IF(ILAG.NE.3) THEN  
                   IF(NQ2.EQ.0) READ(SECOND,END=1010) JDAY2,TMDAY2,  
     +                                    DELT2,(QO2(I),I=1,LOCAT2)  
                   IF(NQ2.GT.0) READ(SECOND,END=1010) JDAY2,TMDAY2,  
     +               DELT2,(QO2(I),(POLL2(J,I),J=1,NQ2),I=1,LOCAT2)  
                   if(jday2.lt.jday4) jday2 = jday4  
	             if(tmday2.gt.86400.0) tmday2 = 0.0  
                   IF(delt2.le.0.0) delt2 = tmday2 - timday4  
	             tmday2 = timday4 + delt2  
                   if(jday4.eq.0) jday4 = jday2  
				 if(tmday2.gt.86400.0) then  
				    tmday2 = timday4 + delt2 - 86400.0  
	                if(jday2.eq.jday4) jday2 = jday2 + 1  
	                else  
	                if(jday2.gt.jday4) jday2 = jday4  
	                endif  
				 tmday2 = anint(tmday2)   
	             jday4  = jday2  
                   IF(JDAY2.EQ.99999) JDAY2 = 9999999  
                   timday4 = tmday2  
				 JYEAR = JDAY2/1000  
                   IF (JYEAR.LT.100) THEN  
                   JDAY2 = JDAY2 - JYEAR*1000  
                   JYEAR = JYEAR + 1900  
                   JDAY2 = JDAY2 + JYEAR*1000  
                   ENDIF  
                   ELSE  
                   DO 746 I   = 1,LOCAT2  
                   QO2(I)     = QO3(I)  
                   DO 745 J   = 1,NQ2  
                   POLL2(J,I) = POLL3(J,I)  
  745              CONTINUE  
  746              CONTINUE  
                   ENDIF  
      DELT = DELT2  
      ENDIF  
C=======================================================================  
C     The end of both input files has been found.  Branch to 1020.  
C=======================================================================  
      IF(JULDAY.EQ.9999999.AND.JDAY2.EQ.9999999) GO TO 1020  
C=======================================================================  
C     Calculate the time difference in seconds between two data sets.  
C=======================================================================  
      CALL NTIME(JDAY2,TMDAY2,DIFF)  
    make this double precision - 6/5/2003  
C=======================================================================  
C                      Calculate the variable ILAG.  
C  
C     ILAG = 1 ==> The difference in time between files 2 & 1 = 0.  
C                  No changes from the original COMBINE code.  
C     ILAG = 2 ==> The difference in time between files 2 & 1 is < 0.  
C                  This means that file 2's time is before file 1's  
C                  time.  File 1's values for flow and pollutants will  
C                  be set to zero.  File 1's values will be temporarily  
C                  stored in QO3 and POLL3.  
C     ILAG = 3 ==> The difference in time between FILE 2 & 1 is > 0.  
C                  This means that File 1's time is before file 2's  
C                  time.  File 2's values for flow and pollutants will  
C                  be set to zero.  File 2's values will be temporarily  
C                  stored in QO3 and POLL3.  
C  
C=======================================================================  
      IF(DIFF.EQ.0.0) THEN  
                      ILAG        = 1  
                      J1LAG       = 0  
                      J2LAG       = 0  
                      DO 7400 I   = 1,LOCAT1  
                      QOLD1(I)    = QO1(I)  
                      DO 7410 J   = 1,NQ1  
7410                  POLD1(J,I)  = POLL1(J,I)  
7400                  CONTINUE  
                      DO 7420 I   = 1,LOCAT2  
                      QOLD2(I)    = QO2(I)  
                      DO 7430 J   = 1,NQ2  
7430                  POLD2(J,I)  = POLL2(J,I)  
7420                  CONTINUE  
                      XTIM1      = XTIM1 + DELT  
                      XTIM2      = XTIM2 + DELT  
                      ENDIF  
      IF(DIFF.LT.0.0) THEN  
           ILAG       = 2  
           J2LAG      = 0  
           J1LAG      = J1LAG + 1  
C##### WCH, 5/28/93.  CHANGE DABS TO ABS  
           TDIFF      = ABS(DIFF)  
           IF(J1LAG.EQ.1) TDIF1(I) = TDIFF + DELT2  
cred       add an error check for division by zero - 2/12/2003  
           if(TDIF1(I).ne.0.0) then  
		    slope      = (TDIF1(I)-TDIFF)/TDIF1(I)  
	        else  
	        slope      =  0.0  
	        endif  
cred       SLOPE      = (TDIF1(I)-TDIFF)/TDIF1(I)  
           DO 748 I   = 1,LOCAT1  
           QO3(I)     = QO1(I)  
           QO1(I)     = (QO1(I)-QOLD1(I))*SLOPE + QOLD1(I)  
           IF(QO1(I).LT.0.0) QO1(I) = 0.0  
           DO 747 J   = 1,NQ1  
           POLL3(J,I) = POLL1(J,I)  
           POLL1(J,I) = (POLL1(J,I)-POLD1(J,I))*SLOPE + POLD1(J,I)  
           IF(POLL1(J,I).LT.0.0) POLL1(J,I) = 0.0  
  747      CONTINUE  
  748      CONTINUE  
cred       update the values of Qold2 and POLD2 - 5/6/01  
cred       this should have been updated for Diff > 0 as well as  
cred       diff = 0; from Mitch Heinemann and Mark Yeboah of CDM  
           DO I             = 1,LOCAT2  
              QOLD2(I)      = QO2(I)  
              DO J          = 1,NQ2  
                 POLD2(J,I) = POLL2(J,I)  
	           enddo  
              enddo  
		 if(DELT2.LT.DELT1) DELT1 = DELT1 - DELT2  
           DELT       = DELT2  
           if(XTIM1.le.xtim2) XTIM1  = XTIM1 + DELT1  
                              XTIM2  = XTIM2 + DELT2  
           ENDIF  
      IF(DIFF.GT.0.0) THEN  
           ILAG       = 3  
           J1LAG      = 0  
           J2LAG      = J2LAG + 1  
           IF(J2LAG.EQ.1) TDIF2(I) = DIFF + DELT1  
cred       add an error check for division by zero - 2/12/2003  
           if(TDIF2(I).ne.0.0) then  
		    slope      = (TDIF2(I)-DIFF)/TDIF2(I)  
	        else  
	        slope      =  0.0  
	        endif  
           DO 751 I   = 1,LOCAT2  
           QO3(I)     = QO2(I)  
           QO2(I)     = (QO2(I)-QOLD2(I))*SLOPE + QOLD2(I)  
           IF(QO2(I).LT.0.0) QO2(I) = 0.0  
	     if(nq2.gt.0) then  
           DO 749 J   = 1,NQ2  
           POLL3(J,I) = POLL2(J,I)  
           POLL2(J,I) = (POLL2(J,I)-POLD2(J,I))*SLOPE + POLD2(J,I)  
           IF(POLL2(J,I).LT.0.0) POLL2(J,I) = 0.0  
  749      CONTINUE  
           endif  
  751      CONTINUE  
cred       update the values of Qold1 and POLD1 - 5/6/01  
cred       this should have been updated for Diff > 0 as well as  
cred       diff = 0; from Mitch Heinemann and Mark Yeboah of CDM  
           DO I             = 1,LOCAT1  
              QOLD1(I)      = QO1(I)  
              DO J          = 1,NQ1  
                 POLD1(J,I) = POLL1(J,I)  
	           enddo  
              enddo  
		 if(DELT1.Lt.DELT2) DELT2  = DELT2 - DELT1  
           DELT       = DELT1  
           XTIM1      = XTIM1 + DELT1  
           if(XTIM2.le.xtim1) XTIM2  = XTIM2 + DELT2  
           ENDIF  
C=======================================================================  
C     Combine all the input locations into one output location.  
C=======================================================================  
      IF(ICOMB.EQ.1) THEN  
                     DO 940 KK1  = 1,LOCAT1  
                     QQO(KPOSIT) = QQO(KPOSIT) + QO1(KK1)  
                     IF(NPOLL.GT.0) THEN  
                              DO 945  MM       = 1,NPOLL  
                              K1               = NPOS1( MM )  
  945                         CPOLL(MM,KPOSIT) = CPOLL(MM,KPOSIT)  
     +                                            + POLL1(K1,KK1)  
                              ENDIF  
  940                CONTINUE  
                     DO 950 KK2  = 1,LOCAT2  
                     QQO(KPOSIT) = QQO(KPOSIT) + QO2(KK2)  
                     IF(NPOLL.GT.0) THEN  
                              DO 955  MM       = 1,NPOLL  
                              K2               = NPOS2( MM )  
  955                         CPOLL(MM,KPOSIT) = CPOLL(MM,KPOSIT)  
     +                                            + POLL2(K2,KK2)  
                              ENDIF  
  950                CONTINUE  
                     ENDIF  
C=======================================================================  
C     Collate (interleave) all the input locations together.  
C=======================================================================  
      IF(ICOMB.EQ.0) THEN  
                     DO 960 NPOSIT = 1,LOCATS  
                     KK1         = INPOS1(NPOSIT)  
                     KK2         = INPOS2(NPOSIT)  
                     IF(JCOMB(NPOSIT).EQ.1) QQO(NPOSIT) =  
     +                               QQO(NPOSIT) + QO1(KK1) + QO2(KK2)  
                     IF(JCOMB(NPOSIT).EQ.2) QQO(NPOSIT) =  
     +                                          QQO(NPOSIT) + QO1(KK1)  
                     IF(JCOMB(NPOSIT).EQ.3) QQO(NPOSIT) =  
     +                                          QQO(NPOSIT) + QO2(KK2)  
                     IF(NPOLL.GT.0) THEN  
                        DO 920 MM        = 1,NPOLL  
                        K1               = NPOS1( MM )  
                        K2               = NPOS2( MM )  
                        IF(JCOMB(NPOSIT).EQ.1) CPOLL(MM,NPOSIT) =  
     +                  CPOLL(MM,NPOSIT) + POLL1(K1,KK1) + POLL2(K2,KK2)  
                        IF(JCOMB(NPOSIT).EQ.2) CPOLL(MM,NPOSIT) =  
     +                                  CPOLL(MM,NPOSIT) + POLL1(K1,KK1)  
                        IF(JCOMB(NPOSIT).EQ.3) CPOLL(MM,NPOSIT) =  
     +                                  CPOLL(MM,NPOSIT) + POLL2(K2,KK2)  
  920                   CONTINUE  
                        ENDIF  
  960                   CONTINUE  
                     ENDIF  
C=======================================================================  
C     Write the actual interface data line.  
C=======================================================================  
  990 IF(NPOLL.EQ.0) WRITE(NEXT) JULDAY,TIMDAY,DELT,(QQO(K),K=1,LOCATS)  
      IF(NPOLL.GT.0) THEN  
      IF(ILAG.EQ.2)  THEN  
                     WRITE(NEXT) JDAY2,TMDAY2,DELT2,(QQO(K),  
     +                      (CPOLL(M,K),M=1,NPOLL),K=1,LOCATS)  
                     ELSE  
                     WRITE(NEXT) JULDAY,TIMDAY,DELT1,(QQO(K),  
     +                      (CPOLL(M,K),M=1,NPOLL),K=1,LOCATS)  
                     ENDIF  
                     ENDIF  
      GO TO 999  
C=======================================================================  
C     End of the first file is reached.  
C=======================================================================  
 1000 CONTINUE  
      JULDAY    = 9999999  
      TIMDAY    =   0.0  
      DO 1050 I = 1,LOCAT1  
      QO1(I)    = 0.0  
      QOLD1(I)  = 0.0  
      IF(NQ1.GT.0) THEN  
                   DO 1060 J  = 1,NQ1  
                   POLL1(J,I) = 0.0  
 1060              POLD1(J,I) = 0.0  
                   ENDIF  
 1050 CONTINUE  
      GO TO 999  
C=======================================================================  
C     End of the second file is reached.  
C=======================================================================  
 1010 CONTINUE  
      JDAY2     = 9999999  
      TMDAY2    =   0.0  
      DO 1100 I = 1,LOCAT2  
      QO2(I)    = 0.0  
      QOLD2(I)  = 0.0  
      IF(NQ2.GT.0) THEN  
                   DO 1110 J  = 1,NQ2  
                   POLL2(J,I) = 0.0  
 1110              POLD2(J,I) = 0.0  
                   ENDIF  
 1100 CONTINUE  
  999 CONTINUE  
 1020 CONTINUE  
      WRITE(N6,9000)  
      WRITE(*,9000)  
      RETURN  
C#### WCH, 11/22/93  
 2200 WRITE(N6,2210) KPOLL  
      STOP  
C#### WCH, 8/2/93.  ADD ADDITIONAL ERROR MESSAGE.  
  887 WRITE (*,9500) CC  
      WRITE(N6,9500) CC  
  888 CALL IERROR  
C=======================================================================  
  10  FORMAT(/,  
     +' ################################################',/,  
     +' # Entry made to Combine Block. Last updated at #',/,  
     +' # CDM, July 2001.                              #',/,  
     +' ################################################',/)  
C#### WCH, 7/25/96.  CHANGE FORMAT 71 SLIGHTLY  
  71  FORMAT(/,' ICOMB...................................',I5,/,  
     +         ' = 0 ==> Collate option',/,  
     +         '   1 ==> Combine option',/,  
     +         '   2 ==> Extract option',/,  
     +         '   3 ==> File reader option',/,  
     +         '   4 ==> ASCII file creation',/,  
     +         '   5 ==> Interface file summation option',/,  
     +         '   6 ==> Rain Block interface file summation option',/,  
     +         '   7 ==> Rain Block interface file summation and ASCII f  
     +ile creation on JOUT',/)  
  410 FORMAT(/,' Output node number is............',I10,//,  
     1         ' Output data-set unit number is...',I10,//,  
     2         ' Number of quality constituents...',I10,/)  
  411 FORMAT(/,' Output node name is..............',A10,//,  
     1         ' Output data-set unit number is...',I10,//,  
     2         ' Number of quality constituents...',I10,/)  
C#### WCH, 11/23/93  
  415 FORMAT(' Output ASCII file will give loads (flow x concentration)   
     1for pollutant units.')  
  416 FORMAT(' Output ASCII file will give concentrations for pollutant   
     1units (NPOLL < 0).')  
  420 FORMAT(/,' Water quality constituent........',I3,/,  
     +         ' Position on input file one.......',I3,/,  
     +         ' Position on input file two.......',I3)  
  430 FORMAT(/,' Locations to be extracted (NUMX).',I3,//,  
     +         ' Locations to be renumbered (NUMR)',I3)  
  440 FORMAT(/,  
     +' #########################################',/,  
     +' # The following nodes will be extracted #',/,  
     +' #     from the input file(s).           #',/,  
     +' #########################################',/)  
  445 FORMAT(/,  
     +' ##################################################',/,  
     +' # The following numbers are the new node numbers #',/,  
     +' # assigned to the extracted/renumbered nodes.    #',/,  
     +' ##################################################',/)  
  450 FORMAT(1X,10I10)  
  451 FORMAT(1X,10A10)  
  455 FORMAT(///,' Ending time in seconds for file 1 --->',F15.2,  
     +        /, ' Ending time in seconds for file 2 --->',F15.2)  
  660 FORMAT(1H1,4X,A80,/,5X,A80)  
C#### WCH, 11/22/93  
 2210 FORMAT(//,' Error NPOS1 and NPOS2 (data group B3) are both zero f  
     +or pollutant number',I2,/,' At least one must be non-zero.  Run st  
     +opped from the Combine Block.')  
 9000 FORMAT(/,' ===> Combine Block ended normally.')  
 9005 FORMAT(/,  
     +' **************************************************',/,  
     +' *  Reading information from the NSCRAT(1) file.  *',/,  
     +' **************************************************')  
 9010 FORMAT(/,  
     +' ********************************************',/,  
     +' *  Reading information from the JIN file.  *',/,  
     +' ********************************************')  
 9015 FORMAT(/,  
     +' *******************************************',/,  
     +' *  Writing information on the JOUT file.  *',/,  
     +' *******************************************')  
C#### WCH, 8/2/93.  
 9500 FORMAT (/' $$$ YOU ARE ABOUT TO RECEIVE AN ERROR MESSAGE WHILE TRY  
     1ING TO READ LINE ',A2,/,'    IT IS POSSIBLE THIS IS CAUSED BY NOT   
     2USING ALPHANUMERIC VALUES (ENCLOSED',/,'     IN QUOTES) WHEN'  
     3 ,' NODE NUMBERS ARE REQUESTED AS INPUT.  FOR EXAMPLE,'/  
     4'     A ZERO INPUT FOR ALPHANUMERIC IS JUST TWO QUOTES',4H ''.)  
      END  
  
ECHO is off.
REM File: DATED.FOR  
ECHO is off.
      SUBROUTINE DATED  
C#######################################################################  
C     FIND THE YEAR, MONTH, DAY, HOUR, MINUTE AND SECOND CORRESPONDING  
C     TO THE EXISTING JULDAY AND TIMDAY  
C  
C     JULDAY = JULIAN DAY  
C     TIMDAY = TIME OF DAY IN SECONDS  
C     CORRECTION BY WCH, 4/93 TO FIX CONVERSION FROM TIMDAY IN   
C       SECONDS TO HR/MIN/SEC.  
C#######################################################################  
      INCLUDE 'STIMER.INC'  
C=======================================================================  
      NYEAR = JULDAY/1000  
      JEWEL = JULDAY - 1000*NYEAR  
      IF (NYEAR.LT.100) THEN  
           NYEAR  = NYEAR + 1900  
           JULDAY = JEWEL + NYEAR*1000  
           ENDIF  
      IFEB  = 28  
      IF((NYEAR/4)*4-NYEAR.EQ.0) IFEB = 29  
      IF(JEWEL.LE.31)      THEN  
                           MONTH = 1  
                           NDAY  = JEWEL  
                           GO TO 100  
                           ENDIF  
      IF(JEWEL.LE.31+IFEB) THEN  
                           MONTH = 2  
                           NDAY  = JEWEL - 31  
                           GO TO 100  
                           ENDIF  
      IF(JEWEL.LE.62+IFEB) THEN  
                           MONTH = 3  
                           NDAY  = JEWEL - 31 - IFEB  
                           GO TO 100  
                           ENDIF  
      IF(JEWEL.LE.92+IFEB) THEN  
                           MONTH = 4  
                           NDAY  = JEWEL - 62 - IFEB  
                           GO TO 100  
                           ENDIF  
      IF(JEWEL.LE.123+IFEB) THEN  
                            MONTH = 5  
                            NDAY  = JEWEL - 92 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.153+IFEB) THEN  
                            MONTH = 6  
                            NDAY  = JEWEL - 123 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.184+IFEB) THEN  
                            MONTH = 7  
                            NDAY  = JEWEL - 153 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.215+IFEB) THEN  
                            MONTH = 8  
                            NDAY  = JEWEL - 184 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.245+IFEB) THEN  
                            MONTH = 9  
                            NDAY  = JEWEL - 215 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.276+IFEB) THEN  
                            MONTH = 10  
                            NDAY  = JEWEL - 245 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.306+IFEB) THEN  
                            MONTH = 11  
                            NDAY  = JEWEL - 276 - IFEB  
                            GO TO 100  
                            ENDIF  
      IF(JEWEL.LE.337+IFEB) THEN  
                            MONTH = 12  
                            NDAY  = JEWEL - 306 - IFEB  
                            ENDIF  
C#### WCH, 4/20/93. CHANGE FRACTION ADDED TO 0.0001 HR.  MUST BE < 1 SEC.  
  100 JHR     = IFIX(TIMDAY/3600.0 + 0.0001)  
      JSEC    = IFIX(TIMDAY - FLOAT(JHR)*3600.0 + 0.01)  
      MINUTE  = JSEC / 60  
      JSEC    = JSEC - 60*MINUTE  
      RETURN  
      END  
  
ECHO is off.
REM File: DEPTH.FOR  
ECHO is off.
      FUNCTION DEPTH(ALPHA)  
C	TRANSPORT BLOCK  
C  
C=======================================================================  
C     COMPUTES NORMALIZED DEPTH IN CONDUIT GIVEN  
C     NORMALIZED AREA, ALPHA.   LAST UPDATED BY RED IN NOVEMBER, 1988.  
C     RED, 12/31/93.  CHECK FOR RANGE OF SUBSCRIPT.  
C     WCH, 12/5/94.  CHECK FOR RANGE OF SUBSCRIPT FOR MOD. BASKET HAND.  
C     CIM, 9/8/00.  Add option for detailed calculation of irregular  
C                   sections.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'TABLES.INC'  
      INCLUDE 'HUGO.INC'  
      INCLUDE 'NEW81.INC'  
      INCLUDE 'FLODAT.INC'  
C#### CIM 9/8/00  Add NEWTR common block  
      INCLUDE 'NEWTR.INC'  
      DIMENSION QI(NET),QO(NET)  
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2))  
C=======================================================================  
C     KDEPTH(NTPE) = 1 FOR CONDUIT WITH A FUNCTIONAL D-A RELATIONSHIP.  
C     KDEPTH(NTPE) = 2 FOR CONDUIT WITH A TABULAR D-A RELATIONSHIP.  
C     KDEPTH(NTPE) = 3 FOR ELEMENT OTHER THAN CONDUIT.  
C=======================================================================  
      NTPE = NTYPE(M)  
C=======================================================================  
C     IN RECTANGULAR CONDUIT, NORMALIZED DEPTH EQUALS NORMALIZED AREA.  
C=======================================================================  
      IF(NTPE.EQ.2.OR.ALPHA.EQ.0.0) THEN  
                                  DEPTH = ALPHA  
                                  RETURN  
                                  ENDIF  
C=======================================================================  
C     ROUTINE FOR TABULAR D-A CURVE.  
C     LINEAR  INTERPOLATION BETWEEN TABULAR POINTS IS USED.  
C=======================================================================  
      IF(KDEPTH(NTPE).EQ.2) THEN  
C=======================================================================  
C     PARABOLIC, POWER FUNCTION OR NATURAL CHANNELS  
C     Note that NTPE = 16 for all three channel types.   
C=======================================================================  
           IF(NTPE.EQ.16) THEN  
                   I     = 1 + IFIX(ALPHA/0.04)  
                   IF(I.GT.25) I = 25  
C#### RED (WCH), 12/31/93.  ADD ANOTHER CHECK FOR VALUE OF I.  
                   IF(I.LE.0)  I = 1  
CIM###  9/8/00  CIMDETAIL   add if here  
             IF(IDETAIL.EQ.0.OR.I.GE.2) THEN  
                   DELTA = (ALPHA - 0.04*FLOAT(I-1))/0.04  
                   M1    = NQC(M)  
                   DEPTH = (QCURVE(M1,2,I) +  
     +                    (QCURVE(M1,2,I+1)-QCURVE(M1,2,I))*DELTA)  
CIM###  9/8/00  CIMDETAIL   here is code for detailed section  
             ELSE     HERE IDETAIL = 1 and I LT 2  
                   I  =  1 + IFIX(ALPHA/0.0016)  
                   IF (I.LE.0) I = 1  
                   DELTA = (ALPHA - 0.0016*FLOAT(I-1))/0.0016  
                   M1    = NQC(M)  
                   DEPTH = (QCURV2(M1,2,I) +  
     +                    (QCURV2(M1,2,I+1)-QCURV2(M1,2,I))*DELTA)  
cim      WRITE(N6,*) 'DEPTH2',M,M1,ALPHA,I,DELTA,DEPTH,QCURV2(M1,2,I),  
cim     +QCURV2(M1,2,I+1)  
             ENDIF  
CIM###  9/8/00 end of change  
                   RETURN  
                   ENDIF  
C=======================================================================  
C     NON-CIRCULAR CONDUITS OR CIRCULAR CONDUITS WITH LARGE DEPTHS  
C=======================================================================  
           IF(NTPE.NE.1.OR.ALPHA.GE.0.04) THEN  
                          DALPHA = 1.0 / (FLOAT(NN(NTPE)) - 1.0)  
                          I      = IFIX(ALPHA/DALPHA) + 1  
                          IF(I.GE.NN(NTPE)) THEN  
                              DEPTH = DNORM(NTPE,I)  
                              ELSE  
                          DEPTH = DNORM(NTPE,I)+(ALPHA - ANORM(NTPE,I))/  
     +                            DALPHA*(DNORM(NTPE,I+1)-DNORM(NTPE,I))  
                              ENDIF  
C=======================================================================  
C                        IMPROVE ESTIMATE WITH PARABOLIC INTERPOLATION  
*                                FOR NON-CIRCULAR CONDUITS.  
C=======================================================================  
                         IF(ALPHA.LT.0.04) DEPTH = DEPTH + (ALPHA -  
     +                  ANORM(NTPE,I)) * (DNORM(NTPE,I) - 2.0 *  
     +                  DNORM(NTPE,I+1)+DNORM(NTPE,I+2))/(2.0*DALPHA**2)  
                         RETURN  
                         ENDIF  
C=======================================================================  
C     SPECIAL ROUTINE FOR HIGH ACCURACY AT LOW FLOWS.  
C=======================================================================  
           ALF = ALPHA  
           CALL CIRCLE(ALF,PS,DN,2)  
                        DEPTH = DN  
           IF(NTPE.EQ.12) DEPTH = DEPTH*2.0*GEOM3(M)/(P2(M)*DIST(M))  
           RETURN  
           ENDIF  
C=======================================================================  
C     END OF TABULAR COMPUTATIONS.  
C     BEGIN FUNCTIONAL-FORM COMPUTATIONS (KEPTH = 1).  
C=======================================================================  
C     FUNCTIONAL FORM FOR MODIFIED BASKET-HANDLE.  
C=======================================================================  
      IF (NTPE.EQ.10) THEN  
                    AA = ALPHA*AFULL(M)  
                    IF(AA.LE.GEOM3(M)) THEN  
                          DEPTH = AA/GEOM2(M)/(GEOM1(M)+GEOM2(M)/2.0)  
                          RETURN  
                          ENDIF  
                    ALF   = (AA-GEOM3(M)+P5(M)/2.0)/P5(M)  
                    I     = IFIX(ALF/0.02) + 1  
C#### WCH, 12/5/94.  CHECK FOR POSSIBLE I GT 51.  CHANGE EQ TO GE.  
                    IF(I.GE.51) THEN  
                            DD = DNORM(1,I)  
                            ELSE  
                            DD    = DNORM(1,I)+(ALF-ANORM(1,I))/0.02 *  
     +                              (DNORM(1,I+1)-DNORM(1,I))  
                            DEPTH = ((DD-0.5)*GEOM2(M)+GEOM1(M))/  
     +                              (GEOM1(M) + GEOM2(M)/2.0)  
                            ENDIF  
                    RETURN  
                    ENDIF  
C=======================================================================  
C     FUNCTIONAL FORM FOR RECTANGULAR, TRIANGULAR BOTTOM.  
C=======================================================================  
      IF (NTPE.EQ.11) THEN  
                    AA = ALPHA*AFULL(M)  
                    AB = GEOM3(M)*GEOM2(M)/2.0  
                    IF(AA-AB.LT.0.0) DEPTH = GEOM3(M)/GEOM1(M) *  
     +                                       SQRT(AA/AB)  
                    IF(AA-AB.EQ.0.0) DEPTH = GEOM3(M)/GEOM1(M)  
                    IF(AA-AB.GT.0.0) DEPTH = (GEOM3(M) +  
     +                                       (AA-AB)/GEOM2(M))/GEOM1(M)  
                    RETURN  
                    ENDIF  
C=======================================================================  
C     FUNCTIONAL FORM FOR RECTANGULAR, ROUND BOTTOM.  
C=======================================================================  
      IF (NTPE.EQ.12) THEN  
                    AA = ALPHA*AFULL(M)  
                    IF (AA.GT.P6(M)) THEN  
                                     DD    = P2(M)*DIST(M)-GEOM1(M)  
                                     DEPTH = (DD+(AA-P6(M))/GEOM2(M))/  
     +                                       (P2(M)*DIST(M))  
                                     RETURN  
                                     ENDIF  
                    ALF = ALPHA*AFULL(M)/(3.1415965*GEOM3(M)*GEOM3(M))  
                    IF(ALF.LT.0.04) THEN  
                           CALL CIRCLE(ALF,PS,DN,2)  
                           DEPTH = DN  
                           IF(NTPE.EQ.12) DEPTH = DEPTH*2.0*GEOM3(M)/  
     +                                          (P2(M)*DIST(M))  
                           RETURN  
                           ENDIF  
                    I     = IFIX(ALF/0.02) + 1  
                    IF(I.EQ.51) THEN  
                            DEPTH = DNORM(1,I)  
                            ELSE  
                            DEPTH = DNORM(1,I) + (DNORM(1,I+1) -  
     +                              DNORM(1,I))/0.02*(ALF-ANORM(1,I))  
                            ENDIF  
                    DEPTH = DEPTH*2.0*GEOM3(M)/(P2(M)*DIST(M))  
                    RETURN  
                    ENDIF  
C=======================================================================  
C    FUNCTIONAL FORM FOR TRAPEZOID  
C=======================================================================  
      IF(NTPE.EQ.13) THEN  
                   AA = ALPHA * AFULL(M)  
                   DEPTH = (-GEOM2(M) + SQRT(GEOM2(M)**2 +  
     +                     4.0 * AA/GEOM3(M))) * GEOM3(M)/2.0/GEOM1(M)  
                   RETURN  
                   ENDIF  
      END  
ECHO is off.
REM File: EXTRAN.FOR  
ECHO is off.
      SUBROUTINE EXTRAN  
C=======================================================================  
C        EXTENDED TRANSPORT MODEL IS UPDATED CONTINUOUSLY  
C                             BY  
C                 CAMP DRESSER AND MCKEE, INC.  
C                      LARRY A. ROESNER  
C                     ROBERT P. SHUBINSKI  
C                       JOHN A. ALDRICH  
C   BRETT A. CUNNINGHAM, CHARLES I. MOORE, MICHAEL F. SCHMIDT  
C  
C                             AND  
C                (FORMERLY) UNIVERSITY OF FLORIDA  
C                       ROBERT E. DICKINSON -- CDM  
C                        WAYNE C. HUBER -- Oregon State University  
C=======================================================================  
C     ADD NO-QUOTE OPTION, WCH, 11/29/93.  
C     INITIALIZE QINN AND QINNK3, WCH, 10/17/95.  
C     Modified statement 103 and 104 to include warning, CIM 9/8/00  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'BND.INC'  
      INCLUDE 'BD.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'ORF.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'OUT.INC'  
      INCLUDE 'TIDE.INC'  
CIM TRANAID START  
cim include common block for tranaid transfer file  
      INCLUDE 'TRANAID.INC'  
CIM TRANAID END  
C=======================================================================  
C     Set up transfer files.  
C=======================================================================  
      INCNT  = INCNT  + 1  
      IOUTCT = IOUTCT + 1  
      LAST   = JIN(INCNT)  
      NEXT   =  JOUT(IOUTCT)  
      WRITE(*,100)  
      WRITE(N6,100)  
C#### WCH, 11/39/93.  ADD NO-QUOTE OPTION TO EXTRAN.  
      IF(NOQ.EQ.0) THEN  
           WRITE(*,102)  
           WRITE(N6,102)  
           ELSE  
           WRITE(*,101)  
           WRITE(N6,101)  
           ENDIF  
C=======================================================================  
C     Open all scratch files for the Extran Block.  
C=======================================================================  
CIM 2/99 Why open this input file as scratch????  
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR.  
     +      FFNAME(INCNT).EQ.'JIN.UF')) THEN  
c     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      WRITE(N6,103)  
	JIN(INCNT) = 0  
      LAST = 0  
      ENDIF  
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND.  
     +      FFNAME(INCNT).NE.'JIN.UF')  
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
CIM 2/99  change next line to avoid writing data to JOUT if  
CIM       it won't be saved  
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR.  
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF')) THEN  
c     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH')  
c	Reset JOUT(IOUTCT to 0 to avoid writing all this data to  
c     an scratch file that is not saved.  
      WRITE(N6,104)  
      JOUT(IOUTCT) = 0  
	NEXT = 0  
      ENDIF  
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND.  
     +      FFNAME(25+IOUTCT).NE.'JIN.UF')  
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED',  
     +      STATUS='REPLACE')  
cim change to unformatted  
cim      IF(NSCRAT(1).GT.0.AND.FFNAME(51).NE.'SCRT1.UF') OPEN(NSCRAT(1),  
cim     +             FILE=FFNAME(51),FORM='FORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).NE.'SCRT1.UF') OPEN(NSCRAT(1),  
     +             FILE=FFNAME(51),FORM='UNFORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(2).GT.0.AND.FFNAME(52).NE.'SCRT2.UF') OPEN(NSCRAT(2),  
     +             FILE=FFNAME(52),FORM='UNFORMATTED',STATUS='UNKNOWN')  
cim 3 starts out formatted  
      IF(NSCRAT(3).GT.0.AND.FFNAME(53).NE.'SCRT3.UF') OPEN(NSCRAT(3),  
     +             FILE=FFNAME(53),FORM='FORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(4).GT.0.AND.FFNAME(54).NE.'SCRT4.UF') OPEN(NSCRAT(4),  
     +             FILE=FFNAME(54),FORM='UNFORMATTED',STATUS='UNKNOWN')  
cim 5 is formatted  
      IF(NSCRAT(5).GT.0.AND.FFNAME(55).NE.'SCRT5.UF') OPEN(NSCRAT(5),  
     +             FILE=FFNAME(55),FORM='FORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(6).GT.0.AND.FFNAME(56).NE.'SCRT6.UF') OPEN(NSCRAT(6),  
     +             FILE=FFNAME(56),FORM='UNFORMATTED',STATUS='UNKNOWN')  
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).NE.'SCRT7.UF') OPEN(NSCRAT(7),  
     +             FILE=FFNAME(57),FORM='UNFORMATTED',STATUS='UNKNOWN')  
CIM 8 IS FORMATTED EXTRAN TO WASP HYDRODYNAMICS INTERFACE FILE  
	IF(NSCRAT(8).GT.0.AND.FFNAME(58).NE.'SCRT8.UF') OPEN(NSCRAT(8),  
     +             FILE=FFNAME(58),STATUS='UNKNOWN')  
cim  
cim change 1 to unformatted  
cim      IF(NSCRAT(1).GT.0.AND.FFNAME(51).EQ.'SCRT1.UF') OPEN(NSCRAT(1),  
cim     +             FORM='FORMATTED',STATUS='SCRATCH')  
      IF(NSCRAT(1).GT.0.AND.FFNAME(51).EQ.'SCRT1.UF') OPEN(NSCRAT(1),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(NSCRAT(2).GT.0.AND.FFNAME(52).EQ.'SCRT2.UF') OPEN(NSCRAT(2),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
cim 3 starts out formatted  
      IF(NSCRAT(3).GT.0.AND.FFNAME(53).EQ.'SCRT3.UF') OPEN(NSCRAT(3),  
     +             FORM='FORMATTED',STATUS='SCRATCH')  
      IF(NSCRAT(4).GT.0.AND.FFNAME(54).EQ.'SCRT4.UF') OPEN(NSCRAT(4),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
cim 5 is formatted  
      IF(NSCRAT(5).GT.0.AND.FFNAME(55).EQ.'SCRT5.UF') OPEN(NSCRAT(5),  
     +             FORM='FORMATTED',STATUS='SCRATCH')  
      IF(NSCRAT(6).GT.0.AND.FFNAME(56).EQ.'SCRT6.UF') OPEN(NSCRAT(6),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(NSCRAT(7).GT.0.AND.FFNAME(57).EQ.'SCRT7.UF') OPEN(NSCRAT(7),  
     +             FORM='UNFORMATTED',STATUS='SCRATCH')  
CIM 8 IS FORMATTED EXTRAN TO WASP HYDRODYNAMICS INTERFACE FILE  
      IF(NSCRAT(8).GT.0.AND.FFNAME(58).EQ.'SCRT8.UF') OPEN(NSCRAT(8),  
     +             STATUS='SCRATCH')  
C=======================================================================  
C     INITIALIZATION  
C=======================================================================  
      DO 5    N    = 1,NEE  
CIM   TRANAID START  
      qsum(n)      = 0.0  
      qisum(n)     = 0.0  
CIM   TRANAID END  
      ICHECK(N)    = IND(1)  
      JCHECK(N)    = IND(1)  
      PMAX(N,1)    = 0.0  
      PMAX(N,2)    = 0.0  
      JSKIP(N)     = 0  
      INGATE(N)    = 0  
      YTOT(N)      = 0.0  
      QTOT(N)      = 0.0  
      YDEV(N)      = 0.0  
      QDEV(N)      = 0.0  
      Y(N)         = 0.0  
      YT(N)        = 0.0  
      YO(N)        = 0.0  
      A(N)         = 0.0  
      AT(N)        = 0.0  
      V(N)         = 0.0  
      VT(N)        = 0.0  
      Q(N)         = 0.0  
      QO(N)        = 0.0  
      QT(N)        = 0.0  
      AS(N)        = 0.0  
      ASFULL(N)    = 0.0  
      WIDE(N)      = 0.0  
      AMAX(N)      = 0.0  
      HMAX(N)      = 0.0  
      AFULL(N)     = 0.0  
      RFULL(N)     = 0.0  
      H(N,1)       = 0.0  
      H(N,2)       = 0.0  
      ZD(N)        = 0.0  
      ZU(N)        = 0.0  
C#### WCH, 10/17/95.  INITIALIZE QINN AND QINNK3  
      DO 4    M    = 1,2  
      QINN(N,M)    = 0.0  
    4 QINNK3(N,M)  = 0.0  
      DO 5    M    = 1,NCHN  
    5 NCHAN(N,M)   = 0  
      DO 6    M    = 1,NVORF  
      DO 6    N    = 1,NVOTIM  
      VORIF(M,N,1) = 999999.0  
      VORIF(M,N,2) = 0.0  
      VORIF(M,N,3) = 0.0  
    6 CONTINUE  
      DO 900 N   = 1,NEE  
      VMAXX(N)   = 0.0  
      QMAXX(N)   = 0.0  
      IVHR(N)    = 0  
      IVMIN(N)   = 0  
      IQHR(N)    = 0  
      IQMIN(N)   = 0  
  900 CONTINUE  
Cim   Done in Sub. OUTPUT:   SUMQIN     = 0.0  
      VLEFT      = 0.0  
      VINIT      = 0.0  
      DO 950 J   = 1,NEE  
      JCHECK(J)  = IND(1)  
      SUMQ(J)    = 0.0  
      SUMQS(J)   = 0.0  
      SUMAL(J)   = 0.0  
      SURLEN(J)  = 0.0  
      DEPMAX(J)  = 0.0  
      QOU(J)     = 0.0  
      FLDLEN(J)  = 0.0  
      ASMAXX(J)  = 0.0  
      IDHR(J)    = 0  
      IDMIN(J)   = 0  
	GRELEV(J) = 0.0  
	SURELEV(J) = 0.0  
  950 CONTINUE  
C=======================================================================  
C     Read input data.  
C=======================================================================  
      CALL INDAT1  
      CALL INDAT2  
      CALL INDAT3  
C=======================================================================  
C     Call TRANSX the driver routine for modified Euler solution.  
C=======================================================================  
c      TIME  = TZERO  
C   TIME SHOULD BE TIME IN HOURS FROM START OF SIMULATION  
C     TIMDAY IS THE TIME OF DAY, JULDAY DESCRIBES THE DAY  
      TIME = 0.0  
      CALL TRANSX  
      WRITE(*,1610)  
      CALL OUTPUT  
      WRITE(*,150)  
      WRITE(N6,150)  
      RETURN  
C=======================================================================  
C#### WCH, 11/29/93.  
  100 FORMAT(/,  
     +' *********************************************************',/,  
     +' * Entry made to the EXTENDED TRANSPORT MODEL (EXTRAN)   *',/,  
     1' * developed 1973 by Camp, Dresser and McKee (CDM) with  *',/,  
     1' * modifications 1977-1991 by the University of Florida. *',/,  
     1' *                                                       *',/,  
     1' * Most recent update: July 2004 by CDM and Oregon      *',/,  
     1' * State University                                      *')  
  101 FORMAT(  
     1' *********************************************************',/)  
  102 FORMAT(  
     1' *                                                       *',/,  
     1' * "Smooth runs the water where the brook is deep."      *',/,  
     1' *                   Shakespeare, Henry VI, II, III, 1   *',/,  
     1' *********************************************************',/)  
CIM 9/8/00 add Warning to message to allow search to find problem  
  103 FORMAT(5X,'WARNING : ',  
     a'JIN WAS SET TO NONZERO BUT FILE NAME WAS NOT',  
     a' SPECIFIED THROUGH @ LINES',/,5X,'JIN IS SET TO ZERO')  
  104 FORMAT(5X,'WARNING : ',  
     a'JOUT WAS SET TO NONZERO BUT FILE NAME WAS NOT ',  
     a'SPECIFIED THROUGH @ LINES',/,5X,'JOUT WAS SET TO ZERO TO ',  
     a'AVOID WRITING DATA TO UNSAVED SCRATCH FILE')  
  150 FORMAT(/,' ===> Extended Transport model simulation',  
     1         ' ended normally.')  
 1610 FORMAT(/,' Calling output and graph subroutines.')  
C=======================================================================  
      END  
ECHO is off.
REM File: FILECK.FOR  
ECHO is off.
      SUBROUTINE FILECK(IO,FNAME,DEFORM)  
C      ADD FOLLOWING LINE FOR DIGITAL VISUAL FORTRAN  
c2013  USE DFPORT  
C=======================================================================  
C     Subroutine to check form (formatted vs. unformatted) of existing  
C     file to avoid run-stopping error when desired form does not  
C     match existing form.  
C     This problem does not occur with an empty file, only one   
C     previously used that contains data in the wrong form.    
C     At program pause, user will have option to allow deletion of  
C     existing file (FNAME), and continue run.  
C     Note: Subroutine SYSTEM may be Lahey-specific, in which case   
C     do not use this subroutine or references to it, and just suffer  
C     through resulting error message.  
C     Wayne Huber, 7/25/96.  
C     Modified 7/97 to check if file exists  C. Moore CDM 6/25/97  
C     Add EX to logical, INQUIRE, and add check to return if file  
C     doesn't exist.  
C=======================================================================  
C     IO    = unit number of file to be checked.  
C     FNAME = DOS name of file  
C     DEFORM = desired form for file (FORMATTED or UNFORMATTED)  
C=======================================================================  
      CHARACTER*128 FNAME  
      CHARACTER*11 DEFORM,ACFORM  
      LOGICAL OPEND,EX  
C=======================================================================  
C     If no file is specified (IO = 0), do nothing.  
C=======================================================================  
      IF(IO.LE.0) RETURN  
C=======================================================================  
C     Otherwise, check form of file FNAME to see if is OK to open.  
C     OK if form about to be used matches existing form.    
C     Otherwise, print message and ask user if it is OK to delete  
C     the offending file.  
C=======================================================================  
      INQUIRE(IO,FORM=ACFORM,OPENED=OPEND,exist=EX)  
      IF (.NOT.EX) RETURN  
      IF(ACFORM.EQ.DEFORM) THEN  
           IF(OPEND) REWIND IO  
           RETURN  
           ELSE  
CIM ELIMINATE WRITE AND PAUSE  
c           WRITE(*,9000) IO,FNAME,DEFORM,IO  
c           PAUSE  
C=======================================================================  
C     Prepare a delete command by concatenating DOS delete command  
C     with offending file name.  
C     Caution.  Subroutine SYSTEM allows a DOS command to be executed.  
C     This may be Lahey-specific.  
C=======================================================================  
c the following line is lahey  
C           CALL SYSTEM('del '//FNAME)  
c  the following line is digital visual fortran  
           IOEER = SYSTEM('del '//FNAME)  
           ENDIF  
      RETURN  
C=======================================================================  
c 9000 FORMAT(/,' Program is about to stop with error message for unit',  
c     1 I3,/,' about ''form'' of file: ',A60,/,  
c     2' File momentarily should be of form: ',A11,', but is not.',/,  
c     3' At prompt, press <enter> to delete above file and then',/,  
c     4' over-write it, or press <control>-C or <control>-break',/,  
c     5' to end run and not delete the file.  In this latter case,',/,  
c     6' provide new file name on @-line for unit',I3,' and run again.')  
      END  
ECHO is off. 
ECHO is off.
REM File: FINDA.FOR  
ECHO is off.
      SUBROUTINE FINDA(PS,AA)  
C     TRANSPORT BLOCK  
C     CALLED BY ROUTE NEAR LINE 240  
C               INITAL NEAR LINE 211  
C=======================================================================  
C     CALCULATES THE FLOW AREA IN CONDUITS GIVEN THE FLOW RATE.  
C  
C     UPDATED (NEW COMMON) BY W.C.H., SEPTMEBER 1981.  
C     UPDATED 12/31/93 BY RED.  FIX DO LOOP RANGE.  
C     UPDATED 09/08/00 BY CIM.  Changes to add option for additional  
C                               detail in irregular sections.  
C     Use QCURVE(4), not (3), for flow.  WCH, 7/6/01  
C     No change to QCURV2.  
C     Fix possible error at end of search for correct PS range.    
C        WCH, 5/24/02.   
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'TABLES.INC'  
      INCLUDE 'HUGO.INC'  
      INCLUDE 'NEW81.INC'  
      INCLUDE 'FLODAT.INC'  
CIM## 9/8/00 add new common  
      INCLUDE 'NEWTR.INC'  
C=======================================================================  
      AA = 0.0  
      IF(PS.EQ.0.0) RETURN  
      NTPE = NTYPE(M)  
C=======================================================================  
C     CONDUITS WITH FUNCTIONAL Q-A RELATIONSHIP.  
C=======================================================================  
      IF(KLASS(NTPE).EQ.1) THEN  
                         C2    = -PS  
                         ALPHA = 0.2  
                         CALL NEWTON(ALPHA,PS,0.0,C2,KFLAG)  
                         IF(KFLAG.EQ.2) THEN  
                                 IF(JCE.EQ.0) WRITE(N6,910)  
     +                                 TIME,N,NOE(M),A(M,1,1)  
                                 IF(JCE.EQ.1) WRITE(N6,911)  
     +                                 TIME,N,KOE(M),A(M,1,1)  
                                 AA = A(M,1,1)  
                                 ELSE  
                                 AA = ALPHA*AFULL(M)  
                                 ENDIF  
                         RETURN  
                         ENDIF  
C=======================================================================  
C      SPECIAL ROUTINE FOR HIGH ACCURACY AT LOW FLOWS FOR CIRCULAR PIPE.  
C=======================================================================  
      IF(NTPE.EQ.1.AND.PS.LE.0.015) THEN  
                                  CALL CIRCLE(ALPHA,PS,DN,3)  
                                  AA = ALPHA*AFULL(M)  
                                  RETURN  
                                  ENDIF  
C=======================================================================  
C     CONDUITS WITH TABULAR Q-A RELATIONSHIP.  
C     Note, NTPE also = 16 for parabolic and power functions (changed   
C     from 14 and 15 in Sub. INTRAN).  
C=======================================================================  
      IF(NTPE.EQ.16) THEN  
C=======================================================================  
C     PARABOLIC, POWER FUNCTION, OR NATURAL CROSS SECTIONS  
C=======================================================================  
         MMM     = 26  
         KK      = NQC(M)  
         DALPHA  = 0.04  
C#### RED (WCH), 12/31/93.  CHANGE END OF LOOP TO MMM-1 FROM MMM TO  
C####                       AVOID OUT OF BOUNDS ERROR IN LINE 207.  
         DO 210 I = 1,MMM-1  
         II = I  
Cwch, 7/6/01.  Use QCURVE(4), not (3), for flow.   
         IF(PS-QCURVE(KK,4,I+1)) 207,208,210  
  210    CONTINUE  
         ALPHA = 1.0  
         AA = ALPHA*AFULL(M)  
         RETURN  
  208    I = II  
CIM### 9/8/00 Change next if  
         IF ((IDETAIL.EQ.0).OR.(I.GE.2)) THEN  
            ALPHA = FLOAT(I-1)*0.04  
            AA    = ALPHA*AFULL(M)  
            RETURN  
            ENDIF  
  207    I = II  
CIM### 9/8/00 Add if statement major changes throughout next section.  
         IF ((IDETAIL.EQ.0).OR.(I.GE.2)) THEN  
Cwch, 7/6/01.  Use QCURVE(4), not (3), for flow.   
            ALPHA = FLOAT(I-1)*0.04 + (PS-QCURVE(KK,4,I))/  
     +                      (QCURVE(KK,4,I+1)- QCURVE(KK,4,I))*DALPHA  
C=======================================================================  
C        IMPROVE ESTIMATE WITH PARABOLIC INTERPOLATION.  
C=======================================================================  
            IF(PS.LT.0.015) ALPHA = ALPHA + (PS - QCURVE(KK,4,I)) *  
     +        (PS - QCURVE(KK,4,I+1)) * (DALPHA/(QCURVE(KK,4,I+2) -  
     +         QCURVE(KK,4,I+1))      - DALPHA/(QCURVE(KK,4,I+1)  
     +       - QCURVE(KK,4,I)))/(QCURVE(KK,4,I+2) - QCURVE(KK,4,I))  
            AA = ALPHA*AFULL(M)  
            RETURN  
            ELSE     here when IDETAIL.EQ.1 AND I LE 1  
            DALPHA = 0.0016  
            DO 205 J = 1,MMM-1  
            JJ = J  
            IF(PS-QCURV2(KK,3,J+1)) 203,204,205  
  205       CONTINUE  
CIM SHOULD NOT GET HERE  
            write(n6,*) 'Error in FINDA - 1',ps,m,kk,qcurv2(kk,3,26)  
            STOP ' ERROR IN FINDA - 1'  
  203       J=JJ  
            ALPHA = FLOAT(J-1)*0.0016 + (PS-QCURV2(KK,3,J))/  
     +                    (QCURV2(KK,3,J+1) - QCURV2(KK,3,J))*DALPHA  
            AA = ALPHA*AFULL(M)  
c     write(n6,*) 'finda3',ps,J,qcurv2(kk,3,J),qcurv2(kk,3,J+1),  
c    .alpha,aa,afull(m)  
            RETURN  
  204       J=JJ  
            ALPHA = FLOAT(J-1)*0.0016  
            AA = ALPHA*AFULL(M)  
c     write(n6,*) 'finda4',ps,J,qcurv2(kk,3,J),QCURV2(KK,3,J+1),  
c    .alpha,aa,afull(m)  
            RETURN  
            ENDIF  
CIM### 9/8/00 end of changes.  
C=======================================================================  
C     OTHER TABULAR CROSS SECTIONS  
C=======================================================================  
         ELSE   Here tabular, but not NTPE = 16.   
         MMM      = MM(NTPE)  
         DALPHA   = ANORM(NTPE,2) - ANORM(NTPE,1)  
         DO 110 I = 1,MMM-1  
         IF(PS-QNORM(NTPE,I+1)) 107,108,110  
  107    ALPHA = ANORM(NTPE,I) + (PS-QNORM(NTPE,I))/(QNORM(NTPE,I+1) -  
     +                        QNORM(NTPE,I))*DALPHA  
C=======================================================================  
C        IMPROVE ESTIMATE WITH PARABOLIC INTERPOLATION.  
C=======================================================================  
         IF(PS.LT.0.015) ALPHA = ALPHA +  
     1                       (PS-QNORM(NTPE,I))*(PS-QNORM(NTPE,I+1))*  
     2                       (DALPHA/(QNORM(NTPE,I+2)-QNORM(NTPE,I+1))-  
     3                       DALPHA/(QNORM(NTPE,I+1) -  
     4                       QNORM(NTPE,I)))/  
     5                       (QNORM(NTPE,I+2)-QNORM(NTPE,I))  
         AA = ALPHA*AFULL(M)  
         RETURN  
  108    ALPHA = ANORM(NTPE,I+1)  
         AA    = ALPHA*AFULL(M)  
         RETURN  
  110    CONTINUE  
C=======================================================================  
Cwch, 5/24/02. Since PS should be <= 1.0 and since QNORM-max should be   
C     1.0, should not exit DO-loop this way. but in case we do, because  
C     of numerical error or something, we want max. value for area, not  
C     zero. (Lew Rossman)  
C=======================================================================  
C         AA = ALPHA*AFULL(M)  
         AA = AFULL(M)  
         ENDIF  
C=======================================================================  
      RETURN  
C=======================================================================  
  910 FORMAT (/,' ===> WARNING  NEWTON UNABLE TO FIND AREA GIVEN FLOW.  
     1TIME = ',F7.1,', TIME STEP= ',I3,', EXT. ELE. NUM.=',I10,', USE OL  
     2D UPSTREAM AREA = ',F6.2)  
  911 FORMAT (/,' ===> WARNING  NEWTON UNABLE TO FIND AREA GIVEN FLOW.  
     1TIME = ',F7.1,', TIME STEP= ',I3,', EXT. ELE. NUM.=',A10,', USE OL  
     2D UPSTREAM AREA = ',F6.2)  
C=======================================================================  
      END  
ECHO is off.
REM File: G3RAIN.FOR  
ECHO is off.
      SUBROUTINE G3RAIN(IDO,IGO,ILOST)  
C	RAIN BLOCK  
C	CALLED BY RAIN NEAR LINES 440 AND 465  
C	  
C#######################################################################  
C     This program reads a user defined time series.  
C     Updated 2/93 by WCH to correct hour values for user-supplied data.  
C     Updated 11/12/93 by WCH to allow for hours to range from 1 - 24.  
C     Updated 10/25/94 by WCH to allow YEAR and NEWYR to be read as  
C       either 19XX or XX.  Program uses two-digit form.  
C     Updated 8/1/95 by WCH to change station ID to character after  
C       input for IFORM = 3.  
C     WCH, 8/1/95.  Make changes for character station ID.  No longer  
C       compare requested ID with ID on data lines, to avoid character  
C       comparison complications.  
C     WCH, 10/2/96. Add new error message for READ(IO).  
C     WCH, 12/3/96. Remove unused statement number 777.  Backspace IO  
C       after reading first record of next year, to avoid missing that  
C       record when returning to G3RAIN.  
C#######################################################################  
C     IFORM = 3 MEANS USER DEFINED FORMAT  
C     IDO   = 0 SEARCH FOR STATION NUMBER  
C     IDO   = 1 READ STATION RAINFALL  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'PRECIP.INC'  
C#### WCH, 8/1/95.  CHANGE STATION ID TO CHARACTER.  
C####      INTEGER DAY,YEAR,STA,FF(6),XRAIN(24)  
      INTEGER DAY,YEAR,FF(6),XRAIN(24)  
      CHARACTER*8 IBUF, STA  
	character text(80)  
C=======================================================================  
C     First find the correct rainfall station (IDO = 0)  
C=======================================================================  
      IF(IDO.EQ.0)   THEN  
C#### WCH, 8/1/95.  
      IPRINT = 0  
C=======================================================================  
      IF(F1.GT.0) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
C#### 5              READ(IO,FIRMAT,ERR=5,END=40) (FF(I),I=1,6)  
5              READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) (FF(I),I=1,6)  
C#### WCH, 8/1/95.  CONVERT STATION ID TO CHARACTER.  
C####               IBUF   = FF(F1)  
               WRITE(IBUF,'(I8)') FF(F1)  
C  
               NEWYR  = FF(F2)  
C#### WCH, 10/25/94.  
c               IF(NEWYR.GT.1900) NEWYR = NEWYR - 1900  
                IF(NEWYR.LT.100)  NEWYR = NEWYR + 1900  
               NEWMON = FF(F3)  
               NEWDAY = FF(F4)  
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY.  
C####               IF(IBUF.NE.ISTA) GO TO 5  
               IF(IPRINT.EQ.0) THEN  
                    WRITE(N6,990) IBUF,ISTA  
                    WRITE(*,990) IBUF,ISTA  
                    IPRINT = 1  
                    ENDIF  
C  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 5  
               IF(NEWMON.LT.IYBEG(2).AND.  
     +                            NEWYR.EQ.IYBEG(1))    GO TO 5  
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3)  
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 5  
CC$$$$$5/3/92  
                  BACKSPACE IO  
               ENDIF  
C=======================================================================  
      IF(F1.EQ.0) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
6              READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS) (FF(I),I=1,5)  
               NEWYR  = FF(F2)  
C#### WCH, 10/25/94.  
c               IF(NEWYR.GT.1900) NEWYR = NEWYR - 1900  
                IF(NEWYR.LT.100)  NEWYR = NEWYR + 1900  
               NEWMON = FF(F3)  
               NEWDAY = FF(F4)  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 6  
               IF(NEWMON.LT.IYBEG(2).AND.  
     +                            NEWYR.EQ.IYBEG(1))    GO TO 6  
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3)  
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 6  
CC$$$$$5/3/92  
                   BACKSPACE IO  
               ENDIF  
C=======================================================================  
      ENDIF  
C=======================================================================  
C====> End of IDO = 0 (Executed only once).  
C=======================================================================  
C     Read the rainfall values (IDO = 1)  
C=======================================================================  
C     CLEAR THIS YEAR'S MATRIX  
C     BACKSPACE FOR A NEW YEAR OR NEW STATION  
C     COMPUTE STARTING DAY NUMBER FOR THIS YEAR  
C=======================================================================  
      IF(IDO.EQ.1) THEN  
      CALL SETIA(HOUR,366,27,0)  
cim 11/07 update LIMRN values  
c      CALL SETIA(RDAY,3000,1,0)  
      CALL SETIA(RDAY,LIMRN,1,0)  
      ILOST  = 1  
      NSTORM = 0  
      IDAST  = KDATE(0,1,NEWYR)  
C=======================================================================  
C     Read this year's rainfall.  
C=======================================================================  
C     Read Rainfall and station number > 0 for a  
C             User defined time series.  
C=======================================================================  
   10 CONTINUE  
      IF(NUVAL.EQ.1) THEN  
           IF(F1.GT.0.AND.F7.EQ.7) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
                     READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS)  
     1                   (FF(I),I=1,6),REIN  
                     IF(REIN.NE.0.0) THEN  
C#### WCH, 8/1/95.  CONVERT STATION ID TO CHARACTER.  
C####                      STA   = FF(F1)  
                          WRITE(STA,'(I8)') FF(F1)  
C  
                          YEAR  = FF(F2)  
C#### WCH, 10/25/94.  
c                         IF(YEAR.GT.1900) YEAR = YEAR - 1900  
                          IF(YEAR.LT.100) YEAR = YEAR + 1900  
                          MONTH = FF(F3)  
                          DAY   = FF(F4)  
                          REIN  = REIN*CONV  
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR  
                          IHR   = FF(F5)  
                          MINU  = FF(F6)  
                          IF(METRIC.EQ.1) THEN  
                               IRAIN = IFIX(REIN*1000.0+0.1)  
                               ELSE  
                               IRAIN = IFIX(REIN*100.0+0.1)  
                               ENDIF  
                          ELSE  
                          GO TO 10  
                          ENDIF  
                     ENDIF  
C=======================================================================  
C     Read rainfall and station number > 0 for a  
C       user-defined time series.  
C=======================================================================  
           IF(F1.GT.0.AND.F7.EQ.1) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
                READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS)  
     1              REIN,(FF(I),I=1,6)  
                IF(REIN.NE.0.0) THEN  
C#### WCH, 8/1/95.  CONVERT STATION ID TO CHARACTER.  
C####                      STA   = FF(F1)  
                          WRITE(STA,'(I8)') FF(F1)  
C  
                          YEAR  = FF(F2)  
C#### WCH, 10/25/94.  
c                         IF(YEAR.GT.1900) YEAR = YEAR - 1900  
                          IF(YEAR.LT.100)  YEAR = YEAR + 1900  
                          MONTH = FF(F3)  
                          DAY   = FF(F4)  
                          REIN  = REIN*CONV  
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR  
                          IHR   = FF(F5)  
                          MINU  = FF(F6)  
                          IF(METRIC.EQ.1) THEN  
                               IRAIN = IFIX(REIN*1000.0+0.1)  
                               ELSE  
                               IRAIN = IFIX(REIN*100.0+0.1)  
                               ENDIF  
                          ELSE  
                          GO TO 10  
                          ENDIF  
                     ENDIF  
C=======================================================================  
C     Read rainfall and station number = 0 for a  
C             user-defined time series.  
C=======================================================================  
           IF(F1.EQ.0.AND.F7.GE.6) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
                READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS)  
     1              (FF(I),I=1,5),REIN  
                IF(REIN.NE.0.0) THEN  
                     STA   = ISTA  
                     YEAR  = FF(F2)  
C#### WCH, 10/25/94.  
c                    IF(YEAR.GT.1900) YEAR = YEAR - 1900  
                     IF(YEAR.LT.100)  YEAR = YEAR + 1900  
                     MONTH = FF(F3)  
                     DAY   = FF(F4)  
                     REIN  = REIN*CONV  
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR  
                     IHR   = FF(F5)  
                     MINU  = FF(F6)  
                     IF(METRIC.EQ.1) THEN  
                               IRAIN = IFIX(REIN*1000.0+0.1)  
                               ELSE  
                               IRAIN = IFIX(REIN*100.0+0.1)  
                               ENDIF  
                     ELSE  
                     GO TO 10  
                     ENDIF  
                ENDIF  
C=======================================================================  
C     Read rainfall and station number = 0 for a  
C             user-defined time series.  
C=======================================================================  
           IF(F1.EQ.0.AND.F7.EQ.1) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
                READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS)  
     1              REIN,(FF(I),I=1,5)  
                IF(REIN.NE.0.0) THEN  
                     STA   = ISTA  
                     YEAR  = FF(F2)  
C#### WCH, 10/25/94.  
c                    IF(YEAR.GT.1900) YEAR = YEAR - 1900  
                     IF(YEAR.LT.100)  YEAR = YEAR + 1900  
                     MONTH = FF(F3)  
                     DAY   = FF(F4)  
                     REIN  = REIN*CONV  
C###### WCH 2/9/93 REMOVE IF STMT FOR IHR  
                     IHR   = FF(F5)  
                     MINU  = FF(F6)  
                     IF(METRIC.EQ.1) THEN  
                               IRAIN = IFIX(REIN*1000.0+0.1)  
                               ELSE  
                               IRAIN = IFIX(REIN*100.0+0.1)  
                               ENDIF  
                     ELSE  
                     GO TO 10  
                     ENDIF  
                ENDIF  
C=======================================================================  
           ENDIF  
C=======================================================================  
C     Read rainfall and station number for a user-defined time series.  
C=======================================================================  
      IF(NUVAL.GT.1) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
                     READ(IO,FIRMAT,ERR=970,END=40,IOSTAT=IOS)  
     1                   (FF(I),I=1,3),(XRAIN(K),K=1,NUVAL)  
                     STA   = ISTA  
                     YEAR  = FF(F2)  
C#### WCH, 10/25/94.  
c                    IF(YEAR.GT.1900) YEAR = YEAR - 1900  
                     IF(YEAR.LT.100)  YEAR = YEAR + 1900  
                     MONTH = FF(F3)  
                     DAY   = FF(F4)  
                     ENDIF  
C=======================================================================  
C     Check for same station.     Check for same year.  
C     Add to this year's matrix.  Find the day number and indicate  
C                                 unusual conditions.  
C     Hour =  -2 means meter stuck.  
C     Hour =  -1 means missing data.  
C=======================================================================  
C#### WCH, 8/1/95.  DON'T MAKE THIS CHECK ANYMORE.  
C####      IF(STA.NE.ISTA) GO TO 40  
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GE.IYEND(2)  
     *                   .AND.DAY.GT.IYEND(3))   GO TO 40  
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GT.IYEND(2))  
     *                                           GO TO 40  
      IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))     GO TO 40  
C=======================================================================  
C#### WCH, 12/3/96. NEED TO BACKSPACE IO, OTHERWISE MISS FIRST RECORD  
C     OF NEXT YEAR.  
C=======================================================================  
C####      IF(YEAR.GT.NEWYR)                          RETURN  
      IF(YEAR.GT.NEWYR) THEN  
           BACKSPACE IO  
           RETURN  
           ENDIF  
      IDAY = KDATE(DAY,MONTH,YEAR) - IDAST  
C=======================================================================  
C     User defined format for one value per line.  
C=======================================================================  
      IF(NUVAL.EQ.1) THEN  
                     NSTORM         = NSTORM     + 1  
C#######################################################################  
C  WCH 2/9/93  CAUTION. IHR USED AS SUBSCRIPT.  USER INPUTS  
C    FROM 0 TO 23, THUS ADD 1 FOR SUBSCRIPT FOR HOURS OF DAY.  
C#######################################################################  
C  WCH, 11/12/93.  ADD OPTION FOR IHR TO VARY FROM 1 - 24.  
C#######################################################################  
                     IF(IHH.EQ.0.AND.IHR.GE.24) THEN  
                        WRITE(N6,9050) IHR,YEAR,MONTH,DAY  
                        IHR = 23  
                        ENDIF  
                     IF(IHH.EQ.1) THEN  
                        IHR = IHR - 1  
                        IF(IHR.LT.0) THEN  
                           WRITE(N6,9060) IHR+1,YEAR,MONTH,DAY  
                           IHR = 1  
                           ENDIF  
                        ENDIF  
                     HOUR(IDAY,IHR+1) = IRAIN      + HOUR(IDAY,IHR+1)  
                     RTIME(NSTORM)  = FLOAT(IHR) + FLOAT(MINU)/60.0  
                     RRAIN(NSTORM)  = IRAIN  
                     RDAY(NSTORM)   = IDAY  
c                    write(*,*) nstorm,rday(nstorm),rtime(nstorm)  
cim change from EQ to GE 11/97  
                     IF(NSTORM.GE.LIMRN) THEN  
                                         WRITE(N6,9000) LIMRN  
                                         GO TO 40  
                                         ENDIF  
                     ENDIF  
C=======================================================================  
C     User defined format for multiple values per line.  
C=======================================================================  
      IF(NUVAL.GT.1) THEN  
                     DO 7000     J  = 1,24  
                     IF(XRAIN(J).EQ.0.0) GO TO 7000  
                     IF(METRIC.EQ.1) THEN  
                               IRAIN = 10 * XRAIN(J)  
                               ELSE  
                               IRAIN =      XRAIN(J)  
                               ENDIF  
                     HOUR(IDAY,J)   = IRAIN  
                     NSTORM         = NSTORM     + 1  
                     RTIME(NSTORM)  = J  
                     RRAIN(NSTORM)  = IRAIN  
                     RDAY(NSTORM)   = IDAY  
cim include check and write for nstorm here also  
                     IF(NSTORM.GE.LIMRN) THEN  
                                         WRITE(N6,9000) LIMRN  
                                         GO TO 40  
                                         ENDIF  
 7000                CONTINUE  
                     ENDIF  
C=======================================================================  
C#### WCH, 12/3/96.  REMOVE UNUSED STATEMENT NUMBER 777.  
Cwch 2/3/03 error print  
      if(iday.lt.1.or.iday.gt.366) then   
	     write(n6,9876) iday,idast,year,  
     1     month,day,ihr,minu,rein  
Cwch, 8/27/03  
                		backspace io  
	                read(io,9123) text  
 9123 format(80a1)  
	                write(n6,9123) text  
	                endif  
 9876 format(/,' iday,idast,year,month,day,ihr,minu,rein ',7i8,f7.2)  
      HOUR(IDAY,25) = MONTH  
      HOUR(IDAY,26) =   DAY  
      HOUR(IDAY,27) =  YEAR  
      GO TO 10  
C=======================================================================  
C     End of loop for IF(IDO.EQ.1)  
C=======================================================================  
      ENDIF  
C=======================================================================  
C     Skip if the new station is not the station selected.  
C     Return if the new year is less than the selected ending year.  
C=======================================================================  
49    RETURN  
C=======================================================================  
C     Here if reach end of file or passed designated ending date.  
C=================================================================  
40    IGO = 1  
c  do this to ensure that all rainfall on interface is written  
      IF (NSTORM.LT.LIMRN) NSTORM = NSTORM + 1  
      RDAY(NSTORM) = 999999  
c  
      RETURN  
C=======================================================================  
C#### WCH, 10/2/96.  NEW ERROR MESSAGE FOR READ(IO) ERRORS.  
C=======================================================================  
  970 WRITE(N6,9700) IO,MOD(IOS,256),FF  
      WRITE(*,9700) IO,MOD(IOS,256),FF  
      STOP 'Run stopped from Sub. G3RAIN.'  
C=======================================================================  
C#### WCH, 8/1/95.  NEW FORMAT STATEMENT 990.  
  990 FORMAT(/,' STATION ID ON PRECIP. DATA INPUT FILE = ',A8,/,  
     1' REQUESTED STATION ID = ',A8,' CHECK TO BE SURE THEY MATCH.',/)  
 9000 FORMAT(/,' Error ==> Limit of ',I6,  
     +         ' precipitation values exceeded for this year.')  
C#### WCH, 11/12/93  
 9050 FORMAT(' WARNING VALUE OF IHOUR =',I3,' AND IS .GE. 24.',  
     1 ' HOURS SHOULD RUN FROM 0 (MIDNIGHT) TO 23.',/,  
     2' VALUE RESET TO 23, YEAR = ',I4,', MONTH =',I3,', DAY =',I3)  
 9060 FORMAT(' WARNING$$ VALUE OF IHOUR =',I3,' AND SHOULD NOT BE LESS T  
     1HAN 1 FOR HOUR-OPTION YOU HAVE CHOSEN.',/,' (HOURS GO FROM 1-24)',  
     2'  VALUE RESET TO 1.  YEAR = ',I4,', MONTH =',I3,', DAY =',I3)  
C#### WCH, 10/2/96.  
 9700 FORMAT(/,' ERROR DURING READ OF UNIT',I3,/,  
     1 ' COMPAQ DIGITAL FORTRAN ERROR NUMBER =',I5,/,  
     2 ' CURRENT VALUES OF ARRAY FF(1-6): ',6I8)  
C=======================================================================  
      END  
ECHO is off.
REM File: GAMP.FOR  
ECHO is off.
      SUBROUTINE GAMP(SUCT,SMD,SMDMAX,IFLAG,FU,F,HYDCON,WDEPTH,  
     1           TR,DELT,TIME,RI,RLOSS,UL,SVAP,KAMEW,NAMEW,FLOW2P)  
C     RUNOFF BLOCK  
C     CALLED BY WSHED NEAR LINE 300  
C=======================================================================  
C     Green-Ampt infiltration routine,  written FEB 1979 by R.G.MEIN.  
C  
C     Theory as given in Mein & Larson, Water Resources Research,  
C                                       Vol. 9, NO. 2, 384-394, 1973  
C=======================================================================  
C     Redistribution rate depends on soil hydraulic conductivity  
C     and is considered only for the surface region.  
C#######################################################################  
C     WCH (CDM), 10/5/93.  CHANGE EVAP TO SVAP FOR CONSISTENCY, 5   
C       LOCATIONS.  
C     WCH, 4/5/00. Declare TIME as double precision to match delcarion   
C       in TIMER.INC..  
C     WCH, 12/20/00.  Add rerouted overland flow to rain-evap calc.   
C     WCH, 4/11/02. Correct use of RI to R1 in several places, to   
C       account for rerouted overland flow.   
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      DOUBLE PRECISION RI,RLOSS,SVAP,TIME  
      CHARACTER KAMEW*10  
C=======================================================================  
C     Statement function for Green-Ampt equation.  
C=======================================================================  
      F22(X) = X-(X-F-C1*ALOG(X+C1)+C2)/(1.0-C1/(X+C1))  
C=======================================================================  
      C1    = SUCT*SMD  
      TBS   = 6.0  
Cwch, 12/20/00. Add rerouted water from impervious areas.  
Cwch, 4/11/02.  Add standing water to potential infiltration,   
C     as in HORTON.  
      R1    = RI - SVAP + FLOW2P + WDEPTH/DELT  
      FUMAX = UL*SMDMAX  
      RVOL  = R1*DELT   
C=======================================================================  
C     Check for surface saturation.  
C=======================================================================  
      IF(IFLAG.EQ.1)   GO TO 200  
C=======================================================================  
C     Surface unsaturated at the beginning of the time step.  
C=======================================================================  
      TR = TR - DELT  
C=======================================================================  
C     Evaporation depletes any rainfall or standing water.  
Cwch, 4/11/02. Set RLOSS = total water available for loss.  
C=======================================================================  
      IF(R1.LE.0.0) THEN  
                    RLOSS = RI + FLOW2P + WDEPTH/DELT  
                    IF(FU.LE.0.0) RETURN  
C=======================================================================  
C                   Deplete soil moisture during dry period.  
C=======================================================================  
                    DF  = UL*DELT/90000.  
                    DEP = DF*FUMAX  
                    F   = F  - DEP  
                    FU  = FU - DEP  
                    IF(FU.LE.0.0) THEN  
                                  FU  = 0.0  
                                  F   = 0.0  
                                  SMD = SMDMAX  
                                  RETURN  
                                  ENDIF  
C=======================================================================  
C                   If sufficient time elapsed since rain, redistribute.  
C=======================================================================  
                    IF(TR.LE.0.0) THEN  
                                  SMD = (FUMAX-FU)/UL  
                                  F   = 0.0  
                                  ENDIF  
                    RETURN  
                    ENDIF  
C=======================================================================  
C     Low intensity, all infiltrates.  Rain intensity > 0.0  
C=======================================================================  
      IF(R1.LE.HYDCON) THEN  
                       FU = FU + RVOL  
                       IF(FU.GT.FUMAX) FU = FUMAX  
                       F                  = F + RVOL  
Cwch, 4/11/02. Loss should be R1 plus evap, not RI.   
                       RLOSS              = R1 + SVAP  
                       IF(TR.LE.0.0) THEN  
                                     SMD = (FUMAX-FU)/UL  
                                     F   = 0.0  
                                     ENDIF  
                       RETURN  
                       ENDIF  
C=======================================================================  
C     Rain (minus evap) intensity > Hyd. conductivity.  
C=======================================================================  
      TR = 900.0*TBS/UL  
      FS = HYDCON*C1/(R1-HYDCON)-F  
C=======================================================================  
C     Soil still wet from last rain, surface saturates.  
C=======================================================================  
      IF(FS.LE.0.0) THEN  
                    IFLAG = 1  
                    GO TO 200  
                    ENDIF  
C=======================================================================  
C     All water infiltrates.  
C=======================================================================  
      IF(FS.GE.RVOL) THEN  
Cwch, 4/11/02. Loss should be R1 plus evap, not RI.   
                     RLOSS = R1 + SVAP  
                     F     = F  + RVOL  
                     FU    = FU + RVOL  
                     IF(FU.GT.FUMAX) FU = FUMAX  
                     RETURN  
                     ENDIF  
C=======================================================================  
C     Surface saturates during interval.  
C=======================================================================  
      F  = F + FS  
      TS = FS/R1  
      C2 = C1*ALOG(F+C1)-HYDCON*(DELT-TS)  
      GO TO 300  
C=======================================================================  
C     Surface is saturated, so compute vol of potential infiltration.  
C=======================================================================  
  200 TR = 900.0*TBS/UL  
      TS = 0.0  
      IF(C1.LE.0.0) THEN  
                    F2 = HYDCON*DELT+F  
                    ELSE  
                    C2 = C1*ALOG(F+C1) - HYDCON*DELT  
                    GO TO 300  
                    ENDIF  
C=======================================================================  
C     Excess water at surface.  Corrected December, 1990.  
Cwch 4/11/02. RVOL includes WDEPTH.  Should not add here.  
C=======================================================================  
C  210 IF((F2-F).LE.(WDEPTH+RVOL)) THEN  
  210 IF((F2-F).LE.RVOL) THEN  
                                  RLOSS = (F2-F)/DELT + SVAP  
                                  FU    = F2 - F      + FU  
                                  F     = F2  
C---- old code                    FU    = F2  
                                  IF(FU.GT.FUMAX) FU = FUMAX  
                                  RETURN  
C=======================================================================  
C     Rain+surface water infiltrates.  Corrected December, 1990.  
C=======================================================================  
                                  ELSE  
Cwch, 4/11/02. Loss should be R1 + evap. R1 includes all available water.   
C                                  RLOSS = WDEPTH/DELT + RI  
                                  RLOSS = R1 + SVAP  
                                  F     = F  + AMAX1(WDEPTH+RVOL,0.0)  
                                  IFLAG = 0  
                                  FU    = FU + AMAX1(WDEPTH+RVOL,0.0)  
C--- old code                     FU    = F  
                                  IF(FU.GT.FUMAX) FU = FUMAX  
                                  RETURN  
                                  ENDIF  
C=======================================================================  
C     Newton-Raphson iteration to solve for infiltration volume.  
C=======================================================================  
  300 F21      = F  
      DO 310 I = 1,11  
      F2       = F22(F21)  
      IF(ABS(F2-F21).LT.0.0001)   GO TO 320  
      F21      = F2  
  310 CONTINUE  
C=======================================================================  
C     No convergence.  
C=======================================================================  
      F2 = F + (DELT-TS)*R1/2.0  
      IF(JCE.EQ.0) WRITE(N6,315) NAMEW,TIME,IFLAG,SMD,F,R1  
      IF(JCE.EQ.1) WRITE(N6,316) KAMEW,TIME,IFLAG,SMD,F,R1  
C=======================================================================  
C     Convergence, return to call point.  
C=======================================================================  
  320 IF(IFLAG.EQ.0) THEN  
                     RLOSS = (F2 - F + FS)/DELT + SVAP  
                     FU    = F2 - F  + FU  
                     F     = F2  
                     IFLAG = 1  
C--- old code        FU    = F2  
                     IF(FU.GT.FUMAX) FU = FUMAX  
                     RETURN  
                     ENDIF  
      GO TO 210  
C=======================================================================  
315   FORMAT(' ===>  Warning, No convergence of Green-Ampt equation. F  
     1or subcat. input # ',I10,' Time =',F9.0,' seconds',/,  
     2 ' IFLAG =',I2,' SMD =',F6.4,' F(ft) =',F7.4,' Rain-Evap(ft/s) =',  
     3 E12.5,' ===>  Assume infil. vol. = half of rain-evap.')  
316   FORMAT(' ===>  Warning, No convergence of Green-Ampt equation. F  
     1or subcat. input name  ',A10,' Time =',F9.0,' seconds',/,  
     2 ' IFLAG =',I2,' SMD =',F6.4,' F(ft) =',F7.4,' Rain-Evap(ft/s) =',  
     3 E12.5,' ===>  Assume infil. vol. = half of rain-evap.')  
C=======================================================================  
      END  
  
ECHO is off.
REM File: GETCUR.FOR  
ECHO is off.
      SUBROUTINE GETCUR(JNO,XFROM,SLOPE,METRIC,KNORM,KCOND,  
cim 3/99 use length on C1 line.  
c     +      AFULL,DEEP,TWFULL,XLEN,RN0,RFULL,NSTOP,IDNUM,KDNUM,KSTOP)  
     +      AFULL,DEEP,TWFULL,XLENIN,RN0,RFULL,NSTOP,IDNUM,KDNUM,KSTOP)  
C     TRANSPORT AND EXTRAN BLOCK  
C=======================================================================  
C     THIS ROUTINE READS THE INPUT FILE AND FINDS  
C     FLOW/COEF CURVES FOR SECTIONS SPECIFIED IN EXTRAN OR TRANSPORT.  
C     A.C. ROWNEY JUNE 1986, UPDATED J. E. SWANSON MARCH 1987  
C     MODIFIED BY R. E. DICKINSON JANUARY, 1988, MAY, 1989.  
C     MODIFIED BY WAYNE C. HUBER, HALLOWEEN, 1991 and August 1992.  
C     MODIFIED BY WCH, 2/24/93 TO CORRECT HYDRAULIC RADIUS CALCULATION  
C      FOR VERTICAL CROSS SECTIONS, AS PER HINTS FROM CHUCK MOORE AT CDM.  
C     MODIFIED BY RED, 6/2/93 FOR USE WITH TRANSPORT BLOCK.  
C     MODIFIED BY WCH (RED), 9/23/93 TO MULTIPLY STCHL ETC. BY PXSECR.  
C     MODIFIED BY WCH, 11/30/93.  IF ROUGHNESS TRANSITION OCCURS EXACTLY  
C      AT VERTICAL SECTION, ASSUME VERTICAL WALL SHOULD HAVE MAIN  
C      CHANNEL ROUGHNESS.  CHANGE IF STATEMENT TO STRICTLY LT AND GT.  
C     MODIFIED BY WCH, 8/25/94.  ANOTHER CORRECTION FOR CASE WHEN  
C      VERTICAL WALL OCCURS AT ROUGHNESS TRANSITION.  
C     RED, 12/16/94.  CORRECTION FOR POWER FUNCTION CHANNELS FOR  
C      INTERMEDIATE SLICE (2-26) AREA CALCULATIONS.  
C     WCH, 2/7/95.  OPTION TO INCREASE NUMBER OF ALLOWABLE CROSS SECTION  
c      POINTS WITH PARAMETER STATEMENT.  LEAVE AT 100 FOR NOW.  
C     CIM, 9/8/00.  Major changes for option of adding additional  
C                   detail for irregular sections in TRANSPORT.  
C                   Move some of calculations to new subroutine IRRSECT.  
C                   Modified check for STCHL and STCHR.  
C     WCH, 7/6/01.  Need top width for new Transport quality calcs.  
C                   Create new QCURVE(NATUR,4,I) array to store  
C                   normalized flows for Transport and use same  
C                   QCURVE(NATUR,3,I) array for top width for both  
C                   Extran and Transport.    
C     WCH, 3/14/02. Add metric fixes for calling from Transport.    
C     WCH, 3/15/02. Check for zero value of XFROM.  
C     WCH, 4/16/02. Allow default for zero SLOPE.  
C     WCH (CIM), 7/20/04. Fix format variable KK for Transport   
C                   output table.   
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'FLODAT.INC'  
      INCLUDE 'BALINES.INC'  
CIM### 9/9/00 New common block  
      INCLUDE 'NEWTR.INC'  
      CHARACTER KDNUM*10  
C#### WCH, 2/7/95.  INCREASE DIMENSION FROM 100 TO 300.  
C  IF CHANGED, CHANGE IN CHECKSTCH AND IRRSECT ALSO  
      PARAMETER (NXSPTS=100)  
      DIMENSION ELSTA(2,NXSPTS)  
      LOGICAL GOTOO,FAILED,OKL,OKR  
C=======================================================================  
C     JNO      = CONDUIT INPUT ORDER NUMBER FROM EXTRAN OR TRANSPORT  
C     XFROM    = CROSS SECTION IDENTIFICATION NUMBER,OR  
C                POWER FUNCTION EXPONENT  
C     SLOPE    = AVERAGE CHANNEL SLOPE  
C     METRIC   = US CUSTOMARY OR METRIC UNITS  
C     KNORM    = IF 0 - CALLED FROM EXTRAN, IF 1 - CALLED FROM TRANSPORT  
C     KCOND    = IF 0 - READ NATURAL CROSS SECTIONS  
C     KCOND    = IF 1 - CREATE POWER FUNCTION CHANNELS  
C     AFULL    = AREA WHEN CONDUIT IS FULL  
C     DEEP     = MAXIMUM DEPTH  
C     TWFULL   = TOP WIDTH WHEN CONDUIT IS FULL  
C     XLEN     = CONDUIT LENGTH  
C     RN0      = CHANNEL MANNING'S N  
C     RFULL    = HYDRAULIC RADIUS WHEN CONDUIT IS FULL  
C     NSTOP    = NUMBER OF ERRORS  
C     IDNUM    = CONDUIT NUMBER  
C     KDNUM    = CONDUIT NAME  
C     KSTOP    = 0.... PRINT NORMALIZED CURVES  
C     KSTOP    = 1.... DO NOT PRINT NORMALIZED CURVES  
C     NATUR    = NUMBER (SEQUENCE NO.) OF NATURAL CHANNEL AND/OR OF  
C                POWER FUNCTION CHANNEL. PASSED IN FLODAT.INC.   
C=======================================================================  
C     EXTRAN USES EITHER U.S. CUSTOMARY OR METRIC UNITS INTERNALLY.  
C     TRANSPORT USES U.S. CUSTOMARY UNITS INTERNALLY.  BUT TRANSPORT  
C     USES METRIC UNITS WITHIN GETCUR FOR NATURAL SECTIONS, IF METRIC=2.  
C=======================================================================  
      IF(KNORM.EQ.0) KMET = METRIC  
      IF(KNORM.EQ.1) KMET = 1  
C=======================================================================  
C     INITIALIZE AS REQUIRED  
C=======================================================================  
      NQC(JNO)            = NATUR  
      GOTOO               = .FALSE.  
      FAILED              = .FALSE.  
      NUMST               = 0  
      NUMQ(NATUR)         = 26  
      PXSECR              = 1.0  
      POW                 = XFROM  
      QCURVE(NATUR,1,1)   = 0.0  
      QCURVE(NATUR,2,1)   = 0.0  
      QCURVE(NATUR,3,1)   = 0.0  
Cwch, 7/6/01  
      QCURVE(NATUR,4,1)   = 0.0  
      IF(KCOND.EQ.0) XLEN = 0.0  
Cwch, 4/16/02. Does it matter if slope is zero since it's only used  
C     to develop a rating curve?  Try allowing a default of 0.01.  
      IF(KCOND.EQ.0.AND.SLOPE.LE.0.0) THEN  
                                      IF(JCE.EQ.0) WRITE(N6,9600) IDNUM  
                                      IF(JCE.EQ.1) WRITE(N6,9601) KDNUM  
	                                SLOPE = 0.01  
C                                      STOP  
                                      ENDIF  
      RTSLOP              = SQRT(SLOPE)  
      IF(KNORM.EQ.1.AND.KCOND.EQ.0) TWFULL = 0.0  
C=======================================================================  
C FOR POWER FUNCTION CHANNELS, GO RIGHT TO CALCULATIONS.  
C=======================================================================  
      IF(KCOND.EQ.1) GO TO 6666  
C=======================================================================  
C READ CARDS. WHEN NC OR GR CARD IS ENCOUNTERED, INCORPORATE VALUES.  
C             WHEN X1 CARD IS ENCOUNTERED, CHECK IF NAME IS RIGHT.  
C             IF X1 CARD IS OKAY, USE IT. IF NOT, FORGET IT.  
C=======================================================================  
C     READ THE CROSS-SECTION DATA  
C=======================================================================  
C REDUCE LENGTH OF DO LOOP FROM 100000 TO 2200, WCH, 8/28/92  
C#######################################################################  
Cwch, 3/115/02 Follow CIM suggestion re. checking for zero XFROM.  
	IF(XFROM.EQ.0) THEN  
	     WRITE (N6,9005) JNO  
	     WRITE(*,9005)   JNO  
	     NSTOP = NSTOP + 1  
	     ENDIF  
      DO 300 KREAD = 1,2200  
      READ(N5,*,ERR=888,END=9000) CC  
cimbridges  
      IF(CC.EQ.'D1') then  
cimbridges   additional time saving error check  
      write(n6,*) 'ERROR - Cross-section ',XFROM,' was not found'  
      write(n6,*) '        Input data may be missing from',  
     a' cross-section data.'  
      write(n6,*) '        More likely cause is the order of sections',  
     a'        in cross-section cards is not the same as they appear ',  
     b'in the C1 cards.'  
      stop 'Cross-section card not found'  
      endif  
      IF(CC.EQ.'NC'.OR.CC.EQ.'C2'.OR.CC.EQ.'E2') THEN  
           BACKSPACE N5  
           READ(N5,*,ERR=888) CC,XNL,XNR,XNCH  
           IF(XNCH.LE.0.0) WRITE(N6,201)  
           ENDIF  
      RN0 = XNCH  
      IF(XNCH.LE.0.0) WRITE(N6,201)  
      IF(CC.EQ.'X1'.OR.CC.EQ.'C3'.OR.CC.EQ.'E3') THEN  
           BACKSPACE N5  
           READ(N5,*,ERR=888) CC,SECNO,NUMST,STCHL,STCHR,  
     +                                 XLOBL,XLOBR,XLEN,PX,PSXECE  
           IF(SECNO.EQ.XFROM) THEN  
                              GOTOO                = .TRUE.  
                              IF(PX.NE.0.0) PXSECR =  PX  
                              ENDIF  
           ENDIF  
C  
      IF(CC.EQ.'GR'.OR.CC.EQ.'C4'.OR.CC.EQ.'E4'.AND.NUMST.NE.0) THEN  
           BACKSPACE N5  
           DO 210 II = 1,NUMST,5  
           IEND = II + 4  
           IF(IEND.GT.NUMST) IEND = NUMST  
           READ(N5,*,ERR=888) CC,((ELSTA(K,I),K=1,2),I=II,IEND)  
  210      CONTINUE  
cim 9/8/00  check that at least one station matches STCHL and STCHR  
      CALL CHECKSTCH(ELSTA,STCHL,NUMST,'STCHL')  
      CALL CHECKSTCH(ELSTA,STCHR,NUMST,'STCHR')  
C=======================================================================  
C WCH MODIFICATION  
C ALLOW ONLY ONE SET OF C3-C4 LINES, IF DESIRED.  
C BACKSPACE THE NUMBER OF LINES REQUIRED.  
C NREQ = NUMBER OF C4 LINES PLUS ONE C3 LINE.  
C=======================================================================  
C NEW CORRECTION, 8/92, WCH.  BACKSPACE ONLY IF USING  
C  DESIRED C3-C4 LINES.  
C=======================================================================  
          IF(GOTOO) THEN  
                    NREQ = NUMST/5  
                    IF(NREQ*5.LT.NUMST) NREQ = NREQ + 1  
                    NREQ = NREQ + 1  
                    DO 240 J = 1,NREQ  
  240               BACKSPACE N5  
                    ENDIF  
          IF(GOTOO) GO TO 1200  
          ENDIF  
  300 CONTINUE  
C#######################################################################  
C IF ARRIVE HERE, HAVEN'T BEEN ABLE TO FIND MATCH FOR NATURAL CHANNEL.  
C WRITE ERROR MESSAGE.  WCH, 8/28/92  
C#######################################################################  
      WRITE(N6,9040) XFROM, SECNO  
      NSTOP = NSTOP+1  
      RETURN  
C=======================================================================  
C     IRREGULAR CHANNEL CALCS FOR EXTRAN OR TRANSPORT CHANNEL ROUTING.  
C                       TRANSPORT IS NORMALIZED BY AREA.  
C                       EXTRAN IS NORMALIZED BY DEPTH.  
C=======================================================================  
C     MODIFY BY FACTORS ON X1 LINE  
C=======================================================================  
 1200 CONTINUE  
      IF(PXSECR.NE.1.0.OR.PSXECE.NE.0.0) THEN  
                                         DO 1300 I  = 1,NUMST  
                                         ELSTA(2,I) = PXSECR*ELSTA(2,I)  
 1300                                    ELSTA(1,I) = PSXECE+ELSTA(1,I)  
C#### WCH (RED), 9/93.  
C#### RED (WCH), 12/31/93.  SHOULD BE PXSECR, NOT PSXECR  
                                         STCHL      = PXSECR*STCHL  
                                         STCHR      = PXSECR*STCHR  
                                         ENDIF  
C=======================================================================  
C     ALL REQUIRED DATA IN PLACE. CREATE CURVES AS REQUIRED.  
C     DUMMY OUT OVERBANK ROUGHNESS IF IT WAS NOT SPECIFIED.  
C=======================================================================  
      IF(XNR.EQ.0.0) XNR = XNCH  
      IF(XNL.EQ.0.0) XNL = XNCH  
C=======================================================================  
C     FIND MIN AND MAX STAGE POINTS.  
C     CHECK IF STATIONS ARE IN THE WRONG ORDER.  
C=======================================================================  
      ELMIN =  99999.0  
      ELMAX = -99999.0  
      DO 1400 I = 1,NUMST  
      IF(ELSTA(1,I).GT.ELMAX) ELMAX = ELSTA(1,I)  
      IF(ELSTA(1,I).LT.ELMIN) ELMIN = ELSTA(1,I)  
      IF(I.GT.1) THEN  
C#### WCH, 2/24/93.  MAKE ERROR CHECK SLIGHTLY MORE LIBERAL.  
              IF(ELSTA(2,I)-ELSTA(2,I-1).LT.-0.001) FAILED=.TRUE.  
              IF(FAILED) GO TO 9020  
              ENDIF  
 1400 CONTINUE  
C=======================================================================  
C     ESTABLISH RANGE ON CURVES.  
C=======================================================================  
      IF(DEEP.LE.0.0)         DEEP = ELMAX - ELMIN  
      IF(DEEP.GT.ELMAX-ELMIN) DEEP = ELMAX - ELMIN  
      WIDE        = ELSTA(2,NUMST)-ELSTA(2,1)  
      ELDEL       = DEEP/25.0  
cim### 9/8/00 change for transport  detailed output  
      ELEVN        = ELMAX  
C=======================================================================  
C     DO A FEW BASIC CHECKS.  
C=======================================================================  
      IF(XNCH.EQ.0.0) THEN  
                      WRITE(N6,1405)  
                      NSTOP = NSTOP + 1  
                      RETURN  
                      ENDIF  
CIM Change code here to check length against  
CIM length on C1 lines.  Adopt convention that  
CIM length on C1 line should be used.  For now  
CIM stop program run if it doesn't  
c      IF(XLEN.EQ.0.0) THEN  
c                      WRITE(N6,1406)  
c                      NSTOP = NSTOP + 1  
c                      RETURN  
c                      ENDIF  
C=======================================================================  
Cwch 3/14/02.Must worry about metric or not when calling from Transport.  
C     Error found by Sandy Elliot.   
C=======================================================================  
      CMETGET = 1.0  
	IF(KNORM.EQ.1.) CMETGET = CMET(1,METRIC)  
      IF(ABS((XLEN-XLENIN/CMETGET)/XLEN).GT.0.01) THEN  
          IF (KNORM.EQ.0) THEN  
C This is EXTRAN  
             SELECT CASE (IWLEN)  
               CASE (0)  
                 WRITE(N6,7020) XLENIN, XLEN  
                 nstop = nstop + 1  
               CASE (1)  
                 WRITE(N6,7040) XLENIN, XLEN  
                 XLENIN = XLEN  
               CASE (2)  
                 WRITE(N6,7050) XLENIN, XLEN  
             END SELECT  
             ELSE  
C This is TRANSPORT  
Cwch, 3/14/02  
             WRITE(N6,7030) XLENIN/CMETGET, XLEN  
             nstop = nstop + 1  
             ENDIF  
          endif  
      IF(WIDE.EQ.0.0) THEN  
                      WRITE(N6,1407)  
                      NSTOP = NSTOP + 1  
                      RETURN  
                      ENDIF  
      IF(DEEP.EQ.0.0) THEN  
                      WRITE(N6,1408)  
                      NSTOP = NSTOP + 1  
                      RETURN  
                      ENDIF  
      IF(NUMST.LE.1)  THEN  
                      WRITE(N6,1409)  
                      NSTOP = NSTOP + 1  
                      RETURN  
                      ENDIF  
C=======================================================================  
C     FIND STAGES, TOTAL AREAS, FLOWS AND TOP WIDTHS FOR EACH STAGE.  
CIM### 9/8/00  MOVE MUCH OF CALCULATIONS TO SUBROUTINE IRRSECT  
C=======================================================================  
CIM  FIRST CALL FOR FULL CROSS SECTION  
Cwch, 3/14/02. No metric conversions have occured for Transport.  Hence,  
C     use full metric units in IRRSECT.  Use METRIC, not KMET as param.   
      CALL IRRSECT(0,ELDEL,ELMIN,KNORM,TWFULL,  
     .STCHL,STCHR,XNL,XNCH,XNR,NUMST,RTSLOP,METRIC,elsta)  
CIM DO BELOW ONLY IF IDETAIL equals 1  
      IF(IDETAIL.EQ.1) THEN  
CIM  SECOND CALL FOR SECTION BELOW 1/25 AFULL  
cim  linearly interpolate to find first guess for depth  
cim  corresponding to 1/25 afull  
           I = 1  
           AREAT = QCURVE(NATUR,2,26)/25.0  
1500       I = I + 1  
           IF (QCURVE(NATUR,2,I).LE.AREAT) GO TO 1500  
C      WRITE(N6,*) I,AREAT,QCURVE(NATUR,2,I),QCURVE(NATUR,2,I-1)  
           RATIO = (AREAT-QCURVE(NATUR,2,I-1))/  
     .                    (QCURVE(NATUR,2,I)-QCURVE(NATUR,2,I-1))  
           DEEP2 = ((I-2)+RATIO)*0.04*DEEP  
cim below iterate to find DEEP2 that matches target area within 0.05%  
           ERRMAX = 0.0005*AREAT  
           ERRMIN = AREAT  
           CLOSEST = 0.0  
           ICOUNT=0  
1505       CONTINUE  
           ELDEL = DEEP2/25.0  
C      WRITE(N6,*) RATIO,DEEP2,ELDEL  
           CALL IRRSECT(1,ELDEL,ELMIN,KNORM,TWFULL2,  
     .       STCHL,STCHR,XNL,XNCH,XNR,NUMST,RTSLOP,METRIC,ELSTA)  
CIM   may need to iterate until qcurv2(natur,2,26) = 1/25 afull  
           EDELTA = AREAT - QCURV2(NATUR,2,26)  
cim      write(n6,*) icount,DEEP2,areat,qcurv2(natur,2,26),edelta  
           IF ((ABS(EDELTA).GT.ERRMAX).AND.(ICOUNT.LT.100)) THEN  
              IF (ABS(EDELTA).LT.ERRMIN) THEN  
                 ERRMIN = ABS(EDELTA)  
                 CLOSEST = DEEP2  
                 ENDIF  
CIM   NEW GUESS FOR DEEP2  
              ICOUNT = ICOUNT + 1  
              IF (ICOUNT.GE.100) THEN  
                 DEEP2 = CLOSEST  
                 GO TO 1505  
                 ENDIF  
              IF (ICOUNT.EQ.1) THEN  
                 SLIPE = 0.0016/(QCURV2(NATUR,2,26)-QCURV2(NATUR,2,25))  
                 DEEP2OLD = DEEP2  
                 AREAOLD = QCURV2(NATUR,2,26)  
                 DEEP2 = DEEP2 + EDELTA*SLIPE  
                ELSE  
                 IF (QCURV2(NATUR,2,26).NE.AREAOLD)  
     .           SLIPE = (DEEP2-DEEP2OLD)/(qcurv2(natur,2,26)-AREAOLD)  
                 DEEP2OLD = DEEP2  
                 AREAOLD = QCURV2(NATUR,2,26)  
                  ENDIF  
              DEEP2 = DEEP2 + EDELTA*SLIPE  
              GO TO 1505  
              ENDIF  
           ENDIF  
CIM### 9/8/00 End of major changes.  
C=======================================================================  
C=======================================================================  
C     CALCULATE AREA, HYDRAULIC RADIUS, AND TOP WIDTH FOR  
C               POWER FUNCTION CROSS SECTIONS  
C=======================================================================  
C     POWER FUNCTION CHANNELS WILL HAVE SKIPPED NATURAL CROSS SECTION  
C       INPUT AND CALCS.  
C=======================================================================  
 6666 CONTINUE  
C=======================================================================  
C	When called from Transport, metric conversions have already   
C     occured.  Hence, even if METRIC = 2, internal calcs for power-  
C     function channels from Transport are in U.S. units.   
C=======================================================================  
      IF(KCOND.EQ.1) THEN  
           PEW        = 1.0/POW  
           DEPTH      = 0.0  
           DINC       = DEEP/25.0  
           WETPER     = 0.0  
           DO 2500 I  = 2,26  
           DEPTH      = DEPTH + DINC  
           CALL POWER(DEPTH,DEEP,TWFULL,WP,POW,DINC)  
           WETPER = WETPER + WP  
C#### WCH (RED), 12/16/94.  FIX INTERMEDIATE SLICE (2-26) CALCS FOR  
C     POWER FUNCTION CHANNELS.  
C     REMOVE TWFULL FROM AREA CALCULATIONS.  
C####           AREA   = TWFULL*DEPTH*(1.0 - 1.0/(1.0 + POW))  
           TWIDTH = TWFULL*DEPTH**PEW/DEEP**PEW  
C#### WCH (RED), 12/16/94.  ADD TWIDTH TO AREA CALCULATIONS.  
           AREA   = TWIDTH*DEPTH*(1.0 - 1.0/(1.0 + POW))  
CIM### 9/8/00 MOVE RADIUS CALC BELOW AREA CALC ???  
           RADIUS = AREA/WETPER  
           FLOW   = CMET(9,KMET)/RN0*RADIUS**0.666667*RTSLOP*AREA  
           QCURVE(NATUR,1,I) = RADIUS  
           QCURVE(NATUR,2,I) = AREA  
Cwch, 7/6/01. Use same array for top width and new array 4 for flow.  
Cwch           IF(KNORM.EQ.0) QCURVE(NATUR,3,I) = TWIDTH  
Cwch           IF(KNORM.EQ.1) QCURVE(NATUR,3,I) = FLOW  
           QCURVE(NATUR,3,I) = TWIDTH  
           IF(KNORM.EQ.1) QCURVE(NATUR,4,I) = FLOW  
 2500      CONTINUE  
CIM ### 9/8/00  
           IF(KNORM.EQ.1.AND.IDETAIL.EQ.1) THEN  
CIM  This is for added detail below 1/25 of full area  
cim  First find depth that corresponds to 1/25 afull  
              AREAT = QCURVE(NATUR,2,26)/25.0  
cim   solve directly for deep2 that corresponds to Areat  
              PEW        = 1.0/POW  
              DEEP2=((DEEP**PEW*AREAT)/(TWFULL*(1.0 - 1.0/(1.0 + POW))))  
     1          **(1.0/(1.0+PEW))  
              DINC2       = DEEP2/25.0  
              TWFULL2= TWFULL*DEEP2**PEW/DEEP**PEW  
cim           AREA   = TWFULL2*DEEP2*(1.0 - 1.0/(1.0 + POW))  
cim      WRITE(N6,*) deep2,areat,area  
              DEPTH      = 0.0  
              WETPER     = 0.0  
              DO 2550 I  = 2,26  
              DEPTH      = DEPTH + DINC2  
              CALL POWER(DEPTH,DEEP2,TWFULL2,WP,POW,DINC2)  
              WETPER = WETPER + WP  
C#### WCH (RED), 12/16/94.  FIX INTERMEDIATE SLICE (2-26) CALCS FOR  
C     POWER FUNCTION CHANNELS.  
C     REMOVE TWFULL FROM AREA CALCULATIONS.  
C####           AREA   = TWFULL*DEPTH*(1.0 - 1.0/(1.0 + POW))  
              TWIDTH = TWFULL2*DEPTH**PEW/DEEP2**PEW  
C#### WCH (RED), 12/16/94.  ADD TWIDTH TO AREA CALCULATIONS.  
              AREA   = TWIDTH*DEPTH*(1.0 - 1.0/(1.0 + POW))  
CIM MOVE RADIUS CALC BELOW AREA CALC.  
              RADIUS = AREA/WETPER  
C  
              FLOW   = CMET(9,KMET)/RN0*RADIUS**0.666667*RTSLOP*AREA  
              QCURV2(NATUR,1,I) = RADIUS  
              QCURV2(NATUR,2,I) = AREA  
              QCURV2(NATUR,3,I) = FLOW  
 2550         CONTINUE  
              ENDIF  
           ENDIF  
CIM### 9/8/00 End of changes for power function.  
C=======================================================================  
C     CALCULATE EQUIVALENT HYDRAULIC RADIUS,  
C     NORMALIZE CURVES, AND FIND MAX VALUES OF AREA AND EQUIV. HYD. RAD.  
C=======================================================================  
Cwch 4/14/02. For natural channels, Transport is working here in   
C     metric.  For power functions, Transport is working here in   
C     U.S. units.   
C=======================================================================  
      IF(KCOND.EQ.0) CONST  =  CMET(9,METRIC)/RN0*RTSLOP  
      IF(KCOND.EQ.1) CONST  =  CMET(9,KMET)/RN0*RTSLOP  
C=======================================================================  
C     Normalization process is independent of U.S. or metric units.   
C     QFULL, AFULL, RFULL etc. are passed to Transport in argument list  
C     of call statement.  For natural channels, convert from metric   
C     to U.S. customary units in Sub. INTRAN, right after call   
C     statement.  For power function channels, no conversion is needed  
C     in Sub. INTRAN.    
C=======================================================================  
      AFULL  =  QCURVE(NATUR,2,26)  
      IF(KNORM.EQ.0) QMAX   =  QCURVE(NATUR,1,26)  
Cwch, 7/6/01. Use new array 4, not 3, for Transport flow.   
      IF(KNORM.EQ.1) QMAX   =  QCURVE(NATUR,4,26)  
      IF(KCOND.EQ.0) RFULL  =  (QMAX/(AFULL*CONST))**1.5  
      IF(KCOND.EQ.1) RFULL  =  QCURVE(NATUR,1,26)  
Cwch, 7/6/01. Save TWFULL for Transport also.  
Cwch      IF(KNORM.EQ.0) TWFULL =  QCURVE(NATUR,3,26)  
      TWFULL =  QCURVE(NATUR,3,26)  
C  
      DO 1600 I = 2,26  
      IF(KCOND.EQ.1) QCURVE(NATUR,1,I) = QCURVE(NATUR,1,I)/RFULL  
      IF(KCOND.EQ.0) THEN  
C=======================================================================  
C NOTE THAT HERE FOR EXTRAN, QCURVE-1 IS CONVERTED FROM FLOW TO HYD RAD.  
Cwch, 7/6/01. For Transport, use QCURVE4 instead of 3.   
C=======================================================================  
           IF(KNORM.EQ.0) QCURVE(NATUR,1,I) =  
     +  ((QCURVE(NATUR,1,I)/(CONST*QCURVE(NATUR,2,I)))**1.5)/RFULL  
           IF(KNORM.EQ.1) QCURVE(NATUR,1,I) =  
     +  ((QCURVE(NATUR,4,I)/(CONST*QCURVE(NATUR,2,I)))**1.5)/RFULL  
           ENDIF  
      QCURVE(NATUR,2,I) = QCURVE(NATUR,2,I)/AFULL  
Cwch      IF(KNORM.EQ.0) QCURVE(NATUR,3,I) = QCURVE(NATUR,3,I)/TWFULL  
Cwch      IF(KNORM.EQ.1) QCURVE(NATUR,3,I) = QCURVE(NATUR,3,I)/QMAX  
      QCURVE(NATUR,3,I) = QCURVE(NATUR,3,I)/TWFULL  
      IF(KNORM.EQ.1) QCURVE(NATUR,4,I) = QCURVE(NATUR,4,I)/QMAX  
 1600 CONTINUE  
CIM### 9/8/00  
CIM   FOR ADDED DETAIL BELOW 1/25 AREA  
cim   NOTE THAT THIS IS NORMALIZED TO AFULL, QMAX, RFULL  
      IF (KNORM.EQ.1.AND.IDETAIL.EQ.1) THEN  
C  
         DO 1650 I = 2,26  
         IF(KCOND.EQ.1) QCURV2(NATUR,1,I) = QCURV2(NATUR,1,I)/RFULL  
         IF(KCOND.EQ.0) THEN  
C=======================================================================  
C NOTE THAT HERE FOR EXTRAN, QCURVE-1 IS CONVERTED FROM FLOW TO HYD RAD.  
C=======================================================================  
            QCURV2(NATUR,1,I) =  
     +  ((QCURV2(NATUR,3,I)/(CONST*QCURV2(NATUR,2,I)))**1.5)/RFULL  
            ENDIF  
         QCURV2(NATUR,2,I) = QCURV2(NATUR,2,I)/AFULL  
         QCURV2(NATUR,3,I) = QCURV2(NATUR,3,I)/QMAX  
 1650    CONTINUE  
         ENDIF  
C======================================================================  
C     CONVERT TO NORMALIZED AREA IF CALLED BY TRANSPORT  
CIM### 9/8/00   CALCULATIONS MOVED TO SUBROUTINE TRANNORM  
C======================================================================  
      IF(KNORM.EQ.1) THEN  
CIM  FIRST CALL FOR FULL SECTION  
           CALL TRANNORM(0,DEEP2,DEEP)  
CIM  SECOND CALL FOR SECTION BELOW 1/25 OF AFULL  
           IF (IDETAIL.EQ.1) THEN  
              CALL TRANNORM(1,DEEP2,DEEP)  
cim correct radius, depth, and q for qcurve(natur,*,2) for true,  
cim not interpolate, values at 0.04 afull.  
              QCURVE(NATUR,1,2) = QCURV2(NATUR,1,26)  
              QCURVE(NATUR,2,2) = QCURV2(NATUR,2,26)  
Cwch, 7/6/01              QCURVE(NATUR,3,2) = QCURV2(NATUR,3,26)  
              QCURVE(NATUR,4,2) = QCURV2(NATUR,3,26)  
              ENDIF  
           END IF  
C======================================================================  
C     PRINT CROSS SECTION OR CONDUIT INFORMATION FOR NATURAL CHANNELS.  
C     THE 100th IRREGULAR STATION POINT IS SET = 0 TO GIVE  
C     CORRECT OUTPUT IN PRINTING ROUTINE.  
C     These prints should be OK for both Extran and Transport since  
C     metric units have not been converted for Transport.    
C======================================================================  
      IF(KCOND.EQ.0) THEN  
           IF(JCE.EQ.0) WRITE(N6,1690) IDNUM  
           IF(JCE.EQ.1) WRITE(N6,1691) KDNUM  
           WRITE(N6,1696)  XFROM,NATUR  
           IF(METRIC.EQ.1) THEN  
                WRITE(N6,1700) XLEN,ELEVN,SLOPE,DEEP,  
     +                               XNL,STCHL,AFULL,XNCH,RFULL  
                WRITE(N6,1701) XNR,STCHR,TWFULL,QMAX  
                IF(KSTOP.EQ.0) WRITE(N6,1710) NUMST,PSXECE,PXSECR  
                ELSE  
                WRITE(N6,2700) XLEN,ELEVN,SLOPE,DEEP,  
     +                               XNL,STCHL,AFULL,XNCH,RFULL  
                WRITE(N6,2701) XNR,STCHR,TWFULL,QMAX  
                IF(KSTOP.EQ.0) WRITE(N6,2710) NUMST,PSXECE,PXSECR  
                ENDIF  
C  
C CIM HERE CHECK THAT STCHL AND STCHR ARE ELSTA STATIONS  
      OKL = .FALSE.  
	OKR = .FALSE.  
	DO I = 1,NUMST  
	IF (ELSTA(2,I).EQ.STCHL) OKL = .TRUE.  
	IF (ELSTA(2,I).EQ.STCHR) OKR = .TRUE.  
	IF (OKL.AND.OKR) EXIT  
	ENDDO  
	IF (.NOT.OKL) THEN  
	  WRITE(N6,7000) 'LEFT ','STCHL'  
	  NSTOP = NSTOP + 1  
	ENDIF  
	IF (.NOT.OKR) THEN  
	  WRITE(N6,7000) 'RIGHT','STCHR'  
	  NSTOP = NSTOP + 1  
	ENDIF  
C#### WCH, 2/7/95.  CHANGE ELSTA TO VARIABLE DIMENSION.  
C#### REPLACE 100 IN STATEMENTS BELOW BY NXSPTS.  
C#### MAX. TIMES THROUGH LOOP = NXSPTS/5 = ILOPPX  
           ELSTA(1,NXSPTS) = 0.0  
           ELSTA(2,NXSPTS) = 0.0  
           ILOPPX          = NXSPTS/5  
           DO 1303 I    = 1,ILOPPX  
           II           = 5*(I-1)+1  
           III          = 5*(I-1)+2  
           IF(III.GT.NUMST)   III = NXSPTS  
                               IV = 5*(I-1)+3  
           IF(IV.GT.NUMST)     IV = NXSPTS  
                              IIV = 5*(I-1)+4  
           IF(IIV.GT.NUMST)   IIV = NXSPTS  
                             IIIV = 5*(I-1)+5  
           IF(IIIV.GT.NUMST) IIIV = NXSPTS  
           IF(KSTOP.EQ.0) WRITE(N6,1302) (ELSTA(K,II),K=1,2),  
     +                (ELSTA(K,III),K=1,2),(ELSTA(K,IV),K=1,2),  
     +                (ELSTA(K,IIV),K=1,2),(ELSTA(K,IIIV),K=1,2)  
           IF(IIIV.GE.NUMST) GO TO 1304  
 1303      CONTINUE  
 1304      CONTINUE  
           ENDIF  
C======================================================================  
C     PRINT CONDUIT INFORMATION FOR POWER FUNCTION CHANNELS  
Cwch 3/14/02.  Here, need to back convert to metric for printout when  
C     calling from Transport.   
C======================================================================  
      IF(KCOND.EQ.1) THEN  
                     CMETGET = 1.0  
	IF(KNORM.EQ.1) CMETGET = CMET(1,METRIC)  
	     IF(JCE.EQ.0) WRITE(N6,2690) IDNUM  
           IF(JCE.EQ.1) WRITE(N6,2691) KDNUM  
           IF(METRIC.EQ.1) THEN  
                WRITE(N6,3700) XLEN,POW,DEEP,  
     +                               RN0,AFULL,RFULL,TWFULL,NATUR  
                ELSE  
                WRITE(N6,3710) XLEN/CMETGET,POW,DEEP/CMETGET,  
     +       RN0,AFULL/CMETGET**2,RFULL/CMETGET,TWFULL/CMETGET,NATUR  
                ENDIF  
           ENDIF  
C=======================================================================  
C     WRITE CROSS SECTION DIMENSIONLESS CURVES  
C=======================================================================  
Cwch, 7/6/01      IF(KNORM.EQ.0.AND.QCURVE(NATUR,3,1).EQ.0.0)  
      IF(QCURVE(NATUR,3,1).EQ.0.0)  
     +                  QCURVE(NATUR,3,1) = QCURVE(NATUR,3,2)  
      IF(KSTOP.EQ.0) THEN  
           IF(KNORM.EQ.0) WRITE(N6,1702)  
           IF(KNORM.EQ.1) WRITE(N6,1703)  
	     KK = 3  
	     IF(KNORM.EQ.1) KK = 4  
           DO 1900 I = 1,8  
           II        = I + 9  
           III       = I + 18  
           WRITE(N6,3333) I,(QCURVE(NATUR,K,I),K=1,KK),II,  
                         (QCURVE(NATUR,K,II),K=1,KK),III,  
                         (QCURVE(NATUR,K,III),K=1,KK)  
 1900      CONTINUE  
           WRITE(N6,3333) 9,(QCURVE(NATUR,K,9),K=1,KK),18,  
                         (QCURVE(NATUR,K,18),K=1,KK)  
CIM### 9/8/00  
C  WRITE ADDITIONAL TABLE FOR DETAILED PART OF CURVE  
           IF(KNORM.EQ.1.AND.IDETAIL.EQ.1) THEN  
CIM 2004 set KK to 3 for this write so correct format 3333 is used.   
Cwch 7/20/04.  
              KK = 3   
              WRITE(N6,1704)  
              WRITE(N6,1705)  
              DO 1920 I = 1,8  
              II        = I + 9  
              III       = I + 18  
              WRITE(N6,3333) I,(QCURV2(NATUR,K,I),K=1,3),II,  
                         (QCURV2(NATUR,K,II),K=1,3),III,  
                         (QCURV2(NATUR,K,III),K=1,3)  
 1920         CONTINUE  
              WRITE(N6,3333) 9,(QCURV2(NATUR,K,9),K=1,3),18,  
                         (QCURV2(NATUR,K,18),K=1,3)  
              ENDIF  
           ENDIF  
CIM### 9/8/00  
C=======================================================================  
      RETURN  
C=======================================================================  
C=======================================================================  
C     PRINT POSSIBLE INPUT ERRORS  
C=======================================================================  
C     DATA COULD NOT BE FOUND  
C=======================================================================  
 9000 CONTINUE  
      WRITE(N6,9010) XFROM  
      NSTOP = NSTOP+1  
      RETURN  
C=======================================================================  
C     DATA INPUT IN WRONG ORDER  
C=======================================================================  
 9020 CONTINUE  
      WRITE(N6,9030) XFROM  
      NSTOP = NSTOP+1  
      RETURN  
  888 CALL IERROR  
C=======================================================================  
  201 FORMAT(/,' ===> WARNING   XNCH LE 0.0.')  
 1302 FORMAT(5(F10.2,2X,F10.2,4X))  
 1405 FORMAT(/,' ===> ERROR  MANNINGS "N" OF CENTER CHANNEL IS 0.0.  
     +JOB STOPPED.')  
 1406 FORMAT(/,' ===> ERROR  CHANNEL LENGTH IS 0.0.  JOB STOPPED.')  
 1407 FORMAT(/,' ===> ERROR  WIDTH OF CHANNEL IS 0.0.  JOB STOPPED.')  
 1408 FORMAT(/,' ===> ERROR  DEPTH OF CHANNEL IS 0.0.  JOB STOPPED.')  
 1409 FORMAT(/,' ===> ERROR  NUMBER OF DATA POINTS LE 1.  JOB STOPPED  
     +.')  
 1410 FORMAT(/,' ===> ERROR  NATURAL CHANNEL LIMITED TO MAXIMUM OF  
     *50 INTERIOR DEPRESSIONS.  JOB STOPPED.')  
 1690 FORMAT(/,9X,'NATURAL CROSS-SECTION INFORMATION FOR CHANNEL ',  
     +       I10,/,9X,53('='))  
 1691 FORMAT(/,9X,'NATURAL CROSS-SECTION INFORMATION FOR CHANNEL ',  
     +       A10,/,9X,53('='))  
 1696 FORMAT(9X,' CROSS-SECTION ID (FROM X1 CARD) : ',F15.2,  
     +          ' CHANNEL SEQUENCE NUMBER :',I6,/)  
 1700 FORMAT(3X,'LENGTH    :',F12.2,' FT ',T55,  
     +          ' MAXIMUM ELEVATION        : ',F10.2,'     FT.',/,  
     +3X,       'SLOPE     :',F12.4,' FT/FT',T55,  
     +          ' MAXIMUM DEPTH            : ',F10.2,'     FT.',/,  
     +3X,       'MANNING N :',F12.3,' TO STATION  ',F10.1,T55,  
     +          ' MAXIMUM SECTION AREA     : ',1PG10.2,' SQ. FT.',  
     +/,3X,'  "    "  :',0PF12.3,' IN MAIN CHANNEL',T55,  
     +' MAXIMUM HYDRAULIC RADIUS : ',F10.2,'     FT.')  
 1701  FORMAT(3X,'  "    "  :',F12.3,' BEYOND STATION',F8.1,T55,  
     +' MAX TOPWIDTH             : ',F10.2,'     FT.',/,T55,  
     +' MAXIMUM UNIFORM FLOW     : ',1PE10.2,' CFS.   ')  
 1702 FORMAT(///,26X,' CROSS-SECTION DIMENSIONLESS CURVES ',/,  
     +           26X,'       NORMALIZED BY DEPTH',/,  
     +      24X,42('-')/  
     +      3(' POINT  HYDRAULIC                           '),/,  
     +      3('  NO.    RADIUS       AREA     TOPWIDTH     '),/,  
     +      3(' -----  ---------    -----     --------     '))  
Cwch, 7/6/01  
 1703 FORMAT(//,26X,' CROSS-SECTION DIMENSIONLESS CURVES ',/,  
     +           26X,'       NORMALIZED BY AREA',/,  
     +      24X,42('-')/  
     +      3(' POINT  HYDRAULIC                                       '  
     +),/,  
     +      3('  NO.    RADIUS      DEPTH    TOP WIDTH        FLOW     '  
     +),/,  
     +      3(' -----  ---------     ----     --------     -------     '  
     +))  
CIM### 9/8/00  
 1704 FORMAT(//,26x,' DETAILED NORMALIZED CURVE FOR PORTION OF SECTION',  
     +' BELOW 0.04 AFULL',//)  
 1705 FORMAT(//,  
     +      24X,42('-')/  
     +      3(' POINT  HYDRAULIC                           '),/,  
     +      3('  NO.    RADIUS      DEPTH         FLOW     '),/,  
     +      3(' -----  ---------     ----     --------     '))  
 1710 FORMAT(//,52X,'CROSS-SECTION POINTS',/,  
     +          51X,'--------------------',/,10X,  
     +'THE FOLLOWING ',I2,' STATIONS WERE READ AND ADJUSTED',  
     +F9.3,' FT VERTICALLY AND HORIZONTALLY BY A RATIO OF ',F6.3,//,  
     +5('   ELEVATION   STATION    '),/,  
     +5('      FT         FT       '),/,  
     +5('   ---------   -------    '))  
 2690 FORMAT(/,9X,'POWER FUNCTION CROSS-SECTION INFORMATION',  
     +       ' FOR CHANNEL ',I10,/,9X,53('='))  
 2691 FORMAT(/,9X,'POWER FUNCTION CROSS-SECTION INFORMATION',  
     +       ' FOR CHANNEL ',A10,/,9X,53('='))  
 2700 FORMAT(3X,'LENGTH    :',F12.1,' METERS.',T55,  
     +' MAXIMUM ELEVATION        : ',F10.2,' METERS.',/,  
     +3X,'SLOPE     :',F12.4,'  M/M ',T55,  
     +' MAXIMUM DEPTH            : ',F10.2,' METERS.',/,  
     +3X,'MANNING N :',F12.3,' TO STATION  ',F10.1,T55,  
     +' MAXIMUM SECTION AREA     : ',1PG10.2,' SQ.MET.',  
     +/,3X,'  "    "  :',0PF12.3,' IN MAIN CHANNEL',T55,  
     +' MAXIMUM HYDRAULIC RADIUS : ',F10.2,' METERS.')  
 2701  FORMAT(3X,'  "    "  :',F12.3,' BEYOND STATION',F8.1,T55,  
     +' MAX TOPWIDTH             : ',F10.2,' METERS.',/,T55,  
     +' MAXIMUM UNIFORM FLOW     : ',1PE10.2,' CMS.   ')  
 2710 FORMAT(//,52X,'CROSS-SECTION POINTS',/,  
     +          51X,'--------------------',/,10X,  
     +'THE FOLLOWING ',I2,' STATIONS WERE READ AND ADJUSTED',  
     +F9.3,'  M VERTICALLY AND HORIZONTALLY BY A RATIO OF ',F6.3,//,  
     +5('   ELEVATION   STATION    '),/,  
     +5('    METERS     METERS     '),/,  
     +5('   ---------   -------    '))  
Cwch, 7/6/01 3333 FORMAT(3(I3,3F12.4,5X))  
Cwch  Try CVF "variable format expression" option. Lang.Ref.Manual 11-44.  
 3333 FORMAT(3(I3,<KK>F12.4,5X))  
 3700 FORMAT(9X,'LENGTH                   :',F12.1,' FEET.',/,  
     +       9X,'EXPONENT OF CHANNEL      :',F12.3,/,  
     +       9X,'MAXIMUM DEPTH            :',F12.2,' FEET.',/,  
     +       9X,'MANNING N                :',F12.3,/,  
     +       9X,'MAXIMUM SECTION AREA     :',F12.2,' SQ. FT.',/,  
     +       9X,'MAXIMUM HYDRAULIC RADIUS :',F12.3,' FEET.',/,  
     +       9X,'MAXIMUM TOP WIDTH        :',F12.2,' FEET.',/,  
     +       9X,'CHANNEL SEQUENCE NUMBER  :',I12)  
 3710 FORMAT(9X,'LENGTH                   :',F12.1,' METERS.',/,  
     +       9X,'EXPONENT OF CHANNEL      :',F12.3,/,  
     +       9X,'MAXIMUM DEPTH            :',F12.2,' METERS.',/,  
     +       9X,'MANNING N                :',F12.3,/,  
     +       9X,'MAXIMUM SECTION AREA     :',F12.2,' SQ.MET.',/,  
     +       9X,'MAXIMUM HYDRAULIC RADIUS :',F12.3,' METERS.',/,  
     +       9X,'MAXIMUM TOP WIDTH        :',F12.2,' METERS.',/,  
     +       9X,'CHANNEL SEQUENCE NUMBER  :',I12)  
Cwch, 3/15/02.  
 9005 FORMAT(/,' ERROR. Value of cross-section ID on Transport E1 line (  
     1BARREL)',/,' or Extran C1 line (STHETA) is zero for input line:',  
	2I3,/,' Value on E1 or C1 line must be >>numeric<<, not alphanumeri  
	3c',/,' to correspond to SECNO on E3 or C3 or X1 line.',/,  
	4' This is most likely cause of error.')  
 9010 FORMAT(/,' ===> ERROR  FAILURE TO FIND DATA FOR SECTION',  
     +' (',F10.3,')',/,'               JOB ENDED')  
 9011  FORMAT(/,'  ===> ERROR, END OF DATA SET FOUND WHILE READING',  
      'AREA/STAGE DATA AT JUNCTION # ',I10)  
 9012  FORMAT(/,'  ===> ERROR , END OF DATA SET FOUND WHILE READING',  
      'VOLUME/STAGE DATA AT JUNCTION # ',I10)  
 9030 FORMAT(/,' ===> ERROR  STATIONS NOT IN CORRECT SEQUENCE',  
     +' FOR SECTION (',F10.3,')',/,'                JOB ENDED')  
 9040 FORMAT(/,' ===> ERROR  UNABLE TO MATCH NATURAL CHANNEL CROSS SEC  
     *TION DATA FOR CHANNEL',F10.1,/,  
     *'        LAST SECNO (LINE C3) READ WAS',F10.1,' $$ JOB ENDED.')  
Cwch, 4/16/02.  
 9600 FORMAT(/,' ===> ERROR  . CONDUIT SLOPE WAS ZERO',  
     +         ' FOR CONDUIT ',I10,' Assign default of 0.01.')  
 9601 FORMAT(/,' ===> ERROR  . CONDUIT SLOPE WAS ZERO',  
     +         ' FOR CONDUIT ',A10,' Assign default of 0.01.')  
C 9600 FORMAT(/,' ===> FATAL ERROR  . CONDUIT SLOPE WAS ZERO',  
C     +         ' FOR CONDUIT ',I10)  
C 9601 FORMAT(/,' ===> FATAL ERROR  . CONDUIT SLOPE WAS ZERO',  
C     +         ' FOR CONDUIT ',A10)  
 7000 FORMAT(' ERROR - THE STATION OF THE ',A5,' BANK OF THE CHANNEL (',  
     1A5,') DOES NOT CORRESPOND TO A STATION IN THE CROSS SECTION DATA')  
 7020 FORMAT(/,' ===> ERROR  CHANNEL LENGTH ON C1 LINE DOES NOT',  
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/,  
     a         '      LENGTH ON C1 LINE EQUALS      ',F10.3,/,  
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3)  
 7030 FORMAT(/,' ===> ERROR  CHANNEL LENGTH ON E1 LINE DOES NOT',  
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/,  
     a         '      LENGTH ON E1 LINE EQUALS      ',F10.3,/,  
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3)  
 7040 FORMAT(/,' ===> WARNING  CHANNEL LENGTH ON C1 LINE DOES NOT',  
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/,  
     a' LENGTH ON C3/E1 LINE IS USED (IWLEN = 1)',/,  
     a         '      LENGTH ON C1 LINE EQUALS      ',F10.3,/,  
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3)  
 7050 FORMAT(/,' ===> WARNING  CHANNEL LENGTH ON C1 LINE DOES NOT',  
     a' MATCH LENGTH ENTERED IN IRREGULAR CHANNEL DATA.',/,  
     a' LENGTH ON C1 LINE IS USED (IWLEN = 2)',/,  
     a         '      LENGTH ON C1 LINE EQUALS      ',F10.3,/,  
     a         '      LENGTH IN CHANNEL DATA EQUALS ',F10.3)  
C=======================================================================  
      END  
ECHO is off.
REM File: GTCOLD.FOR  
ECHO is off.
      SUBROUTINE GTCOLD(IDO,IGO)  
C	TEMP BLOCK  
C     CALLED BY TEMP NEAR 110 and 112  
C       
C=======================================================================  
C     UPDATED 11/92 BY WCH TO CORRECT TYPO AT APPROX. LINE 91  
C       AND TO ALLOW NO STATION NUMBER FOR USER-DEFINED INPUT  
C     UPDATED 12/92 TO CORRECT DATE PROBLEMS.  
C     UPDATED 9/30/93 TO ALLOW ZERO STATION NUMBER AND BETTER END-OF-  
C       FILE MESSAGE.  WCH.  
C     ENHANCE ERROR MESSAGE FOR READING OF DATA, WCH, 4/18/94.  
C     ALTER IOSTAT NUMBER FOR LAHEY, WCH, 8/5/95.  
C     READ YEARS AS 4-DIGITS, WCH, 3/28/00.  
C     FIX MAJOR UNITS PROBLEM HERE AND IN SUB. TEMP. WCH, 7/27/04.  
C     ADD OPTION TO USE ALL KTYPE VALUES FOR USER INPUT. ALLOWS USER  
C       TO PROVIDE ANY OR ALL THREE OF TEMP, EVAP, OR WIND. WCH, 7/28/04.  
C=======================================================================  
C     THIS PROGRAM READS TWO FORMATS  
C     IFORM = 0 MEANS POST 1980 FORMAT  
C     IFORM = 2 MEANS USER DEFINED FORMAT  
C     IDO   = 0 SEARCH FOR STATION NUMBER  
C     IDO   = 1 READ STATION DATA  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'TEW.INC'  
      INTEGER  DAY,YEAR,STA,FF(8),IVALUE(31)  
      CHARACTER ELMTYP*4,LERR*30  
C=======================================================================  
      IF(IDO.EQ.0)   THEN  
      IF(IFORM.EQ.0) THEN  
C#### WCH, 4/18/94.  ADD IOSTAT  
2              READ(IO,1000,ERR=60,END=440,IOSTAT=IOS) IBUF,ELMTYP,  
     +              NEWYR,NEWMON  
               IF(NEWYR.LT.100) NEWYR = NEWYR + 1900  
C#### WCH, 9/30/93.  ALLOW ZERO STATION NUMBER OPTION HERE TOO.  
               IF(ISTA.GT.0.AND.IBUF.NE.ISTA) GO TO 2  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 2  
               IF(IYBEG(2).NE.0.AND.NEWMON.LT.IYBEG(2)) GO TO 2  
               BACKSPACE IO  
               ISTA = IBUF  
               ENDIF  
C  
      IF(IFORM.EQ.2) THEN  
C#######################################################################  
C WCH, 11/92  CORRECT TO ALLOW NO STATION NO. ENTERED IF F1=0,  
C               AS IN DOCUMENTATION  
C#######################################################################  
               NUMPAR = 6  
               IF(KTYPE.EQ.1.OR.KTYPE.EQ.2) NUMPAR = NUMPAR - 1  
	         IF(KTYPE.EQ.3.OR.KTYPE.EQ.4) NUMPAR = NUMPAR + 1  
	         IF(KTYPE.EQ.6)               NUMPAR = NUMPAR + 2  
               IF(F1.EQ.0)                  NUMPAR = NUMPAR - 1  
C#### WCH, 4/18/94.  ADD IOSTAT  
4              READ(IO,FIRMAT,ERR=60,END=440,IOSTAT=IOS)   
     +             (FF(I),I=1,NUMPAR)  
               IF(F1.NE.0) IBUF = FF(F1)  
               NEWYR  = FF(F2)  
C#### WCH, 12/92.  NEED 2-DIGIT YEAR.  
c              IF(NEWYR.GT.1900) NEWYR = NEWYR - 1900  
               IF(NEWYR.LT.100)  NEWYR = NEWYR + 1900  
               NEWMON = FF(F3)  
               NEWDAY = FF(F4)  
               IF(F1.NE.0.AND.IBUF.NE.ISTA) GO TO 4  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 4  
               IF(IYBEG(2).NE.0.AND.NEWMON.LT.IYBEG(2)) GO TO 4  
               IF(IYBEG(3).NE.0.AND.NEWDAY.LT.IYBEG(3)) GO TO 4  
               BACKSPACE IO  
               ENDIF  
      RETURN  
C#### WCH, 9/30/93.  ADD ALTERNATE END OF FILE MESSAGE.  
  440 WRITE(N6,9440) IO,ISTA,IBUF  
      STOP  
C=======================================================================  
C  ENDIF FOR IDO = 0  
C=======================================================================  
      ENDIF  
C  
      IF(IDO.EQ.1) THEN  
 7    BACKSPACE IO  
      CALL SETZER(BARAY,12,31,-99.0)  
      CALL SETZER(SARAY,12,31,-99.0)  
      CALL SETZER(EARAY,12,31,-99.0)  
      CALL SETZER(WARAY,12,31,-99.0)  
C  
10    CONTINUE  
      IF(IFORM.EQ.0) THEN  
C#### WCH, 4/18/94.  ADD IOSTAT  
         READ(IO,1000,END=40,ERR=60,IOSTAT=IOS) STA,ELMTYP,  
     +             YEAR,MONTH,(IDUM,IDUM,IVALUE(J),J=1,31)  
         IF (YEAR.LT.100) YEAR = YEAR + 1900  
C  
         IF(KTYPE.EQ.0.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'))  
     +              GO TO 15  
      IF(KTYPE.EQ.1.AND.ELMTYP.EQ.'EVAP') GO TO 15  
      IF(KTYPE.EQ.2.AND.ELMTYP.EQ.'WDMV') GO TO 15  
      IF(KTYPE.EQ.3.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'.  
     +                          OR.ELMTYP.EQ.'EVAP')) GO TO 15  
      IF(KTYPE.EQ.4.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'.  
     +                          OR.ELMTYP.EQ.'WDMV')) GO TO 15  
      IF(KTYPE.EQ.5.AND.(ELMTYP.NE.'EVAP'.OR.ELMTYP.EQ.'WDMV'))GO TO 15  
      IF(KTYPE.EQ.6.AND.(ELMTYP.EQ.'TMIN'.OR.ELMTYP.EQ.'TMAX'.  
     +              OR.ELMTYP.EQ.'EVAP'.OR.ELMTYP.EQ.'WDMV')) GO TO 15  
         GO TO 30  
C  
  15     CONTINUE  
         DO 200 K = 1,31  
         IF(IVALUE(K).EQ.-9999) GO TO 200  
         IF(ELMTYP.EQ.'EVAP') EARAY(MONTH,K) = FLOAT(IVALUE(K))  
         IF(ELMTYP.EQ.'WDMV') WARAY(MONTH,K) = FLOAT(IVALUE(K))  
         IF(ELMTYP.EQ.'TMIN') SARAY(MONTH,K) = FLOAT(IVALUE(K))  
         IF(ELMTYP.EQ.'TMAX') BARAY(MONTH,K) = FLOAT(IVALUE(K))  
  200    CONTINUE  
         ENDIF  
C  
      IF(IFORM.EQ.2) THEN  
C#### WCH 11/92  
C#### WCH, 4/18/94.  ADD IOSTAT  
Cwch, 7/28/04. Allow reading of temperature and/or evap and/or wind.  
         READ(IO,FIRMAT,END=40,ERR=60,IOSTAT=IOS) (FF(I),I=1,NUMPAR)  
         IF(F1.NE.0) STA = FF(F1)  
         YEAR  = FF(F2)  
C#### WCH, 12/92.  NEED 2-DIGIT YEAR.  
c         IF(YEAR.GT.1900) YEAR = YEAR - 1900  
          IF(YEAR.LT.100) YEAR = YEAR + 1900  
         MONTH = FF(F3)  
         DAY   = FF(F4)  
Cwch, 7/28/04         MAXU  = FF(F5)  
         IF(MONTH.LE.0.OR.MONTH.GT.12) GO TO 30  
         IF(DAY.LE.0.OR.DAY.GT.31)     GO TO 30  
Cwch, 7/28/04. More complicated IF statements for multiple input options.  
Cwch	   MINU  = FF(F6)  
C         IF(KTYPE.EQ.0) BARAY(MONTH,DAY) = FLOAT(MAXU)  
C         IF(KTYPE.EQ.0) SARAY(MONTH,DAY) = FLOAT(MINU)  
C         IF(KTYPE.EQ.1) EARAY(MONTH,DAY) = FLOAT(MAXU)*CONV  
C         IF(KTYPE.EQ.2) WARAY(MONTH,DAY) = FLOAT(MAXU)*CONV  
         IF(KTYPE.EQ.0.OR.KTYPE.EQ.3.OR.KTYPE.EQ.4.OR.KTYPE.EQ.6) THEN  
              BARAY(MONTH,DAY) = FLOAT(FF(F5))  
	        SARAY(MONTH,DAY) = FLOAT(FF(F6))  
	        ENDIF  
	   IF(KTYPE.EQ.1.OR.KTYPE.EQ.3.OR.KTYPE.EQ.5.OR.KTYPE.EQ.6)  
     1        EARAY(MONTH,DAY) = FLOAT(FF(F7))*CONV  
	   IF(KTYPE.EQ.2.OR.KTYPE.GE.4)  
     1        WARAY(MONTH,DAY) = FLOAT(FF(F8))*CONV  
Cwch, 7/2704. Save units conversion for after print-out.   
C     Convert in Sub. TEMP while placing on interface file.  
C         IF(KUNIT.EQ.1.AND.KTYPE.EQ.0) THEN  
C                   BARAY(MONTH,DAY) = 1.8*BARAY(MONTH,DAY) + 32.0  
C#####  
C WCH, 11/92 CHANGE BARAY TO SARAY  
C#####  
C                   SARAY(MONTH,DAY) = 1.8*SARAY(MONTH,DAY) + 32.0  
C                   ENDIF  
         ENDIF  
C=======================================================================  
C     SKIP IF THE NEW STATION IS NOT THE STATION SELECTED  
C     RETURN IF THE NEW YEAR IS LESS THAN THE SELECTED ENDING YEAR  
C=======================================================================  
30    CONTINUE  
C#######################################################################  
C  WCH, 12/92  RETURN IF LAST DAY OF YEAR.  
C  ALSO CHECK FOR NO ADDITIONAL RECORDS.  
C  END = 40 IN READ MEANS THIS IS LAST YEAR IF REACH END OF FILE.  
C#######################################################################  
      IF(IFORM.EQ.0) DAY = 31  
      IF(MONTH.EQ.12.AND.DAY.EQ.31)  THEN  
C#### WCH, 4/18/94.  ADD IOSTAT  
             IF(IFORM.EQ.0) READ(IO,1000,END=40,ERR=60,IOSTAT=IOS)   
     +             STA,ELMTYP,YEAR,MONTH,(IDUM,IDUM,IVALUE(J),J=1,31)  
             IF (YEAR.LT.100) YEAR = YEAR + 1900  
C#### WCH, 4/18/94.  ADD IOSTAT  
             IF(IFORM.EQ.2) READ(IO,FIRMAT,END=40,ERR=60,IOSTAT=IOS)   
     +             (FF(I),I=1,NUMPAR)  
             IF (FF(F2).LT.100) FF(F2) = FF(F2) + 1900  
C  NOTE, IO BACKSPACED AT BEGINNING OF LOOP FOR IDO = 1 (STATEMENT 7).  
             RETURN  
             ENDIF             
C#### WCH, 11/92  
      IF(IFORM.EQ.2.AND.F1.EQ.0) GO TO 33  
      IF(STA.NE.ISTA)                            GO TO 40  
C#######################################################################  
C  WCH, 12/92 CORRECT WRONG SUBSCRIPTS FOR YEAR AND MONTH  
C  (3) = DAY, (2) = MONTH, (1) = YEAR  
C  ALSO, ALTER THE CHECK FOR ENDING DATE TO CHECK FOR EXACT   
C    DATE FOR IFORM = 2.  
C#######################################################################  
33    IF(IFORM.EQ.2) THEN  
        IF(YEAR.EQ.IYEND(1).AND.MONTH.EQ.IYEND(2).AND.DAY.EQ.IYEND(3))   
     *                                           GO TO 40  
        ENDIF  
      IF(IFORM.EQ.0) THEN  
        IF(YEAR.EQ.IYEND(1).AND.MONTH.GE.IYEND(2)) GO TO 40  
        ENDIF  
      IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))     GO TO 40  
      IF(YEAR.GT.NEWYR)                          RETURN  
      GO TO 10  
C=======================================================================  
C     ENDIF FOR IDO = 1  
C=======================================================================  
      ENDIF  
C=======================================================================  
40    IGO = 1  
      RETURN  
C=======================================================================  
C     ERROR MESSAGE FOR READING INPUT FILE.  
C=======================================================================  
C#### WCH, 4/18/94.  ADD IOSTAT  
C#### WCH, 8/5/95.  ALTER IOS FOR LAHEY.  
60    WRITE(N6,2000) IO,MOD(IOS,256)  
      WRITE(*,2000)  IO,MOD(IOS,256)  
      WRITE(*,2001)  
      BACKSPACE IO  
      READ(IO,3000)  LERR  
      WRITE(N6,3001) LERR  
      STOP  
C=======================================================================  
Cwch, 3/28/00.  Read year as 4 digits.  
C1000 FORMAT(3X,I6,2X,A4,4X,I2,I2,7X,31(2I2,I6,2X))  
 1000 FORMAT(3X,I6,2X,A4,2X,I4,I2,7X,31(2I2,I6,2X))  
C#### WCH, 4/18/94.  ADD IOSTAT  
C#### WCH, 8/5/95.  ALTER IOSTAT NUMBER FOR LAHEY.  
 2000 FORMAT(/,' ===> ERROR   READING THE INPUT FILE, UNIT',I3,/,  
     1        '  LAHEY ERROR NUMBER =',I5,/,  
     2        '  EXECUTION STOPS FROM TEMP BLOCK.')  
C#### WCH, 4/18/94  
 2001 FORMAT ('  SEE OUTPUT FILE FOR MORE INFORMATION.')  
 3000 FORMAT(A30)  
 3001 FORMAT(/,' FIRST 30 CHARACTERS OF THE LAST LINE READ ARE: ',/,  
     +         3X,A30 )  
C#### WCH, 9/30/93.  
 9440 FORMAT (' ERROR FROM TEMP BLOCK.  END OF FILE REACHED ON UNIT',  
     1I3,/,' EITHER ISTA > 0 AND CAN''T FIND MATCHING STATION NUMBER ON   
     2DATA FILE OR ELSE CAN''T FIND CORRECT DATES.',/,' ISTA =',I8,  
     3 ' STA. NO. ON DATA FILE =',I8,/,' RUN STOPPED FROM TEMP BLOCK.')  
C=======================================================================  
      END  
  
ECHO is off.
REM File: GTRAIN.FOR  
ECHO is off.
      SUBROUTINE GTRAIN(IDO,IGO,ILOST,M4)  
C     RAIN BLOCK  
C     CALLED BY RAIN BLOCK AT NUMEROUS LOCATIONS  
C#######################################################################  
C     This program reads 15 versions of precipitation files.  
C     WCH, 3/2/93.  Precautionary IF statement if IHR = 25.  
C     WCH, 8/93.  Add option for recent EarthInfo ASCII files in  
C       Subroutine G9RAIN and misc. corrections.  
C     WCH, 8/93. Add code to ensure 15-min. data are properly placed  
C       on interface file.  
C     WCH, 10/11/93.  Revise input format for IFORM = 4 or 6 for 15-min.  
C       rainfall.  Include calc. of JULDAY when necessary.  
C     WCH, 4/25/94.  Correct computation of Julian date for 15-min.  
C       data for IFORM = 0 and 1.  
C     WCH, 4/26/94.  Major code modifications to permit averaging of  
C       NCDC accumulated rainfall and to list special codes in data.  
C     WCH, 5/24/94.  Fix subscript for FLAG1 for IFORM=1 and remove  
C       ILOOP (no discernable purpose).  
C     WCH, 8/1/95.  Change all station IDs to character from integer.  
C       Also, add new AES format.  No longer compare requested ID with  
C       ID read on data lines to avoid character comparison  
C       complications.  
C     WCH, 8/4/95. Alter IOSTAT number for Lahey.  
C     WCH, 10/2/96.  Add better error path for initial reads of files.  
C     WCH, 12/5/96.  Correct the logic for starting at indicated  
C       beginning year when IFORM = 4 or 6.  
C     WCH, 12/6/96.  Fix averaging process for 15-min. rainfall  
C       for special combinations of hour/minute.  
C     WCH, 11/9/99.  Read year as 4 digits to fix Y2K in several spots.   
C     WCH, 11/22/99. Add Y2K compatibility for AES data.    
C     WCH, 2/9/01.  Reset value of NEND every call to GTRAIN.  
C        Suggested by Nerkez Gavranovic, Sydney, Australia  
C     WCH, 7/28/04. Add option for unformatted read for IFORM=1.  
C#######################################################################  
C     IFORM = 0 NWS POST 1980 TD-3240 FIXED LENGTH FORMAT  
C     IFORM = 1 NWS POST 1980 TD-3240/3260 VARIABLE LENGTH FORMAT  
C     IFORM = 2 NWS PRE-1980 FORMAT  
C			  Note, IFORM = 2 is CANNOT be Y2K compatible.    
C     IFORM = 3 USER-SPECIFIED INPUT FORMAT AND FILE (SUB. G3RAIN)  
C     IFORM = 4 NWS MICROCOMPUTER FORMAT WITH QUOTATION MARKS (RELEASE  
C               B, CONDENSED)  
C               Note, IFORM = 4 CANNOT be Y2K compatible.   
C     IFORM = 5 HOURLY AES PRECIPITATION DATA (OLDER COMPRESSED FORMAT)  
C               Note, IFORM = 5 CANNOT be Y2K compatible.  
C     IFORM = 6 NWS MICROCOMPUTER FORMAT (IFORM=4) WITH APOSTROPHES  
C     IFORM = 7 EARTH INFO NCDC  DISPLAY COMPUTER FORMAT.  
C     IFORM = 8 EARTH INFO ASCII DISPLAY COMPUTER FORMAT.  
C         THE FOLLOWING FOUR OPTIONS ARE IN SUBROUTINE G9RAIN:  
C     IFORM = 9 EARTH INFO UNPROCESSED ASCII OUTPUT FILE - 1993, 15-MIN.  
C     IFORM =10 EARTH INFO UNPROCESSED ASCII OUTPUT FILE - 1993, HOURLY.  
C     IFORM =11 EARTH INFO PROCESSED ASCII FILE - 1993, 15-MIN.  
C     IFORM =12 EARTH INFO PROCESSED ASCII FILE - 1993, HOURLY.  
C  
C     IFORM =13 AES PRECIPITATION DATA (NEWER FORMAT, WITH FLAGS).  
C               Note, IFORM = 13 CANNOT be Y2K compatible.  
C     IFORM =14 HOURLY AES PRECIP. DATA, NEWER FORMAT WITH 4-DIGIT YR.  
C     IFORM =15 15-MIN. AES PRECIP. DATA, NEWER FORMAT WITH 4-DIGIT YR.  
C=======================================================================  
C     IDO   = 0 SEARCH FOR STATION NUMBER  
C     IDO   = 1 READ STATION RAINFALL  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'PRECIP.INC'  
C#### WCH, 8/1/95.  CHANGE STA TO CHARACTER.  
CWCH, 11/22/99. CHANGE XRAIN TO 96  
C####      INTEGER DAY,YEAR,STA,XRAIN(24),IHOUR(100),VALUE(100)  
      INTEGER DAY,YEAR,XRAIN(96),IHOUR(100),VALUE(100)  
      REAL    YRAIN(24)  
      CHARACTER*3 XRA(12),ZIM,BIB,BLK  
      CHARACTER STNAME*20,UNITS*2,CH(50)*1,FLAG1(100)*1,FLAG2(100)*1  
C#### WCH, 8/1/95.  ADD IBUF AND STA. 7/28/04 +ABUF  
      CHARACTER IA*1,IM*1,ICODE*1,ELMTYP*4,SQUOTE*1,IBUF*8,STA*8,ABUF*6,  
     1 ABUF2*2,ABUF3,IBUF2*6,STA6*6  
C#### WCH, 10/11/93 AND 4/26/94  
      CHARACTER*1 M3LINE(50),BLANK,IKODE  
      DATA IM/'M'/,IA/'A'/,ZIM/'0- '/,BIB/'   '/,BLK/'-  '/  
      DATA SQUOTE/''''/,BLANK/' '/  
C=======================================================================  
C     First find the correct Rainfall station (IDO = 0)  
C=======================================================================  
      IF(IFORM.EQ.4) THEN  
                     M3 = NSCRAT(3)  
                     IF(M3.EQ.0) CALL ERROR(104)  
                     ENDIF  
      IF(IDO.EQ.0)   THEN  
C#### WCH, 8/1/95.  
      IPRINT = 0  
C=======================================================================  
      IF(IFORM.EQ.0) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
C#### 2              READ(IO,1000,ERR=2,END=40) IBUF,ELMTYP,  
2              READ(IO,1000,ERR=970,END=40,IOSTAT=IOS) IBUF,ELMTYP,  
     +                                    NEWYR,NEWMON,NEWDAY  
                    IF (NEWYR.LT.100) NEWYR = NEWYR + 1900  
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY.  
C####               IF(IBUF.NE.ISTA) GO TO 2  
               IF(IPRINT.EQ.0) THEN  
                    WRITE(N6,990) IBUF,ISTA  
                    WRITE(*,990) IBUF,ISTA  
                    IPRINT = 1  
                    ENDIF  
C  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 2  
               IF(NEWMON.LT.IYBEG(2).AND.  
     +                            NEWYR.EQ.IYBEG(1))    GO TO 2  
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3)  
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 2  
               IF(ELMTYP.EQ.'QPCP') THISTO = 900.0  
               IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0  
               ENDIF  
C=======================================================================  
      IF(IFORM.EQ.1) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
Cwch, 7/28/04. Add option for unformatted file for IFORM=1  
C 3              READ(IO,1060,ERR=970,END=40,IOSTAT=IOS) IBUF,ELMTYP,  
3     IF(IFORM1.EQ.0) READ(IO,1060,ERR=970,END=40,IOSTAT=IOS) IBUF,  
     +                                 ELMTYP,NEWYR,NEWMON,NEWDAY  
	IF(IFORM1.EQ.1) THEN  
C 3123      READ(IO,*,ERR=970,END=3124,IOSTAT=IOS) ABUF  
C     Check first for two extraneous lines at top of file.  
C	     IF(ABUF.EQ.'COOPID'.OR.ABUF.EQ.'------') THEN  
C			  GOTO 3123  
C	          ELSE  
C	          REWIND IO  
C	          ENDIF  
           READ(IO,*,ERR=970,END=3124,IOSTAT=IOS) IBUF2,ABUF2,  
     +                   ELMTYP,ABUF2,NEWYR,NEWMON,NEWDAY  
	     IBUF = IBUF2  
	     ENDIF  
C  
                    IF (NEWYR.LT.100) NEWYR = NEWYR + 1900  
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY.  
C####               IF(IBUF.NE.ISTA) GO TO 3  
               IF(IPRINT.EQ.0) THEN  
                    WRITE(N6,990) IBUF,ISTA  
                    WRITE(*,990) IBUF,ISTA  
                    IPRINT = 1  
                    ENDIF  
C  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 3  
               IF(NEWMON.LT.IYBEG(2).AND.  
     +                            NEWYR.EQ.IYBEG(1))    GO TO 3  
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3)  
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 3  
Cwch, 7/28/04. Can't do 15-min yet with IFORM1=1  
               IF(ELMTYP.EQ.'QPCP'.AND.IFORM.EQ.1) THEN  
	              WRITE(N6,9123)  
	              WRITE(*,9123)  
 9123 FORMAT(/,' ERROR. Sorry, cannot yet read 15-min. unformatted data   
     1with IFORM=-1. Run will have to stop.')  
	               STOP  
	               ENDIF  
               IF(ELMTYP.EQ.'QPCP') THISTO = 900.0  
               IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0  
               ENDIF  
C=======================================================================  
      IF(IFORM.EQ.2) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
4              READ(IO,1040,ERR=970,END=40,IOSTAT=IOS) IBUF,NEWYR,  
     1              NEWMON,NEWDAY  
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900  
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY.  
C####               IF(IBUF.NE.ISTA) GO TO 4  
               IF(IPRINT.EQ.0) THEN  
                    WRITE(N6,990) IBUF,ISTA  
                    WRITE(*,990) IBUF,ISTA  
                    IPRINT = 1  
                    ENDIF  
C  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 4  
               IF(NEWMON.LT.IYBEG(2).AND.  
     +                            NEWYR.EQ.IYBEG(1))    GO TO 4  
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3)  
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 4  
C#### WCH, 8/93.  
               THISTO = 3600.0  
               ENDIF  
C=======================================================================  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. ADD 4-DIGIT YEAR AND 15-MIN. DATA OPTION FOR AES.  
      IF(IFORM.EQ.5.OR.IFORM.GE.13) THEN  
C#### WCH, 10/2/96.  GO TO 970 ON ERROR, NOT BACK TO SAME STATEMENT.  
7              IF(IFORM.LE.13) READ(IO,1045,ERR=970,END=40,IOSTAT=IOS)   
     1             IBUF,NEWYR,NEWMON,NEWDAY  
	         IF(IFORM.GE.14) READ(IO,1047,ERR=970,END=40,IOSTAT=IOS)  
     1             IBUF,NEWYR,NEWMON,NEWDAY  
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900  
C#### WCH, 8/1/95.  PRINT NAME INSTEAD OF TESTING EQUALITY.  
C####               IF(IBUF.NE.ISTA) GO TO 7  
               IF(IPRINT.EQ.0) THEN  
                    WRITE(N6,990) IBUF,ISTA  
                    WRITE(*,990) IBUF,ISTA  
                    IPRINT = 1  
                    ENDIF  
C  
               IF(IYBEG(1).NE.0.AND.NEWYR.LT.IYBEG(1))  GO TO 7  
               IF(NEWMON.LT.IYBEG(2).AND.  
     +                            NEWYR.EQ.IYBEG(1))    GO TO 7  
               IF(NEWMON.LE.IYBEG(2).AND.NEWDAY.LT.IYBEG(3)  
     +                       .AND.NEWYR.EQ.IYBEG(1))    GO TO 7  
C#### WCH, 8/93.  
               THISTO = 3600.0  
CWCH, 11/22/99. ADD 15-MIN OPTION.  
			 IF(IFORM.EQ.15) THISTO = 900.0  
               ENDIF  
C=======================================================================  
      IF(IFORM.EQ.7) THEN  
                     READ(IO,1050,END=40) YEAR  
                     IF(YEAR.GT.1900) THEN  
c                                      YEAR = YEAR - 1900  
                                      ELSE  
                                      BACKSPACE IO  
                                      READ(IO,1051,ERR=40,END=40) YEAR  
c                                      YEAR = YEAR - 1900  
                                      ENDIF  
                    IF (YEAR.LT.100) YEAR = YEAR + 1900  
                     BACKSPACE IO  
                     IBUF   = ISTA  
                     THISTO = 3600.0  
                     NEWYR  = YEAR  
                     ENDIF  
C=======================================================================  
      IF(IFORM.EQ.8) THEN  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1150,ERR=40,END=40) YEAR  
                     BACKSPACE IO  
                     IBUF   = ISTA  
                     IF (YEAR.LT.100) YEAR = YEAR + 1900  
                     NEWYR  = YEAR  
                     THISTO = 3600.0  
                     ENDIF  
C=======================================================================  
C     Read Rainfall lines 1 to 5 for IFORM = 4 and IFORM = 6.  
C=======================================================================  
      IF(IFORM.EQ.4) THEN  
C=======================================================================  
C                    Open rainfall file  
C======================================================================  
C#### WCH, 8/93.  PERMIT PROCESSED NSCRAT(3) FILE TO BE SAVED.  
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).NE.'SCRT3.UF')  
     +      OPEN(M3,FILE=FFNAME(53),FORM='FORMATTED',STATUS='UNKNOWN')  
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).EQ.'SCRT3.UF')  
     +      OPEN(M3,FORM='FORMATTED',STATUS='SCRATCH')  
                     REWIND M3  
                     WRITE(*,1090)  
                     DO 2000 J = 1,1000000  
                     READ(IO,1080,END=2001) CH  
C=======================================================================  
C                    Change double quotes " in record to single '  
C                    so that character strings can be read by  
C                    List-Directed I/O  
C=======================================================================  
                     DO 30 I = 1,50  
                     IF(CH(I).EQ.'"') CH(I) = SQUOTE  
   30                CONTINUE  
                     WRITE(M3,1080) CH  
 2000                CONTINUE  
 2001                CONTINUE  
                     REWIND M3  
                     READ(M3,*,ERR=888) LN  
                     READ(M3,*,ERR=888) LN,STNAME  
C#### WCH, 8/1/95.  READ STATION AS INTEGER AND CONVERT.  
                     READ(M3,*,ERR=888) LN,IISTA  
                     WRITE(ISTA,'(I8)') IISTA  
C  
                     READ(M3,*,ERR=888) LN,NEWYR,NEWMON,IEY,IEM  
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900  
                     READ(M3,*,ERR=888) LN,ELMTYP  
c                     NEWYR = NEWYR - 1900  
                     IF(ELMTYP.EQ.'QPCP') THISTO = 900.0  
                     IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0  
                     ENDIF  
      IF(IFORM.EQ.6) THEN  
                     M3 = IO  
                     REWIND M3  
                     READ(M3,*,ERR=888) LN  
                     READ(M3,*,ERR=888) LN,STNAME  
C#### WCH, 8/1/95.  READ STATION AS INTEGER AND CONVERT.  
                     READ(M3,*,ERR=888) LN,IISTA  
                     WRITE(ISTA,'(I8)') IISTA  
C  
                     READ(M3,*,ERR=888) LN,NEWYR,NEWMON,IEY,IEM  
               IF (NEWYR.LT.100) NEWYR = NEWYR + 1900  
                     READ(M3,*,ERR=888) LN,ELMTYP  
c                     NEWYR = NEWYR - 1900  
                     IF(ELMTYP.EQ.'QPCP') THISTO = 900.0  
                     IF(ELMTYP.EQ.'HPCP') THISTO = 3600.0  
                     ENDIF  
C=======================================================================  
      ENDIF  
C=======================================================================  
C====> End of IDO = 0 (Executed only once).  
C=======================================================================  
Cwch, 2/9/01  Apparently it is possible to lose value of NEND between   
C     calls to GTRAIN.  So reset value of NEND every call.  Move to  
C     this location between IDO = 0 and IDO = 1.  
C     Suggested by Nerkez Gavranovic, Sydney, Australia  
C#######################################################################  
C    WCH, 8/93.  CHECK FOR COMPATIBILITY OF HYETOGRAPH TIME INTERVALS.  
C#######################################################################  
      IF(HIST.GT.0.0) THEN  
           IF(ABS(HIST-THISTO).GT.0.1) THEN  
                WRITE(N6,9110) THISTO,HIST  
                WRITE(*,9110)  THISTO,HIST  
                STOP  
                ENDIF  
           ELSE  
           HIST = THISTO  
           ENDIF  
C#### WCH, 4/26/94.  
      NEND = 24  
      IF(ABS(HIST-900.0).LE.0.1) NEND = 96  
C=======================================================================  
C     Read the rainfall values (IDO = 1)  
C=======================================================================  
C     CLEAR THIS YEAR'S MATRIX  
C     BACKSPACE FOR A NEW YEAR OR NEW STATION  
C     COMPUTE STARTING DAY NUMBER FOR THIS YEAR  
C=======================================================================  
      IF(IDO.EQ.1) THEN  
C=======================================================================  
C     IF 8 < IFORM < 13, DO ALL CALCULATIONS IN SUB. G9RAIN  
C=======================================================================  
CWCH, 11/22/99. ADD OPTION FOR IFORM .GE.13  
      IF(IFORM.LT.4.OR.IFORM.EQ.5.OR.IFORM.GE.13) BACKSPACE IO  
      CALL SETIA(HOUR,366,27,0)  
cim fix set LIMRN values 11/97  
C     CALL SETIA(RDAY,3000,1,0)  
      CALL SETIA(RDAY,LIMRN,1,0)  
C#### WCH, 4/26/94.  INITIALIZE NEW VARIABLE ACODE.  
      DO 8 I = 1,366  
      DO 8 J = 1,4  
    8 ACODE(I,J) = BLANK  
      IOK    = 0  
C#### WCH, 5/24/94.  DON'T SEE A REASON FOR ILOOP???  
C####      ILOOP  = 0  
      ILOST  = 1  
      NSTORM = 0  
      IDAST  = KDATE(0,1,NEWYR)  
      IF(NEND.EQ.96) REWIND M4  
C=======================================================================  
C     Read this year's rainfall.  
C=======================================================================  
      IF(IFORM.EQ.7) THEN  
                     READ(IO,1050,ERR=40,END=40) YEAR  
                     IF(YEAR.GT.1900) THEN  
c                                      YEAR = YEAR - 1900  
                                      ELSE  
                                      BACKSPACE IO  
                                      READ(IO,1051,ERR=40,END=40) YEAR  
c                                      YEAR = YEAR - 1900  
                                      ENDIF  
                     IF (YEAR.LT.100) YEAR = YEAR + 1900  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     IBUF  = ISTA  
                     NEWYR = YEAR  
                     IDAST = KDATE(0,1,NEWYR)  
                     ENDIF  
      IF(IFORM.EQ.8) THEN  
                     READ(IO,1150,ERR=40,END=40) YEAR  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     READ(IO,1080,ERR=40,END=40) CH(1)  
                     IBUF  = ISTA  
                     IF (YEAR.LT.100) YEAR = YEAR + 1900  
                     NEWYR = YEAR  
                     IDAST = KDATE(0,1,NEWYR)  
                     ENDIF  
C#### WCH, 4/26/94.  INITIALIZE VARIABLE FOR NEW KODEA OPTION.  
      JDOLD = 0  
C=======================================================================  
10    IF(IFORM.EQ.0) READ(IO,1000,ERR=10,END=40) STA,ELMTYP,YEAR,  
     *               MONTH,DAY,IHR,IRAIN,ICODE  
C#### WCH, 8/93.  ZERO OUT ALL 100 CELLS OF ARRAY 'VALUE'.  
      IF(IFORM.EQ.1) CALL SETIA(VALUE,100,1,0)  
Cwch, 7/28/04  
C      IF(IFORM.EQ.1) READ(IO,1060,ERR=10,END=40) STA,ELMTYP,YEAR,  
      IF(IFORM.EQ.1.AND.IFORM1.EQ.0) READ(IO,1060,ERR=10,END=40)   
     *               STA,ELMTYP,YEAR,MONTH,DAY,NUM,(IHOUR(I),  
     *               VALUE(I),FLAG1(I),FLAG2(I),I=1,NUM)  
      IF(IFORM.EQ.1.AND.IFORM1.EQ.1) THEN  
	     NUM = 24  
	     READ(IO,*,ERR=10,END=40)   
     *     STA6,ABUF2,ELMTYP,ABUF2,YEAR,MONTH,DAY,ABUF3,(IHOUR(I),  
     *               VALUE(I),FLAG1(I),FLAG2(I),I=1,NUM)  
	write(n6,*) STA6,ABUF2,ELMTYP,ABUF2,YEAR,MONTH,DAY,ABUF3,  
     *               (IHOUR(I),VALUE(I),FLAG1(I),FLAG2(I),I=1,NUM)  
	     ENDIF  
      IF(IFORM.EQ.2) READ(IO,1040,ERR=10,END=40) STA,YEAR,MONTH,  
     *               DAY,ICARD,XRA  
      IF(IFORM.EQ.5) READ(IO,1045,ERR=10,END=40) STA,YEAR,MONTH,  
     *               DAY,(XRAIN(I),I=1,24)  
C#### WCH, 8/1/95.  ADD NEW AES FORMAT OPTION.  
      IF(IFORM.EQ.13) READ(IO,1046,ERR=10,END=40) STA,YEAR,MONTH,  
     *               DAY,(XRAIN(I),FLAG1(I),I=1,24)  
CWCH, 11/22/99. ADD TWO NEW AES FORMATS.  
      IF(IFORM.EQ.14) READ(IO,1047,ERR=10,END=40) STA,YEAR,MONTH,  
     *               DAY,(XRAIN(I),FLAG1(I),I=1,24)  
      IF(IFORM.EQ.15) READ(IO,1048,ERR=10,END=40) STA,YEAR,MONTH,  
     *               DAY,(XRAIN(I),FLAG1(I),I=1,96)  
                     IF (YEAR.LT.100) YEAR = YEAR + 1900  
      IF(IFORM.EQ.7) THEN  
                     READ(IO,1085,ERR=49,END=40) MONTH,DAY,  
     +                                           (YRAIN(I),I=1,12)  
                     READ(IO,1095,ERR=10,END=40) (YRAIN(I),I=13,24)  
                     ILOST = 0  
                     IF(IYBEG(1).NE.0.AND.YEAR.LT.IYBEG(1))  GO TO 10  
                     IF(MONTH.LT.IYBEG(2).AND.  
     +                                     YEAR.EQ.IYBEG(1)) GO TO 10  
                     IF(MONTH.LE.IYBEG(2).AND.DAY.LT.IYBEG(3)  
     +                                .AND.YEAR.EQ.IYBEG(1)) GO TO 10  
                     STA   = ISTA  
                     ILOST = 1  
                     ENDIF  
      IF(IFORM.EQ.8) THEN  
                     READ(IO,1155,ERR=40,END=40) MONTH,DAY,XRAIN  
                     STA   = ISTA  
                     ILOST = 0  
                     IF(MONTH.EQ.0) GO TO 10  
                     IF(IYBEG(1).NE.0.AND.YEAR.LT.IYBEG(1))  GO TO 10  
                     IF(MONTH.LT.IYBEG(2).AND.  
     +                                     YEAR.EQ.IYBEG(1)) GO TO 10  
                     IF(MONTH.LE.IYBEG(2).AND.DAY.LT.IYBEG(3)  
     +                                .AND.YEAR.EQ.IYBEG(1)) GO TO 10  
                     ILOST = 1  
                     ENDIF  
C=======================================================================  
C#### 8/1/95.  ADD CHECK FOR ZERO YEAR/MONTH/DAY.  LIKELY CAUSED BY  
C     EXTRA CARRIAGE RETURN AT END OF INPUT ASCII DATA FILE.  
C=======================================================================  
      IF(IFORM.NE.4.AND.IFORM.NE.6) THEN  
           IF(YEAR.LE.0.OR.MONTH.LE.0.OR.DAY.LE.0) THEN  
                WRITE(N6,9655) IO  
                GO TO 40  
                ENDIF  
           ENDIF  
C=======================================================================  
C     NCDC Release B Condensed data.  
C     IFORM = 4 or 6.  Read Rainfall lines 8 and 9 (first column)  
C       for microcomputer format.  
C=======================================================================  
      IF(IFORM.EQ.4.OR.IFORM.EQ.6) THEN  
                     READ(M3,*,END=940,ERR=950,IOSTAT=IOS) LN  
                     IF(LN.EQ.10) GO TO 40  
                     BACKSPACE M3  
C=======================================================================  
C     Here, should be reading data line LN = 8.  
C=======================================================================  
                     READ(M3,*,ERR=950,IOSTAT=IOS) LN,YEAR,MONTH,DAY,  
     1                     UNITS,NR  
                     IF (YEAR.LT.100) YEAR = YEAR + 1900  
CIM    here year 1948 comes over as 948   
CIM    I guess that 2000 will be 000  
                     IF (YEAR.LT.1000) THEN  
	                     IF (YEAR.GT.500) THEN  
	                     YEAR = YEAR + 1000  
	                     ELSE  
	                     YEAR = YEAR + 2000  
	                     ENDIF  
	                 ENDIF  
c                     YEAR    = YEAR - 900  
                     IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.  
     +               MONTH.GE.IYEND(2).AND.DAY.GT.IYEND(3))  GO TO 40  
                     IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.  
     +               MONTH.GT.IYEND(2))                      GO TO 40  
                     IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))  GO TO 40  
C=======================================================================  
C      BACKSPACE AND RETURN FOR FIRST ENTRY OF NEXT YEAR IN ORDER  
C      RECORD/ANALYZE DATA FOR PRIOR YEAR AND INCREMENT NEWYR.  
C      BUT ONLY DO IT IF DATA HAVE BEEN FOUND, IOK=1.  
C=======================================================================  
                     IF(YEAR.GT.NEWYR.AND.IOK.EQ.1) THEN  
                                                    BACKSPACE M3  
                                                    RETURN  
                                                    ENDIF  
                     IF(IYBEG(1).NE.0.AND.YEAR.LT.IYBEG(1))  GO TO 55  
                     IF(MONTH.LT.IYBEG(2).AND.  
     +                                     YEAR.EQ.IYBEG(1)) GO TO 55  
                     IF(MONTH.LE.IYBEG(2).AND.DAY.LT.IYBEG(3)  
     +                                .AND.YEAR.EQ.IYBEG(1)) GO TO 55  
C=======================================================================  
C      ALSO BACKSPACE AND RETURN IF THIS IS FIRST DAY OF STARTING YEAR.  
C      IN THIS CASE, NO RAIN WOULD HAVE BEEN READ, IOK=0.  
C      DO THIS IN ORDER TO INCREMENT NEWYR AND GET CORRECT IDAST.  
C=======================================================================  
                     IF(IYBEG(1).NE.0.AND.YEAR.EQ.IYBEG(1)  
     1                  .AND.YEAR.GT.NEWYR.AND.IOK.EQ.0) THEN  
                          IF(MONTH.EQ.IYBEG(2).AND.DAY.EQ.IYBEG(3)) THEN  
                               NEWYR = YEAR  
                               ILOST = 0  
                               BACKSPACE M3  
                               RETURN  
                               ENDIF  
                          ENDIF  
C#### WCH, 5/24/94.  DON'T SEE A REASON FOR ILOOP???  
C####                     ILOOP   = ILOOP + 1  
C####                     IF(ILOOP.EQ.1)                          GO TO 55  
C=======================================================================  
C     HERE, FINALLY, READ THE ACTUAL PRECIP. VALUES. (DATA LINE LN = 9)  
C     NEED SEPARATE READS FOR HOURLY AND 15-MIN. DATA.  
C=======================================================================  
C#### WCH, 4/26/94.  
C     ALLOW FOR AVERAGING OF NCDC VALUES WITH "A" (ACCUMULATED TOTALS),  
C     OR ELSE THE OPTION FOR USING THAT RAINFALL VALUE LUMPED AT THE  
C     TIME INDICATED FOR THE "A".  
C  
C     KODEA = 0, OLD PROCEDURE.  DON'T INCLUDE ACCUMULATED TOTALS, BUT  
C                DO KEEP A TOTAL AT END OF EVENT SUMMARY.  
C     KODEA = 1, AVERAGE ACCUMULATED TOTAL OVER PRECEDING HOURS SINCE  
C                LAST "A", "I", OR "M" VALUE OR FROM BEGINNING OF DAY.  
C     KODEA = 2, USE ACCUMULATED TOTAL AS RAINFALL AT TIME OF "A".  
C=======================================================================  
C     SAVE OLD TIME FOR KODEA = 1 OPTION.  
C=======================================================================  
                     JD1    = JDATE(DAY,MONTH,YEAR)  
                     JULDAY = JD1 + YEAR*1000  
                     IHROLD = 1  
                     MINOLD = 0  
                     RHOURO = 0.0  
                     MIN    = 0  
                     DO 50 J = 1,NR  
                     IF(NEND.LT.96) READ(M3,*,ERR=960,IOSTAT=IOS)  
     1                       LN,IHR,IRAIN,ICODE  
                     IF(NEND.EQ.96) READ(M3,*,ERR=960,IOSTAT=IOS)  
     1                       LN,IHR,MIN,IRAIN,ICODE  
C#######################################################################  
C  WCH, 3/2/93 AND 10/8/93.  
C  LAST ENTRY IS TOTAL FOR DAY.  SKIP CALCULATIONS FOR THIS CASE.  
C#######################################################################  
                     IF(ICODE.EQ.'0') ICODE = BLANK  
                     IF(J.EQ.NR) THEN  
                          CALL RAINCD(ICODE,JD1)  
                          GO TO 50  
                          ENDIF  
                     IF(IRAIN.GE.99999) THEN  
                                        IRAIN = 0  
                                        ICODE = IM  
                                        IF(KODEA.EQ.1) THEN  
C=======================================================================  
C    HERE, SAVE ENDING TIME OF MISSING RAINFALL VALUE, FOR HOURLY DATA  
C=======================================================================  
C#### WCH, 12/6/96. SEVERAL REPLACED STATEMENTS UP TO COMMENT OF 4/26/94  
                                           IF(NEND.EQ.24) THEN  
                                               IHROLD = IHR  
                                               MINOLD = 0  
                                               RHOURO = FLOAT(IHR)*3600.  
                                               ELSE  
C=======================================================================  
C    HERE, SAVE STARTING TIME OF MISSING RAINFALL VALUE, FOR 15-MIN DATA  
C=======================================================================  
                                               IHRSO  = IHR  
                                               MINOLD = MIN - 15  
                                               IF(MINOLD.EQ.-15) THEN  
                                                  MINOLD = 45  
                                                  IHRSO  = IHRSO - 1  
                                                  ENDIF  
                                               IHROLD = IHRSO + 1  
                                               RHOURO = FLOAT(IHRSO)*  
     1                                          3600.+FLOAT(MINOLD)*60.  
                                               ENDIF  
                                           ENDIF  
                                        ENDIF  
C#######################################################################  
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT.  
C=======================================================================  
                     CALL RAINCD(ICODE,JD1)  
                     IOK   = 1  
                     ILOST = 1  
                     IDAY  = KDATE(DAY,MONTH,YEAR) - IDAST  
C#### WCH, 8/93  
C=======================================================================  
C#### WCH, 12/6/96.  NEED TO COMPUTE IHRS AND RECOMPUTE MIN EVEN IF  
C     THERE IS NO RAIN, IN EVENT THEY ARE NEEDED FOR AVERAGING OF  
C     ACCUMULATED DATA.  SO, PUT IRAIN GT OR EQ 0 CHECKS INSIDE LOOP  
C     FOR NEND.EQ.96 (15 MIN DATA).  
C=======================================================================  
C####                     IF(NEND.EQ.96.AND.IRAIN.GT.0) THEN  
                     IF(NEND.EQ.96) THEN  
C=======================================================================  
C  FOR 15-MIN. DATA, COMPUTE STARTING HOUR AND MINUTE (IHRS, 0-23 AND  
C    MIN, 0-45) AND ENDING HOUR (IHR, 1-24).  
C    RELEASE-B CONDENSED HAS HOURS GOING FROM 0-24 AND MINUTES  
C    FROM 0 - 45.  SMALLEST TIME SHOULD BE HR=0 AND  
C    MIN=15 AND LARGEST TIME SHOULD BE HR = 24 AND MIN = 0.  HOWEVER  
C    PROTECT AGAINST POSSIBILITY OF HR = 0 AND MIN = 0 IN CODE AND  
C    AGAINST POSSIBILITY OF HR = 24 AND MIN > 0.  
C    NOTE THAT TIMES IN DATA (IHR,MIN) ARE ENDING TIMES OF RAINFALL.  
C=======================================================================  
                        IHRS = IHR  
                        MIN = MIN - 15  
                        IF(MIN.EQ.-15) THEN  
                             MIN = 45  
                             IHRS = IHRS - 1  
                             ENDIF  
                        IHR  = IHRS + 1  
                        JPJDAY = JULDAY  
C#### WCH, 10/8/93.  WORRY ABOUT RAIN ENDING EXACTLY AT MIDNITE AND IHR=0.  
C#### JUST IN CASE HR=0 AND MIN=0 START SHOWING UP ON INPUT DATA:  
                        IF(IHRS.EQ.-1.AND.MIN.EQ.45) THEN  
                           IHR  = 1  
                           IHRS = 23  
                           IF(JULDAY-(JULDAY/1000)*1000.GT.1) THEN  
                               JPJDAY = JPJDAY - 1  
                               ELSE  
                               JPJDAY = JDATE(31,12,YEAR-1) +  
     1                                   (YEAR-1)*1000  
                               ENDIF  
                           ENDIF  
                        RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0  
C=======================================================================  
C#### WCH, 12/6/96.  HERE, PUT IN CHECK FOR RAIN OR NO RAIN.  
C=======================================================================  
                        IF(IRAIN.GT.0) THEN  
C=======================================================================  
C  IF KODEA = 1, PLACE AVERAGE ON FILE DURING INTERVENING HOURS.  
C  NOTE, EXTRA AVERAGING INTERVAL IS ADDED IN SUB. RAINAVG TO ACCOUNT  
C  FOR GETTING TO END OF CURRENT INTERVAL THAT CONTAINS "A" CODE.  
C=======================================================================  
                             IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN  
                                CALL RAINAVG(RHOUR,RHOURO,JPJDAY,  
     1                            IDAY,IHROLD,MINOLD,NEND,IRAIN,M4)  
                                ICODE = ' '  
C=======================================================================  
C  PLACE 15-MIN. PRECIP. VALUE ON SCRATCH FILE IN UNITS OF INCHES/HOUR.  
C=======================================================================  
                                ELSE  
                                REIN  = FLOAT(IRAIN)/100.0/0.25  
                                WRITE(M4) JPJDAY,RHOUR,THISTO,REIN  
                                HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN  
                                ENDIF  
C  
C#### WCH, 12/6/96.  
C####                    ELSE IF(NEND.EQ.96) THEN  
C####                    IHR = IHR + 1  
                             ELSE IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN  
C####                    RHOURO = FLOAT(IHR-1)*3600.+FLOAT(MIN)*60.  
C=======================================================================  
C     HERE HAVE ACCUMULATION CODE ("A") BUT NO RAIN.  UNLIKELY, BUT  
C     POSSIBLE.  
C=======================================================================  
                                  RHOURO = RHOUR  
                                  IHROLD = IHR  
                                  MINOLD = MIN  
                                  ENDIF  
                        ENDIF  
C=======================================================================  
C#### WCH, 10/8/93.  RECOGNIZE POSSIBLE ERROR WHEN 15-MIN RAINFALL ENDS  
C       AT MIDNIGHT.  PREVIOUS 15-MIN INCREMENT COUNTED IN FIRST HOUR  
C       OF NEXT DAY FOR PRINT-OUT OF HOURLY TOTALS, ONLY.  SHOULD BE  
C       CORRECT ON PRECIPITATION INTERFACE FILE.  
C=======================================================================  
                     IF(IHR.GT.24) IHR = 24  
                     IF(NEND.EQ.24) THEN  
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA  
     1                              .AND.IRAIN.GT.0) THEN  
C=======================================================================  
C     SUBTRACT HOUR FROM END HOUR BECAUSE EXTRA INTERVAL IS ADDED IN  
C     SUB. RAINAVG.  
C=======================================================================  
                           RHOUR = FLOAT(IHR-1)*3600.  
                           CALL RAINAVG(RHOUR,RHOURO,JPJDAY,  
     1                       IDAY,IHROLD,MINOLD,NEND,IRAIN,M4)  
                           ICODE = ' '  
                           ELSE  
                           HOUR(IDAY,IHR) = IRAIN + HOUR(IDAY,IHR)  
                           ENDIF  
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA.AND.  
     1                                          IRAIN.EQ.0) THEN  
                           RHOURO = FLOAT(IHR)*3600.  
                           IHROLD = IHR  
                           ENDIF  
                        ENDIF  
C=======================================================================  
C                    Special codes for missing rainfall.  
C=======================================================================  
                     IF(ICODE.EQ.IA.AND.KODEA.EQ.0) THEN  
                                     HOUR(IDAY,IHR) = -2  
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV  
                                     ENDIF  
C#### WCH, 12/6/96.  DON'T DO THIS FOR 15-MIN DATA.  
                     IF(NEND.EQ.24.AND.ICODE.EQ.IM) HOUR(IDAY,IHR) = -1  
   50                CONTINUE  
                     GO TO 52  
C=======================================================================  
C     Here if need to read data to advance file before arriving at  
C     desired start time.  
C=======================================================================  
   55                CONTINUE  
                     ILOST = 0  
                     IF(YEAR.GT.NEWYR) THEN  
                                       NEWYR = YEAR  
                                       BACKSPACE M3  
                                       RETURN  
                                       ENDIF  
                     DO 51 J = 1,NR  
C#### WCH, 10/8/93.  NEED SEPARATE READS FOR HOURLY AND 15-MIN.  
                     IF(NEND.LT.96) READ(M3,*,ERR=950,IOSTAT=IOS)  
     1                    LN,IHR,IRAIN,ICODE  
                     IF(NEND.EQ.96) READ(M3,*,ERR=950,IOSTAT=IOS)  
     1                    LN,IHR,MIN,IRAIN,ICODE  
   51                CONTINUE  
                     NEWYR = YEAR  
                     IDAST = KDATE(0,1,NEWYR)  
   52                CONTINUE  
                     ENDIF  
C=======================================================================  
C     Check for same station.     Check for same year.  
C     Add to this year's matrix.  Find the day number and indicate  
C                                 unusual conditions.  
C     Hour =  -2 means meter stuck.  
C     Hour =  -1 means missing data.  
C=======================================================================  
      IF((IFORM.EQ.4.OR.IFORM.EQ.6).AND.IOK.EQ.0)  GO TO 10  
      IF((IFORM.EQ.4.OR.IFORM.EQ.6).AND.IOK.EQ.1)  GO TO 777  
C#### WCH, 8/1/95.  ELIMINATE THIS CHECK.  
C####      IF(STA.NE.ISTA) GO TO 40  
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GE.IYEND(2)  
     *                   .AND.DAY.GT.IYEND(3))   GO TO 40  
      IF(IYEND(1).NE.0.AND.YEAR.EQ.IYEND(1).AND.MONTH.GT.IYEND(2))  
     *                                           GO TO 40  
      IF(IYEND(1).NE.0.AND.YEAR.GT.IYEND(1))     GO TO 40  
      IF(YEAR.GT.NEWYR)                          RETURN  
      IDAY = KDATE(DAY,MONTH,YEAR) - IDAST  
C=======================================================================  
C#### WCH, 8/1/95.  ADD CHECK FOR SUBSCRIPT.  
      IF(IDAY.LE.0.OR.IDAY.GT.366) THEN  
           WRITE(N6,9660) IDAY,YEAR,MONTH,DAY,NEWYR  
           WRITE (*,9660) IDAY,YEAR,MONTH,DAY,NEWYR  
           GO TO 40  
           ENDIF  
C=======================================================================  
C     Special codes for new format of rainfall.  
C=======================================================================  
C     NCDC, TD-3240, fixed length records (one rainfall value per line).  
C=======================================================================  
      IF(IFORM.EQ.0) THEN  
C=======================================================================  
C     SAVE OLD TIME FOR KODEA = 1 OPTION.  
C=======================================================================  
                     JD1   = JDATE(DAY,MONTH,YEAR)  
                     JDNEW = JD1 + YEAR*1000  
                     IF(KODEA.EQ.1) THEN  
                        IF(JDNEW.GT.JDOLD.OR.JD1.EQ.1) THEN  
                           IHROLD = 1  
                           MINOLD = 0  
                           RHOURO = 0.0  
                           JDOLD  = JDNEW  
                           ENDIF  
                        ENDIF  
C  
                     IF(IRAIN.GE.99999) THEN  
                              IRAIN = 0  
                              ICODE = IM  
                              IF(KODEA.EQ.1) THEN  
C=======================================================================  
C    HERE, SAVE ENDING TIME OF MISSING RAINFALL VALUE, FOR HOURLY DATA  
C=======================================================================  
C#### WCH, 12/6/96. SEVERAL REPLACED STATEMENTS UP TO COMMENT OF 4/26/94  
                                   IF(NEND.EQ.24) THEN  
                                       IHROLD = IHR  
                                       MINOLD = 0  
                                       RHOURO = FLOAT(IHR)*3600.  
                                       ELSE  
C=======================================================================  
C    HERE, SAVE STARTING TIME OF MISSING RAINFALL VALUE, FOR 15-MIN DATA  
C=======================================================================  
                                       IHRSO  = IHR/100  
                                       MINOLD = IHR - (IHR/100)*100 - 15  
                                       IF(MINOLD.EQ.-15) THEN  
                                            MINOLD = 45  
                                            IHRSO  = IHRSO - 1  
                                            ENDIF  
                                       IHROLD = IHRSO + 1  
                                       RHOURO = FLOAT(IHRSO)*  
     1                                     3600.+FLOAT(MINOLD)*60.  
                                       ENDIF  
                                   ENDIF  
                              ENDIF  
C#######################################################################  
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT.  
C=======================================================================  
                     CALL RAINCD(ICODE,JD1)  
C#### WCH, 8/93  
C#### WCH, 12/6/96.  CHECK FOR IRAIN.GT.0 LATER.  
C####                     IF(NEND.EQ.96.AND.IRAIN.GT.0) THEN  
                     IF(NEND.EQ.96) THEN  
C=======================================================================  
C  FOR 15-MIN. DATA, COMPUTE STARTING HOUR AND MINUTE (IHRS, 0-23 AND  
C    MIN, 0-45) AND ENDING HOUR (IHR, 1-24)  
C  FORM OF IHR IS HRMN WHERE HR = HOUR, FROM 0 - 24, AND MN = MIN, E.G.,  
C    0045, 1530, 2300.  THIS IS END TIME OF RAINFALL VALUE.  
C=======================================================================  
                        MIN  = IHR - (IHR/100)*100 - 15  
                        IHRS = IHR/100  
                        IF(MIN.LT.0) THEN  
                           MIN  = 45  
                           IHRS = IHRS - 1  
                           ENDIF  
                        IHR  = IHRS + 1  
C#### WCH, 12/6/96.  NEED TO COMPUTE RHOUR HERE.  
                        RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0  
                        IF(IRAIN.GT.0) THEN  
C#### WCH, 4/25/94.  DON'T SUBTRACT 1900 FROM YEAR.  ALREADY 2-DIGIT.  
                           JULDAY = JDATE(DAY,MONTH,YEAR)  
     1                                 + YEAR*1000  
C####                RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0  
C=======================================================================  
C  IF KODEA = 1, PLACE AVERAGE ON FILE DURING INTERVENING HOURS.  
C=======================================================================  
                           IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN  
                                CALL RAINAVG(RHOUR,RHOURO,JULDAY,  
     1                           IDAY,IHROLD,MINOLD,NEND,IRAIN,M4)  
                                ICODE = ' '  
                                JDOLD = JULDAY  
C=======================================================================  
C  PLACE 15-MIN. PRECIP. VALUE ON SCRATCH FILE IN UNITS OF INCHES/HOUR.  
C=======================================================================  
                                ELSE  
                                REIN  = FLOAT(IRAIN)/100.0/0.25  
                                WRITE(M4) JULDAY,RHOUR,THISTO,REIN  
                                HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN  
                                ENDIF  
C#### WCH, 12/6/96  
C####                           ENDIF  
C####                        ELSE IF(NEND.EQ.96.AND.KODEA.EQ.1.AND.  
C####     1                            ICODE.EQ.IA) THEN  
                           ELSE IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN  
                                   IHROLD = IHR  
                                   MINOLD = MIN  
C####                   RHOURO = FLOAT(IHRS)*3600.+FLOAT(MIN)*60.  
                                   RHOURO = RHOUR  
                                   ENDIF  
                           ENDIF  
C=======================================================================  
C  ALLOW AVERAGING OF HOURLY RAINFALL ALSO.  
C=======================================================================  
                     IF(NEND.EQ.24) THEN  
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA  
     1                             .AND.IRAIN.GT.0) THEN  
                           RHOUR = FLOAT(IHR-1)*3600.  
                           CALL RAINAVG(RHOUR,RHOURO,JDNEW,  
     2                          IDAY,IHROLD,MINOLD,NEND,IRAIN,M4)  
                           ICODE = ' '  
                           JDOLD = JDNEW  
                           ELSE  
                           HOUR(IDAY,IHR) = IRAIN + HOUR(IDAY,IHR)  
                           ENDIF  
                        IF(KODEA.EQ.1.AND.ICODE.EQ.IA) THEN  
                           RHOURO = FLOAT(IHR)*3600.  
                           IHROLD = IHR  
                           JDOLD = JDNEW  
                           ENDIF  
                        ENDIF  
C  
                     IF(ICODE.EQ.IA.AND.KODEA.EQ.0) THEN  
                                     HOUR(IDAY,IHR) = -2  
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV  
                                     ENDIF  
C#### WCH, 12/6/96.  DON'T DO THIS FOR 15-MIN DATA.  
                     IF(NEND.EQ.24.AND.ICODE.EQ.IM) HOUR(IDAY,IHR) = -1  
                     ENDIF  
C=======================================================================  
C     NCDC TD-3240/3260, variable length records (data for all hours on  
C     one line).  This format is also for "NCDC format" for exporting  
C     of data from EarthInfo and Hydrosphere CD-ROMs.  
C=======================================================================  
      IF(IFORM.EQ.1) THEN  
                     IF(KODEA.EQ.1) THEN  
                        IHROLD = 1  
                        MINOLD = 0  
                        RHOURO = 0.0  
                        ENDIF  
                     ICODE = ' '  
C#### WCH, 12/6/96.  PLACE THIS DATE CALCULATION OUTSIDE LOOP.  
                     JD1 = JDATE(DAY,MONTH,YEAR)  
                     JULDAY = JD1 + YEAR*1000  
C  
                     DO 8000 I = 1,NUM  
                     IRAIN     = VALUE(I)  
                     IF(IRAIN.GE.99999) THEN  
                              IRAIN = 0  
                              ICODE = IM  
                              IF(KODEA.EQ.1) THEN  
C=======================================================================  
C    HERE, SAVE ENDING TIME OF MISSING RAINFALL VALUE, FOR HOURLY DATA  
C=======================================================================  
C#### WCH, 12/6/96. SEVERAL REPLACED STATEMENTS UP TO COMMENT OF 4/26/94  
                                   IF(NEND.EQ.24) THEN  
                                       IHR    = IHOUR(I)/100  
                                       IHROLD = IHR  
                                       MINOLD = 0  
                                       RHOURO = FLOAT(IHR)*3600.  
                                       ELSE  
C=======================================================================  
C    HERE, SAVE STARTING TIME OF MISSING RAINFALL VALUE, FOR 15-MIN DATA  
C=======================================================================  
                                       IHR   = IHOUR(I)  
                                       IHRSO = IHR/100  
                                       MINOLD = IHR - (IHR/100)*100 - 15  
                                       IF(MINOLD.EQ.-15) THEN  
                                            MINOLD = 45  
                                            IHRSO  = IHRSO - 1  
                                            ENDIF  
                                       IHROLD = IHRSO + 1  
                                       RHOURO = FLOAT(IHRSO)*  
     1                                     3600.+FLOAT(MINOLD)*60.  
                                       ENDIF  
                                   ENDIF  
                              ENDIF  
C#######################################################################  
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT.  
C=======================================================================  
                     IKODE = BLANK  
                     IF(ICODE.NE.BLANK)    IKODE = ICODE  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
                     IF(FLAG1(I).NE.BLANK) IKODE = FLAG1(I)  
                     CALL RAINCD(IKODE,JD1)  
                     IF(I.EQ.NUM) GO TO 8000  
C#######################################################################  
C  WCH, 8/93,  Need to perform this time calculation for both 15-min.  
C    and hourly data because IHOUR is of form HRMN, e.g.,  
C    2330, 0015, etc.  
C#######################################################################  
                     IHR  = IHOUR(I)  
                     MIN  = IHR - (IHR/100)*100 - 15  
                     IHRS = IHR/100  
                     IF(MIN.LT.0) THEN  
                        MIN  = 45  
                        IHRS = IHRS - 1  
                        ENDIF  
                     IHR  = IHRS + 1  
C#### WCH, 12/6/96.  CHECK FOR ZERO RAIN LATER.  
                     IF(NEND.EQ.96) THEN  
C####                     IF(NEND.EQ.96.AND.IRAIN.GT.0) THEN  
C#### WCH, 4/25/94.  DON'T SUBTRACT 1900 FROM YEAR.  ALREADY 2-DIGIT.  
                          RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0  
C=======================================================================  
C  IF KODEA = 1, PLACE AVERAGE ON FILE DURING INTERVENING HOURS.  
C=======================================================================  
C#### WCH, 12/6/96  
                          IF(IRAIN.GT.0) THEN  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
                             IF(KODEA.EQ.1.AND.FLAG1(I).EQ.IA) THEN  
                                 CALL RAINAVG(RHOUR,RHOURO,JULDAY,  
     1                             IDAY,IHROLD,MINOLD,NEND,IRAIN,M4)  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
                                 FLAG1(I) = ' '  
                                 JDOLD = JULDAY  
C=======================================================================  
C  PLACE 15-MIN. PRECIP. VALUE ON SCRATCH FILE IN UNITS OF INCHES/HOUR.  
C=======================================================================  
                                 ELSE  
                                 REIN  = FLOAT(IRAIN)/100.0/0.25  
                                 WRITE(M4) JULDAY,RHOUR,THISTO,REIN  
                                 HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN  
                                 ENDIF  
C  
C#### WCH, 12/6/96  
                             ELSE IF(FLAG1(I).EQ.IA.AND.KODEA.EQ.1) THEN  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
C####                        ELSE IF(NEND.EQ.96.AND.FLAG1(I).EQ.IA.AND.  
C####     1                      KODEA.EQ.1) THEN  
                                 IHROLD = IHR  
                                 MINOLD = MIN  
C####                   RHOURO = FLOAT(IHRS)*3600.+FLOAT(MIN)*60.  
                                 RHOURO = RHOUR  
                                 ENDIF  
                          ENDIF  
C=======================================================================  
C  ALLOW AVERAGING OF HOURLY RAINFALL ALSO.  
C=======================================================================  
                     IF(NEND.EQ.24) THEN  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
                        IF(KODEA.EQ.1.AND.FLAG1(I).EQ.IA  
     1                                 .AND.IRAIN.GT.0) THEN  
                           RHOUR = FLOAT(IHR-1)*3600.  
                           CALL RAINAVG(RHOUR,RHOURO,JDNEW,  
     1                          IDAY,IHROLD,MINOLD,NEND,IRAIN,M4)  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
                           FLAG1(I) = ' '  
                           ELSE  
                           HOUR(IDAY,IHR) = IRAIN + HOUR(IDAY,IHR)  
                           ENDIF  
C#### WCH, 5/24/94.  CHANGE SUBSCRIPT 1 TO I FOR FLAG1().  
                        IF(KODEA.EQ.1.AND.FLAG1(I).EQ.IA) THEN  
                           RHOURO = FLOAT(IHR)*3600.  
                           IHROLD = IHR  
                           ENDIF  
                        ENDIF  
C  
                     IF(FLAG1(I).EQ.IA.AND.KODEA.EQ.0) THEN  
                                     HOUR(IDAY,IHR) = -2  
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV  
                                     ENDIF  
C#### WCH, 12/6/96.  DON'T DO THIS FOR 15-MIN DATA.  
                     IF(NEND.EQ.24.AND.ICODE.EQ.IM) HOUR(IDAY,IHR) = -1  
 8000                CONTINUE  
                     ENDIF  
C=======================================================================  
C     NWS Card Deck 488 format.  
C     Special codes for old format of rainfall.  
C=======================================================================  
      IF(IFORM.EQ.2) THEN  
                     IF(ICARD.EQ.1) J1 =  0  
                     IF(ICARD.EQ.2) J1 = 12  
                     DO 35 J = 1,12  
                     IF(XRA(J).EQ.ZIM) THEN  
                                       HOUR(IDAY,J+J1) = -2  
C#### WCH, 4/26/94.  
                             CALL RAINCD(IA,IDAY)  
                                       GO TO 35  
                                       ENDIF  
                     IF(XRA(J).EQ.BIB) THEN  
                                       HOUR(IDAY,J+J1) = -1  
C#### WCH, 4/26/94.  
                             CALL RAINCD(IM,IDAY)  
                                       GO TO 35  
                                       ENDIF  
                     IF(XRA(J).EQ.BLK) THEN  
                                       HOUR(IDAY,J+J1) = 0  
                                       GO TO 35  
                                       ENDIF  
                     HOUR(IDAY,J+J1) = INTCHR(XRA(J))  
35                   CONTINUE  
                     ENDIF  
C=======================================================================  
C     Special codes for AES Canadian data.  
C=======================================================================  
C#### WCH, 8/1/95.  ADD NEW FORMAT OPTION, IFORM = 13.  
CWCH, 11/22/99. ADD FORMAT FOR 4-DIGIT YEAR (IFORM = 14).  
      IF(IFORM.EQ.5.OR.IFORM.EQ.13.OR.IFORM.EQ.14) THEN  
                     DO 45 J = 1,24  
                     IF(XRAIN(J).GE.9999) THEN  
                             SUM(1)       = SUM(1)+FLOAT(XRAIN(J))*CONV  
                             HOUR(IDAY,J) = -2  
C#### WCH, 4/26/94.  
                             CALL RAINCD(IA,IDAY)  
C#### WCH, 8/1/95.  IF THERE IS A FLAG, PRINT IT.  
CWCH, 11/22/99. CHANGE TO .GE.13  
                             IF(IFORM.GE.13) CALL RAINCD(FLAG1(J),IDAY)  
                             GO TO 45  
                             ENDIF  
C     Code for missing data is -1. (AES value = -99999)  
                     IF(XRAIN(J).LE.-999) THEN  
                             HOUR(IDAY,J) = -1  
C#### WCH, 4/26/94.  
                             CALL RAINCD(IM,IDAY)  
C#### WCH, 8/1/95.  IF THERE IS A FLAG, PRINT IT.  
CWCH, 11/22/99. CHANGE TO .GE.13  
                             IF(IFORM.GE.13) CALL RAINCD(FLAG1(J),IDAY)  
                             GO TO 45  
                             ENDIF  
C#### WCH, 8/1/95.  IF THERE IS A FLAG, PRINT IT.  
CWCH, 11/22/99. MAKE .GE.13  
                     IF(IFORM.GE.13) CALL RAINCD(FLAG1(J),IDAY)  
                     HOUR(IDAY,J)         = XRAIN(J)  
45                   CONTINUE  
                     ENDIF  
C=======================================================================  
CWCH, 11/22/99.  AES 15-min precip. data.  
C	Now more properly called CMC or NCDA format?  
C     AES "ELEM" code = 159 for FIF21 (15-min precip).  
C     Take format from Web page at:  
C     http://www.cmc.ec.gc.ca/climate/document.htm  
C=======================================================================  
      IF(IFORM.EQ.15) THEN  
                     JD1 = JDATE(DAY,MONTH,YEAR)  
                     JULDAY = JD1 + YEAR*1000  
	               NUM = 96  
C  
                     DO 808 I = 1,NUM  
                     IRAIN     = XRAIN(I)  
C     Don't fully understand AES format, so don't allow for special  
C     computations for missing or accumulated data.    
                     IF(IRAIN.LE.-999) THEN  
                              IRAIN = 0  
                              ICODE = IM  
                              ENDIF  
C#######################################################################  
C#### WCH, 4/26/94.  MAKE NOTE OF SPECIAL CODES FOR EVENT PRINT-OUT.  
C=======================================================================  
                     IKODE = BLANK  
                     IF(FLAG1(I).NE.BLANK) IKODE = FLAG1(I)  
                     CALL RAINCD(IKODE,JD1)  
C=======================================================================  
C     Compute hour and minute of start of interval.  
C     IHR  = 1-24 = subscript.  
C     IHRS = 0-23 = starting hour.  
C=======================================================================  
                     IHR  = (I-1)/4 + 1  
	               IHRS = IHR - 1  
                     MIN  = (I - 1 - IHRS*4)*15  
                     RHOUR = FLOAT(IHRS)*3600.0 + FLOAT(MIN)*60.0  
                     IF(IRAIN.GT.0) THEN  
C=======================================================================  
C     Intensity is 15-min. depth/.25 hr and divided by conversion factor  
C     of 0.1 to get mm/hr.   
C=======================================================================  
                                 REIN  = FLOAT(IRAIN)/0.1/0.25  
                                 WRITE(M4) JULDAY,RHOUR,THISTO,REIN  
                                 HOUR(IDAY,IHR) = HOUR(IDAY,IHR) + IRAIN  
                                 ENDIF  
                     IF(FLAG1(I).EQ.IA.AND.KODEA.EQ.0) THEN  
                                     HOUR(IDAY,IHR) = -2  
                                     SUM(1) = SUM(1) + FLOAT(IRAIN)*CONV  
                                     ENDIF  
  808                CONTINUE  
                     ENDIF  
C=======================================================================  
C     Earth Info precipitation data.  
C     Old format, data retrieved from display.  For new ASCII files,  
C       use Subroutine G9RAIN (IFORM = 9-12).  
C=======================================================================  
      IF(IFORM.EQ.7) THEN  
                     DO 60 J       = 1,24  
                     HOUR(IDAY,J)  = IFIX(YRAIN(J)*100.0+0.1)  
60                   CONTINUE  
                     ENDIF  
C=======================================================================  
C     Earth Info Precipitation data.  
C=======================================================================  
      IF(IFORM.EQ.8) THEN  
                     DO 65 J       = 1,24  
                     HOUR(IDAY,J)  = XRAIN(J)  
65                   CONTINUE  
                     ENDIF  
C=======================================================================  
 777  HOUR(IDAY,25) = MONTH  
      HOUR(IDAY,26) =   DAY  
      HOUR(IDAY,27) =  YEAR  
      GO TO 10  
      ENDIF  
C=======================================================================  
C     Skip if the new station is not the station selected.  
C     Return if the new year is less than the selected ending year.  
C=======================================================================  
   49 RETURN  
C=======================================================================  
  940 WRITE(N6,9400) M3  
   40 IGO = 1  
      RETURN  
  888 WRITE(N6,1070)  
      STOP  
C#######################################################################  
C     WCH, 10/11/93.  Additional error messages while reading precip.  
C     file.  
C=======================================================================  
C#### WCH, 8/4/95.  ALTER IOSTAT NUMBER FOR LAHEY, FOR FOUR WRITES.  
  950 WRITE(N6,9500) M3,LN,YEAR,MONTH,DAY,NR,MOD(IOS,256)  
      WRITE(*,9501)  M3,MOD(IOS,256)  
      GO TO 965  
  960 WRITE(N6,9600) M3,LN,YEAR,MONTH,DAY,NR,J,IHR,MIN,IRAIN,  
     1  MOD(IOS,256)  
      WRITE(N6,9601) M3,MOD(IOS,256)  
  965 BACKSPACE M3  
      READ(M3,9650,END=966) M3LINE  
  966 WRITE(N6,9651) M3,M3LINE  
3124	write(N6,*) IBUF2,ABUF2,  
     +                   ELMTYP,ABUF2,NEWYR,NEWMON,NEWDAY  
      STOP  
C#### WCH, 10/2/96.  ADD NEW ERROR ROUTINE FOR INITIAL READS.  
Cwch, 7/28/04 Just print IOSTAT  
C  970 WRITE(N6,9700) IO,MOD(IOS,256),IBUF  
C      WRITE(*,9700) IO,MOD(IOS,256),IBUF  
  970 WRITE(N6,9700) IO,IOS,IBUF  
      WRITE(*,9700) IO,IOS,IBUF  
      STOP 'Run stopped from Sub. GTRAIN.'  
C=======================================================================  
C#### WCH, 8/1/95.  NEW FORMAT STATEMENT 990.  
  990 FORMAT(/,' STATION ID ON PRECIP. DATA INPUT FILE = ',A8,/,  
     1' REQUESTED STATION ID = ',A8,'  CHECK TO BE SURE THEY MATCH.',/)  
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I6 TO A6.  
CWCH, 11/9/99. READ YEAR (3RD PARAMETER) AS 4 DIGITS, NOT 2.    
 1000 FORMAT(3X,A6,2X,A4,2X,I4,I2,I4,3X,I2,3X,I5,A1)  
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I6 TO A6.  
 1040 FORMAT(A6,3I2,I1,12A3)  
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I8 TO A7 AND ALTER NEXT  
C     FIELD ALSO. ADD NEW 1046 FOR NEW AES FORMAT.  
 1045 FORMAT(A7,1X,3I2,3X,24I4)  
 1046 FORMAT(A7,1X,3I2,3X,24(I6,A1))  
CWCH, 11/22/99. ADD OPTION FOR 4-DIGIT YEAR AES DATA.  
 1047 FORMAT(A7,I4,2I2,3X,24(I6,A1))  
 1048 FORMAT(A7,I4,2I2,3X,96(I6,A1))  
 1050 FORMAT(72X,I4)  
 1051 FORMAT(73X,I4)  
C#### WCH, 8/1/95.  CHANGE IBUF FORMAT FROM I6 TO A6.  
CWCH, 11/9/99. READ YEAR (3RD PARAMETER) AS 4 DIGITS, NOT 2.    
 1060 FORMAT(3X,A6,2X,A4,2X,I4,I2,I4,I3,100(I4,I6,2A1))  
 1070 FORMAT(/,' ===> Error  in your rainfall file input.',/)  
 1080 FORMAT(50A1)  
 1085 FORMAT(25X,I2,1X,I2,4X,4(F6.0,F7.0,F7.0,1X))  
 1095 FORMAT(25X,9X,4(F6.0,F7.0,F7.0,1X))  
 1090 FORMAT(/,' Changing double quotation marks to single quotation',  
     +         ' marks in input file.',/)  
 1150 FORMAT(66X,I2)  
 1155 FORMAT(I2,1X,I2,24I5)  
 9000 FORMAT(/,' Error ==> Limit of ',I6,  
     +         ' Precipitation values exceeded for this year.')  
C#### WCH, 8/93.  
 9110 FORMAT(/,' ===> ERROR. Time interval for new data,',F7.1,  
     1 ' sec. does not',/,'     agree with time interval,',F7.1,  
     2 ' sec. of data on unit JOUT with which',/,  
     3 '     new data are to be combined.  Run stopped.')  
C#### WCH, 10/11/93.  
 9400 FORMAT(/,' WARNING END-OF-FILE REACHED ON UNIT',I3,' WHILE READIN  
     1G PRECIPITATION DATA',/,' FOR IFORM = 4 OR 6.  SHOULD HAVE A NUMBE  
     2R 10 IN FIRST TWO COLUMNS',/,' TO CONCLUDE THIS FILE.  POSSIBLE ER  
     3ROR.  PROCESSING CONTINUES.')  
C#### WCH, 8/4/95. CHANGE RMFORT TO LAHEY.  
 9500 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S  
     1HOULD BE A',/,' LINE 8 INPUT STRING. CURRENT PARAMETER VALUES ARE:  
     2',/,' LINE ID =',I3,/,' YEAR =',I5,/,' MONTH =',I3  
     3,/,' DAY =',I3,/,' NO. LINES =',I3,/,' LAHEY ERROR NO. =',I5  
     4,/,' RUN STOPPED FROM RAIN BLOCK.')  
C#### WCH, 10/2/96.  CHANGE 'RMFORT' TO 'LAHEY'.  
 9501 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S  
     1HOULD BE A',/,' LINE 8 INPUT STRING.  LAHEY ERROR NO. =',I5,/,' SE  
     2E OUTPUT FILE FOR COMPLETE MESSAGE.',/,  
     3' RUN STOPPED FROM RAIN BLOCK.')  
C#### WCH, 8/4/95.  CHANGE RMFOR TO LAHEY.  
 9600 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S  
     1HOULD BE A',/,' LINE 9 INPUT STRING. CURRENT PARAMETER VALUES ARE:  
     2',/,' LINE ID =',I3,/,' YEAR =',I5,/,' MONTH =',I3  
     3,/,' DAY =',I3,/,' NO. LINES =',I3,/,' LINE NO. =',I3  
     4,/,' HOUR =',I4,/,' MIN =',I4,/,' RAIN =',I5  
     5,/,' LAHEY ERROR NO. =',I5  
     6,/,' RUN STOPPED FROM RAIN BLOCK.')  
C#### WCH, 10/2/96.  CHANGE 'RMFORT' TO 'LAHEY'.  
 9601 FORMAT(' ERROR WHILE READING PRECIP. DATA ON UNIT',I3,' FOR WHAT S  
     1HOULD BE A',/,' LINE 9 INPUT STRING.  LAHEY ERROR NO. =',I5,/,' SE  
     2E OUTPUT FILE FOR COMPLETE MESSAGE.',/,  
     3' RUN STOPPED FROM RAIN BLOCK.')  
 9650 FORMAT(50A1)  
 9651 FORMAT(' OFFENDING LINE FROM UNIT',I3,' MAY BE:',/,1X,50A1)  
C#### WCH, 8/1/95.  TWO NEW WARNING MESSAGES.  
 9655 FORMAT (/, ' $$$$ CAUTION.  AT LEAST ONE OF YEAR/MONTH/DAY IS .LE.  
     1 ZERO ON UNIT',I3,/,' LIKELY HAVE EXTRA CARRIAGE RETURN AT END OF  
     2INPUT PRECIPITATION DATA FILE.',/,' ASSUME END-OF-FILE AND CEASE D  
     3ATA INPUT.')  
 9660 FORMAT (/,' ERROR.  INCORRECT DAY OF YEAR COMPUTED IN SUB. GTRAI  
     1N: IDAY =',I8,/,' HAS TO BE CAUSED BY WRONG YEAR/MONTH/DAY = ',  
     2 3I5,/,' CURRENT YEAR SHOULD BE: NEWYR =',I5,/,  
     3' CEASE DATA INPUT.  PERFORM FINAL RAIN ANALYSIS.')  
C#### WCH, 10/2/96.  
Cwch, 7/28/04  
 9700 FORMAT(/,' ERROR DURING INITIAL READ OF UNIT',I3,/,  
     1 ' Visual Fortran IOSTAT =',I5,/,  
     2 ' CURRENT STATION ID VALUE =',A10)  
C=======================================================================  
      END  
ECHO is off.
REM File: GUTNR.FOR  
ECHO is off.
      SUBROUTINE GUTNR(J,GLEN,GD,RDELT,NPG,WTYPE,WELEV,WDIS,SPILL,  
     +           GS1,GS2,GWIDTH,GCON,DFULL,QIN,QSUR,GFLOW,OUTFLW,  
     +           AXZERO,AX,FLZERO)  
C     RUNOFF BLOCK  
C     CALLED BY GUTTER NEAR LINE 26  
C=======================================================================                 
C     NEWTON-RAPHSON SOLUTION OF GUTTER OR PIPE DEPTH  
C     LAST UPDATED 4/22/92 BY RED AND WCH.  
C     UPDATED 9/23/93 BY WCH (RED) TO FIX IF-STMT NEAR END.  
C     WCH (CDM), 8/13/96.  REMOVE ERRANT CONVERGENCE CHECK FOR CHANNELS  
C       WITH WEIRS/ORIFICES.    
C=======================================================================  
      INCLUDE  'TAPES.INC'  
      INCLUDE  'NEW88.INC'  
      DIMENSION NSEQ(4),YZ(4),DZ(4),DY(4)  
      INTEGER   WTYPE  
      DATA NSEQ/1,2,4,8/  
C=======================================================================  
      NUSE     = 4  
      KCHAN(J) = KCHAN(J) + 1  
C=======================================================================  
C     MAIN LOOP  
C=======================================================================  
      DO 400 JJ= 1,NUSE  
      GDEPTH   = GD  
      DELT     = RDELT/FLOAT(NSEQ(JJ))  
      DELD     = 0.0  
      DO 250 K = 1,NSEQ(JJ)  
      GDEPTH   = GDEPTH + DELD  
      IFLG     = 0  
      IFLAG2   = 0  
      DELD     = 0.0  
      D0       = GDEPTH  
      AX0      = 0.0  
      WP0      = 0.001  
C=======================================================================  
C     TRAPEZOIDAL PARAMETERS  
C=======================================================================  
      IF(NPG.EQ.1) THEN  
         AX0 = 0.5*(GS1+GS2)*D0**2.0 + GWIDTH*D0  
         WP0 = SQRT(GS1**2.0+1.0)*D0 + SQRT(GS2**2.0+1.0)*D0 + GWIDTH  
         ENDIF  
C=======================================================================  
C     CIRCULAR PARAMETERS  
C=======================================================================  
      IF(NPG.EQ.2) THEN  
                   SIN2D0  = 0.5*SIN(2.0*D0)  
                   AX0     = GWIDTH**2*(D0-SIN2D0)/4.0  
                   WP0     = GWIDTH*D0  
                   D1      = 1.5707963  
                   DELD    = D1 - GDEPTH  
                   ENDIF  
C=======================================================================  
C     PARABOLIC PARAMETERS  
C=======================================================================  
      IF(NPG.EQ.4.AND.GDEPTH.GT.0.0) THEN  
                      WIDTH = GWIDTH*SQRT(D0/DFULL)  
                      X     = WIDTH/2.0  
                      A2    = GWIDTH**4.0/(64.0*DFULL**2.0)  
                      WP0   = 8.0*DFULL/GWIDTH**2.0*(X*SQRT(A2+X**2.0) +   
     +                                       A2*LOG(X+SQRT(A2+X**2.0)) -   
     +                                       A2*LOG(SQRT(A2)))         
                      AX0   = 0.66666667*WIDTH*D0  
                      ENDIF  
C=======================================================================  
      IF(AX0.LT.0.001) AX0 = 0.0  
      IF(WP0.LE.0.001) WP0 = 0.001  
      RAD                  = AX0/WP0  
C=======================================================================  
      FLOW0 = 0.0  
      IF(WTYPE.EQ.-1.AND.RAD.GT.0.0) FLOW0 = GCON*AX0*RAD**0.666666667  
      IF(WTYPE.EQ.0.AND.D0.GT.WELEV) FLOW0 = WDIS*SPILL*(D0-WELEV)**1.5  
      IF(WTYPE.EQ.1.AND.D0.GT.WELEV) FLOW0 = WDIS*SPILL*(D0-WELEV)**2.5  
      IF(WTYPE.EQ.2.AND.D0.GT.WELEV) FLOW0 = WDIS*SPILL*  
     +                                       (2.0*32.2*(D0-WELEV))**0.5  
      IF(JJ.EQ.1) THEN  
                  FLZERO = FLOW0  
                  AXZERO = AX0  
                  ENDIF  
C=======================================================================  
C     COMPUTE CHANGE IN DEPTH (NEWTON-RAPHSON)  
C  
C     D1 = ESTIMATED FINAL DEPTH.  
C          FOR PIPES, 'DEPTH' IS HALF OF ANGLE SUBTENDED BY  
C          WETTED PERIMETER, IN RADIANS.  
C=======================================================================  
                        KSOL = 0  
      IF(DELT.GE.900.0) KSOL = 1  
      DO 210 I = 1,20  
      D1       = GDEPTH+DELD  
C=======================================================================  
C     TRAPEZOIDAL CHANNEL  
C=======================================================================  
      IF(NPG.EQ.1) THEN  
             IF(D1.LE.0.0) THEN  
                           IFLAG2 = IFLAG2 + 1  
                           D1     = 0.0  
                           DELD   =  -GDEPTH  
                           ENDIF  
             DELV = GLEN*DELD * ((GS1+GS2)*(D0 + 0.5 * DELD)  
     +                                         + GWIDTH)/DELT  
             DDELV = GLEN*((GS1+GS2)*D1  + GWIDTH)/DELT  
             AX    = 0.5*(GS1+GS2)*D1**2 + GWIDTH*D1  
             DAX   = (GS1+GS2)*D1+GWIDTH  
             WP    = SQRT(GS1**2+1.0)*D1+SQRT(GS2**2+1.0)*D1+GWIDTH  
             DWP   = SQRT(GS1**2+1.0)+SQRT(GS2**2+1.0)  
             ENDIF  
C=======================================================================  
C     CIRCULAR PIPE  
C=======================================================================  
      IF(NPG.EQ.2) THEN  
                   IF(I.EQ.1) THEN  
                              D1   = 1.5707963  
                              DELD = D1 - GDEPTH  
                              ENDIF  
                   IF(D1.LE.0.0) THEN  
                                 IFLAG2 = IFLAG2 + 1  
                                 D1     = 0.0  
                                 DELD   = -GDEPTH  
                                 ENDIF  
                   IF(D1.GT.DFULL) THEN  
                                   D1   = DFULL  
                                   DELD = D1 - GDEPTH  
                                   ENDIF  
                   SIN2D1 = 0.5*SIN(2.0*D1)  
                   COS2D1 = COS(2.0*D1)  
                   DELV   = .25*GLEN*GWIDTH**2*(DELD-SIN2D1+SIN2D0)/DELT  
                   DDELV  = .25*GLEN*GWIDTH**2*(1.0-COS2D1)/DELT  
                   AX     = GWIDTH**2*(D1-SIN2D1)/4.0  
                   DAX    = GWIDTH**2*(1.0-COS2D1)/4.0  
                   WP     = GWIDTH*D1  
                   DWP    = GWIDTH  
                   ENDIF  
C=======================================================================  
C     PARABOLIC CHANNEL  
C=======================================================================  
      IF(NPG.EQ.4) THEN  
             IF(D1.LE.0.0) THEN  
                           IFLAG2 = IFLAG2 + 1  
                           D1     = 0.001  
                           DELD   =  -GDEPTH + 0.001  
                           ENDIF  
             WID0  = GWIDTH*SQRT(D0/DFULL)  
             WID1  = GWIDTH*SQRT(D1/DFULL)  
             DELV  = 0.66666667*GLEN/DELT*(D1*WID1 - D0*WID0)  
             DDELV = 0.66666667*GLEN/DELT*1.50*WID1  
             AX    = 0.66666667*WID1*D1  
             DAX   = 0.66666667*WID1*1.50  
             X     = WID1/2.0  
             A2    = GWIDTH**4.0/(64.0*DFULL**2.0)  
             WP    = 8.0*DFULL/GWIDTH**2.0*(X*SQRT(A2+X**2.0) +   
     +                              A2*LOG(X+SQRT(A2+X**2.0)) -   
     +                              A2*LOG(SQRT(A2)))         
                           DX  = 0.0  
             IF(D1.GT.0.0) DX  = 0.25*GWIDTH/SQRT(D1*DFULL)  
             DXX   = 0.25*GWIDTH**2.0/DFULL  
             DWP   = 8.0*DFULL/GWIDTH**2.0*(DX*SQRT(A2+X**2.0) +  
     +               0.5*X*DXX/SQRT(A2+X**2.0) +   
     +         (DX+0.5*DXX/SQRT(A2+X**2.0))/(LOG(X+SQRT(A2+X**2.0))))  
             ENDIF  
C=======================================================================  
C     HYDRAULIC RADIUS (ALL CROSS-SECTIONS)  
C=======================================================================  
      IF(AX.LE.0.001) AX = 0.000  
      IF(WP.LE.0.001) WP = 0.001  
      RAD                = AX/WP  
C=======================================================================  
C     FLOW1 = INSTANTANEOUS FLOW AT END OF TIME STEP.  
C=======================================================================  
                      FLOW1 = 0.0  
      IF(WTYPE.EQ.-1) FLOW1 = GCON*AX*RAD**0.666666667                          
      IF(WTYPE.EQ.0.AND.D1.GT.WELEV) FLOW1 = WDIS*SPILL*(D1-WELEV)**1.5  
      IF(WTYPE.EQ.1.AND.D1.GT.WELEV) FLOW1 = WDIS*SPILL*(D1-WELEV)**2.5  
      IF(WTYPE.EQ.2.AND.D1.GT.WELEV) FLOW1 = WDIS*SPILL*  
     +                                       (2.0*32.2*(D1-WELEV))**0.5  
      FLOW   = 0.5*(FLOW1+FLOW0)  
      DFLOW  = 0.0  
      IF(WTYPE.EQ.-1) DFLOW =  0.5*GCON*(1.6666667*(RAD**0.66666667)  
     +                         *DAX - 0.66666667*(RAD**1.6666667)*DWP)  
      IF(WTYPE.EQ.0.AND.D1.GT.WELEV) DFLOW = 1.5*WDIS*SPILL*  
     +                                       (D1-WELEV)**0.5  
      IF(WTYPE.EQ.1.AND.D1.GT.WELEV) DFLOW = 2.5*WDIS*SPILL*  
     +                                       (D1-WELEV)**1.5  
      IF(WTYPE.EQ.2.AND.D1.GT.WELEV) DFLOW = 32.2*WDIS*SPILL/  
     +                                       (64.4*(D1-WELEV))**0.5  
C=======================================================================  
C     NEWTON-RAPHSON CORRECTION (ALL CROSS-SECTIONS)  
C=======================================================================  
      IF(KSOL.EQ.0) THEN  
C$$$  WCH THINKS SHOULD DIVIDE BY RDELT (CONST DT), NOT DELT (VARIABLE DT)  
C$$$  TRY CORRECTION 4/20/92  
                    F     = DELV  + FLOW  - QIN - QSUR/RDELT  
                    DF    = DDELV + DFLOW  
                    ELSE  
                    DFLOW = 2.0*DFLOW  
                    F     = DELV  + FLOW1 - QIN - QSUR/RDELT  
                    DF    = DDELV + DFLOW  
                    ENDIF  
C=======================================================================  
C     ZERO SLOPE  
C=======================================================================  
      IF(ABS(DF).LE.1.0E-10) THEN  
                        DEL = 0.001  
                        ELSE  
                        DEL = DELD - F/DF  
                        ENDIF  
C=======================================================================  
C     CONVERGENCE CHECK (INDIVIDUAL GUTTER)  
C=======================================================================  
C#### WCH (CDM=C.I.M.), 8/13/96  
C     THIS IF-LOOP SEEMS TO CAUSE PREMATURE END TO CONVERGENCE  
C     ITERATIONS FOR CHANNELS WITH WEIRS/ORIFICES WHEN GUESS CAUSES  
C     LEVEL BELOW OUTLET LEVEL (WELEV).  THIS MAKES IT HARD FOR CHANNEL   
C     TO "FILL UP" TO OUTLET LEVEL, ESPECIALLY AT START OF STORM WHEN   
C     CHANNEL IS DRY.  ELIMINATING THIS IF-LOOP SEEMS TO WORK, BASED  
C     ON CDM EXPERIENCE.  
C  
C####      IF(WTYPE.GE.0.AND.GDEPTH+DEL.LT.WELEV) THEN  
C####                                          GD       = GDEPTH+DEL  
C####                                          LCHAN(J) = LCHAN(J) + 1  
C####                                          GO TO 402  
C####                                          ENDIF                      
      IF(GDEPTH+DEL.GE.DFULL) THEN  
                       IF(IFLG.EQ.1) THEN  
                                     GD       = DFULL  
                                     LCHAN(J) = LCHAN(J) + 1  
                                     GO TO 402  
                                     ENDIF  
                       DEL  = DFULL-GDEPTH  
                       IFLG = 1  
                       ELSE  
                       IFLG = 0  
                       IF(ABS(DEL-DELD).LE.0.001) GO TO 250  
                       IF(IFLAG2.GE.2) KSOL = 1  
                       ENDIF  
  210 DELD = DEL  
C=======================================================================  
C     NO CONVERGENCE.  
C  
C     NEW DEPTH AT END OF TIME INTERVAL  
C=======================================================================  
  250 DELD   = DEL  
      GDEPTH = GDEPTH + DELD  
C=======================================================================  
C     CHECK FOR ALLOWABLE CONDUIT DEPTHS.  4/22/92  
C=======================================================================  
      IF(GDEPTH.GT.DFULL) GDEPTH = DFULL  
      IF(GDEPTH.LT.0.0)   GDEPTH = 0.0  
      QSUR   = 0.0  
      YZ(JJ) = GDEPTH  
      IF(JJ.EQ.1) DY(1) = YZ(1)  
      IF(JJ.EQ.2) THEN  
                  DY(2) = (4.0*YZ(2) - YZ(1))/3.0  
                  IF(ABS(DY(2)-DY(1)).LE.0.001*ABS(DY(1))) THEN  
                                      LCHAN(J) = LCHAN(J) + 3  
                                      GD       = DY(2)  
                                      GO TO 402  
                                      ENDIF  
                  ENDIF  
      IF(JJ.EQ.3) THEN  
                  DY(3) = (4.0*YZ(3)  - YZ(2))/3.0  
                  DZ(3) = (16.0*DY(3) - DY(2))/15.0  
                  IF(ABS(DZ(3)-DY(3)).LE.0.001*ABS(DZ(3))) THEN  
                                      LCHAN(J) = LCHAN(J) + 7  
                                      GD       = DZ(3)  
                                      GO TO 402  
                                      ENDIF  
                 ENDIF  
      IF(JJ.EQ.4)THEN  
                 DY(4)    = (4.0*YZ(4)  - YZ(3))/3.0  
                 DZ(4)    = (16.0*DY(4) - DY(3))/15.0  
                 DZ(4)    = (64.0*DZ(4) - DZ(3))/63.0  
                 GD       = DZ(4)  
                 LCHAN(J) = LCHAN(J) + 15  
                 ENDIF  
 400  CONTINUE  
 402  CONTINUE  
C=======================================================================  
C     CHECK FOR ALLOWABLE CONDIUT DEPTHS.  4/22/92  
C=======================================================================  
      IF(GD.GT.DFULL) GD = DFULL  
      IF(GD.LT.0.0)   GD = 0.0  
      IF(WTYPE.EQ.-1) THEN  
      IF(NPG.EQ.1)    THEN  
             AX = 0.5*(GS1+GS2)*GD**2.0 + GWIDTH*GD  
             WP = SQRT(GS1**2.0+1.0)*GD + SQRT(GS2**2.0+1.0)*GD+GWIDTH  
             ENDIF  
      IF(NPG.EQ.2)  THEN  
                    SIN2D0  = 0.5*SIN(2.0*GD)  
                    AX      = GWIDTH**2*(GD-SIN2D0)/4.0  
                    WP      = GWIDTH*GD  
                    ENDIF  
      IF(NPG.EQ.4)  THEN  
           IF(GD.GT.0.0) THEN  
                    WIDTH = GWIDTH*SQRT(GD/DFULL)  
                    AX    = 0.66666667*WIDTH*GD  
                    X     = WIDTH/2.0  
                    A2    = GWIDTH**4.0/(64.0*DFULL**2.0)  
                    WP    = 8.0*DFULL/GWIDTH**2.0*(X*SQRT(A2+X**2.0) +   
     +                                     A2*LOG(X+SQRT(A2+X**2.0)) -   
     +                                     A2*LOG(SQRT(A2)))         
                    ELSE  
                    AX    = 0.0  
                    WP    = 0.001  
                    ENDIF  
           ENDIF  
      IF(AX.LT.0.001) AX = 0.0  
      IF(WP.LE.0.001) WP = 0.001  
      RAD                = AX/WP  
      ENDIF  
                                     FLOW1 = 0.0  
      IF(WTYPE.EQ.-1.AND.RAD.GT.0.0) FLOW1 = GCON*AX*RAD**0.666666667                          
      IF(WTYPE.EQ.0.AND.GD.GT.WELEV) FLOW1 = WDIS*SPILL*(GD-WELEV)**1.5  
      IF(WTYPE.EQ.1.AND.GD.GT.WELEV) FLOW1 = WDIS*SPILL*(GD-WELEV)**2.5  
      IF(WTYPE.EQ.2.AND.GD.GT.WELEV) FLOW1 = WDIS*SPILL*  
     +                                       (2.0*32.2*(GD-WELEV))**0.5  
      OUTFLW = FLOW1                          
      FLOW   = (OUTFLW + FLZERO)/2.0  
      IF(FLOW.LT.1.0E-10.AND.WTYPE.EQ.-1) THEN  
                                          FLOW   = 0.0  
                                          GD     = 0.0  
                                          ENDIF  
      IF(FLOW.LT.0.0.AND.WTYPE.GE.0) THEN  
                                     FLOW   = 0.0  
                                     GD     = 0.0  
                                     ENDIF  
      GFLOW  = FLOW  
C#### WCH (RED), 9/93.  ADD QSUR > 0.0 TO IF STMT.  
      IF(IFLG.EQ.1.OR.QSUR.GT.0.0) THEN  
                    QSUR   = QSUR + (QIN-FLOW)*RDELT  
                    IF(QSUR.LT.0.0) QSUR = 0.0  
                    ENDIF  
      RETURN  
      END  
  
ECHO is off.
REM File: HCURVE.FOR  
ECHO is off.
      SUBROUTINE HCURVE(NTYPE)  
C     GRAPH RUNOFF BLOCK  
C     CALLED FROM RUNOFF NEAR LINES 265 through 269  
C=======================================================================  
C     HCURVE WAS LAST UPDATED BY THE UNIVERSITY OF FLORIDA JANUARY, 1989  
C     DIMENSION MODIFICATION, DELETED LOOP, AND NEW PRINT, 12/92 BY WCH  
C     WCH, 11/10/99. FIX RAINFALL GRAPHS THAT EXTEND BEYOND ONE PLOT.   
C     WCH, 7/1/03. Fix GW output loop.   
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'GRWTR.INC'  
      INCLUDE 'LAB.INC'  
C=======================================================================  
C#### WCH, 12/92.  DIMENSION TO NGW.  
CIM INCREASE HYETOGRAPHS  ~~~~~~~~~~~~~~~~~~~~~~~~~  
      DIMENSION GWFLWB(NGW),STPOLL(2,NGW),JSTA(MAXRG)  
      DIMENSION X(201,2),Y(201,2),Y1(201,2),NPT(2),REIN(maxrg)  
cim      DIMENSION GWFLWB(NGW),STPOLL(2,NGW),JSTA(10)  
cim      DIMENSION X(201,2),Y(201,2),Y1(201,2),NPT(2),REIN(10)  
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~  
      INTEGER MPGRW(NGW)  
      CHARACTER*30 TITL(6),ORIZ,TSEC,TFIR  
      CHARACTER*10 VER1(5),VER2(5),VER3(10),ALPLOT,KPGRW(NGW)  
C=======================================================================  
      DATA TITL/'RAINFALL HYETOGRAPH           ',  
     1 'SURFACE INLET HYDROGRAPH FLOW ','PLOT OF INFILTRATION RATE    ',  
     2 'SUBSURFACE OUTLET HYDROGRAPH  ',  
     3 'SUBSURFACE STAGE GRAPH        ','SUBSURFACE MOISTURE FRACTION '/  
      DATA TFIR/'SUMMATION OVER PERVIOUS AREA '/  
      DATA TSEC/'SUMMATION FOR ALL INLETS'/  
      DATA ORIZ /'         TIME IN HOURS        '/  
      DATA VER1/' RAINFALL ','  RUNOFF  ','   FLOW  ','  STAGE   ',  
     +          ' MOISTURE '/  
      DATA VER2/'    IN    ','    IN    ','    IN   ','    IN    ',  
     +          '    IN    '/  
      DATA VER3/'  IN/HR   ','   MM/HR  ','    CFS   ',' CUB M/S  ',  
     +          '   CFS    ',' CUB M/S  ','   FEET   ','  METERS  ',  
     +          ' FRACTION ',' FRACTION '/  
C=======================================================================  
      NREIN    = NSCRAT(1)  
      NFLOW    = NSCRAT(4)  
      ALPLOT   = ' '  
C=======================================================================  
C      PLOT RAINFALL HYETOGRAPH OR INLET HYDROGRAPH  
C=======================================================================  
      X(1,1)   = TZERO/3600.0  
      Y(1,1)   = 0.0  
      HORIZ(1) = ORIZ  
      HTITLE(1)= TITL(NTYPE)  
      HTITLE(2)= '       '  
      MTYPE    = NTYPE  
      IF(NTYPE.EQ.3) MTYPE = 1  
      IF(NTYPE.EQ.4) MTYPE = 3  
      VERT1    = VER1(MTYPE)  
      VERT2    = VER2(MTYPE)  
      VERT3    = VER3(2*MTYPE-2+METRIC)  
      IF(NTYPE.EQ.3) THEN  
                     VERT1     = 'INFILTRATN'  
                     HTITLE(2) = TFIR  
                     ENDIF  
C=======================================================================  
C     FIND THE STARTING POSITION ON THE RAINFALL INTERFACE FILE  
C=======================================================================  
      IF(NTYPE.EQ.1) THEN  
      I        = 0  
      DO 110 J = 1,NRGAG  
      REWIND NREIN  
      READ(NREIN) NSTA,MRAIN,(JSTA(K),K=1,NSTA)  
      I        = I+1  
      TNEXT    = TZERO  
      JULDAY   = IDATEZ  
      TIME     = TZERO  
      TIMDAY   = TZERO  
      DO 65 L  = 1,MRAIN  
      READ(NREIN,END=71) JDAY,TMDAY,THISTO,(REIN(K),K=1,NSTA)  
      IF(JDAY.GE.JULDAY.AND.TMDAY.GE.TIMDAY) THEN  
                        BACKSPACE NREIN  
                        GO TO 66  
                        ENDIF  
  65  CONTINUE  
  66  CONTINUE  
C=======================================================================  
C     READ RAINFALL FILE  
C=======================================================================  
      N        = 1  
      X(N,1)   = TZERO/3600.0  
      Y(N,1)   = 0.0  
      DO 70 L  = 1,NRAIN  
      READ(NREIN,END=71) JDAY,TMDAY,THISTO,(REIN(K),K=1,NSTA)  
      CALL NTIME(JDAY,TMDAY,TRN)  
      CALL STIME(TRN)  
      TIME     = TIME + TRN  
	      IF(TIME.GT.TNEXT) THEN  
                        N      = N + 1  
                        X(N,1) = TNEXT/3600.0  
                        Y(N,1) = 0.0  
                        N      = N + 1  
                        X(N,1) = TIME/3600.0  
                        Y(N,1) = 0.0  
                        ENDIF  
      N        = N+1  
      X(N,1) = TIME/3600.0  
      Y(N,1) = REIN(J)  
      N      = N+1  
      TNEXT  = TIME + THISTO  
      X(N,1) = TNEXT/3600.0  
      Y(N,1) = REIN(J)  
      IF(N.GE.199) THEN  
                   N      = N+1  
CWCH, 11/10/99. CAN SOMEHOW GET N > 201 AND EXCEED DIMENSION.   
C     MAX N ENCOUNTERED AT THIS POINT IS 202,   
C     SO ASSUME N = 202 IS TRUE HERE FOR FIX.  
C     MOVE LAST TWO X AND Y VALUES TO 199 AND 200.  
                   IF(N.GT.201) THEN  
	                  X(199,1) = X(200,1)  
				      X(200,1) = X(201,1)  
	                  Y(199,1) = Y(200,1)  
	                  Y(200,1) = Y(201,1)  
	                  N = 200  
	                  ENDIF  
                   X(N,1) = X(N-1,1)  
CWCH, 11/10/99.  BE SURE THAT MAX VALUE OF X IS NOT CHANGED.  
			     XXX    = X(N,1)	  
                   Y(N,1) = 0.0  
                   NPT(1) = N  
                   KSTAT = JSTA(J)  
                   CALL CURVE(X,Y,NPT,1,KSTAT,ALPLOT)  
C                   X(1,1) = X(N,1)  
                   X(1,1) = XXX  
                   Y(1,1) = 0.0  
                   N = 1  
                   ENDIF  
   70 CONTINUE  
   71 N      = N+1  
      X(N,1) = X(N-1,1)  
      Y(N,1) = 0.0  
      NPT(1) = N  
      KSTAT = JSTA(J)  
      CALL CURVE(X,Y,NPT,1,KSTAT,ALPLOT)  
  110 CONTINUE  
      RETURN  
      ENDIF  
C=======================================================================  
C     PLOT THE INLET HYDROGRAPH  
C     MAKE THE CONVERSION FROM CFS TO CUBIC METERS PER SECOND (METRIC=2)  
C=======================================================================  
      IF(NTYPE.EQ.2) THEN  
      REWIND NFLOW  
      HTITLE(2)= TSEC  
      N        = 1  
      X(N,1)   = TZERO/3600.0  
      Y(N,1)   = 0.0  
      KINC     = (MTIME+199)/200 + 1  
      NPLOT    = 1  
C======================================================================  
      DO 130 J = 1,MTIME,KINC  
      DO 140 K = 1,KINC  
 140  READ(NFLOW,END=135) TIME,FLWOFF,FINF  
      N        = N + 1  
      X(N,1)   = TIME/3600.0  
      Y(N,1)   = FLWOFF  
      IF(METRIC.EQ.2) Y(N,1) = Y(N,1) * 0.028316847  
  130 CONTINUE  
C=======================================================================  
  135 NPT(1) = N  
      KCE    = JCE  
      JCE    = 1  
      ALPLOT = 'FLOW SUM'  
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT)  
      JCE    = KCE  
      RETURN  
      ENDIF  
C=======================================================================  
C     PLOT THE IFILTRATION RATE PLOT  
C=======================================================================  
      IF(NTYPE.EQ.3.AND.PRCIMP.LT.1.0) THEN  
      REWIND NFLOW  
      TY       = TRIBA*3630.0*(1.0-PRCIMP)  
      IF (TY.NE.0.0) THEN   
      TY       = 3600.0/TY  
      ELSE   
      TY       = 0.0  
      END IF  
      HTITLE(1)= TITL(3)  
      HTITLE(2)= '                  '  
      N        = 1  
      X(N,1)   = TZERO/3600.0  
      Y(N,1)   = 0.0  
      KINC     = (MTIME+199)/200 + 1  
      NPLOT    = 1  
C======================================================================  
      DO 230 J = 1,MTIME,KINC  
      DO 240 K = 1,KINC  
 240  READ(NFLOW,END=235) TIME,FLWOFF,FINF  
      N        = N + 1  
      X(N,1)   = TIME/3600.0  
      Y(N,1)   = FINF*TY  
      IF(METRIC.EQ.2) Y(N,1) = Y(N,1) * 25.4  
 230  CONTINUE  
C=======================================================================  
  235 NPT(1) = N  
      KCE    = JCE  
      JCE    = 1  
      ALPLOT = 'INFILTRA'  
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT)  
      JCE    = KCE  
      RETURN  
      ENDIF  
C=======================================================================  
C     PLOT SUBSURFACE FLOWS, SOIL MOISTURE, AND STAGE  
C=======================================================================  
      IF(NTYPE.EQ.4) THEN  
             NGRND = NSCRAT(6)  
C      MCOUN        = 0  
C#### WCH, 12/92  NOTE, FORMER DO 395 LOOP 1,NSVGW DELTED AT THIS POINT.  
C  
Cwch, 7/1/03. Here *any* subcat can have GW, not just first NOGWSC.  
C     Have saved subcat ID in Sub. CATCH.  Don't need initial loop.   
C  
C      DO 405 JH    = 1,NOGWSC  
C	      IF(NSCSFG(JH).GT.0) THEN  
C                          MCOUN        = MCOUN + 1  
C                          MPGRW(MCOUN) = NMSUB(JH)  
C                          IF(JCE.EQ.1) KPGRW(MCOUN) = KMSUB(JH)  
C                          ENDIF  
C 405  CONTINUE  
C##### WCH, 12/92  
      WRITE (*,8990)  
      DO 400 JJ    = 1,NSVGW  
C##### WCH, 12/92.  PLOTS CAN BE TIME CONSUMING.  PRINT REASSURANCE.  
      WRITE (*,9000) JJ,NSVGW  
      REWIND NGRND  
      N        = 1  
      X(N,1)   = TZERO/3600.0  
      Y(N,1)   = 0.0  
      KINC     = (MTIME+199)/200 + 1  
      DO 330 J = 1,MTIME,KINC  
      DO 340 K = 1,KINC  
C=======================================================================  
C     READ SUBSURFACE PLOT INFORMATION  
C=======================================================================  
 340  READ(NGRND,END=335) JULDAY,TIMDAY,TIME,(GWFLWB(JI),  
     .            (STPOLL(JV,JI),JV=1,2),JI=1,NSVGW)  
      N        = N + 1  
      X(N,1)   = TIME/3600.0  
      Y(N,1)   = GWFLWB(JJ)  
      Y1(N,1)  = STPOLL(1,JJ)  
      Y1(N,2)  = STPOLL(2,JJ)  
 330  CONTINUE  
 335  CONTINUE  
      NPT(1) = N  
C=======================================================================  
Cwch, 7/1/03. Use names saved in Sub. CATCH.  
C                    NPLOT = MPGRW(JJ)  
C      IF(JCE.EQ.1) ALPLOT = KPGRW(JJ)  
      IF(JCE.EQ.0)  NPLOT = NAMWPL(JJ)  
	IF(JCE.EQ.1) ALPLOT = KMSUPL(JJ)  
      HTITLE(1) = TITL(4)  
      HTITLE(2) = '      '  
      VERT1     = VER1(3)  
      VERT2     = VER2(3)  
      VERT3     = VER3(5+METRIC-1)  
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT)  
      DO 300 J  = 1,N  
 300  Y(J,1)    = Y1(J,1)  
      HTITLE(1) = TITL(5)  
      VERT1     = VER1(4)  
      VERT2     = VER2(4)  
      VERT3     = VER3(7+METRIC-1)  
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT)  
      DO 350 J  = 1,N  
 350  Y(J,1)    = Y1(J,2)  
      HTITLE(1) = TITL(6)  
      VERT1     = VER1(5)  
      VERT2     = VER2(5)  
      VERT3     = VER3(9+METRIC-1)  
      CALL CURVE(X,Y,NPT,1,NPLOT,ALPLOT)  
 400  CONTINUE  
C#### WCH, 12/92  
      RETURN  
      ENDIF  
C#######################################################################  
 8990 FORMAT (//)  
 9000 FORMAT ('+ Constructing no.',I3,' of',I4,' requested groundwater p  
     *lots.')  
      END  
  
ECHO is off.
REM File: HYDRO.FOR  
ECHO is off.
      SUBROUTINE HYDRO  
C	RUNOFF BLOCK  
C	CALLED BY SUBROUTINE RUNOFF NEAR LINE 262  
C=======================================================================  
C     Hydro was last updated May 1993 by R.E.D.  
C     Updated 8/93 by Chuck Moore, CDM to include infiltration/inflow  
C     and new statistical summaries.  
C     Correct rainfall total for situation in which THISTO < WET, RED,  
C       12/31/93.  
C     Cosmetic changes to continuity check printouts, WCH, 1/4/94.  
C     Add check for snow on surface and channel/pipe flow in order to  
C       use WETDRY time step during continuous simulations, WCH, 4/7/94.  
C     Change precip. station ID (JSTA) to character to be compatible  
C       with changes in Rain Block, WCH, 8/1/95.  
C     Alter IOSTAT for Lahey, WCH, 8/4/95.  
C     Metric unit correction for RDII CIM 9/8/00  
C     Correction for rainfall summer. WCH, 4/15/02.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'SUBCAT.INC'  
      INCLUDE 'QUALTY.INC'  
      INCLUDE 'GRWTR.INC'  
      INCLUDE 'NEW88.INC'  
C#### C. MOORE, CDM, 8/93.  
      INCLUDE 'RDII.INC'  
      INCLUDE 'RUNSTAT.INC'  
Cwch, 12/20/00  
      INCLUDE 'OVERLAND.INC'  
CIM INCREASE HYETOGRAPHS  ~~~~~~  
      DIMENSION ZUM(30),REIN(MAXRG),BANE(MAXRG),JSTA(MAXRG)  
CIM  ~~~~~~~  
C=======================================================================  
CIM      DIMENSION ZUM(30),REIN(10),BANE(10),JSTA(10)  
C=======================================================================  
C     DECLARE THESE VARIABLES.  WCH, 11/1/91  
C=======================================================================  
      REAL   TRN  
      DOUBLE PRECISION DTRN  
      LOGICAL DELUGE,DESERT  
C#### WCH, 8/1/95.  CHANGE PRECIP STATION TO CHARACTER.  
      CHARACTER*8 JSTA  
C=======================================================================  
C     Compute the initial water stored in channels.  
C=======================================================================  
      CNT(20)    = 0.0  
      IF(NOG.NE.999) THEN  
             DO 100 J = 1,NOG  
             IF(NPG(J).EQ.1) AX = 0.5*(GS1(J)+GS2(J))*GDEPTH(J)**2 +  
     +                                 GWIDTH(J)*GDEPTH(J)  
             IF(NPG(J).EQ.2) AX = GWIDTH(J)**2/4.0*(GDEPTH(J) -  
     +                                0.5*SIN(2.0*GDEPTH(J)))  
             IF(NPG(J).EQ.4) THEN  
                       WIDTH = GWIDTH(J)*SQRT(GDEPTH(J)/DFULL(J))  
                       AX    = 0.66666667*WIDTH*GDEPTH(J)  
                       ENDIF  
             IF(NPG(J).NE.3) THEN  
                             VOL    = AX*GLEN(J)  
                             CNT(20)  = CNT(20) + VOL + QSUR(J)  
                             ENDIF  
  100        CONTINUE  
             ENDIF  
C=======================================================================  
      DELUGE  = .FALSE.  
      DESERT  = .TRUE.  
C#######################################################################  
C     C. Moore, CDM, 8/93.  Option to pre-process rainfall to compute  
C       infiltration/inflow for inlet at each subcatchment.  
C#######################################################################  
      CALL RDIIRES  
Cwch, 1/7/03. Add write statement as help in error checking.  
	WRITE (N6,2110)  
C  
      NREIN   = NSCRAT(1)  
      REWIND NREIN  
      IF(IPRN(2).EQ.0) THEN  
                       NFLOW   = NSCRAT(4)  
                       IF(NFLOW.EQ.0) CALL ERROR(20)  
                       REWIND NFLOW  
                       ENDIF  
      READ(NREIN,END=777,ERR=777) NSTA,MRAIN,(JSTA(I),I=1,NSTA)  
      WRITE(N6,2115)  NSTA  
      WRITE(N6,2120) (I,JSTA(I),I=1,NSTA)  
      IF(NRGAG.GT.NSTA) CALL ERROR(115)  
C=======================================================================  
C     The next DO loop is the driver of the Runoff Block.  
C     It will call subroutines Wshed, Qshed amd Gutter.  
C=======================================================================  
      TRAIN  = TZERO  
      TIME   = TZERO  
      KWIK   = 0  
C#### WCH, 4/7/94.  Initialize KWIKSN and KWIKGT.  
                     KWIKSN = 0  
      IF(ISNOW.EQ.2) KWIKSN = 1  
      KWIKGT = 0  
      LWEAT  = 0  
      KRAIN  = 0  
      NRAIN  = 0  
      JWET   = 1  
      JDRY   = 0  
      MTIME  = 0  
C#### WCH, 4/7/94.  ADD PARAMETER KWIKGT  
      CALL GUTTER(REIGN,KWIKGT)  
C=======================================================================  
C     Calculate ending Julian day.  
C=======================================================================  
      CALL NDATE(LONG,JDAY,TMDAY)  
      LONG   = LONG + TZERO  
      WRITE(*,23) (LONG/3600.0),JDAY  
      DELT   = 0.0  
      DLAST  = 0.0  
      JDAY   = JULDAY  
      TMDAY  = TIMDAY  
C=======================================================================  
C     Recapture starting date/time.  
C=======================================================================  
      DO 2000 MBIG = 1,1000000  
C=======================================================================  
      IF(KRAIN.LE.MRAIN) THEN  
C=======================================================================  
C     If current time >= rainfall time, need to read new rainfall.  
C=======================================================================  
         IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN  
                   DELUGE = .FALSE.  
                   DESERT = .TRUE.  
 200               READ(NREIN,END=800,ERR=777,IOSTAT=IOS) JDAY,TMDAY,  
     +                                THISTO, (BANE(J),J=1,NSTA)  
Cwch, 4/15/02. Move rainfall summer from here.  
                   CALL NTIME(JDAY,TMDAY,TRN)  
                   DTRN = DBLE(TRN)  
                   DTRN  = TRN  
                   IF(DABS(DTRN).LT.WET*0.001) TRN = 0.0  
                   TRAIN = TRN  
                   KRAIN = KRAIN + 1  
                   NRAIN = NRAIN + 1  
C=======================================================================  
C#### WCH (CDM, C. MOORE), 10/93  
Cwch, 4/15/02. Start to sum rain *after* start of simulation.  
C     Otherwise, may get rainfall total in subcatchment summaries  
C     that includes extensive rain prior to start of simulation.   
C=======================================================================  
                   IF(.NOT.(MBIG.EQ.1.AND.TRN.LT.0.0)) THEN  
                        DO 201 J=1,NSTA  
 201                    RTOT(J)=RTOT(J)+BANE(J)*THISTO  
                        ENDIF  
C#######################################################################  
C#### WCH, 4/7/94.  If no precipitation  .AND.  snow on ground (KWIKSN  
C     = 1) or if overland flow is occuring (KWIK = 1) or channel/pipe  
C     flow is occuring (KWIKGT = 1), use WETDRY time step.  For better  
C     accuracy, user must set WETDRY closer to WET, at expense of  
C     computation time.  Check for none of the above (dry conditions  
C     and DRY time step) is made later.  
C=======================================================================  
                   IF(TRAIN.EQ.0.0)  THEN  
C=======================================================================  
C     Here, have rain value at this time.  Will assign WET time step  
C     later.  
C=======================================================================  
                                TRAIN  = THISTO + TRAIN  
                                JDRY   = 0  
                                JWET   = 1  
                                ELSE IF(TRAIN.GT.0.0) THEN  
C=======================================================================  
C     Here, have rain value at future time.  Will use WETDRY time step  
C     unless DRY is determined later.  
C=======================================================================  
                                JDRY   = IFIX(TRAIN/WETDRY)  
                                IF(JDRY.EQ.0) THEN  
                                              JDRY  = 1  
                                              XDELT = TRAIN  
                                              ELSE  
                                              XDELT = TRAIN/FLOAT(JDRY)  
                                              ENDIF  
                                TRAIN  = THISTO + TRAIN  
                                ELSE  
C=======================================================================  
C     TRAIN < 0, current time > rainfall time.   
C     Here, still need to read rainfall value at time >= current time.  
C=======================================================================  
                                GO TO 200  
                                ENDIF  
                   IF(THISTO.LT.WET) THEN  
C#######################################################################  
C RED (WCH), 12/31/93. If THISTO < WET, change the time step to THISTO  
C                      to ensure calculation of correct rainfall amount.  
C                      Change the time step, not the rainfall.  
C                      Add new variable IMSHORT.  
C#######################################################################  
C#### Old code:  
C####                           DO 300 J = 1,NRGAG  
C#### 300                       BANE(J)  = BANE(J)*THISTO/WET  
C####                           JWET     = 1  
C####                           ELSE  
C####                           JWET     = IFIX(THISTO/WET)  
C####                           ENDIF  
C#### New code:  
                                JWET     = 1  
                                IMSHORT  = 1  
                                ELSE  
                                JWET     = IFIX(THISTO/WET)  
                                IMSHORT  = 0  
C#### Check for some slop.  
                                IF(FLOAT(JWET)*WET.LT.THISTO-0.01) THEN  
                                     JWET    = JWET + 1  
                                     IMSHORT = 2  
                                     ENDIF  
                                ENDIF  
C  
                   GO TO 801  
C=======================================================================  
C     Here if reach end-of-file on precipitation input file.  
C=======================================================================  
  800              CALL NDATE (LONG,JDAY,TMDAY)  
C#### 5/28/93, RED.  REMOVE TRN=TRAIN AND ADD TRAIN=TRN AFTER CALL STMT.  
C####             TRN = TRAIN  
                   CALL NTIME (JDAY,TMDAY,TRN)  
                   TRAIN = TRN  
                   JDRY   = IFIX(TRAIN/WETDRY)  
                   IF(JDRY.EQ.0) THEN  
                            JDRY  = 1  
                            XDELT = TRAIN  
                            ELSE  
                            XDELT = TRAIN/FLOAT(JDRY)  
                            ENDIF  
                   JWET   = 0  
                   DO 810 J = 1,NRGAG  
  810              BANE(J)  = 0.0  
  801              CONTINUE  
                   ENDIF  
         ELSE  
C=======================================================================  
C     Here, have read future rainfall value.  Use zero until reach  
C     that time.  
C=======================================================================  
         DO 820 J = 1,NRGAG  
  820    BANE(J)  = 0.0  
         ENDIF  
C=======================================================================  
C     Wet, Wet/Dry or Dry Time Step.  
C=======================================================================  
      NSTEP  = 1  
 2050 MTIME  = MTIME + 1  
C=======================================================================  
C     DELUGE = .TRUE.   ==> Wet time step.  
C     DELUGE = .FALSE.  ==> Dry or wet/dry time step.  
C  
C     KWIK   =    0     ==> No overland flow.  
C     KWIK   =    1     ==> Some overland flow occuring.  
C#### WCH, 4/7/94.  
C     KWIKSN =    0     ==> No snow on catchment surface.  
C     KWIKSN =    1     ==> Snow somewhere in catchment.  
C  
C     KWIKGT =    0     ==> No channel/pipe routing occuring.  
C     KWIKGT =    1     ==> Some channel/pipe routing occuring.  
C  
C     Set DELUGE = TRUE if reach a time with precipitation.  
C=======================================================================  
      IF(NSTEP.GT.JDRY) DELUGE = .TRUE.  
      IF(DELUGE) THEN  
C#### RED (WCH), 12/31/93.  Calculate DELT based on IMSHORT.  
                 IF(IMSHORT.EQ.0) DELT   = WET  
                 IF(IMSHORT.EQ.1) DELT   = THISTO  
                 IF(IMSHORT.EQ.2) DELT   = THISTO/FLOAT(JWET)  
C####                 DELT   = WET  
                 DO 305 J = 1,NRGAG  
  305            REIN(J)  = BANE(J)  
C=======================================================================  
C     Here if DELUGE is false (not a time step with precipitation).  
C  
C     Use WETDRY time step for:  
C     - remaining overland flow  
C     - snow on surface  
C     - remaining channel/pipe flow  
C     - groundwater flow to channel/pipes.  
C  
C     Use DRY time step if none of the above.  Thus, DRY applies to  
C     lingering evaporation, infiltration and groundwater ET/seepage.  
C  
C     NOTE: Time steps are only approximately equal to DRY or WETDRY.  
C     Divide interval between end of precip (or snow) and next precip  
C     into intervals nearest to DRY or WETDRY.  This means that  
C     calculations and time step print-outs do not necessarily come at  
C     even time intervals corresponding to DRY or WETDRY entered by the  
C     user.  
C=======================================================================  
                 ELSE  
                 DO 310 J = 1,NRGAG  
  310            REIN(J)  = 0.0  
C=======================================================================  
C#### WCH, 4/7/94.  Change code to add check for snow on surface or  
C     overland flow or channel/pipe flow.  Need to use WETDRY time step  
C     if there is snow because don't know when it will melt.  
C  
C     For snow, variable KWIKSN is initialized in WSHED and changed  
C     (if snow is present) in SNOW.  
C  
C     Check for presence of channel/pipe routing in GUTTER.  
C=======================================================================  
                 IF((ISNOW.GT.0.AND.KWIKSN.EQ.1).OR.KWIKGT.EQ.1) KWIK=1  
C=======================================================================  
C     Purpose of logical variable DESERT is to ensure that only pass  
C     through following IF-THEN loop once, to set time step at beginning  
C     of a dry or wet/dry period.  
C     This is the only place where DRY time step is established.  
C=======================================================================  
                 IF(KWIK.EQ.0.AND.DESERT) THEN  
                               TMREM = FLOAT(JDRY-NSTEP+1)*XDELT  
                               JDRY  = IFIX(TMREM/DRY)  
                               IF(JDRY.EQ.0) THEN  
                                             JDRY  = 1  
                                             DELT  = TMREM  
                                             ELSE  
                                             DELT = TMREM/FLOAT(JDRY)  
                                             ENDIF  
                               DESERT = .FALSE.  
                               NSTEP  = 1  
                               ENDIF  
C=======================================================================  
C     Similarly, if water is on surface (or KWIK is otherwise set to 1),  
C     then only pass through following IF-THEN once, to set up time  
C     intervals.  
C=======================================================================  
                 IF(KWIK.GT.0.AND. .NOT.DESERT) THEN  
                               TMREM = FLOAT(JDRY-NSTEP+1)*DELT  
                               JDRY  = IFIX(TMREM/WETDRY)  
                               IF(JDRY.EQ.0) THEN  
                                             JDRY  = 1  
C#### WCH, 4/7/94.  CHANGE DELT TO XDELT IN ORDER TO USE THESE CALCS.  
                                             XDELT  = TMREM  
                                             ELSE  
C#### WCH, 4/7/94.  CHANGE DELT TO XDELT IN ORDER TO USE THESE CALCS.  
                                             XDELT = TMREM/FLOAT(JDRY)  
                                             ENDIF  
                               DESERT = .TRUE.  
                               NSTEP  = 1  
                               ENDIF  
                 IF(KWIK.GT.0) DELT = XDELT  
                 ENDIF  
      REIGN  = REIN(1)  
      TIME   = TIME + DELT  
      FINF   = CNT(4)  
      IF(TIME.GT.LONG) THEN  
                       DELT = LONG - TIME + DELT  
                       TIME = LONG  
                       IF(NRAIN.GT.0) NRAIN = NRAIN - 1  
                       ENDIF  
C=======================================================================  
C#### WCH, 11/30/93.  TRY DEFINITION OF DLAST AND DMEAN CONSISTENT WITH  
C                     OTHER BLOCKS AND COMPUTATIONS.  USE NEW DELT FOR  
C                     DMEAN IF PAST TIME STEP WAS DRY (NO RUNOFF TO  
C                     INLETS, LWEAT = 0).  
C=======================================================================  
                     DMEAN = 0.5 * (DLAST + DELT)  
      IF(LWEAT.EQ.0) DMEAN = DELT  
C  
      CALL STIME(DELT)  
cim   need to write to 6 not * to get carriage control on writes to console  
      WRITE(6,22) MTIME,TIME/3600.0,JULDAY  
C=======================================================================  
C     Watershed Elements (Overland Flow).  
C=======================================================================  
      CALL WSHED(REIN,KWIK)  
C#######################################################################  
C     C. Moore, CDM, 8/93.  I/I timestep calculations.  
C=======================================================================  
      IF (RRMAX.GT.0.0) CALL RDIISHED  
C=======================================================================  
C     Watershed Quality contributions.  
C=======================================================================  
      IF(KWALTY.EQ.1) CALL QSHED  
C=======================================================================  
C#### WCH, 9/93.  Add infiltration/inflow to subcatchment flows after  
C       performing quality calculations.  
C=======================================================================  
      IF(RRMAX.GT.0.0) THEN  
           DO 220 JK = 1,NOW  
  220      WFLOW(JK) = WFLOW(JK) + FLOWII(JK)  
           ENDIF  
C=======================================================================  
C     Channel/Pipe Elements.  
C=======================================================================  
C#### WCH, 4/7/94.  ADD PARAMETER KWIKGT  
      CALL GUTTER(REIGN,KWIKGT)  
C=======================================================================  
C     Sum inlet flows over the basin.  
C=======================================================================  
      FLWOFF    = 0.0  
cim   next should be NSAVE  NOT   NOW  
      DO 250 JK = 1,NSAVE  
      IF(NGTOI(JK).EQ.0) GO TO 255  
      NX        = NGTOI(JK)  
  250 FLWOFF    = FLWOFF  + OUTFLW(NX)  
  255 CNT(5)    = CNT(5)  + FLWOFF*DMEAN  
      FINF      = (CNT(4) - FINF)/DELT  
      DLAST = DELT  
C=======================================================================  
C#### WCH, 11/30/93.  TRY DEFINITION OF DLAST/DMEAN CONSISTENT WITH  
C                     BLOCKS.  
C####      IF(LWEAT.EQ.0) DLAST = WET  
C####                     LWEAT = KWIK  
C=======================================================================  
      LWEAT = 1  
      IF(FLWOFF.LE.0.0) LWEAT = 0  
C  
      IF(IPRN(2).EQ.0) WRITE(NFLOW,ERR=778,IOSTAT=IOS) TIME,FLWOFF,FINF  
C=======================================================================  
      IF(TIME.EQ.LONG) GO TO 2100  
      NSTEP = NSTEP + 1  
      IF(NSTEP.LE.JDRY+JWET) GO TO 2050  
 2000 CONTINUE  
 2100 CONTINUE  
      CALL DATED  
      WRITE(N6,272) MONTH,NDAY,NYEAR,MTIME,JULDAY,TIMDAY,TIMDAY/3600.0,  
     +              TIME/3600.0,TIME/86400.0  
C=======================================================================  
C     Write the extrapolation summary.  
C=======================================================================  
      WRITE(N6,8000)  
      DO 8100 J = 1,NOW,3  
      JJ        = J + 2  
      IF(JJ.GT.NOW) JJ = NOW  
      IF(JCE.EQ.0) WRITE(N6,8020) (NAMEW(K),LND(K),KLND(K),K=J,JJ)  
      IF(JCE.EQ.1) WRITE(N6,8021) (KAMEW(K),LND(K),KLND(K),K=J,JJ)  
 8100 CONTINUE  
C=======================================================================  
      IF(NOG.GT.0.AND.NOG.NE.999) THEN  
             WRITE(N6,8010)  
             DO 8200 J = 1,NOG,3  
             JJ        = J + 2  
             IF(JJ.GT.NOG) JJ = NOG  
             IF(JCE.EQ.0) WRITE(N6,8020) (NAMEG(K),  
     +                                    LCHAN(K),KCHAN(K),K=J,JJ)  
             IF(JCE.EQ.1) WRITE(N6,8021) (KAMEG(K),  
     +                                    LCHAN(K),KCHAN(K),K=J,JJ)  
 8200        CONTINUE  
             ENDIF  
C=======================================================================  
C     Calculate final subsurface storage.  
C=======================================================================  
      GRAREA     = 0.0  
      IF(NOGWSC.GT.0) THEN  
      DO 286 JE1 = 1,NOGWSC  
      GRAREA     = GRAREA + WAREA(JE1)  
 286  CNT(16)    = CNT(16)+TH1(JE1)*(GRELEV(JE1)-STG(JE1))*WAREA(JE1) +  
     +             POR(JE1)*(STG(JE1)-BELEV(JE1))*WAREA(JE1)  
      ELSE  
      GRAREA     = TRIBA  
      ENDIF  
C=======================================================================  
C     Compute water volume on subcatchments.  
C=======================================================================  
                     KKK = 3  
      IF(ISNOW.GT.0) KKK = 4  
      CNT(10)  = 0.0  
      DO 288 K = 1,KKK  
      DO 288 J = 1,NOW  
  288 CNT(10)  = CNT(10) + WDEPTH(K,J)*WAR(K,J)  
C=======================================================================  
C     Compute snow volume on subcatchments.  
C=======================================================================  
      IF(ISNOW.GT.0) THEN  
            DO 290 J = 1,NOW  
            CNT(8) = CNT(8)+(WSNOW(2,J)+FW(2,J))*WAR(2,J)  
            CNT(8) = CNT(8)+(WSNOW(1,J)+FW(1,J))*WAR(4,J)  
  290       CNT(8) = CNT(8)+(WSNOW(3,J)+FW(3,J))*(WAR(1,J)+WAR(3,J))  
            END IF  
      DO 295 K  = 1,MQUAL  
  295 REFF(1,K) = 0.0  
      IF(NOG.EQ.0.OR.NOG.EQ.999) GO TO 350  
C=======================================================================  
C     Compute water stored in channels.  
C=======================================================================  
      DO 340 J = 1,NOG  
      IF(NPG(J).EQ.3) GO TO 340  
C=======================================================================  
C     Volume in TRAPEZOIDAL SECTIONS.  
C=======================================================================  
      IF(NPG(J).EQ.1) AX = 0.5*(GS1(J)+GS2(J))*GDEPTH(J)**2 +  
     +                     GWIDTH(J)*GDEPTH(J)  
C=======================================================================  
C     Volume in circular sections. Compute area of segment of a circle.  
C=======================================================================  
      IF(NPG(J).EQ.2) AX = GWIDTH(J)**2/4.0*(GDEPTH(J) -  
     +                     0.5*SIN(2.0*GDEPTH(J)))  
      IF(NPG(J).EQ.4) THEN  
                      WIDTH = GWIDTH(J)*SQRT(GDEPTH(J)/DFULL(J))  
                      AX    = 0.66666667*WIDTH*GDEPTH(J)  
                      ENDIF  
      VOL    = AX*GLEN(J)  
      CNT(7) = CNT(7) + VOL + QSUR(J)  
C=======================================================================  
C     Calculate remaining channel pollutant loads.  
C     Store the sums in array REFF until reaching print routines.  
C=======================================================================  
      IF(NQS.NE.0) THEN  
                   DO 335 K  = 1,NQS  
                   RNEW      = VOL*C(K,J) + CVSUR(K,J)  
  335              REFF(1,K) = REFF(1,K)  + RNEW  
                   ENDIF  
  340 CONTINUE  
C=======================================================================  
C     Compute continuity error due to computations.  
C=======================================================================  
  350 SUMALL  = CNT(4) + CNT(6) + CNT(19) + CNT(21) +  
     +          CNT(8) + CNT(9) + CNT(10)  
C=======================================================================  
C     Print values in inches or millimeters over the basin.  
C     The number 3630 converts cubic feet per acre to inches.  
C=======================================================================  
      TY       =  TRIBA*3630.0  
      GY       = GRAREA*3630.0/43560.0  
      DO 351 J = 1,30  
      IF(J.LE.10.OR.J.GE.20) THEN  
                             IF (TY.NE.0.0) THEN  
                             ZUM(J)   = CNT(J)/TY  
                             ELSE  
                             ZUM(J)   = 0.0  
                             END IF  
                             ELSE  
                             IF (GY.NE.0.0) THEN  
                             ZUM(J)   = CNT(J)/GY  
                             ELSE  
                             ZUM(J) = 0.0  
                             END IF  
                             ENDIF  
  351 CONTINUE  
      IF (TY.NE.0.0) THEN  
                        ZALL    = SUMALL/TY  
      ELSE  
                        ZALL    = 0.0  
      END IF  
      IF(PRCIMP.LT.1.0) ZUM(18) = ZUM(11)/(1.0-PRCIMP)  
      IF(PRCIMP.LT.1.0) ZUM(19) = ZUM(12)/(1.0-PRCIMP)  
C=======================================================================  
C     IF METRIC = 2 ALL SUMMERS WILL HAVE TO BE CONVERTED TO CUBIC  
C                   METERS AND MILLIMETERS FROM CUBIC FEET AND  
C                   AND INCHES RESPECTIVELY.  
C=======================================================================  
      DO 355 J = 1,30  
      ZUM(J)   = ZUM(J) * CMET(5,METRIC)  
 355  CNT(J)   = CNT(J) / CMET(8,METRIC)  
      SUMALL   = SUMALL / CMET(8,METRIC)  
      ZALL     = ZALL   * CMET(5,METRIC)  
C=======================================================================  
C     Write the title for the continuity page depending on metric.  
C     CNT(21) = surface runoff from subcatchments  
C=======================================================================  
      IF(METRIC.EQ.1) WRITE (N6,360) CNT(1),ZUM(1)  
      IF(METRIC.EQ.2) WRITE (N6,361) CNT(1),ZUM(1)  
      IF(ISNOW.GT.0)  WRITE(N6,370)  CNT(2),ZUM(2),CNT(3),ZUM(3)  
                      WRITE(N6,380)  CNT(4),ZUM(4),CNT(6),ZUM(6),  
     1                               CNT(21),ZUM(21),CNT(10),ZUM(10)  
      IF(ISNOW.GT.0)  WRITE(N6,390)  CNT(8),ZUM(8),CNT(9),ZUM(9)  
C=======================================================================  
C     Calculate the infiltration in inches over the pervious area only.  
C=======================================================================  
      IF(PRCIMP.LT.1.0)    ZUM4 = ZUM(4) / ( 1.0 - PRCIMP )  
      Z1    = CNT(1) + CNT(3)  
      Z2    = ZUM(1) + ZUM(3)  
                    ERRER = 0.0  
      IF(Z2.NE.0.0) ERRER = 100.0*(Z2 - ZALL)/Z2  
      WRITE(N6,395) CNT(4),ZUM4,SUMALL,ZALL,Z1,Z2  
      WRITE(N6,400) ERRER  
C#### C. MOORE, CDM, 8/93.  
      WRITE(*,401) ERRER  
C#######################################################################  
C     C. Moore, CDM, 8/93.  Write the I/I continuity check.  
C#######################################################################  
      IF (RRMAX.GT.0.0) THEN  
cim           SUMOFRS = 0.0  
cim           DO 3340 J=1,NOW  
cim           DO 3340 I=1,3  
cim           DO 3340 JJ=1,12  
cim 3340      SUMOFRS = SUMOFRS + RDIIR(J,I,JJ)*SEWAREA(J)  
           SUMOFRS = SUMOFRS/RDIIAREA  
           SUMRII  = 0.0  
           DO 3350 I=1,3  
 3350      SUMRII = SUMRII + CNTRDII(I)  
CIM### 9/8/00 corrections for metric units  
	  IF(METRIC.EQ.2) THEN  
           IF(CNEXCESS.NE.0.0) THEN  
                ERRER = (SUMRII/35.315/RDIIAREA/10.0 -  
     +                  SUMOFRS*CNEXCESS)*100.0/(SUMOFRS*CNEXCESS)  
                ELSE  
                ERRER = 999.0  
                IF(SUMRII.EQ.0.0) ERRER = 0.0  
                ENDIF  
	   ELSE  
           IF(CNEXCESS.NE.0.0) THEN  
                ERRER = ((SUMRII/(RDIIAREA*3630.0)) -  
     +                  SUMOFRS*CNEXCESS)*100.0/(SUMOFRS*CNEXCESS)  
                ELSE  
                ERRER = 999.0  
                IF(SUMRII.EQ.0.0) ERRER = 0.0  
                ENDIF  
	   ENDIF  
CIM### 9/8/00  
C=======================================================================  
C     Include metric options.  
C=======================================================================  
           IF(METRIC.EQ.1) WRITE(N6,3358)  
           IF(METRIC.EQ.2) WRITE(N6,3359)  
           IF(METRIC.EQ.1)  
     1       WRITE(N6,3360) CNRAIN*RDIIAREA*43560.0/12.0,CNRAIN,  
     2       CNEXCESS*RDIIAREA*43560.0/12.0,CNEXCESS,SUMOFRS,  
     3       SUMOFRS*CNEXCESS*RDIIAREA*43560.0/12.0,SUMOFRS*CNEXCESS,  
     4       CNTRDII(1),(CNTRDII(1)/(RDIIAREA*3630.0)),  
     5       CNTRDII(2),(CNTRDII(2)/(RDIIAREA*3630.0)),  
     6       CNTRDII(3),(CNTRDII(3)/(RDIIAREA*3630.0)),  
     7       SUMRII,(SUMRII/(RDIIAREA*3630.0))  
           IF(METRIC.EQ.2)  
CIM### 9/8/00 Correction for metric units  
c     1       WRITE(N6,3360) CNRAIN*RDIIAREA*43560.0/12.0/35.3133,  
c     2       CNRAIN*25.4,CNEXCESS*RDIIAREA*43560.0/12.0/35.315,  
c     3       CNEXCESS*25.4,SUMOFRS,  
c     4       SUMOFRS*CNEXCESS*RDIIAREA*43560.0/12.0/35.315,  
c     5       SUMOFRS*CNEXCESS*25.4,  
c     6       CNTRDII(1)/35.315,CNTRDII(1)/(RDIIAREA*3630.0)*25.4,  
c     7       CNTRDII(2)/35.315,CNTRDII(2)/(RDIIAREA*3630.0)*25.4,  
c     8       CNTRDII(3)/35.315,CNTRDII(3)/(RDIIAREA*3630.0)*25.4,  
c     9       SUMRII/35.315,SUMRII/(RDIIAREA*3630.0)*25.4  
CIM   CNRAIN, CNEXCESS IS MM  RDIIAREA IS HECTARES  
     1       WRITE(N6,3360) CNRAIN/1000.0*RDIIAREA*10000.0,CNRAIN,  
     1       CNEXCESS/1000.0*RDIIAREA*10000.0,CNEXCESS,  
     2       SUMOFRS,  
     4       SUMOFRS*CNEXCESS/1000.0*RDIIAREA*10000.0,  
     5       SUMOFRS*CNEXCESS,  
     6       CNTRDII(1)/35.315,CNTRDII(1)/35.315/RDIIAREA/10.0,  
     7       CNTRDII(2)/35.315,CNTRDII(2)/35.315/RDIIAREA/10.0,  
     8       CNTRDII(3)/35.315,CNTRDII(3)/35.315/RDIIAREA/10.0,  
     9       SUMRII/35.315,SUMRII/35.315/RDIIAREA/10.0  
CIM### 9/8/00  
           IF(IIRDII.EQ.0) THEN  
                WRITE(N6,3361) ERRER  
                WRITE(*,3362) ERRER  
                ELSE  
                WRITE(N6,3363)  
                ENDIF  
           ENDIF  
C=======================================================================  
C     Write the channel/pipe continuity check.  
C=======================================================================  
      IF(TY.NE.0.0) THEN  
Cwch, 2/10/01.  Metric correction from Sandy Elliot, NIWA, New Zealand.  
C           ZUM13   = CNT(13)/TY  
           ZUM13   = CNT(13)*CMET(8,METRIC)/TY*CMET(5,METRIC)  
           ELSE  
           ZUM13   = 0.0  
           ENDIF  
      C1      = CNT(5)  + CNT(7)  + CNT(22)  
      C2      = CNT(20) + CNT(21) + CNT(13)  
      Z1      = ZUM(5)  + ZUM(7)  + ZUM(22)  
C#### C. MOORE, CDM, 8/93  
      ZZ1     = CNT(5)  + CNT(7)  + CNT(22)  
      Z2      = ZUM(20) + ZUM(21) + ZUM13  
                    ERRER = 0.0  
C#### C. MOORE, CDM, 8/93  
CCC   IF(Z1.NE.0.0) ERRER = 100.0*(Z1 - ZUM(20) - ZUM13 - ZUM(21))/Z1  
      IF(ZZ1.NE.0.0) ERRER = 100.0*(ZZ1-CNT(20)-CNT(13)-CNT(21))/ZZ1  
      IF(METRIC.EQ.1) WRITE(N6,365) CNT(20),ZUM(20),CNT(7),ZUM(7),  
     +                CNT(21),ZUM(21)  
      IF(METRIC.EQ.2) WRITE(N6,366) CNT(20),ZUM(20),CNT(7),ZUM(7),  
     +                CNT(21),ZUM(21)  
C#### C. MOORE, CDM, 8/93  
      IF(RRMAX.NE.0.0) THEN  
           IF(METRIC.EQ.1) WRITE(N6,369) SUMRII,SUMRII/TY  
           IF(METRIC.EQ.2) WRITE(N6,369) SUMRII/35.315,  
     +                     SUMRII/TY*25.4  
           ERRER = 0.0  
CIM### 9/8/00 Metric correction  
      IF (METRIC.EQ.1) THEN  
           IF(ZZ1.NE.0.0) ERRER = 100.0*(ZZ1-CNT(20)-CNT(13)-CNT(21)-  
     +                            SUMRII)/ZZ1  
      ELSE  
           IF(ZZ1.NE.0.0) ERRER = 100.0*(ZZ1-CNT(20)-CNT(13)-CNT(21)-  
     +                            SUMRII/35.315)/ZZ1  
      endif  
CIM###  
           ENDIF  
      WRITE(N6,367)   CNT(13),ZUM13,CNT(22),  
     +                ZUM(22),CNT(5),ZUM(5),C2,Z2,C1,Z1,ERRER  
C#### C. MOORE, CDM, 8/93  
      WRITE(*,368) ERRER  
C=======================================================================  
C     Write the groundwater continuity check.  
C=======================================================================  
      IF(NOGWSC.GT.0) THEN  
           SUMSBS = ZUM(11)+ZUM(12)+ZUM(13)+ZUM(14)+ZUM(16)  
           IF((ZUM(17)+ZUM(15)).NE.0.0) THEN  
                      SUBERR = (ZUM(17)+ZUM(15)-SUMSBS)/  
     +                         (ZUM(17)+ZUM(15))*100.0  
                      ELSE  
                      SUBERR = 0.0  
                      ENDIF  
            WRITE(N6,356)  
            IF(METRIC.EQ.1) WRITE(N6,358)  
            IF(METRIC.EQ.2) WRITE(N6,357)  
            WRITE(N6,870) CNT(17),ZUM(17),  
     1                CNT(11),ZUM(11),CNT(12),ZUM(12),CNT(13),ZUM(13),  
     2                CNT(14),ZUM(14),CNT(15),ZUM(15),CNT(16),ZUM(16),  
     3                CNT(11),ZUM(18),CNT(12),ZUM(19)  
            ENDIF  
      IF(NOGWSC.NE.0) WRITE(N6,871) SUBERR  
C#######################################################################  
C     Chuck Moore, CDM, 8/93.  Call routine to print summary statistics  
C       for channel/pipes.  
C#######################################################################  
      CALL SMSTAT  
C=======================================================================  
C     CALCULATE THE QUALITY LOAD REMAINING ON THE SURFACE  
C     AND IN THE CATCHBASINS AT THE END OF THE SIMULATION  
C     THE SUMS WILL BE STORED IN ARRAYS PSHED AND PBASIN  
C     FOR EVENTUAL PRINTOUT IN SUBROUTINE PRPOLL.  
Cwch, 1/4/01. Initialize summers inside loop on quality.   
C     Initialize SUMWAT in RUNOFF.     
C=======================================================================  
      IF(NQS.GE.1) THEN  
                   DO 500 I = 1,NQS  
                   SUMSRF   = 0.0  
                   SUMCAT   = 0.0  
                   DO 600 K = 1,NOW  
                   SUMCAT   = SUMCAT + PBASIN(I,K)  
C=======================================================================  
Cwch, 1/4/01 Here need to fix summer, using correct land use value.  
Cwch, 12/20/00. Use SUMNL(J,I,10) to store remaining loads by land use.  
C     And it gets more complicated.  If subcatchment to subcatchmnet or  
C     internal subcatchment overland flow routing occurs, must include  
C     remaining concentration in summation.    
C=======================================================================  
                   IKALC = 0  
                   IF(NWTOW(1,K).NE.0.OR.IFLOWP(K).EQ.1.OR.IFLOWP(K)  
     1  .EQ.2.OR.IFLOWP(K).EQ.4.OR.IFLOWP(K).EQ.5) IKALC = 1  
	             IF(IKALC.EQ.1) THEN  
	                  IJK = 3  
					  IF(ISNOW.GT.0) IJK = 4  
	                  VOL4Q = 0.0  
	                  DO IK=1,IJK  
	                     VOL4Q = VOL4Q + WDEPTH(IK,K)*WAR(IK,K)  
	                     ENDDO  
	                  ENDIF  
				 DO 600 JJ = 1,N1  
	             IF(N1.EQ.1) J = KLAND(K)  
	             IF(N1.GT.1) J = JJ  
	             SUMNL(J,I,10) = SUMNL(J,I,10) + PSHED(J,I,K)  
                   SUMSRF        = SUMSRF        + PSHED(J,I,K)  
C=======================================================================  
Cwch, 12/20/00. Note that land uses are NOT associated with the four  
C     subcatchment flow subareas.  Hence, distribute volume over each  
C     subarea strictly on the basis of the land use fraction.  
C=======================================================================  
	             IF(IKALC.EQ.1) THEN  
	                  SUMWAT(I) = SUMWAT(I) +  
     1                    VOL4Q*PLAND(J,K)*COFF(J,I,K)  
                        SUMNL(J,I,11) = SUMNL(J,I,11) +   
     1                    VOL4Q*PLAND(J,K)*COFF(J,I,K)					    
                        ENDIF  
 600               CONTINUE  
C=======================================================================  
C     Change the units from milligrams to kilograms.  
C     Careful. Here we use PSHED(1,poll#,1) to store remaining  
C     surface load. Can do this because run through land use subscripts   
C     (first subscript) first, in loop just above, and use subscript 1  
C     from first subcatchment.  Hence, we read data before writing  
C     over them.   
C=======================================================================  
                   SUMSRF       = SUMSRF / 1.0E06  
                   SUMCAT       = SUMCAT / 1.0E06  
                   PSHED(1,I,1) = SUMSRF  
                   PBASIN(I,1)  = SUMCAT  
 500               CONTINUE  
C=======================================================================  
C     Calculate the remaining pollutant loads in the channel system.  
C     Change the units of REFF from NDIM units * flow to units of KG.  
C=======================================================================  
                   DO 850  K = 1,NQS  
                   ND        = NDIM(K)   + 1  
 850               REFF(1,K) = REFF(1,K) * FACT3(ND) / 1.0E06  
                   ENDIF  
      RETURN  
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY.  
 777  WRITE(N6,9777) MOD(IOS,256)  
      STOP  
 778  WRITE(N6,9778) MOD(IOS,256)  
      STOP  
C=======================================================================  
   22 FORMAT('+',20X,'Step=',I10,F10.2,' hours. Julian Date = ',I7)  
   23 FORMAT(/,' Beginning time step loop.  End at time ',  
     1           F11.2,' hours. Final date is ',I7,/,  
     2 ' Current step/time = ',/)  
  272 FORMAT(/,  
     1' ************************************************',/,  
     2' *      End of time step DO-loop in Runoff      *',/,  
     3' ************************************************',//,  
     4' Final Date (Mo/Day/Year)   = ',T48,I2,'/',I2,'/',I4,/,  
     5' Total number of time steps = ',T50,I8,/,  
     6' Final Julian Date  =',T45,5X,I8,/,  
     7' Final time of day  =',T45,F13.0,' seconds.',/,  
     8' Final time of day  =',T45,F13.2,'   hours.',/,  
     9' Final running time =',T45,F13.4,'   hours.',/,  
     9' Final running time =',T45,F13.4,'    days.')  
Cwch, 1/7/03   
 2110 FORMAT (/,' End of preliminary input data and data echo.')  
 2115 FORMAT(//,  
     +' ***************************************************',/,  
     +' *  Precipitation Interface File Summary           *',/,  
     +' *  Number of precipitation station....',I9,'   *',/,  
     +' ***************************************************',/)  
C#### WCH, 8/1/95.  CHANGE I13 TO A13.  
 2120 FORMAT(' Location Station Number',/,  
     +       ' -------- --------------',/,  
     +       10(I9,'. ',A13,/))  
 356  FORMAT(/,1H1,/,  
     +' ***************************************************',/,  
     +' *     Continuity Check for Subsurface Water       *',/,  
     +' ***************************************************',/)  
 357  FORMAT(70X,'Millimeters over',/,51X,'cubic meters',7X,  
     .      'Subsurface Basin')  
 358  FORMAT(70X,'Inches over',/,54X,'cubic feet',6X,  
     .       'Subsurface Basin')  
 360  FORMAT(1H1,/,  
     +' **********************************************',/,  
     +' *       Continuity Check for Surface Water   *',/,  
     +' **********************************************',/,  
     1 69X,'Inches over',/, 55X,'cubic feet    Total Basin',/,  
     2 ' Total Precipitation (Rain plus Snow)',16X,1PE13.6,0PF11.3)  
 361  FORMAT(1H1,/,  
     +' **********************************************',/,  
     +' *       Continuity Check for Surface Water   *',/,  
     +' **********************************************',/,  
     1 69X,'Millimeters over',/,55X,'cubic meters  Total Basin',/,  
     2 ' Total Precipitation (Rain plus Snow)',16X,1PE13.6,0PF11.3)  
 365  FORMAT(//,  
     +' **********************************************',/,  
     +' *       Continuity Check for Channel/Pipes   *',/,  
     +' **********************************************',/,  
     1 69X,'Inches over',/,55X,'cubic feet    Total Basin',/,  
     2' Initial Channel/Pipe Storage................',  
     2  8X,1PE13.6,0PF11.3,/,  
     3' Final Channel/Pipe Storage..................',  
     2  8X,1PE13.6,0PF11.3,/,  
     4' Surface Runoff from Watersheds..............',  
     2  8X,1PE13.6,0PF11.3)  
 366  FORMAT(//,  
     +' **********************************************',/,  
     +' *       Continuity Check for Channel/Pipes   *',/,  
     +' **********************************************',/,  
     1 69X,'Millimeters over',/,55X,'cubic meters  Total Basin',/,  
     2' Initial Channel/Pipe Storage................',  
     2  8X,1PE13.6,0PF11.3,/,  
     3' Final Channel/Pipe Storage..................',  
     2  8X,1PE13.6,0PF11.3,/,  
     4' Surface Runoff from Watersheds..............',  
     2  8X,1PE13.6,0PF11.3)  
  368 FORMAT(' Continuity Check for Channel/Pipes =      ',F10.2,  
     1 ' Percent')  
C#### C. MOORE, CDM, 8/93  
  369 FORMAT(  
     1' Total I/I Volume ...........................',  
     2  8X,1PE13.6,0PF11.3)  
  367 FORMAT(  
     5' Groundwater Subsurface Inflow...............',  
     2  8X,1PE13.6,0PF11.3,/,  
     6' Evaporation Loss from Channels..............',  
     2  8X,1PE13.6,0PF11.3,/,  
     7' Channel/Pipe/Inlet Outflow..................',  
     2  8X,1PE13.6,0PF11.3,/,  
     7' Initial Storage + Inflow....................',  
     2  8X,1PE13.6,0PF11.3,/,  
     7' Final Storage + Outflow.....................',  
     2  8X,1PE13.6,0PF11.3,/,  
     8' ********************************************',/,  
     9' * Final Storage + Outflow + Evaporation  - *',/,  
     9' * Watershed Runoff - Groundwater Inflow  - *',/,  
     9' *     Initial Channel/Pipe Storage         *',/,  
     9' *     ----------------------------------   *',/,  
     9' *  Final Storage + Outflow  + Evaporation  *',/,  
     9' ********************************************',/,  
     9' Error.......................................',F11.3,  
     9' Percent')  
 370  FORMAT (' Total Rain only',37X,1PE13.6,0PF11.3,/,  
     1 ' Total Initial Snow Cover (Water equiv.)',13X,1PE13.6,0PF11.3)  
 380  FORMAT (' Total Infiltration',34X,1PE13.6,0PF11.3,/,  
     1 ' Total Evaporation                  ',17X,1PE13.6,0PF11.3,/,  
     2 ' Surface Runoff from Watersheds     ',17X,1PE13.6,0PF11.3,/,  
     4 ' Total Water remaining in Surface Storage',12X,1PE13.6,0PF11.3)  
 390  FORMAT(' Total Water remaining in Snow Cover',17X,1PE13.6,  
     .        0PF11.3,/,' Total Snow removed from Basin (Water equiv.)',  
     .        8X,1PE13.6,0PF11.3)  
 395  FORMAT(' Infiltration over the Pervious Area...',14X,1PE13.6,  
     . 0PF11.3,/,'                       --------        ',/,  
     .         ' Infiltration + Evaporation + ',/,  
     .         ' Surface Runoff + Snow removal +',/,  
     .         ' Water remaining in Surface Storage +',/,  
     .         ' Water remaining in Snow Cover.........',  
     .           14X,1PE13.6,0PF11.3,/,  
     .         ' Total Precipitation + Initial Storage.',  
     .           14X,1PE13.6,0PF11.3)  
  400 FORMAT(//,' The error in continuity is calculated as',/,  
     .      ' ***************************************',/,  
     .      ' * Precipitation + Initial Snow Cover  *',/,  
     .      ' *      - Infiltration -               *'/,  
     .      ' *Evaporation - Snow removal -         *',/,  
     .      ' *Surface Runoff from Watersheds -     *',/,  
     .      ' *Water in Surface Storage -           *',/,  
     .      ' *Water remaining in Snow Cover        *',/,  
     .      ' *-------------------------------------*',/,  
     .      ' * Precipitation + Initial Snow Cover  *',/,  
     .      ' ***************************************',/,  
     .      ' Error..................................',  
     .       3X,F10.3,' Percent')  
  401 FORMAT(/,' Continuity Check for Surface Water =      ',F10.2,  
     1 ' Percent')  
 870  FORMAT(/,' Total Infiltration',34X,1PE13.6,0PF11.3,/,  
     .       ' Total Upper Zone ET',33X,1PE13.6,0PF11.3,/,  
     .       ' Total Lower Zone ET',33X,1PE13.6,0PF11.3,/,  
     .       ' Total Groundwater flow',30X,1PE13.6,0PF11.3,/,  
     .       ' Total Deep percolation',30X,1PE13.6,0PF11.3,/,  
     .       ' Initial Subsurface Storage',26X,1PE13.6,0PF11.3,/,  
     .       ' Final Subsurface Storage',28X,1PE13.6,0PF11.3,/,  
     .       ' Upper Zone ET over Pervious Area',  
     .         20X,1PE13.6,0PF11.3,/,  
     .       ' Lower Zone ET over Pervious Area',  
     .         20X,1PE13.6,0PF11.3)  
 871  FORMAT(//,' ******************************************',/,  
     .          ' * Infiltration + Initial Storage - Final *',/,  
     .          ' * Storage - Upper and Lower Zone ET -    *',/,  
     .          ' * Groundwater Flow - Deep Percolation    *',/,  
     .          ' * -------------------------------------- *',/,  
     .          ' *     Infiltration + Initial Storage     *',/,  
     .          ' ******************************************',/,  
     .          ' Error ....................................',  
     .            F10.3,1X,'Percent',//)  
C#### C. MOORE, CDM, 8/93  
 3358 FORMAT(1H1,/,  
     +' *****************************************************',/,  
     +' *       Continuity Check for Infiltration/Inflow    *',/,  
     +' *****************************************************',/,  
     1 68X,'Inches over',/, 54X,'cubic feet    Sewered Area')  
 3359 FORMAT(1H1,/,  
     +' *****************************************************',/,  
     +' *       Continuity Check for Infiltration/Inflow    *',/,  
     +' *****************************************************',/,  
     1 68X,'mm over',/, 54X,'cubic meters  Sewered Area')  
 3360 FORMAT(  
     2 ' Approx. Total Rain for I/I (Avg. of hyetographs)....',  
     3 1PE13.6,0PF11.3,/,  
     4 ' Total I/I Excess (Rain minus storage losses)........',  
     5 1PE13.6,0PF11.3,/,  
     6 ' Area Weighted Average Total Ratio......',0PF13.6,/,  
     7 ' Approx. Total Infiltration (Ratio*I/I Excess).......',  
     8 1PE13.6,0PF11.3,/,  
     9 ' Total Curve 1 Outflow Volume........................',  
     1 1PE13.6,0PF11.3,/,  
     2 ' Total Curve 2 Outflow Volume........................',  
     3 1PE13.6,0PF11.3,/,  
     4 ' Total Curve 3 Outflow Volume........................',  
     5 1PE13.6,0PF11.3,/,  
     6 ' Total I/I Outflow Volume............................',  
     7 1PE13.6,0PF11.3,//)  
 3361 FORMAT(' Approximate Continuity Error .................',  
     9 0PF10.3,' Percent',//,  
     1 ' Error computed as (Total I/I Outflow Volume - Approx. Total Inf  
     2iltration)  /',/,19X,' (Approx. Total Infiltration)')  
 3362 FORMAT(' Approximate Continuity Check for I/I     =',F10.2,  
     1 ' Percent')  
 3363 FORMAT(' Cannot compute I/I continuity error when using existing I  
     1/I',/,' NSCRAT(8) rainfall file (IIRDII=1).')  
 8000 FORMAT(/,  
     +' **************************************************',/,  
     +' *     Extrapolation Summary for Watersheds       *',/,  
     +' * # Steps ==> Total Number of Extrapolated Steps *',/,  
     +' * # Calls ==> Total Number of OVERLND Calls      *',/,  
     +' **************************************************',//,  
     +'  Subcatch   # Steps   # Calls  Subcatch   # Steps   # Calls  Sub  
     +catch   # Steps   # Calls',/,  
     +'  --------   -------   -------  --------   -------   -------  ---  
     +-----   -------   -------')  
8010  FORMAT(/,  
     +' **************************************************',/,  
     +' *     Extrapolation Summary for Channel/Pipes    *',/,  
     +' * # Steps ==> Total Number of Extrapolated Steps *',/,  
     +' * # Calls ==> Total Number of GUTNR Calls        *',/,  
     +' **************************************************',//,  
     +' Chan/Pipe   # Steps   # Calls Chan/Pipe   # Steps   # Calls Chan  
     +/Pipe   # Steps   # Calls',/,  
     +'  --------   -------   -------  --------   -------   -------  ---  
     +-----   -------   -------')  
8020  FORMAT(9I10)  
8021  FORMAT(3(A10,2I10))  
9777  FORMAT(/,' ===> Error   Reading precipitation time history',  
     1         ' on the NSCRAT(1) file.',/,  
     2' Fortran error number =',I5,'. Run stopped from Sub. HYDRO.')  
9778  FORMAT(/,' ===> Error   Writing inlet hydrograph time history',  
     1         ' on the NSCRAT(4) file.',/,  
     2' Fortran error number =',I5,'. Run stopped from Sub. HYDRO.')  
C=======================================================================  
      END  
ECHO is off.
REM File: INDAT1.FOR  
ECHO is off.
      SUBROUTINE INDAT1  
C	EXTRAN BLOCK  
C	CALLED BY EXTRAN NEAR LINE 198  
C=======================================================================  
C     This Subroutine reads and prints control,  
C     Conduit and Junction data.  
C=======================================================================  
C     THIS PROGRAM LAST MODIFIED BY R.E.D., 4/92.  
C     MODIFICATION IS TO ALLOW ONLY ONE SET OF C3,34 LINES TO BE  
C       USED FOR IRREGULAR CHANNELS IF DESIRED.  
C     ADD INITIAL DATE ON LINE B1, WCH, 4/11/94.  
C     MODIFY FOR CORRECT START TIME USING HOT START, WCH, 7/25/96.  
C       ALSO, MINOR CORRECTION OF PRINTING 'JREDO' INSTEAD OF 'REDO'.  
CIM START  <><><><><><><><><><><><>  
CIM  CHANGE MADE 1/96 BY CDM TO CHANGE INTERNAL NUMBERING OF PIPE  
CIM  TYPES TO ALLOW OTHER TYPES TO BE INCORPORATED  
CIM END  <><><><><><><><><><><>  
CIM  10/98  modifified to remove multiple reads.  Lines are  
CIM  now padded with zeros in STRIP.FOR  
CWCH, 11/12/99, allow for negative IDATZ to force its use with interface  
C    file.  
CWCH, 3/27/00.  Change default date to 19410802 to correspond to other  
C    blocks.  
CWCH, 3/28/00. Fix remarkable typo in computation of equivalent  
C    roughness.  
CIM,  9/8/00.  Open interface after it knows starting date from interface  
C    file.  
CIM,  9/8/00.  Read optional D2 lines for threshold elevations against  
C    which elevations will be compared and reported.  
CWCH 9/8/00.  Trivial change for printout of INTER.  
CWCH 9/9/00.  Metricate ASCII output header and add column headings.  
Cred 2/4/01.  Correction for IDATZ.  
Cwch, 2/10/01.  Add metric conversions for conduits 9,10,11.  
Cwch, 10/30/01. Increase integer field with for conduits at junctions.  
Cwch, 7/20/04. Initialize variables for steady-state check.   
Cwch, 7/20/04. Fix area calc for arch pipes (case 11) and depth-width  
C       table values for vertical ellipse (case 10). From Mike Gregory,  
C       RED, and CIM.   
Cwch, 7/23/04. Provide option for choice of NHEAD spatial weighting.   
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'BD.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'ORF.INC'  
      INCLUDE 'WEIR.INC'  
      INCLUDE 'BND.INC'  
      INCLUDE 'OUT.INC'  
      INCLUDE 'TIDE.INC'  
      INCLUDE 'HYFLOW.INC'  
      INCLUDE 'FLODAT.INC'  
cim TRANAID START  
CIM include common blocks for tranaid interface file  
      INCLUDE 'TRANAID.INC'  
cim TRANAID END  
CIM  NEW COMMON FOR WRITING OF RESULTS TO ASCII FILE  
      INCLUDE 'CWRITE.INC'  
CIM  
CIM  NEW COMMON FOR SAVING AND WRITING INTERMEDIATE CONTINUITY OUTPUT  
      INCLUDE 'INTCON.INC'  
c common for writing detailed EXTRAN ASCII output file.  
      INCLUDE 'ASCOUT1.INC'  
CIM  CHANGE FOR VARIABLE BASE FLOW  
      INCLUDE 'MOBFF.INC'  
CIM  CHANGE FOR BE LINES FOR MULTIPLE OUTPUT PERIODS  
      INCLUDE 'BE.INC'  
CIM  CHANGE FOR BB AND C1 INPUT OF PIPE SEDIMENT DEPTHS  
      INCLUDE 'PIPESED.INC'  
CIM 1/99 CHANGE FOR BA OUTPUT CONTROLS    - OUTPUT CONTROLS  
      INCLUDE 'BALINES.INC'  
	INCLUDE 'WASP.INC'  
cim  <><><><> increase dimensions of CTYPE from 8 to 12 and add types  
cim  to data statement  
cim change dimensions of kdum to NCHN  10/98  
      CHARACTER GTYPE(2)*20,CTYPE(12)*10,KDUM(NCHN)*10,IREAD*4  
	LOGICAL BFFACT,TABLE2  
	LOGICAL GRNDERROR  
      DATA GTYPE/'  POSITIVE FLAP GATE','  NEGATIVE FLAP GATE'/  
      DATA CTYPE/' CIRCULAR ',' RECTANGLE',' HORSESHOE',  
     +           ' EGG-SHAPE',' BASKET   ',' TRAPEZOID',  
     +           ' POWER FNC',' NATURAL  '  
CIM START  <><><><><><><><>  
     +          ,' H ELLIPSE',' V ELLIPSE',' ARCH     ',  
     +           ' BRIDGE   '/  
CIM END   <><><><><><><>  
      DATA IREAD/'CARD'/  
CIM  START  <><><><><><>  
CIM            closed is logical that flags closed conduits for equivalent  
CIM            PIPE CALCS,  NEWKLASS CONTAINS THE MAPPING FROM OLD TO NEW  
CIM            CLASS ID'S  
      LOGICAL CLOSED(NEE)  
      DIMENSION NEWKLASS(12)  
CIM  THESE NEXT ARRAYS CONTAIN DATA FOR STANDARD ELLIPTICAL AND  
CIM  ARCH PIPE TYPES: MAJOR AXIS LENGTH, MINOR AXIS LENGTH,  
CIM  FULL FLOW AREA, FULL FLOW HYDRAULIC RADIUS, INITIALIZED IN  
      INCLUDE 'SHAPE.INC'  
CIM  END     <><><><><><><><><  
C=======================================================================  
C                  E X E C U T I O N  
C=======================================================================  
      NSTOP  = 0  
      ISOL   = 0  
      JSLOT  = 0  
      KSUPER = 0  
      NCSAVE = NSCRAT(4)  
      IF(NCSAVE.GT.0) REWIND NCSAVE  
C=======================================================================  
C     READ THE TWO A1 TITLE LINES  
C=======================================================================  
      READ(N5,*,ERR=888) CC,ALPHA1  
      READ(N5,*,ERR=888) CC,ALPHA2  
      WRITE(N6,2999)  
      WRITE(N6,5060) ALPHA1,ALPHA2  
C=======================================================================  
Cwch, 7/23/04  HERE, OPTION(S) FOR VERSION COMPATIBILITY.  
C=======================================================================  
Cwch, 7/23/04. Initialize NHEAD weighting parameters.  
C     Subscript NAVER = 1 > SWMM3x.  
C     Subscript NAVER = 2 > SWMM4x (default)  
C     Subscript NAVER = 3 > SWMM5  
C=======================================================================  
      WUP(1) = 1./4.  
	WDN(1) = 1./4.  
	WMD(1) = 1./2.  
	WUP(2) = 0.  
	WDN(2) = 0.  
      WMD(2) = 1.0  
      WUP(3) = 1./6.  
      WDN(3) = 1./6.  
      WMD(3) = 2./3.  
      NAVER  = 2  
	NFASNH = 0  
C=======================================================================  
C     READ OPTIONAL LINE AA FOR VERSION COMPATIBILITY VARIABLES.  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'AA') THEN  
                     READ(N5,*,ERR=888) CC,NAVER,NFASNH  
                     IF(NAVER.GE.1.AND.NAVER.LE.3) THEN  
	                    WRITE (N6,5050)  
				        IF(NAVER.EQ.1) WRITE (N6,5051)   
	                    IF(NAVER.EQ.2) WRITE (N6,5052)  
	                    IF(NAVER.EQ.3) WRITE (N6,5053)  
	                    ELSE  
	                    WRITE (N6,5054) NAVER  
	                    NAVER = 2  
	                    ENDIF  
	               IF(NFASNH.EQ.0.OR.NFASNH.EQ.1) THEN  
				        WRITE(N6,5055) NFASNH  
	                    ELSE  
	                    WRITE(N6,5056) NFASNH  
	                    NFASNH = 0  
	                    ENDIF  
	               ENDIF  
C=======================================================================  
C     READ SOLUTION PARAMETERS ON OPTIONAL DATA GROUP B0  
C=======================================================================  
      ISOLSKIP = 0  
Cwch, 7/20/04. Initialize variables for steady-state check.   
      TOLCS1   = 0.  
      QLOWCS   = 0.  
      TOLCS2   = 0.  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'B0') THEN  
                     BACKSPACE N5  
cim ### RHF 8/30/96 CS           READ(N5,*,ERR=888) CC,ISOL,KSUPER  
                     READ(N5,*,ERR=888) CC,ISOL,KSUPER,KREDO,  
     &                                  TOLCS1,QLOWCS,TOLCS2  
                     IF (ISOL.EQ.3) THEN  
                     ISOL = 0  
                     ISOLSKIP = 1  
                     ENDIF  
                     IF (ISOL.EQ.4) THEN  
                     ISOL = 1  
                     ISOLSKIP = 1  
                     ENDIF  
C ---  
                     ELSE  
                     BACKSPACE N5  
                     ENDIF  
CIM   BA THROUGH BE LINES ARE DUPLICATED BELOW.  AS DOCUMENTED IN  
CIM   EXTRAN44.DOC, B LINES SHOULD BE INPUT IN ALPHANUMERIC ORDER  
CIM   (E.G., B0, B1,...B9, BB, BC, BD.  HOWEVER NEED TO KEEP HERE  
CIM   TO MAINTAIN BACKWARD COMPTATIBILITY.  
CIM END  
C=======================================================================  
C     READ OUTPUT CONTROL PARAMETERS ON OPTIONAL DATA GROUP BA  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BA') THEN  
         BACKSPACE N5  
         READ(N5,*,ERR=888) CC,JHEAD,JP10,IWLEN  
         IF (JHEAD.LT.0.OR.JHEAD.GT.1) JHEAD = 0  
         IF (JP10.LT.0.OR.JP10.GT.1) JP10 = 0  
      ELSE  
         JHEAD = 0  
         JP10 = 0  
	   IWLEN = 0  
         BACKSPACE N5  
      ENDIF  
C  these lines are commented to avoid writing stuff  
C  twice when program trys to read lines again below.  
c         IF (JHEAD.EQ.0) WRITE(N6,8020)  
c         IF (JHEAD.EQ.1) WRITE(N6,8022)  
c         IF (JP10.EQ.0) WRITE(N6,8024)  
c         IF (JP10.EQ.1) WRITE(N6,8026)  
c	IF (IWLEN.EQ.0) WRITE(N6,7010)  
c	IF (IWLEN.EQ.1) WRITE(N6,7020)  
c	IF (IWLEN.EQ.2) WRITE(N6,7030)  
C=======================================================================  
C     READ SOLUTION PARAMETERS ON OPTIONAL DATA GROUP BB  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BB') THEN  
                     BACKSPACE N5  
cim SEDEPTH  Add IPIPESED to BB line  
CIM PP 4/1/97  add IPRATE to BB lines  
cim    9/22/97  add IM2 to BB line  
cim  
                     READ(N5,*,ERR=888) CC,JELEV,JDOWN,IPRATE,IM2,  
     a                                 IPIPESED  
                     IF(JELEV.LT.0) JELEV = 0  
                     IF(JDOWN.LT.0.OR.JDOWN.GT.2) JDOWN = 0  
                     ELSE  
                     JELEV = 0  
                     JDOWN = 0  
                     IPRATE = 0  
                     IM2 = 0  
                     IPIPESED = 0  
                     BACKSPACE N5  
                     ENDIF  
C=======================================================================  
C     READ INTERMEDIATE CONTINUITY OUTPUT DATA ON OPTIONAL DATA GROUP BC  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BC') THEN  
                     BACKSPACE N5  
                     READ(N5,*,ERR=888) CC,ICONTER  
                     ELSE  
                     ICONTER = 0  
                     BACKSPACE N5  
                     ENDIF  
c      IF (ICONTER.LE.0) then  
c      write(n6,8005)  
c      ICONTER = 2147483647  
c      else  
c      write(n6,8010) ICONTER  
c      endif  
C=======================================================================  
C>>>>>>>>>>>> READ DATA GROUP BD <<<<<<<<<<<<  
C    OPTIONAL INPUT OF BASE FLOW FACTORS  
C    CIM   10/97  
C=======================================================================  
C  INITIALIZE STUFF  
      NUMSETS = 0  
	BFFACT = .FALSE.  
      MONTHOLD = 0  
      DO 19947 I=1,MAXSETS  
      NUMBFF(I) = 0  
      INBFF(I) = 0  
      IBFF(I) = 0  
      DO 19947 J=1,MAXBFF  
19947 BFFMO(I,J) = 1.0  
      do 19349 i=1,nee  
19349 iwhich(i)=1  
19948 READ (N5,*,ERR=888) CC  
      IF (CC.EQ.'BD') THEN  
	BFFACT = .TRUE.  
      NUMSETS = NUMSETS+1  
      IF (NUMSETS.GT.MAXSETS) THEN  
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SETS SPECIFIED ON BD LINES',  
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXSETS  
      STOP 'TOO MANY BD LINES'  
      ENDIF  
      BACKSPACE N5  
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS)  
      IF (NUMBFF(NUMSETS).GT.MAXBFF) THEN  
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SPECIFIED ON BD LINE',  
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBFF,' FOR SET ',  
     .'NUMBER ',NUMSETS  
      STOP 'TOO MANY BASE BASE FLOW VALUES SPECIFED ON BD LINE'  
      ENDIF  
      BACKSPACE N5  
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS),  
     .              (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS))  
      WRITE(N6,*)  
      WRITE(N6,*) ' MONTHLY BASE FLOW FACTOR SET NUMBER ',NUMSETS  
      WRITE(N6,949) (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS))  
C GO BACK TO TRY TO READ NEXT BD LINE  
      GOTO 19948  
      ELSE  
C NO BD LINES READ, OR NO ADDITIONAL BD LINES FOUND  
C  THEN BACKSPACE AND CONTININUE  
      BACKSPACE N5  
      END IF  
c  initialize following below if needed  
c      IF (NUMSETS.LE.0) NUMSETS = 1  
C=======================================================================  
C>>>>>>>>>>>> READ DATA GROUP BE <<<<<<<<<<<<  
C    OPTIONAL INPUT OF DETAILED SUMMARY OUTPUT PERIODS  
C    CIM   5/98  
C=======================================================================  
C  INITIALIZE STUFF  
      DO NUMBE = 0,MAXBE  
      IBESTART(NUMBE) = 0  
      IBEEND(NUMBE) = 0  
      ENDDO  
      NUMBE = 0  
      IBE = 0  
19950 READ (N5,*,ERR=888) CC  
      IF (CC.EQ.'BE') THEN  
      NUMBE = NUMBE + 1  
      IBE = 1  
C  NOTE MAXBE IS RESERVED FOR PERIOD AFTER LAST PERIOD  
      IF (NUMBE.GT.MAXBE-1) THEN  
      WRITE(N6,*) ' NUMBER OF BE LINES',  
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBE-1  
      STOP 'TOO MANY BE LINES'  
      ENDIF  
      BACKSPACE N5  
      READ(N5,*,ERR=888) CC, IBESTART(NUMBE), IBEEND(NUMBE)  
      IF (NUMBE.EQ.1) WRITE(N6,951)  
      WRITE(N6,952) IBESTART(NUMBE),IBEEND(NUMBE)  
C  TRY TO READ NEXT BE LINE  
      GO TO 19950  
      ELSE  
C  NO BE LINE FOUND.  BACKSPACE AND CONTINUE  
CIM SET IBESTART(0) AND IBEEND(0)  
CIM FOR USE IN CASE NO BE LINES ARE INPUT  
c      IBESTART(0) = NSTART  
c      IBEEND(0) = 999999999  
      BACKSPACE N5  
	ENDIF  
C  Check on inputs  
	IF (NUMBE.GT.0) THEN  
CIM SET IBESTART(NUMBE+1) AND IBBEND(NUMBE+1) HERE  
      IBESTART(NUMBE+1) = 999999999  
      IBEEND(NUMBE+1) = 999999999  
      DO I = 1, NUMBE  
      IF (IBEEND(NUMBE).LE.IBESTART(NUMBE)) THEN  
      WRITE(N6,*) ' ERROR - ENDING CYCLE IS LESS THAN STARTING CYCLE '  
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ',  
     *IBESTART(I),' END CYCLE = ',IBEEND(I)  
      STOP ' ERROR IN NE LINE INPUTS'  
      ENDIF  
      IF (I.GT.1.AND.IBESTART(I).LE.IBEEND(I-1)) THEN  
      WRITE(N6,*) ' ERROR - STARTING CYCLE IS LESS THAN ENDING CYCLE ',  
     A'OF PREVIOUS PRINTOUT PERIOD'  
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ',  
     AIBESTART(I),' END CYCLE OF PREVIOUS NE CARD = ',IBEEND(I-1)  
      STOP ' ERROR IN BE LINE INPUTS'  
      ENDIF  
      ENDDO  
      ENDIF  
C=======================================================================  
C     GENERAL CONTROL PARAMETERS ON DATA GROUPS B1, B2 AND B3  
C=======================================================================  
C#### WCH, 4/11/94.  ADD OPTIONAL INITIAL DATE TO LINE B1 INPUT.  
      IDATZ = 0  
      READ(N5,*,ERR=888) CC,NTCYC,DELT,TZERO,NSTART,INTER,JNTER,JREDO,  
     1 IDATZ  
C  
      READ(N5,*,ERR=888) CC,METRIC,NEQUAL,AMEN,ITMAX,SURTOL  
      READ(N5,*,ERR=888) CC,NHPRT,NQPRT,NPLT,LPLT,NJSW  
C=======================================================================  
C     METRIC = 0 --> U.S. CUSTOMARY UNITS  
C     METRIC = 1 --> METRIC UNITS  
C                    NOTE: METRIC = METRIC + 1  SOON IN FORTRAN CODE.  
C                    NOTE: EXTRAN USES CONSISTENT UNITS (U.S. OR METRIC)  
C                      INTERNALLY IN CODE DURING COMPUTATIONS.  
C     JSLOT  = 0 --> SUM OF JUNCTION FLOW IS ZERO  
C     JSLOT  = 1 --> PREISSMAN SLOT  
C=======================================================================  
      IF(SURTOL.LT.0.0) THEN  
                        ISOL   = 1  
                        SURTOL = ABS(SURTOL)  
                        ENDIF  
cim rhf change .GE. to .EQ.  
      IF(ISOL.EQ.2)  JSLOT = 1  
      METRIC               = METRIC + 1  
      RDELT                = DELT  
      DELT2                = DELT/2.0  
      GRVT                 = 32.2  
      IF(METRIC.EQ.2) GRVT = 9.806  
      IF(AMEN.EQ.0.0.AND.METRIC.EQ.1) AMEN = 12.566  
      IF(AMEN.EQ.0.0.AND.METRIC.EQ.2) AMEN =  1.22  
      WRITE(N6,5100)  NTCYC  
      WRITE(N6,5120)  DELT,DELT*FLOAT(NTCYC)/3600.0  
      IF(NEQUAL.EQ.0) WRITE(N6,5121) NEQUAL  
C BAC START    
C      IF(NEQUAL.GE.1) WRITE(N6,5122) NEQUAL  
      IF(NEQUAL.EQ.1) WRITE(N6,5122) NEQUAL  
      IF(NEQUAL.EQ.2) WRITE(N6,5921) NEQUAL  
      IF(NEQUAL.EQ.3) WRITE(N6,5922) NEQUAL  
      IF(NEQUAL.EQ.4) WRITE(N6,5923) NEQUAL  
      IF(NEQUAL.EQ.5) WRITE(N6,5924) NEQUAL  
cim   check to eliminate possibility of using nequal 4 or 5 with isol = 0 or 3  
cim  
      IF(NEQUAL.GE.4) THEN  
c      IF(ISOL.EQ.0.or.ISOL.EQ.3) THEN  
c      WRITE(N6,7920)  
c      WRITE(*,7920)  
c 7920 FORMAT(' WARNING : TESTING SHOWS THAT USING NEQUAL OF 4 OR 5 ',/,  
c     a' WITH ISOL EQUAL TO 0 OR 3 MAY PRODUCE ERRONEOUS RESULTS.  ',/,  
c     b' WE SUGGEST USING ISOL OF 1 OR 4.  IF YOU USE ISOL OF 0 OR 3, '  
c     c,/,' WE RECOMMEND THAT YOU TEST THE PROGRAM RESULTS AGAINST',/,  
c     d' SIMULATIONS USING NEQUAL OF 3 OR 4.')  
c      WRITE(*,*) 'PRESS ENTER TO CONTINUE WITH SIMULATION'  
c      READ(*,*) KDUM(1)  
c      ENDIF  
      IF (ISOL.EQ.2) THEN  
      WRITE(N6,7930)  
      WRITE(*,7930)  
 7930 FORMAT(' WARNING : USE OF NEQUAL OF 4 OR 5 HAS NOT BEEN TESTED',/  
     A,' WITH ISOL OF 2.  WE SUGGEST THAT YOU COMPARE RESULTS WITH',/,  
     B' NEQUAL OF 4 OR 5 WITH CORRESPONDING RESULTS FROM NEQUAL',  
     C' OF 3 OR 4.')  
      write(*,*) 'PRESS ENTER TO CONTINUE WITH SIMULATION'  
      read(*,*) KDUM(1)  
      ENDIF  
      ENDIF  
C BAC END    
      IF(METRIC.EQ.1) WRITE(N6,5123) METRIC-1  
      IF(METRIC.EQ.2) WRITE(N6,5124) METRIC-1  
      IF(NSTART.LE.0) NSTART   = 1  
CIM IF JNTER is ZERO SET TO BIG  
      IF (JNTER.EQ.0.0) JNTER = 999999999  
CIM CHANGES FOR INTER  
      SELECT CASE(INTER)  
      CASE (0)  
CIM FIRST IF INTER IS ZERO, THEN NO OUTPUT IS WRITTEN  
CIM SET INTER TO A BIG NUMBER  
      INTER = 999999999  
      IASCII = 0  
      CASE (:-1)  
cim less than zero, modify JOUT file to create  
cim detailed ascii results output file  
      INTER = -INTER  
      WRITE(N6,5139)  
      IASCII = JOUT(IOUTCT)  
      NEXT = 0  
      IF (IASCII.EQ.0) THEN  
      WRITE(N6,5137)  
      STOP  
      ENDIF  
      IF (FFNAME(25+IOUTCT).EQ.'JOT.UF') THEN  
      WRITE(N6,5138) JOUT(IOUTCT)  
      stop  
      ELSE  
close file and open as formatted  
      CLOSE(UNIT=IASCII)  
      OPEN(UNIT=IASCII,FILE=FFNAME(25+IOUTCT),STATUS='UNKNOWN',  
     aFORM='FORMATTED')  
      ENDIF  
      CASE(1:)  
      IASCII = 0  
      END SELECT  
      WRITE(N6,5140)  NSTART,INTER,FLOAT(INTER)*DELT/60.0,JNTER,  
     +                FLOAT(JNTER)*DELT/60.0,JREDO  
C#### WCH, 7/25/96.  ADD DATE/TIME EXPLANATIONS WITH HOT START.  
c     IF(JREDO.EQ.0.OR.JREDO.EQ.2) THEN  
c          WRITE(N6,5160)  TZERO  
c          ELSEIF(NEXT.GT.0) THEN  
c               WRITE(N6,5161)  TZERO  
c          ENDIF  
cim  changed to write always, also changed format 11/97  
           WRITE(N6,5160)  TZERO  
           WRITE(N6,5161)  
C#### WCH, 4/11/94 AND 7/25/96 (ADD 5165).  
Cwch, 3/27/00.  Change default to 19410802 to correspond to other blocks.  
      IF(IDATZ.EQ.0) THEN  
           IDATZ = 19410802  
           WRITE(N6,5163) IDATZ  
Cwch, 2/4/01.  Also check for IDATZ with too few digits.  
           ELSEIF(IABS(IDATZ).LE.9999) THEN  
	       WRITE(N6,5162) IDATZ  
	       IDATZ = 19410802  
           ELSE  
CWCH, 11/21/99.  ADD OPTION FOR NEGATIVE IDATZ TO FORCE USE EVEN  
C     FOR INTERFACE FILE INPUT.  
		 IISIGN = ISIGN(1,IDATZ)  
	     IDATZ  = IABS(IDATZ)  
           IYRZ   = IDATZ/10000  
cred            odd logic - 2/04/01  
           IDATZ = IDATZ - IYRZ*10000  
Cwch, 2/4/01.  Check for zero month and day.  
           IMOZ  = IDATZ/100  
	     IDAYZ = IDATZ - IMOZ*100  
cred 2/4/01  add 1 to the default date so there will be days in extran  
	     IF(IDAYZ.EQ.0) IDAYZ = 1  
	     IF(IMOZ.EQ.0)  IMOZ  = 1  
	     IF(IYRZ.LT.100) IYRZ = IYRZ + 1900  
           IDATZ = IYRZ*10000 + IMOZ*100 + IDAYZ  
	     IDATZ = IISIGN*IDATZ  
           WRITE(N6,5164) IDATZ  
           ENDIF  
c next line should have been last not next  
c change to write always 11/97  
c      IF(NEXT.GT.0) WRITE(N6,5165)  
      WRITE(N6,5165)  
C  
      WRITE(N6,5170)  ITMAX,SURTOL  
      IF(METRIC.EQ.1) WRITE(N6,5175) AMEN  
      IF(METRIC.EQ.2) WRITE(N6,5176) AMEN  
      IF(ISOL.EQ.0)   WRITE(N6,5177)  
      IF(ISOL.EQ.1)   WRITE(N6,5178)  
      IF(ISOL.EQ.2)   WRITE(N6,5179)  
C ### RHF 8/30/96 CS  
      if (metric.eq.1) then  
      IF(ISOLSKIP.EQ.1)   WRITE(N6,9050) QLOWCS,TOLCS1,TOLCS2  
      else  
      IF(ISOLSKIP.EQ.1)   WRITE(N6,9051) QLOWCS,TOLCS1,TOLCS2  
      endif  
      IF(JSLOT.EQ.1)  WRITE(N6,9060)  
C ---  
      IF(KSUPER.EQ.0) WRITE(N6,5183)  
      IF(KSUPER.EQ.1) WRITE(N6,5184)  
      TZERO  =  3600.0*TZERO  
      ITMAX  = IABS(ITMAX)  
C BAC START    comment out nequal  
CIM NOTE THAT THIS MODIFICATION CHANGES DEFINITION OF NEQUAL FROM HERE ON.  
C      IF(NEQUAL.EQ.1) NEQUAL = IFIX(DELT)  
C BAC END    
      WRITE(N6,5180) NJSW  
C=======================================================================  
C     Read Junction numbers for print and plot data.  
C=======================================================================  
      IF(NHPRT.GT.0) THEN  
         IF (JCE.EQ.0) THEN  
                     READ(N5,*,ERR=888) CC,(JPRT(I),I=1,NHPRT)  
                     WRITE(N6,5200)  NHPRT,(JPRT(I),I=1,NHPRT)  
         ELSE  
                     READ(N5,*,ERR=888) CC,(AOUT(I,1),I=1,NHPRT)  
                     WRITE(N6,5201)  NHPRT,(AOUT(I,1),I=1,NHPRT)  
         ENDIF  
      ENDIF  
C=======================================================================  
C     READ CONDUIT NUMBERS FOR DETAILED PRINTOUT  
C=======================================================================  
      IF(NQPRT.GT.0) THEN  
         IF (JCE.EQ.0) THEN  
                     READ(N5,*,ERR=888) CC,(CPRT(I),I=1,NQPRT)  
                     WRITE(N6,5220)  NQPRT,(CPRT(I),I=1,NQPRT)  
         ELSE  
                     READ(N5,*,ERR=888) CC,(AOUT(I,2),I=1,NQPRT)  
                     WRITE(N6,5221)  NQPRT,(AOUT(I,2),I=1,NQPRT)  
         ENDIF  
      ENDIF  
C=======================================================================  
C     READ JUNCTION NUMBERS FOR PLOTTING  
C=======================================================================  
      IF(NPLT.GT.0) THEN  
         IF(JCE.EQ.0) THEN  
                    READ(N5,*,ERR=888) CC,(JPLT(N),N=1,NPLT)  
                    WRITE(N6,5240)     NPLT,(JPLT(N),N=1,NPLT)  
         ELSE  
                    READ(N5,*,ERR=888) CC,(AOUT(N,3),N=1,NPLT)  
                    WRITE(N6,5241)     NPLT,(AOUT(N,3),N=1,NPLT)  
         ENDIF  
      ENDIF  
C=======================================================================  
C     READ CONDUIT NUMBERS FOR PLOTTING  
C=======================================================================  
      IF(LPLT.GT.0) THEN  
         IF(JCE.EQ.0) THEN  
                    READ(N5,*,ERR=888) CC,(KPLT(N),N=1,LPLT)  
                    WRITE(N6,5260)     LPLT,(KPLT(N),N=1,LPLT)  
         ELSE  
                    READ(N5,*,ERR=888) CC,(AOUT(N,4),N=1,LPLT)  
                    WRITE(N6,5261)     LPLT,(AOUT(N,4),N=1,LPLT)  
         ENDIF  
      ENDIF  
C=======================================================================  
C     READ CONDUIT NUMBERS FOR PLOTTING WATER SURFACE SLOPE  
C     DATA WILL BE ON DATA GROUP B8 IF PRESENT.  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'B8') THEN  
                     BACKSPACE N5  
                     IF(JCE.EQ.0) THEN  
                      READ(N5,*,ERR=888) CC,NSURF,(JSURF(N),N=1,NSURF)  
                      WRITE(N6,5265)        NSURF,(JSURF(N),N=1,NSURF)  
                     ELSE  
                      READ(N5,*,ERR=888) CC,NSURF,(AOUT(N,5),N=1,NSURF)  
                      WRITE(N6,5266)        NSURF,(AOUT(N,5),N=1,NSURF)  
                     ENDIF  
                     ELSE  
                     NSURF = 0  
                     BACKSPACE N5  
                     ENDIF  
CIM  WRITING OF RESULTS TO ASCII FILE OR BINARY FILE  
C=======================================================================  
C     READ CONDUIT NUMBERS FOR WRITING FLOWS TO ASCII FILE  
C     DATA WILL BE ON DATA GROUP B9 IF PRESENT.  
C         NOFLOW  - Number of conduits for which flows are written.  
C                   Negative indicates that the flows will be written  
C                   to a unformatted sequential file compatible with STATS  
C                   block.  
C                   IF negative then write absolute value of flows  
C         NOFDUP  - Number of additional conduits to write  
C         IFINTER - Number of time steps between output time steps.  
C                   If negative write to a standard SWMM binary file.  
C         FLOWMIN - Minimum flow.  Flows will not be written when the flow  
C                   are less than this value.  
C         FLOWOUT - Conduits for which flows are written.  Repeat NOFLOW  
C                   times without B9 on overlap lines.  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'B9') THEN  
                     BACKSPACE N5  
                     IF(JCE.EQ.0) THEN  
                          READ(N5,*,ERR=888) CC,NOFLOW,NOFDUP,IFINTER,  
     &                              FLOWMIN,(FLOWOUT(N),N=1,ABS(NOFLOW))  
                     DO N = 1, NOFDUP  
                        READ(N5,*,ERR=888) FLOWOUT(N+ABS(NOFLOW)),  
     +				                     FLOWREF(N)  
                     ENDDO  
                          writing = .false.  
                          dryflwstep = 0.0  
                          IF(IFINTER.LT.0) THEN  
                               IFLBIN = 1  
                               WRITE(N6,8260)  
                               IFINTER = -IFINTER  
                               ELSE  
                               IFLBIN = 0  
                               WRITE(N6,8261)  
                               ENDIF  
c  
                          IF(NOFLOW.LT.0) THEN  
                               B9ABS = .TRUE.  
                               NOFLOW = - NOFLOW  
                               WRITE(N6,8263)  
                          ELSE  
                               B9ABS = .FALSE.  
                          ENDIF  
c  
Cwch, 9/9/00, Metricate write statement.  
                       IF(METRIC.EQ.1) WRITE(N6,5267) NOFLOW,  
     1						IFINTER,FLOWMIN,(FLOWOUT(N),N=1,NOFLOW)  
                       IF(METRIC.EQ.2) WRITE(N6,5273) NOFLOW,  
     1						IFINTER,FLOWMIN,(FLOWOUT(N),N=1,NOFLOW)  
                          IF (NOFDUP.GT.0) THEN  
                          WRITE(N6,7268)    NOFDUP  
                          WRITE(N6,7269)  
     &                     (FLOWOUT(N+NOFLOW),FLOWREF(N),N=1,NOFDUP)  
                          ELSE  
                          WRITE(N6,7270)  
                          ENDIF  
C     Alphanumeric read/writes.  
                          ELSE  
                          READ(N5,*,ERR=888) CC,NOFLOW,NOFDUP,IFINTER,  
     &                              FLOWMIN,(AFLWOUT(N),N=1,ABS(NOFLOW))  
                     DO N = 1, NOFDUP  
                       READ(N5,*,ERR=888) AFLWOUT(N+ABS(NOFLOW)),  
     1                                    AFLOWREF(N)  
                     ENDDO  
                          writing = .false.  
                          dryflwstep = 0.0  
                          IF(IFINTER.LT.0) THEN  
                               IFLBIN = 1  
                               WRITE(N6,8260)  
                               IFINTER = -IFINTER  
                               ELSE  
                               IFLBIN = 0  
                               WRITE(N6,8261)  
                               ENDIF  
c  
                          IF(NOFLOW.LT.0) THEN  
                               B9ABS = .TRUE.  
                               NOFLOW = - NOFLOW  
                               WRITE(N6,8263)  
                          ELSE  
                               B9ABS = .FALSE.  
                          ENDIF  
Cwch, 9/8/00. Metricate write statment.  
                       IF(METRIC.EQ.1) WRITE(N6,5268)    NOFLOW,  
     1      				 IFINTER,FLOWMIN,(AFLWOUT(N),N=1,NOFLOW)  
                       IF(METRIC.EQ.2) WRITE(N6,5274)    NOFLOW,  
     1      				 IFINTER,FLOWMIN,(AFLWOUT(N),N=1,NOFLOW)  
                          IF (NOFDUP.GT.0) THEN  
                          WRITE(N6,7268)    NOFDUP  
                          WRITE(N6,7271)  
     &                     (AFLWOUT(N+NOFLOW),AFLOWREF(N),N=1,NOFDUP)  
                          ELSE  
                          WRITE(N6,7270)  
                          ENDIF  
                          ENDIF  
                     DO 25 N=1,MXFLOW  
   25                SUMFLW(MXFLOW)=0.0  
                     ioflow = 0  
                     FLWSTEP = IFINTER * DELT  
                     IF(NSCRAT(3).EQ.0) THEN  
      WRITE(N6,*) 'ERROR - NSCRAT(3) MUST BE NON-ZERO TO USE OPTION',  
     +' TO WRITE RESULTS FOR SELECTED CONDUITS TO ASCII FILE'  
                          STOP 'NSCRAT(3) IS ZERO FOR B9-LINE OPTION'  
                          ELSE  
                          NFOUT = NSCRAT(3)  
                          ENDIF  
                     IF(FFNAME(53).EQ.'SCRT3.UF') THEN  
      WRITE(N6,*) 'ERROR - YOU MUST SPECIFY THE NAME FOR NSCRAT(3)',  
     +' TO WRITE RESULTS FOR SELECTED CONDUITS TO ASCII FILE'  
                          STOP 'NO DOS NAME GIVEN FOR NSCRAT(3)'  
                          ENDIF  
                     IF(IFLBIN.EQ.0) THEN  
Cwch, 9/8/00.  Put metric header on ascii file.  
                          IF(METRIC.EQ.1) WRITE(NFOUT,5269)  
						IF(METRIC.EQ.2) WRITE(NFOUT,5272)  
                          IF(JCE.EQ.0) THEN  
                               WRITE(NFOUT,5270)(FLOWOUT(N),  
     &                          N=1,NOFLOW+NOFDUP)  
                               ELSE  
                               WRITE(NFOUT,5271)(AFLWOUT(N),  
     &                          N=1,NOFLOW+NOFDUP)  
                               ENDIF  
CIM### 9/8/00  
CIM  6/2000 do not open file until after starting and  
cim  ending dates are known.  Move code in INDAT3  
c                          ELSE  
cim here if IFLBIN = 1  
c                          CLOSE(NFOUT,STATUS='DELETE')  
c                          OPEN(NFOUT,FILE=FFNAME(53),FORM='UNFORMATTED',  
c     +                        STATUS='UNKNOWN')  
C=======================================================================  
C     Write file headers for output hydrograph.  
C=======================================================================  
c                         REWIND NFOUT  
c                         NPOLL = 0  
c                         WRITE(NFOUT) NOFLOW+NOFDUP,NPOLL  
c                         IF(JCE.EQ.0) THEN  
c                           WRITE(NFOUT) (FLOWOUT(N),N=1,NOFLOW+NOFDUP)  
c                         ELSE  
c                           WRITE(NFOUT) (AFLWOUT(N),N=1,NOFLOW+NOFDUP)  
c                         ENDIF  
c                         SOURCE = 'EXTRAN BLOCK'  
c                         QQCONV = QCONV  
c                         QCONV  = CMET(8,METRIC)  
c                         TITLE(3) = ALPHA1  
c                         TITLE(4) = ALPHA2  
c                         CALL INFACE(2,NFOUT)  
c                         QCONV    = QQCONV  
                         ENDIF  
                     ELSE  
                     NOFLOW = 0  
                     BACKSPACE N5  
                     ENDIF  
CIM END  
C=======================================================================  
C     READ OUTPUT CONTROL PARAMETERS ON OPTIONAL DATA GROUP BA  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BA') THEN  
         BACKSPACE N5  
         READ(N5,*,ERR=888) CC,JHEAD,JP10,IWLEN  
         IF (JHEAD.LT.0.OR.JHEAD.GT.1) JHEAD = 0  
         IF (JP10.LT.0.OR.JP10.GT.1) JP10 = 0  
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ  
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN  
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE  
C  REMOVED.  
      ELSE  
c         JHEAD = 0  
c         JP10 = 0  
c         IWLEN = 0  
         BACKSPACE N5  
      ENDIF  
         IF (JHEAD.EQ.0) WRITE(N6,8020)  
         IF (JHEAD.EQ.1) WRITE(N6,8022)  
         IF (JP10.EQ.0) WRITE(N6,8024)  
         IF (JP10.EQ.1) WRITE(N6,8026)  
	IF (IWLEN.EQ.0) WRITE(N6,7010)  
	IF (IWLEN.EQ.1) WRITE(N6,7020)  
	IF (IWLEN.EQ.2) WRITE(N6,7030)  
C=======================================================================  
C     READ SOLUTION PARAMETERS ON OPTIONAL DATA GROUP BB  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BB') THEN  
                     BACKSPACE N5  
cim SEDEPTH  Add IPIPESED to BB line  
CIM PP 4/1/97  add IPRATE to BB lines  
cim    9/22/97  add IM2 to BB line  
cim  
                     READ(N5,*,ERR=888) CC,JELEV,JDOWN,IPRATE,IM2,  
     a                                 IPIPESED  
                     IF(JELEV.LT.0) JELEV = 0  
                     IF(JDOWN.LT.0.OR.JDOWN.GT.2) JDOWN = 0  
                     ELSE  
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ  
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN  
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE  
C  REMOVED.  
c                     JELEV = 0  
c                     JDOWN = 0  
c                     IPRATE = 0  
c                     IM2 = 0  
c                     IPIPESED = 0  
                     BACKSPACE N5  
                     ENDIF  
	IF(JELEV.EQ.0) WRITE(N6,8184)  
      IF(JELEV.EQ.1) WRITE(N6,8185)  
	IF(JELEV.EQ.2) WRITE(N6,8186)  
	IF(JELEV.EQ.3) WRITE(N6,8187)  
	IF(JELEV.EQ.4) WRITE(N6,8188)  
      IF(JDOWN.EQ.0) WRITE(N6,5186)  
      IF(JDOWN.EQ.1) WRITE(N6,5187)  
      IF(JDOWN.EQ.2) WRITE(N6,5188)  
      IF(IPRATE.NE.0) WRITE(N6,5189)  
change  
      IF(IM2.EQ.0) THEN  
      WRITE(N6,5190)  
      ELSE  
      IM2 = 1  
      WRITE(N6,5191)  
      ENDIF  
      IF(IPIPESED.NE.0) THEN  
      WRITE(N6,5192)  
      ELSE  
      WRITE(N6,5193)  
      ENDIF  
change  
C=======================================================================  
C     READ INTERMEDIATE CONTINUITY OUTPUT DATA ON OPTIONAL DATA GROUP BC  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BC') THEN  
                     BACKSPACE N5  
                     READ(N5,*,ERR=888) CC,ICONTER  
                     ELSE  
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ  
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN  
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE  
C  REMOVED.  
c                     ICONTER = 0  
                     BACKSPACE N5  
                     ENDIF  
      IF (ICONTER.LE.0) then  
      write(n6,8005)  
      ICONTER = 2147483647  
      else  
      write(n6,8010)  
      endif  
C=======================================================================  
C>>>>>>>>>>>> READ DATA GROUP BD <<<<<<<<<<<<  
C    OPTIONAL INPUT OF BASE FLOW FACTORS  
C    CIM   10/97  
C=======================================================================  
C  INITIALIZE STUFF  
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ  
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN  
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE  
C  REMOVED.  
c      NUMSETS = 0  
c	BFFACT = .FALSE.  
c      MONTHOLD = 0  
c      DO 947 I=1,MAXSETS  
c      NUMBFF(I) = 0  
c      INBFF(I) = 0  
c      IBFF(I) = 0  
c      DO 947 J=1,MAXBFF  
c  947 BFFMO(I,J) = 1.0  
c      do 349 i=1,nee  
c  349 iwhich(i)=1  
  948 READ (N5,*,ERR=888) CC  
      IF (CC.EQ.'BD') THEN  
	BFFACT = .TRUE.  
      NUMSETS = NUMSETS+1  
      IF (NUMSETS.GT.MAXSETS) THEN  
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SETS SPECIFIED ON BD LINES',  
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXSETS  
      STOP 'TOO MANY BD LINES'  
      ENDIF  
      BACKSPACE N5  
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS)  
      IF (NUMBFF(NUMSETS).GT.MAXBFF) THEN  
      WRITE(N6,*) ' NUMBER OF BASE FLOWS SPECIFIED ON BD LINE',  
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBFF,' FOR SET ',  
     .'NUMBER ',NUMSETS  
      STOP 'TOO MANY BASE BASE FLOW VALUES SPECIFED ON BD LINE'  
      ENDIF  
      BACKSPACE N5  
      READ (N5,*,ERR=888) CC,NUMBFF(NUMSETS),  
     .              (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS))  
      WRITE(N6,*)  
      WRITE(N6,*) ' MONTHLY BASE FLOW FACTOR SET NUMBER ',NUMSETS  
      WRITE(N6,949) (BFFMO(NUMSETS,I),I=1,NUMBFF(NUMSETS))  
C GO BACK TO TRY TO READ NEXT BD LINE  
      GOTO 948  
      ELSE  
C NO BD LINES READ, OR NO ADDITIONAL BD LINES FOUND  
C  THEN BACKSPACE AND CONTININUE  
      BACKSPACE N5  
      END IF  
      IF (NUMSETS.LE.0) NUMSETS = 1  
C=======================================================================  
C>>>>>>>>>>>> READ DATA GROUP BE <<<<<<<<<<<<  
C    OPTIONAL INPUT OF DETAILED SUMMARY OUTPUT PERIODS  
C    CIM   5/98  
C=======================================================================  
C  INITIALIZE STUFF  
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ  
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN  
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE REMOVED  
c     DO NUMBE = 0,MAXBE  
c     IBESTART(NUMBE) = 0  
c     IBEEND(NUMBE) = 0  
c     ENDDO  
c     NUMBE = 0  
c     IBE = 0  
  950 READ (N5,*,ERR=888) CC  
      IF (CC.EQ.'BE') THEN  
      NUMBE = NUMBE + 1  
      IBE = 1  
C  NOTE MAXBE IS RESERVED FOR PERIOD AFTER LAST PERIOD  
      IF (NUMBE.GT.MAXBE-1) THEN  
      WRITE(N6,*) ' NUMBER OF BE LINES',  
     .'EXCEEDS MAXIMUM NUMBER ALLOWED = ',MAXBE-1  
      STOP 'TOO MANY BE LINES'  
      ENDIF  
      BACKSPACE N5  
      READ(N5,*,ERR=888) CC, IBESTART(NUMBE), IBEEND(NUMBE)  
      IF (NUMBE.EQ.1) WRITE(N6,951)  
      WRITE(N6,952) IBESTART(NUMBE),IBEEND(NUMBE)  
C  TRY TO READ NEXT BE LINE  
      GO TO 950  
      ELSE  
C  NO BE LINE FOUND.  BACKSPACE AND CONTINUE  
CIM SET IBESTART(0) AND IBEEND(0)  
CIM FOR USE IN CASE NO BE LINES ARE INPUT  
C  NOTE THAT THESE WERE INITIALIZED WHEN PROGRAM TRIED TO READ  
C  CARD ABOVE.  IF/WHEN CODE IS CORRECTED TO HAVE B LINES IN  
C  ALPHA NUMERIC ORDER. THEN THE FOLLOWING COMMENTS SHOULD BE REMOVED  
      IBESTART(0) = NSTART  
      IBEEND(0) = 999999999  
      BACKSPACE N5  
	ENDIF  
C  Check on inputs  
	IF (NUMBE.GT.0) THEN  
CIM SET IBESTART(NUMBE+1) AND IBBEND(NUMBE+1) HERE  
      IBESTART(NUMBE+1) = 999999999  
      IBEEND(NUMBE+1) = 999999999  
      DO I = 1, NUMBE  
      IF (IBEEND(NUMBE).LE.IBESTART(NUMBE)) THEN  
      WRITE(N6,*) ' ERROR - ENDING CYCLE IS LESS THAN STARTING CYCLE '  
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ',  
     *IBESTART(I),' END CYCLE = ',IBEEND(I)  
      STOP ' ERROR IN NE LINE INPUTS'  
      ENDIF  
      IF (I.GT.1.AND.IBESTART(I).LE.IBEEND(I-1)) THEN  
      WRITE(N6,*) ' ERROR - STARTING CYCLE IS LESS THAN ENDING CYCLE ',  
     A'OF PREVIOUS PRINTOUT PERIOD'  
      WRITE(N6,*) '         BE CARD NUMBER = ',I,' START CYCLE = ',  
     AIBESTART(I),' END CYCLE OF PREVIOUS NE CARD = ',IBEEND(I-1)  
      STOP ' ERROR IN BE LINE INPUTS'  
      ENDIF  
      ENDDO  
      ENDIF  
C=======================================================================  
C     CALL TO WASPREAD TO TRY TO READ EXTRAN TO WASP LINKAGE  
C     LINES   BF, BG, BH LINES  
      CALL WASPREAD  
CIM TRANAID START  
C=======================================================================  
CIM   OPTIONAL READ OF BZ CARD FOR INFORMATION TO WRITE TRANAID  
CIM   INTERFACE FILE  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'BZ') THEN  
                     BACKSPACE N5  
                     READ(N5,*,ERR=888) CC,idump, dthyd, hydstr,IVCALC  
                     else  
                     idump = 0  
                     dthyd = 0.0  
                     hydstr = 0.0  
                     BACKSPACE N5  
                     end if  
        if (idump .gt. 0) then  
        write(n6,6666) hydstr, dthyd  
	IF (IVCALC.EQ.0) THEN  
	WRITE(N6,7022)  
	LVCALC = .TRUE.  
	ELSE  
	WRITE(N6,7024)  
	LVCALC = .FALSE.  
	ENDIF  
        end if  
CIM  TRANAID END  
C=======================================================================  
C     Read conduit data on data group C1.  
C=======================================================================  
      WRITE(*,6000)  
      NATUR    = 0  
      DO 260 N = 1,NEE  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'C1') GO TO 280  
      IF(JCE.EQ.0) THEN  
      IF (IPIPESED.EQ.0) THEN  
         READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N),  
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),  
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N)  
                        ENTK(N) = 0.0  
                        EXITK(N) = 0.0  
                        OTHERK(N) = 0.0  
                        SEDEPTH(N) = 0.0  
      ELSE  
         READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N),  
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),  
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N),  
     +                      SEDEPTH(N)  
                        ENTK(N) = 0.0  
                        EXITK(N) = 0.0  
                        OTHERK(N) = 0.0  
      ENDIF  
CIM START  <><><><><><><>  
C *** NOTE:  THE FOLLOWING IF STATEMENT WILL NEED TO BE MODIFIED IF A  
C            CLOSED CONDUIT WITH NKLASS > 5 IS ADDED.  
CIM  ADDED CLOSED ARRAY TO ID CLOSED CONDUITS  
         CLOSED(N) = (NKLASS(N).LE.5).OR.  
     .            (NKLASS(N).EQ.9).OR.  
     .            (NKLASS(N).EQ.10).OR.  
     .            (NKLASS(N).EQ.11).OR.  
     .            (NKLASS(N).EQ.12)  
CIM END     <><><><><><>  
C  BAC START    
C  read entrance exit and other loss coefficent if closed conduit type  
C  
Cwch, 3/12/01. May need to backspace twice if C1 data are on two lines  
C with a carriage return.  After backspacing once, check CC value.  If not  
C C1, then backspace twice and try agin.  
C$$$$$ Need to fix, 3/12/01.  Not yet done.   
        IF(NEQUAL.GE.2.AND.CLOSED(N)) THEN  
          BACKSPACE N5  
        IF(IPIPESED.EQ.0) THEN  
          READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N),  
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),  
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N),  
     +                      ENTK(N),EXITK(N),OTHERK(N)  
          SEDEPTH(N) = 0.0  
        ELSE  
          READ(N5,*,ERR=888) CC,NCOND(N),(NJUNC(N,K),K=1,2),QO(N),  
     +                      NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),  
     +                      ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N),  
     +                      ENTK(N),EXITK(N),OTHERK(N),SEDEPTH(N)  
        ENDIF  
        ENDIF  
C BAC END    
       ELSE  
      IF (IPIPESED.EQ.0) THEN  
      READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2),  
     +                  QO(N),NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),  
     +                  ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N)  
                        ENTK(N) = 0.0  
                        EXITK(N) = 0.0  
                        OTHERK(N) = 0.0  
                        SEDEPTH(N) = 0.0  
      ELSE  
      READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2),  
     +                  QO(N),NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),  
     +                  ZU(N),ZD(N),ROUGH(N),STHETA(N),SPHI(N),  
     +                  SEDEPTH(N)  
                        ENTK(N) = 0.0  
                        EXITK(N) = 0.0  
                        OTHERK(N) = 0.0  
      ENDIF  
CIM START  <><><><><><><>  
C *** NOTE:  THE FOLLOWING IF STATEMENT WILL NEED TO BE MODIFIED IF A  
C            CLOSED CONDUIT WITH NKLASS > 5 IS ADDED.  
CIM  ADDED CLOSED ARRAY TO ID CLOSED CONDUITS  
         CLOSED(N) = (NKLASS(N).LE.5).OR.  
     .            (NKLASS(N).EQ.9).OR.  
     .            (NKLASS(N).EQ.10).OR.  
     .            (NKLASS(N).EQ.11).OR.  
     .            (NKLASS(N).EQ.12)  
CIM END     <><><><><><>  
C BAC START   
C  read entrance exit and other loss coefficent if closed conduit type  
        IF(NEQUAL.GE.2.AND.CLOSED(N)) THEN  
          BACKSPACE N5  
        IF (IPIPESED.EQ.0) THEN  
          READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2),QO(N),  
     +         NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),ZU(N),ZD(N),  
     +         ROUGH(N),STHETA(N),SPHI(N),ENTK(N),EXITK(N),OTHERK(N)  
               SEDEPTH(N)=0.0  
        ELSE  
          READ(N5,*,ERR=888) CC,ACOND(N),(KJUNC(N,K),K=1,2),QO(N),  
     +         NKLASS(N),AFULL(N),DEEP(N),WIDE(N),LEN(N),ZU(N),ZD(N),  
     +         ROUGH(N),STHETA(N),SPHI(N),ENTK(N),EXITK(N),OTHERK(N),  
     +         SEDEPTH(N)  
        ENDIF  
        ENDIF  
C  BAC END   
      ENDIF  
      IF(ROUGH(N).LE.0.0) ROUGH(N) = 0.014  
C=======================================================================  
C     IF LEN(N) IS NEGATIVE A FLAP GATE IS BEING MODELED  
C        THIS FLAP GATE ONLY ALLOWS FLOW IN THE POSITIVE DIRECTION  
C        INGATE = 1  
C        FLOW IS LIMITED TO BE GREATER THAN 0.0  
C=======================================================================  
      INGATE(N) = 0  
      IF(LEN(N).LT.0) THEN  
                      INGATE(N) = 1  
                      LEN(N)    = ABS(LEN(N))  
                      ENDIF  
C=======================================================================  
C     IF NKLASS(N) IS NEGATIVE A FLAP GATE IS BEING MODELED  
C        THIS FLAP GATE ONLY ALLOWS FLOW IN THE NEGATIVE DIRECTION  
C        INGATE IS 2  
C        FLOW IS LIMITED TO BE LESS THAN 0.0  
C=======================================================================  
      IF(NKLASS(N).LT.0) THEN  
                         INGATE(N) = 2  
                         NKLASS(N) = IABS(NKLASS(N))  
                         ENDIF  
C  
C     IF NKLASS is not 6 7 8 or 12 then SPHI is maximum flow  
C  
C=======================================================================  
CIM START  <><><><><><><><><>  
CIM    THE FOLLOWING HOLD TRUE FOR INPUT ONLY, ARE MODIFIED  
CIM    TO INTERNAL NUMBERING SCHEME AT END OF INDAT1 SUBROUTINE  
CIM    Note:  In revised internal numbering scheme,  
cim        o  Conduit types 1 through 20 are reserved  
cim           for closed conduit types that use TWNORM, ANORM, and  
cim           HRNORM ARRAYS  
cim        o  Conduit types 21 through 50 are special types including  
cim           rectangular pipes (22), and also includes parabolic and  
cim           irregular sections (24) that use QCURVE arrays.  
cimbridge     Now includes bridges type 25  
cim        o  Conduit types 51 through 60 are reserved for equivalent  
cim           orifice types.  
CIM  
CIM   NKLASS  TYPE                                NEWKLASS  
C        1    CIRCULAR PIPE  
                                          NEWKLASS(1)=1  
C        2    RECTANGULAR PIPE  
                                          NEWKLASS(2)=21  
C        3    HORSESHOE PIPE  
                                          NEWKLASS(3)=2  
C        4    EGGSHAPED PIPE  
                                          NEWKLASS(4)=3  
C        5    BASKETHANDLE PIPE  
                                          NEWKLASS(5)=4  
C        6    TRAPEZOIDAL CHANNEL  
                                          NEWKLASS(6)=22  
C        7    PARABOLIC CROSS-SECTION OR POWER  
C             FUNCTION CROSS SECTION  
                                          NEWKLASS(7)=23  
C        8    IRREGULAR CROSS-SECTION  
                                          NEWKLASS(8)=24  
C        9    HORIZONTAL ELLIPSE  
C             (LONG AXIS IS HORIZONTAL)  
                                          NEWKLASS(9)=5  
C       10    VERTICAL ELLIPSE  
                                          NEWKLASS(10)=6  
C       11    ARCH  
                                          NEWKLASS(11)=7  
C       12    BRIDGE (TO BE IMPLEMENTED)  
                                          NEWKLASS(12)=25  
CIM    OOOOOOOOO  
CIM  THESE ARE OLD ASSIGNMENTS AND NEW ASSIGNMENTS FOR ORIFICE  
CIM  EQUIVALENT PIPES  
C        9    SIDE OUTLET CIRCULAR ORIFICE          51  
C       10    BOTTOM OUTLET CIRCULAR ORIFICE        52  
C       11    SIDE OUTLET RECTANGULAR ORIFICE       53  
C       12    BOTTOM OUTLET RECTANGULAR ORIFICE     54  
CIM   OOOOOOOOOO  
CIM END <><><><><><><><><><><><>  
C=======================================================================  
      KLASS = NKLASS(N)  
CIM START   <><><><><><><><>  
CIM       IF(KLASS.EQ.1.OR.KLASS.GE.9) THEN  
CIM  9 WAS ORIFICE, DON'T KNOW DATA YET  
c change this to select case  
      SELECT CASE (KLASS)  
      CASE (1)  
CIM END   <><><><><><>  
               RFULL(N)  = DEEP(N)/4.0  
               AFULL(N)  = (3.1415926/4.0)*DEEP(N)**2  
               WIDE(N)   = DEEP(N)  
cim  CALL SEDEPTH1 to adjust pipe if IPIPESED=1  
               IF (SEDEPTH(N).NE.0.0) THEN  
                   CALL SEDEPTH1(N)  
               ELSE  
               SEDAREA(N) = 0.0  
               SEDPERI(N) = 0.0  
               SEDRAD(N) = 0.0  
               ENDIF  
      CASE (2)  
               RFULL(N) = (WIDE(N)*DEEP(N))/(2.*WIDE(N)+2.0*DEEP(N))  
               AFULL(N) =  WIDE(N)*DEEP(N)  
      CASE (3)  
               RFULL(N) = 0.25381  * DEEP(N)  
      CASE (4)  
               RFULL(N) = 0.19311 * DEEP(N)  
      CASE (5)  
               RFULL(N) = 0.28800*DEEP(N)  
      CASE (6)  
               AFULL(N)=DEEP(N)*(WIDE(N)+DEEP(N)/2.*(STHETA(N)+SPHI(N)))  
               IF(WIDE(N).LE.0.0) WIDE(N) = 0.01  
               RFULL(N)=AFULL(N)/(WIDE(N)+DEEP(N)*  
     +                  (SQRT(1.0+STHETA(N)**2)+SQRT(1.0+SPHI(N)**2)))  
      CASE (7)  
      IF(STHETA(N).EQ.0.0) THEN  
               AFULL(N) = 0.666666667*WIDE(N)*DEEP(N)  
               X      = WIDE(N)/2.0  
               X1     = WIDE(N)**4/(64.0*DEEP(N)**2)  
               WETPER = 8.0*DEEP(N)/WIDE(N)**2*(X*SQRT(X1+X**2)  
     +                             +  X1*LOG(X+SQRT(X1+X**2)) -  
     +                                X1*LOG(SQRT(X1)))  
               RFULL(N) = AFULL(N)/WETPER  
               ELSE  
               AFULL(N) = WIDE(N)*DEEP(N)*(1.0 - 1.0/(STHETA(N)+1.0))  
               X      = WIDE(N)/2.0  
               X1     = WIDE(N)**4/(64.0*DEEP(N)**2)  
               WETPER = 8.0*DEEP(N)/WIDE(N)**2*(X*SQRT(X1+X**2)  
     +                             +  X1*LOG(X+SQRT(X1+X**2)) -  
     +                                X1*LOG(SQRT(X1)))  
               RFULL(N) = AFULL(N)/WETPER  
               ENDIF  
CIM START <><><><><><><><>  
CIM      HORIZONTAL ELLIPSE  
      CASE (9)  
C=======================================================================  
C     Approximations for elliptical pipe based on Table 4 "Elliptical  
C     Concrete Pipe," page 90, in Concrete Pipe Design Manual, American   
C     Concrete Pipe Assn., First Edition, 1970. Because ratio of minor  
C     to major axes is ~ constant, area formula works using just one  
C     axis.  It works better than true area for ellipse (pi*a*b) since  
C     pipe is only approximately elliptical.   
C=======================================================================  
      IF ((DEEP(N).LT.0.0).AND.(WIDE(N).LT.0.0)) THEN  
        DEEP(N) = - DEEP(N)  
        WIDE(N) = - WIDE(N)  
        AFULL(N) = 1.2692 * DEEP(N) * DEEP(N)  
        RFULL(N) = 0.3061 * DEEP(N)  
        ELSE  
        ISIZE = DEEP(N)  
        IF ((ISIZE.LE.0).OR.(ISIZE.GT.NUMELL)) THEN  
             IF (JCE.EQ.0)  THEN  
               WRITE(N6,4070) NCOND(N)  
               ELSE  
               WRITE(N6,4071) ACOND(N)  
               ENDIF  
             ISTOP = ISTOP + 1  
             ISIZE = 1  
             END IF  
Cwch, 2/12/01.  Add metric conversions.  
        DEEP(N) = EMINOR(ISIZE)/CMET(12,METRIC)  
        WIDE(N) = EMAJOR(ISIZE)/CMET(12,METRIC)  
        AFULL(N) = EAREA(ISIZE)/CMET(13,METRIC)  
        RFULL(N) = ERADIUS(ISIZE)/CMET(1,METRIC)  
      END IF  
CIM         VERTICAL ELLIPSE  
      CASE (10)  
Cwch (CIM), 7/20/04. Should be .LT. for both.   
C      IF ((DEEP(N).GT.0.0).AND.(WIDE(N).LT.0.0)) THEN  
      IF ((DEEP(N).LT.0.0).AND.(WIDE(N).LT.0.0)) THEN  
        DEEP(N) = - DEEP(N)  
        WIDE(N) = - WIDE(N)  
        AFULL(N) = 1.2692 * WIDE(N) * WIDE(N)  
        RFULL(N) = 0.3061 * WIDE(N)  
        ELSE  
        ISIZE = DEEP(N)  
        IF ((ISIZE.LE.0).OR.(ISIZE.GT.NUMELL)) THEN  
            IF (JCE.EQ.0)  THEN  
            WRITE(N6,4070) NCOND(N)  
            ELSE  
            WRITE(N6,4071) ACOND(N)  
            ENDIF  
            ISTOP = ISTOP + 1  
            ISIZE = 1  
            END IF  
Cwch, 2/12/01.  Add metric conversions.  
Cwch, 7/20/04. Major and minor sizes inverted.  
C        DEEP(N) = EMINOR(ISIZE)/CMET(12,METRIC)  
C        WIDE(N) = EMAJOR(ISIZE)/CMET(12,METRIC)  
        DEEP(N) = EMAJOR(ISIZE)/CMET(12,METRIC)  
        WIDE(N) = EMINOR(ISIZE)/CMET(12,METRIC)  
        AFULL(N) = EAREA(ISIZE)/CMET(13,METRIC)  
        RFULL(N) = ERADIUS(ISIZE)/CMET(1,METRIC)  
        END IF  
CIM         ARCH  
      CASE (11)  
C=======================================================================  
C     Approximations for steel pipe based in part on tables from "Modern  
C     Sewer Design," by American Iron and Steel Institute, Fourth Ed.,  
C     1999.  But see also two web sites:  
C     http://www.lane-enterprises.com/cspFullFlow.htm  
C     http://www.lane-enterprises.com/sppFullFlow_p2.htm  
C     with hydraulic properties.  
C=======================================================================  
      IF ((DEEP(N).LT.0.0).AND.(WIDE(N).LT.0.0)) THEN  
        DEEP(N) = - DEEP(N)  
        WIDE(N) = - WIDE(N)  
Cwch, 7/20/04. Fix error noted by Mike Gregory in swmm-users, from  
C     10/10/03. See his spreadsheet calcs.   
C        AFULL(N) = 0.7879 * DEEP(N) * DEEP(N)  
        AFULL(N) = 0.7879 * DEEP(N) * WIDE(N)  
C  
        RFULL(N) = 0.2991 * DEEP(N)  
        ELSE  
        ISIZE = DEEP(N)  
        IF ((ISIZE.LE.0).OR.(ISIZE.GT.NUMARCH)) THEN  
            IF (JCE.EQ.0) THEN  
               WRITE(N6,4072) NCOND(N)  
               ELSE  
               WRITE(N6,4073) ACOND(N)  
               ENDIF  
            ISTOP = ISTOP + 1  
            ISIZE = 1  
            END IF  
Cwch, 2/12/01.  Add metric conversions.  
        DEEP(N) = AMINOR(ISIZE)/CMET(12,METRIC)  
        WIDE(N) = AMAJOR(ISIZE)/CMET(12,METRIC)  
        AFULL(N) = AAREA(ISIZE)/CMET(13,METRIC)  
        RFULL(N) = ARADIUS(ISIZE)/CMET(1,METRIC)  
        END IF  
      END SELECT  
CIM         BRIDGE  (TO BE IMPLEMENTED)  
cim      IF(KLASS.EQ.12) THEN  
cim      END IF  
CIM END <><><><><><><><><><>  
  260 CONTINUE  
  280 NC  = N-1  
      NTC = NC  
C=======================================================================  
C     PRINT OUT INFORMATION ON FLAP GATES (IF ANY EXIST)  
C=======================================================================  
      NFLAP     = 0  
      DO 9000 N = 1,NC  
      IF(INGATE(N).GT.0) THEN  
                         NFLAP = NFLAP + 1  
                         IF(NFLAP.EQ.1) WRITE(N6,9010)  
                         ND = INGATE(N)  
                         IF(JCE.EQ.0) THEN  
                            WRITE(N6,9020) NCOND(N),GTYPE(ND)  
                            ELSE  
                            WRITE(N6,9021) ACOND(N),GTYPE(ND)  
                         ENDIF  
      IF (INGATE(N).EQ.1) WRITE(N6,4060)  
      IF (INGATE(N).EQ.2) WRITE(N6,4061)  
                         ENDIF  
 9000 CONTINUE  
c   printout data for pipes where maximum positive flow or the  
c   minimum negative flow is limited as identified by SPHI and  
c   or STHETA for all types but 6, 7, 8 and 12.  
      NMXFLW = 0  
      DO 9001 N=1,NC  
      SELECT CASE (NKLASS(N))  
      CASE (6,7,8,12)  
      CASE DEFAULT  
      IF(SPHI(N).NE.0.0.OR.STHETA(N).NE.0.0) THEN  
      NMXFLW = NMXFLW + 1  
      IF (NMXFLW.EQ.1) WRITE(N6,9011)  
      IF (JCE.EQ.0) THEN  
      IF (SPHI(N).NE.0.0) WRITE(N6,4064) NCOND(N),SPHI(N)  
      IF (STHETA(N).NE.0.0) WRITE(N6,4065) NCOND(N),STHETA(N)  
      ELSE  
      IF (SPHI(N).NE.0.0) WRITE(N6,4074) ACOND(N),SPHI(N)  
      IF (STHETA(N).NE.0.0) WRITE(N6,4075) ACOND(N),STHETA(N)  
      END IF  
      IF (SPHI(N).LT.0.0) WRITE(N6,4062)  
      IF (STHETA(N).GT.0.0) WRITE(N6,4063)  
      ENDIF  
      END SELECT  
 9001 CONTINUE  
C=======================================================================  
C     READ THE CS DATA GROUP TO DETERMINE IF THE NATURAL CROSS  
C          SECTION INFORMATION WILL BE SAVED ON NSCRAT(4) OR  
C          READ FROM NSCRAT(4) BY THE PROGRAM  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'CS') THEN  
                     BACKSPACE N5  
                     READ(N5,*,ERR=888) CC,IREAD  
                     ELSE  
                     BACKSPACE N5  
                     ENDIF  
C=======================================================================  
C     NOW GET DATA FOR IRREGULAR CHANNELS FROM THE SCRATCH FILE.  
C=======================================================================  
      IF(IREAD.EQ.'READ') THEN  
               IF(NCSAVE.EQ.0) THEN  
                               WRITE(N6,8999)  
                               STOP  
                               ENDIF  
               READ(NCSAVE,ERR=8888) NATUR,NC  
               READ(NCSAVE,ERR=8888) (NQC(N),N=1,NC)  
               READ(NCSAVE,ERR=8888) (NUMQ(N),N=1,NC)  
               READ(NCSAVE,ERR=8888) ((QCURVE(N,1,J),J=1,26),N=1,NATUR)  
               READ(NCSAVE,ERR=8888) ((QCURVE(N,2,J),J=1,26),N=1,NATUR)  
               READ(NCSAVE,ERR=8888) ((QCURVE(N,3,J),J=1,26),N=1,NATUR)  
               DO 275 N = 1,NC  
CIM START   <><><><><><><><>  
CIM               IF(NKLASS(N).LT.7) GO TO 275  
               IF(NKLASS(N).NE.8.OR.NKLASS(N).NE.7) GO TO 275  
CIM END  <><><><><><><><>  
               READ(NCSAVE,ERR=8888) SLOPE,AFULL(N),DEEP(N),WIDE(N),  
     +                               LEN(N),ROUGH(N),RFULL(N),NKLASS(N)  
  275          CONTINUE  
               ENDIF  
C=======================================================================  
C     NOW GET DATA FOR IRREGULAR CHANNELS, IF ANY.  
C=======================================================================  
      IF(IREAD.EQ.'SAVE'.OR.IREAD.EQ.'CARD') THEN  
      IIPRNT = 0  
      DO 285 N = 1,NC  
      IF(NKLASS(N).EQ.8) THEN  
            IF(IIPRNT.EQ.0) WRITE(N6,5355)  
            IIPRNT = 1  
            SLOPE = SPHI(N)  
            NATUR = NATUR + 1  
            KCOND = 0  
            KSTOP = 0  
            IF(STHETA(N).LT.0.0) THEN  
                                 KSTOP     = 1  
                                 STHETA(N) = ABS(STHETA(N))  
                                 ENDIF  
            CALL GETCUR(N,STHETA(N),SLOPE,METRIC,0,KCOND,AFULL(N),  
     +                  DEEP(N),WIDE(N),LEN(N),ROUGH(N),RFULL(N),  
     +                  NSTOP,NCOND(N),ACOND(N),KSTOP)  
            ENDIF  
C=======================================================================  
C     CALCULATE DATA FOR POWER FUNCTION CROSS SECTIONS  
C=======================================================================  
      IF(NKLASS(N).EQ.7) THEN  
            KCOND    = 1  
            NATUR    = NATUR + 1  
            SLOPE    = 0.0  
            KSTOP    = 0  
            IF(STHETA(N).EQ.0.0) STHETA(N) = 2.0  
            IF(STHETA(N).LT.0.0) THEN  
                                 KSTOP     = 1  
                                 STHETA(N) = ABS(STHETA(N))  
                                 ENDIF  
            CALL GETCUR(N,STHETA(N),SLOPE,METRIC,0,KCOND,AFULL(N),  
     +                  DEEP(N),WIDE(N),LEN(N),ROUGH(N),RFULL(N),  
     +                  NSTOP,NCOND(N),ACOND(N),KSTOP)  
            NKLASS(N) = 8  
            ENDIF  
  285 CONTINUE  
      ENDIF  
C  
C=======================================================================  
C   Call to read data for bridge sections if any  
C=======================================================================  
      CALL GETBRDGE  
C=======================================================================  
C     NOW SAVE THE DATA FOR IRREGULAR CHANNELS ON THE SCRATCH FILE.  
C=======================================================================  
      IF(IREAD.EQ.'SAVE') THEN  
               IF(NCSAVE.EQ.0) THEN  
                               WRITE(N6,8999)  
                               STOP  
                               ENDIF  
               WRITE(NCSAVE,ERR=8888) NATUR,NC  
               WRITE(NCSAVE,ERR=8888) (NQC(N),N=1,NC)  
               WRITE(NCSAVE,ERR=8888) (NUMQ(N),N=1,NC)  
               WRITE(NCSAVE,ERR=8888) ((QCURVE(N,1,J),J=1,26),N=1,NATUR)  
               WRITE(NCSAVE,ERR=8888) ((QCURVE(N,2,J),J=1,26),N=1,NATUR)  
               WRITE(NCSAVE,ERR=8888) ((QCURVE(N,3,J),J=1,26),N=1,NATUR)  
               DO 295 N = 1,NC  
CIM START   <><><><><><><>  
CIM     note now both parabolic and irregular are nklass = 8  
CIM            IF(NKLASS(N).LT.7) GO TO 295  
               IF(NKLASS(N).NE.8) GO TO 295  
CIM END   <><><><><><><>  
               WRITE(NCSAVE,ERR=8888) SLOPE,AFULL(N),DEEP(N),WIDE(N),  
     +                                LEN(N),ROUGH(N),RFULL(N),NKLASS(N)  
  295          CONTINUE  
               ENDIF  
C=======================================================================  
C     PRINT CONDUIT DATA  
C=======================================================================  
cim 1/99 print first header line  
                             WRITE(N6,2999)  
                             WRITE(N6,5060) ALPHA1,ALPHA2  
                             IF(METRIC.EQ.1) WRITE(N6,5300)  
                             IF(METRIC.EQ.2) WRITE(N6,5301)  
      DO 300 N = 1,NC  
      KLASS    = NKLASS(N)  
CIM START      <><><><><><><>  
      IF (KLASS.LT.1.OR.KLASS.GT.12) THEN  
      IF (JCE.EQ.0) THEN  
         WRITE(N6,7000) NCOND(N),NKLASS(N)  
         ELSE  
         WRITE(N6,7001) ACOND(N),NKLASS(N)  
      END IF  
       STOP 'INVALID NKLASS FOR CONDUIT'  
      END IF  
CIM END <><><><><><><><><>  
CIM 1/99 Eliminate intermediate output headers JHEAD = 1  
      IF(JHEAD.EQ.0.AND.MOD(N,50).EQ.0) THEN  
                             WRITE(N6,2999)  
                             WRITE(N6,5060) ALPHA1,ALPHA2  
                             IF(METRIC.EQ.1) WRITE(N6,5300)  
                             IF(METRIC.EQ.2) WRITE(N6,5301)  
                             ENDIF  
CIM 1/99  
      IF(JCE.EQ.0) THEN  
      IF(ZU(N).EQ.0.0.AND.ZD(N).EQ.0.0) THEN  
        IF(NKLASS(N).EQ.6) WRITE(N6,5320) N,NCOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(NJUNC(N,K),K=1,2),STHETA(N),SPHI(N)  
        IF(NKLASS(N).NE.6) WRITE(N6,5321) N,NCOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(NJUNC(N,K),K=1,2)  
                 ELSE  
        IF(NKLASS(N).EQ.6) WRITE(N6,5322) N,NCOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(NJUNC(N,K),K=1,2),ZU(N),ZD(N),  
     +                     STHETA(N),SPHI(N)  
        IF(NKLASS(N).NE.6) WRITE(N6,5323) N,NCOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(NJUNC(N,K),K=1,2),ZU(N),ZD(N)  
                ENDIF  
      ELSE  
      IF(ZU(N).EQ.0.0.AND.ZD(N).EQ.0.0) THEN  
        IF(NKLASS(N).EQ.6) WRITE(N6,5420) N,ACOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(KJUNC(N,K),K=1,2),STHETA(N),SPHI(N)  
        IF(NKLASS(N).NE.6) WRITE(N6,5421) N,ACOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(KJUNC(N,K),K=1,2)  
                 ELSE  
        IF(NKLASS(N).EQ.6) WRITE(N6,5422) N,ACOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(KJUNC(N,K),K=1,2),ZU(N),ZD(N),  
     +                     STHETA(N),SPHI(N)  
        IF(NKLASS(N).NE.6) WRITE(N6,5423) N,ACOND(N),LEN(N),  
     +                     CTYPE(KLASS),AFULL(N),ROUGH(N),WIDE(N),  
     +                     DEEP(N),(KJUNC(N,K),K=1,2),ZU(N),ZD(N)  
                ENDIF  
      ENDIF  
  300 CONTINUE  
C  BAC START    
C=======================================================================  
C     LENGTHEN CONDUITS AND/OR INCORPORATE LOCAL LOSSES INTO MANNING'S N  
C     AS APPROPRIATE  
C=======================================================================  
C  
C  SIMPLY REPLACE EXISTING CODE WITH THIS NEW CODE  
      WRITE(N6,9030)  
      VOLOLD   = 0.0  
      VOLNEW   = 0.0  
        DO 320 N=1,NC  
            VOLOLD   = VOLOLD + AFULL(N)*LEN(N)  
            IF(.NOT.CLOSED(N)) THEN  
                NEWK = NEWKLASS(NKLASS(N))  
                CALL HYDRAD(N,NEWK,DEEP(N),RMID,AMID,BMID)  
                AB = AMID/BMID  
                IF(AB.LE.0.0) AB = 0.01  
            ELSE  
               AB = DEEP(N)  
            ENDIF  
            RATIO = SQRT(AB*GRVT)*DELT/LEN(N)  
        SELECT CASE (NEQUAL)  
        CASE (1,5)  
C  
C     LENGTHEN SHORT PIPES WITHOUT INCORPORATING LOCAL LOSSES  
C  
            IF(RATIO.GT.1.0) THEN  
               CLEN     = DELT*SQRT(AB*GRVT)  
               ROUGH(N) = ROUGH(N)*SQRT(LEN(N)/CLEN)  
               LEN(N)   = CLEN  
               IF(JCE.EQ.0) THEN  
                WRITE(N6,5335) NCOND(N),RATIO  
                WRITE(N6,5337) NCOND(N),CLEN,ROUGH(N),RATIO  
               ELSE  
                WRITE(N6,5336) ACOND(N),RATIO  
                WRITE(N6,5338) ACOND(N),CLEN,ROUGH(N),RATIO  
               ENDIF  
              ENDIF  
         IF ((NEQUAL.EQ.5).AND.CLOSED(N)) THEN  
               IF (JCE.EQ.0) THEN  
                    WRITE(N6,6400) NCOND(N),ENTK(N),EXITK(N),OTHERK(N)  
               ELSE  
                    WRITE(N6,6401) ACOND(N),ENTK(N),EXITK(N),OTHERK(N)  
               ENDIF  
         ENDIF  
C  
C     INCORPORATE LOCAL LOSSES INTO MANNING'S N FOR CLOSED CONDUITS  
C     BUT DO NOT ADJUST FOR SHORT CONDUITS  
           CASE (2)  
             IF(CLOSED(N)) THEN  
               OLDROUGH = ROUGH(N)  
Cwch, Factor of 29 in eqn. is 2g/1.49^2.  Need to include these  
C     coefficients explicitly to allow for metric.  Eqn. factored  
C     a little differently in re-write.  
CCC               ROUGH(N) = ((ENTK(N)+EXITK(N)+OTHERK(N)+29.*ROUGH(N)*  
CCC     +                    ROUGH(N)*LEN(N)/RFULL(N)**(1.333333))*  
CCC     +                    RFULL(N)**(1.333333)/29./LEN(N))**0.5  
			 ROUGH(N) = SQRT(ROUGH(N)**2 +  
     1                   (ENTK(N)+EXITK(N)+OTHERK(N))*  
     2                   CMET(9,METRIC)**2*RFULL(N)**1.333333/  
	3				   (2.0*GRVT*LEN(N)))  
C ****** BAC -- THIS IS A TEMPORARY WRITE TO SEE IF PROGRAM IN FUNCTIONING CORRECTLY  
               IF(JCE.EQ.0) THEN  
                            WRITE(N6,6335) NCOND(N),OLDROUGH,ENTK(N),  
     +                                     EXITK(N),OTHERK(N),ROUGH(N)  
               ELSE  
                            WRITE(N6,6336) ACOND(N),OLDROUGH,ENTK(N),  
     +                                     EXITK(N),OTHERK(N),ROUGH(N)  
               ENDIF  
             ENDIF  
c  set additional losses to zero to avoid using again in _ROUTE routines  
      ENTK(N)   = 0.0  
      EXITK(N)  = 0.0  
      OTHERK(N) = 0.0  
      IF(RATIO.GT.1.0) THEN  
        IF (JCE.EQ.0) THEN  
         WRITE(N6,5335) NCOND(N),RATIO  
        ELSE  
         WRITE(N6,5336) ACOND(N),RATIO  
        ENDIF  
      ENDIF  
C  
C     INCORPORATE LOCAL LOSSES AND LENGTHEN SHORT CONDUITS  
c  
      CASE (3)  
c    IF SHORT THEN DO THIS  
               IF(RATIO.GT.1.0) THEN  
                  CLEN     = DELT*SQRT(AB*GRVT)  
C    IF NOT CLOSED AND SHORT THEN DO THIS  
                 IF(.NOT.CLOSED(N)) THEN  
                    ROUGH(N) = ROUGH(N)*SQRT(LEN(N)/CLEN)  
               IF(JCE.EQ.0) THEN  
                WRITE(N6,5335) NCOND(N),RATIO  
                WRITE(N6,5337) NCOND(N),CLEN,ROUGH(N),RATIO  
                ELSE  
                WRITE(N6,5336) ACOND(N),RATIO  
                WRITE(N6,5338) ACOND(N),CLEN,ROUGH(N),RATIO  
               ENDIF  
C    IF IT IS CLOSED AND SHORT THEN DO THE FOLLOWING  
                  ELSE  
                    OLDROUGH = ROUGH(N)  
Cwch, 3/28/00.  Fix typo again, as above (old eqn. deleted).  
			 ROUGH(N) = SQRT(ROUGH(N)**2 +  
     1                   (ENTK(N)+EXITK(N)+OTHERK(N))*  
     2                   CMET(9,METRIC)**2*RFULL(N)**1.333333/  
	3				   (2.0*GRVT*LEN(N)))  
               IF(JCE.EQ.0) THEN  
c                WRITE(N6,5335) NCOND(N),RATIO  
                WRITE(N6,6337) NCOND(N),OLDROUGH,CLEN,ENTK(N),EXITK(N),  
     +                         OTHERK(N),ROUGH(N)  
                ELSE  
c                WRITE(N6,5336) ACOND(N),RATIO  
                WRITE(N6,6338) ACOND(N),OLDROUGH,CLEN,ENTK(N),EXITK(N),  
     +                         OTHERK(N),ROUGH(N)  
                ENDIF  
              ENDIF  
                  LEN(N)   = CLEN  
              ELSE  
C    GO HERE IF NOT SHORT BUT CLOSED TO INCORPORATED ADDITIONAL LOSSES  
C    INCORPORATE LOCAL LOSSES INTO MANNING'S N FOR CLOSED CONDUITS  
C    BUT DO NOT ADJUST FOR SHORT CONDUITS  
             IF(CLOSED(N)) THEN  
               OLDROUGH = ROUGH(N)  
Cwch, 3/28/00. Fix typo again, as above (old eqn. deleted).  
			 ROUGH(N) = SQRT(ROUGH(N)**2 +  
     1                   (ENTK(N)+EXITK(N)+OTHERK(N))*  
     2                   CMET(9,METRIC)**2*RFULL(N)**1.333333/  
	3				   (2.0*GRVT*LEN(N)))  
C ****** BAC -- THIS IS A TEMPORARY WRITE TO SEE IF PROGRAM IN FUNCTIONING CORRECTLY  
               IF(JCE.EQ.0) THEN  
                            WRITE(N6,6335) NCOND(N),OLDROUGH,ENTK(N),  
     +                                     EXITK(N),OTHERK(N),ROUGH(N)  
               ELSE  
                            WRITE(N6,6336) ACOND(N),OLDROUGH,ENTK(N),  
     +                                     EXITK(N),OTHERK(N),ROUGH(N)  
               ENDIF  
             ENDIF  
             ENDIF  
c  set additional losses to zero to avoid using again in _ROUTE routines  
      ENTK(N) = 0.0  
      EXITK(N) = 0.0  
      OTHERK(N) = 0.0  
C  
C      NEQUAL IS ZERO OR 4  
C      ONLY CHECK FOR SHORT PIPES  
C  
      CASE (0,4)  
      IF(RATIO.GT.1.0) THEN  
         IF(JCE.EQ.0) THEN  
           WRITE(N6,5335) NCOND(N),RATIO  
         ELSE  
           WRITE(N6,5336) ACOND(N),RATIO  
         ENDIF  
      ENDIF  
         IF ((NEQUAL.EQ.4).AND.CLOSED(N)) THEN  
               IF (JCE.EQ.0) THEN  
                    WRITE(N6,6400) NCOND(N),ENTK(N),EXITK(N),OTHERK(N)  
               ELSE  
                    WRITE(N6,6401) ACOND(N),ENTK(N),EXITK(N),OTHERK(N)  
               ENDIF  
         ENDIF  
      END SELECT  
          VOLNEW   = VOLNEW + AFULL(N)*LEN(N)  
  320   CONTINUE  
C  
      IF(NEQUAL.EQ.1.AND.METRIC.EQ.1) WRITE(N6,5339)  
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD  
      IF(NEQUAL.EQ.1.AND.METRIC.EQ.2) WRITE(N6,5340)  
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD  
      IF(NEQUAL.EQ.0.AND.METRIC.EQ.1) WRITE(N6,5341)  VOLOLD  
      IF(NEQUAL.EQ.0.AND.METRIC.EQ.2) WRITE(N6,5342)  VOLOLD  
      IF(NEQUAL.EQ.3.AND.METRIC.EQ.1) WRITE(N6,5339)  
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD  
      IF(NEQUAL.EQ.3.AND.METRIC.EQ.2) WRITE(N6,5340)  
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD  
      IF(NEQUAL.EQ.2.AND.METRIC.EQ.1) WRITE(N6,5341)  VOLOLD  
      IF(NEQUAL.EQ.2.AND.METRIC.EQ.2) WRITE(N6,5342)  VOLOLD  
      IF(NEQUAL.EQ.5.AND.METRIC.EQ.1) WRITE(N6,5339)  
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD  
      IF(NEQUAL.EQ.5.AND.METRIC.EQ.2) WRITE(N6,5340)  
     +                                VOLOLD,VOLNEW,VOLNEW/VOLOLD  
C  BAC END   
C=======================================================================  
C     FIND JUNCTION DATA TO READ FROM GROUP D1.  
C     THE FOLLOWING SEQUENCE IS REQUIRED IF NATURAL CHANNEL INFORMATION  
C     WAS ENTERED IN THE DATA INPUT STREAM.  R.E.D., 4/92  
C     Modified by CIM to eliminate artificial loop which could potentially  
C     fail if may irregular sections.  
C=======================================================================  
C     DO 370 J=1,1000  
 370  CONTINUE  
      READ(N5,*,ERR=372) CC  
C  don't know what C6 was before bridges were invoked  
C     IF(CC.EQ.'D1'.OR.CC.EQ.'C6') THEN  
            IF(CC.EQ.'D1') THEN  
                                   BACKSPACE N5  
                                   GO TO 375  
                                   ENDIF  
      GO TO 370  
  372 WRITE(N6,*) 'D1 lines not found in input stream.'  
      STOP 'D1 lines not found'  
C 370 CONTINUE  
  375 CONTINUE  
C=======================================================================  
C     READ JUNCTION DATA ON DATA GROUP D1  
C=======================================================================  
      WRITE(*,6050)  
      DO 380 J = 1,NEE  
  340 READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'D1'.AND.J.GT.1) GO TO 400  
C These next lines should not be needed. cim 10/97  
C      IF(J.EQ.1. AND.(CC.EQ.'C3'.OR.CC.EQ.'X1'.OR.  
C     *                CC.EQ.'C4'.OR.CC.EQ.'GR')) THEN  
C                                READ(N5,*,ERR=888) CC  
C                                GO TO 340  
C                                ENDIF  
C modify to read optional xloc, yloc, and iwhich  
C  
C     READ IWHICH IF BFFACT IS TRUE INDICATING THAT BD LINES WERE READ  
      IF (BFFACT) THEN  
         IF(JCE.EQ.0) THEN  
           READ(N5,*,ERR=888) CC,JUN(J),GRELEV(J),  
     +                        Z(J),QINST(J),Y(J),  
     +                        XLOC(J),YLOC(J),  
     +                        IWHICH(J),SURELEV(J)  
         ELSE  
           READ(N5,*,ERR=888) CC,AJUN(J),GRELEV(J),  
     +                        Z(J),QINST(J),Y(J),  
     +                        XLOC(J),YLOC(J),  
     +                        IWHICH(J),SURELEV(J)  
         ENDIF  
	ELSE  
C     DONT READ IWHICH IF BFFACT IS FALSE  
         IF(JCE.EQ.0) THEN  
           READ(N5,*,ERR=888) CC,JUN(J),GRELEV(J),  
     +                        Z(J),QINST(J),Y(J),  
     +                        XLOC(J),YLOC(J),  
     +                        SURELEV(J)  
         ELSE  
           READ(N5,*,ERR=888) CC,AJUN(J),GRELEV(J),  
     +                        Z(J),QINST(J),Y(J),  
     +                        XLOC(J),YLOC(J),  
     +                        SURELEV(J)  
         ENDIF  
	ENDIF  
c  350 CONTINUE  
	IF (JELEV.GE.2) Y(J) = Y(J) - Z(J)  
      IF (IWHICH(J).EQ.0) IWHICH(J)=1  
      IF (IWHICH(J).GT.NUMSETS) THEN  
      WRITE(N6,*) 'ERROR - BASE FLOW FACTOR SET FOR JUNCTION (IWHICH)',  
     .' IS GREATER THAN NUMBER OF SETS READ ON B9 LINES'  
      IF (JCE.EQ.0) THEN  
         WRITE(N6,*) ' JUNCTION = ',JUN(J),IWHICH(J)  
      ELSE  
         WRITE(N6,*) ' JUNCTION = ',AJUN(J),IWHICH(J)  
      ENDIF  
      STOP 'INCORRECT BASE FLOW FACTOR SET'  
      ENDIF  
      IF ((NUMSETS.GT.1).AND.(QINST(J).NE.0.0)) THEN  
      IF (JCE.EQ.0) THEN  
         WRITE(N6,*) 'JUNCTION ',JUN(J),  
     .' USES BASE FLOW SET NUMBER ',IWHICH(J)  
      ELSE  
         WRITE(N6,*) 'JUNCTION ',AJUN(J),  
     .' USES BASE FLOW SET NUMBER ',IWHICH(J)  
      ENDIF  
      ENDIF  
      ZCROWN(J) = Z(J)  
C     Set up junction connectivity array from pipe data.  
C=======================================================================  
      LOC      = 0  
      IF(NC.GT.0) THEN  
      DO 360 N = 1,NC  
      DO 360 K = 1,2  
      IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J)) THEN  
                                            LOC          = LOC+1  
	IF (LOC.GT.NCHN) THEN  
	WRITE(N6,8040) J,JUN(J),NCHN  
	NSTOP = NSTOP + 1  
	LOC = NCHN  
	ENDIF  
                                            NCHAN(J,LOC) = N  
                                            ENDIF  
      IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J))THEN  
                                            LOC          = LOC+1  
	IF (LOC.GT.NCHN) THEN  
	WRITE(N6,8045) J,AJUN(J),NCHN  
	NSTOP = NSTOP +1  
	LOC = NCHN  
	ENDIF  
                                            NCHAN(J,LOC) = N  
                                            ENDIF  
  360 CONTINUE  
CIM   DO THIS CHECK AFTER PUMPS AND WEIRS... HAVE BEEN READ  
CIM  
CIM      IF(LOC.EQ.0) THEN  
CIM                   IF(JCE.EQ.0) THEN  
CIM                     WRITE(N6,5350) JUN(J)  
CIM                   ELSE  
CIM                     WRITE(N6,5351) AJUN(J)  
CIM                   ENDIF  
CIM                   JSKIP(J) = 1  
CIM                   ENDIF  
      ELSE  
C=======================================================================  
C     ZCROWN IS EQUAL TO THE GROUND ELEVATION FOR JUNCTIONS WITH  
C            NO CONNECTING CONDUITS.  
C=======================================================================  
      ZCROWN(J) = GRELEV(J) - Z(J)  
      IF(ZCROWN(J).LE.0.0) THEN  
                           IF(JCE.EQ.0) THEN  
                            WRITE(N6,8200)  JUN(J)  
                           ELSE  
                            WRITE(N6,8201) AJUN(J)  
                           ENDIF  
                           NSTOP = NSTOP + 1  
                           ENDIF  
      ENDIF  
  380 CONTINUE  
  400 NJ = J-1  
C=======================================================================  
C     CONVERT CONDUIT CONNECTIVITY NUMBERS TO INTERNAL SYSTEM  
C     ASSIGN POSITIVE DOWNSTREAM FLOW CONVENTION  
C=======================================================================  
      IMOVE    = 0  
      IF(NC.GT.0) THEN  
	GRNDERROR = .FALSE.  
      DO 600 N = 1,NC  
      DO 540 K = 1,2  
      DO 500 J = 1,NJ  
      IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J))  GO TO 520  
      IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J)) GO TO 520  
  500 CONTINUE  
      IF(JCE.EQ.0) THEN  
       WRITE(N6,5390) NJUNC(N,K),NCOND(N)  
      ELSE  
       WRITE(N6,5391) KJUNC(N,K),ACOND(N)  
      ENDIF  
      NSTOP      = NSTOP + 1  
  520 NJUNC(N,K) = J  
  540 CONTINUE  
      NL    = NJUNC(N,1)  
      NH    = NJUNC(N,2)  
      IF(JELEV.EQ.0) THEN  
                     ZU(N) = Z(NL) + ZU(N)  
                     ZD(N) = Z(NH) + ZD(N)  
                     ELSE  
Cim If elevation is zero, then set to invert of junction  
                     IF(ZU(N).EQ.0.0) ZU(N) = Z(NL) + ZU(N)  
                     IF(ZD(N).EQ.0.0) ZD(N) = Z(NH) + ZD(N)  
                     ENDIF  
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  
cim bac added 11/97  
C PREVENT FLAT CONDUITS  
c      DO N = 1, NC  
      IF(ABS(ZU(N)-ZD(N)).LE.0.0001) THEN  
      ZU(N)=ZU(N)+.001  
      IF (JCE.EQ.0) THEN  
                        WRITE(N6,6207) NCOND(N)  
                    ELSE  
                        WRITE(N6,6208) ACOND(N)  
      END IF  
      END IF  
c      END DO  
C^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  
      IF(ZU(N)-ZD(N).LT.0.0) THEN  
                             IMOVE      = IMOVE + 1  
                             IF(JCE.EQ.1) THEN  
                                          KDUM(1)    = KJUNC(N,1)  
                                          KJUNC(N,1) = KJUNC(N,2)  
                                          KJUNC(N,2) = KDUM(1)  
                                          ENDIF  
                             TEMP       = ZU(N)  
                             ZU(N)      = ZD(N)  
                             ZD(N)      = TEMP  
                             QO(N)      = -QO(N)  
                             NJUNC(N,1) = NH  
                             NJUNC(N,2) = NL  
                             NL         = NJUNC(N,1)  
                             NH         = NJUNC(N,2)  
                             IF(IMOVE.EQ.1) WRITE(N6,6200)  
                             IF(JCE.EQ.0) THEN  
                               WRITE(N6,6205) IMOVE,NCOND(N)  
                             ELSE  
                               WRITE(N6,6206) IMOVE,ACOND(N)  
                             ENDIF  
                             ENDIF  
      IF((ZU(N) + DEEP(N)).GT.ZCROWN(NL))  ZCROWN(NL) = ZU(N)+DEEP(N)  
      IF((ZD(N) + DEEP(N)).GT.ZCROWN(NH))  ZCROWN(NH) = ZD(N)+DEEP(N)  
      IF(ZCROWN(NL).GT.GRELEV(NL)+0.001) THEN  
	            GRNDERROR = .TRUE.  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5395) NCOND(N),JUN(NL)  
                    ELSE  
                      WRITE(N6,5396) ACOND(N),AJUN(NL)  
                    ENDIF  
c  update grelev to appropriate land elevation for printout in table below  
                    GRELEV(NL) = ZCROWN(NL) + 0.01  
                    NSTOP      = NSTOP + 1  
                    ENDIF  
      IF(ZCROWN(NH).GT.GRELEV(NH)+0.001) THEN  
	            GRNDERROR = .TRUE.  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5395) NCOND(N),JUN(NH)  
                    ELSE  
                      WRITE(N6,5396) ACOND(N),AJUN(NH)  
                    ENDIF  
c  update grelev to appropriate land elevation for printout in table below  
                    GRELEV(NH) = ZCROWN(NH) + 0.01  
                    NSTOP      = NSTOP + 1  
                    ENDIF  
  600 CONTINUE  
      IF (GRNDERROR) WRITE(N6,8000)  
      ENDIF  
C=======================================================================  
C     Print junction data.  
C=======================================================================  
CIM 1/99 print first header  
                                   WRITE(N6,2999)  
                                   WRITE(N6,5060) ALPHA1,ALPHA2  
                                   IF(METRIC.EQ.1) WRITE(N6,5360)  
                                   IF(METRIC.EQ.2) WRITE(N6,5361)  
      DO 460 J = 1,NJ  
      MPT      = 0  
      NZP      = 0  
      DO 420 I = 1,NCHN  
      K1       = NCHAN(J,I)  
      IF(K1.EQ.0)            GO TO 440  
      IF(JCE.EQ.0) THEN  
       IDUM(I) = NCOND(K1)  
      ELSE  
       KDUM(I) = ACOND(K1)  
      ENDIF  
      MPT                  = MPT + 1  
C=======================================================================  
C     Check for all conduits above the Junction invert.  
C=======================================================================  
                           JJ = 1  
      IF(NJUNC(K1,1).EQ.J) JJ = 1  
      IF(NJUNC(K1,2).EQ.J) JJ = 2  
      IF(JJ.EQ.1.AND.ZU(K1).GT.Z(J)) NZP = NZP + 1  
      IF(JJ.EQ.2.AND.ZD(K1).GT.Z(J)) NZP = NZP + 1  
      IF(JJ.EQ.1.AND.ZU(K1).LT.Z(J)) NZP = NZP + 1  
      IF(JJ.EQ.2.AND.ZD(K1).LT.Z(J)) NZP = NZP + 1  
  420 CONTINUE  
  440 CONTINUE  
CIM 1/99 eliminate intermediate headers if JHEAD = 1  
      IF (JHEAD.EQ.0.AND.MOD(J,50).EQ.0) THEN  
                                   WRITE(N6,2999)  
                                   WRITE(N6,5060) ALPHA1,ALPHA2  
                                   IF(METRIC.EQ.1) WRITE(N6,5360)  
                                   IF(METRIC.EQ.2) WRITE(N6,5361)  
                                   ENDIF  
      IF(MPT.GT.0) THEN  
      IF(JCE.EQ.0) THEN  
                   WRITE(N6,5380) J,JUN(J),GRELEV(J),ZCROWN(J),  
     +                            Z(J),QINST(J),Y(J),(IDUM(K),K=1,MPT)  
      ELSE  
                   WRITE(N6,5381) J,AJUN(J),GRELEV(J),ZCROWN(J),  
     +                            Z(J),QINST(J),Y(J),(KDUM(K),K=1,MPT)  
      ENDIF  
      IF(NZP.EQ.MPT) THEN  
         IF(JCE.EQ.0) THEN  
             WRITE(N6,5382)  JUN(J)  
         ELSE  
             WRITE(N6,5383) AJUN(J)  
         ENDIF  
      ENDIF  
      ELSE  
      IF(JCE.EQ.0) THEN  
                   WRITE(N6,5380) J,JUN(J),GRELEV(J),  
     +                            ZCROWN(J),Z(J),QINST(J),Y(J)  
      ELSE  
                   WRITE(N6,5381) J,AJUN(J),GRELEV(J),  
     +                            ZCROWN(J),Z(J),QINST(J),Y(J)  
      ENDIF  
      ENDIF  
	IF ((XLOC(J).NE.0.0).OR.  
     1    (YLOC(J).NE.0.0).OR.  
     2    (SURELEV(J).NE.0.0)) TABLE2 = .TRUE.  
  460 CONTINUE  
C     PRINT SECOND TABLE FOR ADDITIONAL JUNCTION DATA  
C      X,Y, IWHICH, SURELEV  
      IF (TABLE2.OR.BFFACT) THEN  
	IF (METRIC.EQ.1) THEN  
	                   IREAD = '(FT)'  
	ELSE  
	                   IREAD = ' (M)'  
	ENDIF  
	IF (BFFACT) THEN  
	    WRITE(N6,7360) IREAD  
	ELSE  
	    WRITE(N6,7365) IREAD  
	ENDIF  
      DO 480 J = 1,NJ  
	IF (BFFACT) THEN  
      IF(JCE.EQ.0) THEN  
                   WRITE(N6,7380) J,JUN(J),XLOC(J),YLOC(J),  
     +                            IWHICH(J),SURELEV(J)  
      ELSE  
                   WRITE(N6,7381) J,AJUN(J),XLOC(J),YLOC(J),  
     +                            IWHICH(J),SURELEV(J)  
      ENDIF  
	ELSE  
      IF(JCE.EQ.0) THEN  
                   WRITE(N6,7385) J,JUN(J),XLOC(J),YLOC(J),  
     +                            SURELEV(J)  
      ELSE  
                   WRITE(N6,7386) J,AJUN(J),XLOC(J),YLOC(J),  
     +                            SURELEV(J)  
      ENDIF  
	ENDIF  
	IF ((SURELEV(J).NE.0.0).AND.(SURELEV(J).LT.GRELEV(J)))  
     1         WRITE(N6,7387)  
  480 CONTINUE  
      ENDIF  
	DO J=1,NJ  
	IF(SURELEV(J).EQ.0.0) SURELEV(J) = GRELEV(J)  
	IF(SURELEV(J).LT.GRELEV(J)) SURELEV(J) = GRELEV(J)  
	ENDDO  
C=======================================================================  
C     Check for high pipe and print a warning at the upstream end.  
C=======================================================================  
      DO 495 N = 1,NC  
      J        = NJUNC(N,1)  
      IF(ZU(N).EQ.Z(J)) GO TO 495  
C add a test for ZU lt z  
      IF(ZU(N).LT.Z(J)) THEN  
	IF (JCE.EQ.0) THEN  
	WRITE(N6,8050) 'UPSTREAM  ',NCOND(N),JUN(J),ZU(N),Z(J)  
	ELSE  
	WRITE(N6,8055) 'UPSTREAM  ',ACOND(N),AJUN(J),ZU(N),Z(J)  
      ENDIF  
	NSTOP = NSTOP + 1  
	ENDIF  
      ITEST     = 0  
      JTEST     = 0  
      DO 490 KK = 1,NCHN  
      NKK       = NCHAN(J,KK)  
      IF(NKK.EQ.N) GO TO 490  
      IF(NKK.EQ.0.OR.NKK.GT.NC) GO TO 494  
                            JJ = 1  
      IF(NJUNC(NKK,1).EQ.J) JJ = 1  
      IF(NJUNC(NKK,2).EQ.J) JJ = 2  
      JTEST = JTEST + 1  
      IF(JJ.EQ.1.AND.ZU(N).LE.ZU(NKK) + DEEP(NKK)) GO TO 490  
      IF(JJ.EQ.2.AND.ZU(N).LE.ZD(NKK) + DEEP(NKK)) GO TO 490  
      ITEST = ITEST + 1  
  490 CONTINUE  
  494 CONTINUE  
      IF(ITEST.EQ.JTEST) THEN  
          IF(JCE.EQ.0) THEN  
             WRITE(N6,5392) NCOND(N),JUN(J)  
          ELSE  
             WRITE(N6,5393) ACOND(N),AJUN(J)  
          ENDIF  
      ENDIF  
  495 CONTINUE  
C=======================================================================  
C     Check for high pipe and print a warning at the downstream end.  
C=======================================================================  
      DO 595 N = 1,NC  
      J        = NJUNC(N,2)  
      IF(ZD(N).EQ.Z(J)) GO TO 595  
C add a test for ZU lt z  
      IF(ZD(N).LT.Z(J)) THEN  
	IF (JCE.EQ.0) THEN  
	WRITE(N6,8050) 'DOWNSTREAM',NCOND(N),JUN(J),ZD(N),Z(J)  
	ELSE  
	WRITE(N6,8055) 'DOWNSTREAM',ACOND(N),AJUN(J),ZD(N),Z(J)  
      ENDIF  
	NSTOP = NSTOP + 1  
	ENDIF  
      ITEST     = 0  
      JTEST     = 0  
      DO 590 KK = 1,NCHN  
      NKK       = NCHAN(J,KK)  
      IF(NKK.EQ.N) GO TO 590  
      IF(NKK.EQ.0.OR.NKK.GT.NC) GO TO 594  
                            JJ = 1  
      IF(NJUNC(NKK,1).EQ.J) JJ = 1  
      IF(NJUNC(NKK,2).EQ.J) JJ = 2  
      JTEST = JTEST + 1  
      IF(JJ.EQ.1.AND.ZD(N).LE.ZU(NKK) + DEEP(NKK)) GO TO 590  
      IF(JJ.EQ.2.AND.ZD(N).LE.ZD(NKK) + DEEP(NKK)) GO TO 590  
      ITEST = ITEST + 1  
  590 CONTINUE  
  594 CONTINUE  
      IF(ITEST.EQ.JTEST) THEN  
        IF(JCE.EQ.0) THEN  
          WRITE(N6,5392) NCOND(N),JUN(J)  
        ELSE  
          WRITE(N6,5393) ACOND(N),AJUN(J)  
        ENDIF  
      ENDIF  
  595 CONTINUE  
CIM START   <><><><><><><><>  
CIM     CONVERT NKLASS FROM INPUT VALUES TO INTERNAL VALUES FOR LATER  
CIM     COMPUTATIONS STORED IN NEWKLASS ARRAY  
c  
      BIG = 3.4E+38  
      DO 650  N = 1,NC  
      NKLASS(N) = NEWKLASS(NKLASS(N))  
      IF (NKLASS(N).LE.21) THEN  
      IF (STHETA(N).EQ.0.0) STHETA(N) = -BIG  
      IF (SPHI(N).EQ.0.0)   SPHI(N) = BIG  
      ENDIF  
  650 CONTINUE  
CIM END   <><><><><><>  
C=======================================================================  
CIM### 9/9/00  
C	CALL READTHRESH TO READ D2 AND D3 LINES  
      CALL READTHRESH  
C=======================================================================  
      WRITE(*,6100)  
      RETURN  
 888  CALL IERROR  
 8888 WRITE(N6,8887)  
      STOP  
C=======================================================================  
  949 FORMAT(12F10.3)  
  951 FORMAT(//,5X,'INTERMEDIATE OUTPUT WILL BE WRITTEN FOR THE',  
     A' FOLLOWING PERIODS',/,  
     B10X,' STARTING CYCLE   ENDING CYCLE')  
  952 FORMAT(10X,2I15)  
 2999 FORMAT(/,  
     1       '1',40(2H--)/' ','ENVIRONMENTAL PROTECTION AGENCY',13X,40H*  
     2***   EXTENDED TRANSPORT PROGRAM   ****,8X,'WATER RESOURCES DIVISI  
     3ON',/,' ','WASHINGTON, D.C.            ',16X,4H****,32X,4H****,8X,  
     4'CAMP DRESSER & MCKEE INC.',/,' ','                ',28X,4H****,  
     56X,'   ANALYSIS MODULE  ',6X,4H****,8X,'ANNANDALE, VIRGINIA')  
Cwch, 7/23/04.  
 5050 FORMAT(/,' Version compatibility options from Line AA.',/,  
     1         ' -------------------------------------------')  
 5051 FORMAT(  ' NAVER = 1, Use SWMM3x geometric parameter weighting.')   
 5052 FORMAT(  ' NAVER = 2, Use SWMM4x geometric parameter weighting.')   
 5053 FORMAT(  ' NAVER = 3, Use SWMM5 geometric parameter weighting.')   
 5054 FORMAT(/,' WARNING Parameter NAVER =',I3,' on AA line not 1,2 or  
     13.',/,   ' Use NAVER = 2 (SWMM4x weighting) as default.')  
 5055 FORMAT(  ' NFASNH =',I2,' on AA line re. surface area weighting. S  
     1ee documentation.')  
 5056 FORMAT(  ' NFASNH =',I3,' on AA line re. surface area weighting. O  
     1ut of range Use NFASNH = 0 as default. See documentation.')   
 5060 FORMAT(/,5X,A80,/,5X,A80,/)  
 5100 FORMAT(/,' Control information for simulation',/,  
     +       ' ----------------------------------',//,  
     +       ' Integration cycles.................',I8,/)  
 5120 FORMAT(' Length of integration step is......',F8.2,  
     +       ' seconds',/,  
     +       ' Simulation length..................',F8.2,' hours',/)  
 5121 FORMAT(' Do not create equiv. pipes(NEQUAL).',I8,/)  
C  BAC START  
C5122 FORMAT(' Create equivalent conduits based ',/,  
C    +       ' on the COURANT condition..........',I8,/)  
 5122 FORMAT(' Create equivalent conduits based ',/,  
     +       ' on the COURANT condition (no local',/,  
     +       ' losses)............................',I8,/)  
 5921 FORMAT(' Create equivalent conduits based ',/,  
     +       ' on incorporating local losses (no',/,  
     +       ' lengthening).......................',I8,/)  
 5922 FORMAT(' Create equivalent conduits based ',/,  
     +       ' on incorporating local losses and',/,  
     +       ' on the COURANT condition...........',I8,/)  
 5923 FORMAT(' Local losses read from C1 lines are ',/,  
     +       ' factored into momentum equation (no',/,  
     +       ' lengthening).......................',I8,/)  
 5924 FORMAT(' Local losses read from C1 lines are ',/,  
     +       ' factored into momentum equation and ',/,  
     +       ' conduits are lengthened based on COURANT',/,  
     +       ' condition..........................',I8,/)  
C  BAC END  
 5123 FORMAT(' Use U.S. customary units for I/O...',I8,/)  
 5124 FORMAT(' Use metric units for I/O...........',I8,/)  
C#### WCH, 7/25/96.  JREDO INSTEAD OF REDO.  
Cwch, 9/8/00. Use I9 for INTER.  
 5140 FORMAT(' Printing starts in cycle...........',I8,//,  
     +       ' Intermediate printout intervals of', I9,' cycles',/,  
     +       ' Intermediate printout intervals of.',F8.2,' minutes',//,  
     +       ' Summary printout intervals of......',I8,' cycles',/,  
     +       ' Summary printout time interval of..',F8.2,' minutes',//,  
     +       ' Hot start file parameter (JREDO)...',I8,/)  
 5160 FORMAT(' Initial time (TZERO)...............',F8.2,' hours')  
C#### WCH, 7/25/96.  
c 5161 FORMAT(' Time displacement from interface file starting date/time'  
c     1,/,    ' when hot start is used (TZERO).....',F8.2,' hours')  
 5161 FORMAT(' This is time displacement from JIN interface file ',  
     1'starting date/time when',/,' interface file is used.',/,  
     1' This also describes starting hour in K3 line hydrograph',  
     1' input when K3',/,' lines are used.')  
Cwch, 2/4/01  
 5162 FORMAT(/,' ERROR. IDATZ MUST BE AT LEAST 5 DIGITS TO PROVIDE YR/MO  
     1/DAY. CHANGE ENTERED IDATZ =',I8,' TO DEFAULT = 19410802.')  
C#### WCH, 4/11/94.  
 5163 FORMAT(' Initial date (default).............',I8,' (yr/mo/day)')  
CWCH, 11/12/99. ADD FIELD WIDTH TO ALLOW FOR NEGATIVE SIGN  
 5164 FORMAT(' Initial date (IDATZ).............', I10,' (yr/mo/day)')  
C#### WCH, 7/25/96.  
 5165 FORMAT(' NOTE: Initial date from JIN interface file will be',  
     +' used, if accessed,',/,' unless IDATZ is negative.')  
 5170 FORMAT(/,' Iteration variables: ITMAX.........',I8,/,  
     1         '                      SURTOL........',F8.4,/)  
 5175 FORMAT(' Default surface area of junctions....',F8.2,  
     +       ' square feet.',/)  
 5176 FORMAT(' Default surface area of junctions..',F6.2,  
     +       ' square meters.',/)  
 5177 FORMAT(' EXTRAN VERSION 3.3 SOLUTION. (ISOL = 0).',/,  
     +       ' Sum of junction flow is zero during surcharge.',/)  
 5178 FORMAT(' SEMI-IMPLICIT EXTRAN SOLUTION. (ISOL = 1).',/,  
     +       ' NEWTON-RAPHSON SURCHARGE ITERATION.',/)  
 5179 FORMAT(' ITERATIVE EXTRAN SOLUTION. (ISOL = 2).',/,  
     +       ' NEWTON-RAPHSON SURCHARGE ITERATION.',/)  
 5180 FORMAT(' NJSW INPUT HYDROGRAPH JUNCTIONS....',I6)  
 5183 FORMAT(' NORMAL FLOW OPTION WHEN THE WATER  ',/,  
     +       ' SURFACE SLOPE IS LESS THAN THE     ',/,  
     +       ' GROUND SURFACE SLOPE (KSUPER=0)....',/)  
 5184 FORMAT(' NORMAL FLOW OPTION WHEN THE FROUDE ',/,  
     +       ' # IS GREATER THAN 1.0 (KSUPER=1)...',/)  
CIM 1/99 CLEAN UP FOLLOWING TO PROVIDE BLANKS IF 10 CHARACTERS OR DIGITS  
CIM ARE USED  
 5200 FORMAT(/,' Printed output for the following',I3,  
     +         ' Junctions',//,(5X,10(I10,1X)))  
 5201 FORMAT(/,' Printed output for the following',I3,  
     +         ' Junctions',//,(5X,10(A10,1X)))  
 5220 FORMAT(/,' Printed output for the following',I3,  
     +         ' Conduits',//,(5X,10(I10,1X)))  
 5221 FORMAT(/,' Printed output for the following',I3,  
     +         ' Conduits',//,(5X,10(A10,1X)))  
 5240 FORMAT (/,' Water surface elevations will be plotted',  
     +    ' for the following ',I3,' Junctions',//,(5X,10(I10,1X)))  
 5241 FORMAT (/,' Water surface elevations will be plotted',  
     +    ' for the following ',I3,' Junctions',//,(5X,10(A10,1X)))  
 5260 FORMAT(/,' Flow rate will be plotted for the following ',  
     +             I3,' Conduits',//,(5X,10(I10,1X)))  
 5261 FORMAT(/,' Flow rate will be plotted for the following ',  
     +             I3,' Conduits',//,(5X,10(A10,1X)))  
 5265 FORMAT(/,' THE WATER SURFACE SLOPE WILL BE PLOTTED FOR THE ',  
     +         'FOLLOWING ',I3,' CONDUITS',//,(5X,10(I10,1X)))  
 5266 FORMAT(/,' THE WATER SURFACE SLOPE WILL BE PLOTTED FOR THE ',  
     +         'FOLLOWING ',I3,' CONDUITS',//,(5X,10(A10,1X)))  
CIM  WRITING OF RESULTS TO ASCII FILE  
 5267 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ',  
     +         'FOLLOWING ',I5,' CONDUITS',/,  
     +         ' FLOWS WILL BE WRITTEN EVERY ',i5,' TIME STEPS',/,  
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CFS',  
     +          /,(5X,10(I10,1X)))  
Cwch, 9/9/00.  
 5273 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ',  
     +         'FOLLOWING ',I5,' CONDUITS',/,  
     +         ' FLOWS WILL BE WRITTEN EVERY ',i5,' TIME STEPS',/,  
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CMS',  
     +          /,(5X,10(I10,1X)))  
 5268 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ',  
     +         'FOLLOWING ',I5,' CONDUITS',/,  
     +         ' FLOWS WILL BE WRITTEN EVERY ',I5,' TIME STEPS',/,  
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CFS',  
     +         //,(5X,10(A10,1X)))  
 5274 FORMAT(/,' FLOWS WILL BE WRITTEN FOR THE ',  
     +         'FOLLOWING ',I5,' CONDUITS',/,  
     +         ' FLOWS WILL BE WRITTEN EVERY ',I5,' TIME STEPS',/,  
     +         ' MINIMUM FLOW EQUALS ',F10.3,' CMS',  
     +         //,(5X,10(A10,1X)))  
 8260 FORMAT(/,' FLOWS ARE WRITTEN TO STANDARD SWMM BINARY ',  
     +'SEQUENTIAL UNFORMATTED FILE FOR INPUT TO STATS OR OTHER ',  
     +'SWMM BLOCK')  
 8261 FORMAT(/,' FLOWS ARE WRITTEN TO ASCII FORMATTED FILE')  
 8263 FORMAT(/,' ABSOLUTE VALUE OF FLOWS ARE WRITTEN TO OUTPUT FILE')  
 5269 FORMAT(' FLOWS IN CFS',/,  
     1' MO DY YEAR  HOUR  DT(SEC)   FLOWS IN CHANNEL NOS.:')  
Cwch, 9/8/00.  
 5272 FORMAT(' FLOWS IN CMS',/,  
     1' MO DY YEAR  HOUR  DT(SEC)   FLOWS IN CHANNEL NOS.:')  
 7268 FORMAT(' FLOWS AT FOLLOWING ',I10,' CONDUITS WILL BE WRITTEN',  
     &' WHEN FLOWS IN SECOND PIPE ARE GREATER THAN FLOWMIN',//,  
     &10X,'FIRST PIPE',10X,'SECOND PIPE ')  
 7269 FORMAT(10X,I10,10X,I10)  
 7270 FORMAT('NOFDUP EQUALS ZERO')  
 7271 FORMAT(10X,A10,10X,A10)  
 5270 FORMAT(25X,400I14)  
 5271 FORMAT(25X,400(4X,A10))  
 5300 FORMAT(/,1H1,/,  
     +' *****************************************************',/,  
     +' *                     Conduit Data                  *',/,  
     +' *****************************************************',//,  
     1'  INP  CONDUIT    LENGTH   CONDUIT     AREA    MANNING MAX WIDTH'  
     1,'     DEPTH       JUNCTIONS          INVERT HEIGHT     TRAPEZOID'  
     1,/,  
     2'  NUM   NUMBER     (FT)      CLASS   (SQ FT)     COEF.   (FT)   '  
     2,'      (FT)      AT THE ENDS        ABOVE JUNCTIONS   ',  
     2'SIDE SLOPES',/,  
     3' ----   ------   -------  --------   -------   ------- ---------'  
     3,'     -----   -------   -------     ---------------   ',  
     3'----- -----')  
 5301 FORMAT(/,1H1,/,  
     +' *****************************************************',/,  
     +' *                     Conduit Data                  *',/,  
     +' *****************************************************',//,  
     1'  INP  CONDUIT    LENGTH   CONDUIT     AREA    MANNING MAX WIDTH'  
     1,'     DEPTH       JUNCTIONS          INVERT HEIGHT     TRAPEZOID'  
     1,/,  
     2'  NUM   NUMBER     (M)       CLASS    (SQ M)     COEF.   (M)    '  
     2,'      (M)       AT THE ENDS        ABOVE JUNCTIONS   ',  
     2'SIDE SLOPES',/,  
     3' ----   ------   -------  --------   -------   ------- ---------'  
     3,'     -----   -------   -------     ---------------   ',  
     2'----- -----')  
 5320 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X),  
     a16X,2F7.2)  
 5321 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X))  
 5322 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X)  
     a,2F8.2,2F7.2)  
 5323 FORMAT(I4,I10,F10.0,A10,F10.2,F10.5,F10.2,F10.2,2(I10,1X)  
     a,2F8.2)  
 5335 FORMAT(' ===> WARNING  (C*DELT/LEN) IN CONDUIT',  
     .       I10,' IS',F5.1,' AT FULL DEPTH.')  
 5336 FORMAT(' ===> WARNING  (C*DELT/LEN) IN CONDUIT ',  
     .       A10,' IS',F5.1,' AT FULL DEPTH.')  
 5337 FORMAT(' ===> THE NEW EQUIVALENT LENGTH/ROUGHNESS/RATIO FOR COND',  
     +'UIT ',I10,' IS ',F10.1,' / ',F10.7,' / ',F5.1)  
 5338 FORMAT(' ===> THE NEW EQUIVALENT LENGTH/ROUGHNESS/RATIO FOR COND',  
     +'UIT ',A10,' IS ',F10.1,' / ',F10.7,' / ',F5.1)  
 5339 FORMAT(/,  
     +' ****************************************',/,  
     +' *  Equivalent Conduit Volume Analysis  *',/,  
     +' ****************************************',//,  
     +' Input full depth volume............',1PE14.4,' cubic feet',/,  
     +' New full depth volume..............',1PE14.4,' cubic feet',/,  
     +' New volume / Old volume ratio......',0PF14.4)  
 5340 FORMAT(/,  
     +' ****************************************',/,  
     +' *  Equivalent Conduit Volume Analysis  *',/,  
     +' ****************************************',//,  
     +' Input full depth volume............',1PE14.4,' cubic meters',/,  
     +' New full depth volume..............',1PE14.4,' cubic meters',/,  
     +' New volume / Old volume ratio......',0PF14.4)  
 5341 FORMAT(/,  
     +' ********************',/,  
     +' *  Conduit Volume  *',/,  
     +' ********************',//,  
     +' Input full depth volume............',1PE14.4,' cubic feet')  
 5342 FORMAT(/,  
     +' ********************',/,  
     +' *  Conduit Volume  *',/,  
     +' ********************',//,  
     +' Input full depth volume............',1PE14.4,' cubic meters')  
C 5350 FORMAT(/,'===> WARNING  JUNCTION',I10,  
C     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT.')  
C 5351 FORMAT(/,'===> WARNING  JUNCTION',A10,  
C     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT.')  
 5355 FORMAT(//,'$$$ FOR NATURAL CHANNELS WITH MULTIPLE DEPRESSIONS OR V  
     *ARIABLE MANNINGS N,',/,'    FLOW IS SUM OF FLOWS IN DEPRESSIONS AN  
     *D/OR VARIABLE-N SEGMENTS.',/,'    THIS IS EQUIVALENT TO SUMMING CO  
     *NVEYANCES ACROSS THE CHANNEL. $$$'//)  
 5360 FORMAT(/,1H1,/,  
     +' *****************************************************',/,  
     +' *                  Junction Data                    *',/,  
     +' *****************************************************',//,  
     1' INP  JUNCTION    GROUND    CROWN     INVERT     QINST   INITIAL'  
     +,'     CONNECTING CONDUITS',/,  
     3' NUM    NUMBER     ELEV.     ELEV.     ELEV.       CFS DEPTH(FT)'  
     3,/,' ---    ------   -------   -------    ------   ------- ------'  
     3,'---     -------------------')  
 5361 FORMAT(/,1H1,/,  
     +' *****************************************************',/,  
     +' *                  Junction Data                    *',/,  
     +' *****************************************************',//,  
     1' INP  JUNCTION    GROUND    CROWN     INVERT     QINST   INITIAL'  
     +,'     CONNECTING CONDUITS',/,  
     3' NUM    NUMBER     ELEV.     ELEV.     ELEV.       CMS  DEPTH(M)'  
     3,/,' ---    ------   -------   -------    ------   ------- ------'  
     3,'---   -------------------')  
Cwch, 10/30/01. Change integer field for conduits to I10 from I7  
 5380 FORMAT(I4,I10,F10.2,4F10.2,3X,8(I10,1X))  
 5381 FORMAT(I4,1X,A10,F9.2,4F10.2,3X,5(A10,1X),/,67X,3(A10,1X))  
 5382 FORMAT(' ===> Warning all conduits connecting to Junction ',I10,  
     +       ' lie above the Junction invert.')  
 5383 FORMAT(' ===> Warning all conduits connecting to Junction ',A10,  
     +       ' lie above the Junction invert.')  
 5390 FORMAT(/,' ===> ERROR  JUNCTION',I10,' ON CONDUIT',I10,  
     1       ' IS NOT CONTAINED IN JUNCTION DATA')  
 5391 FORMAT(/,' ===> ERROR  JUNCTION',A10,' ON CONDUIT ',A10,  
     1       ' IS NOT CONTAINED IN JUNCTION DATA')  
 5392 FORMAT(' ===> WARNING   THE INVERT OF ',  
     *'CONDUIT ',I10,' LIES ABOVE THE CROWN OF ALL CONDUITS',  
     *' AT JUNCTION ',I10)  
 5393 FORMAT(' ===> WARNING   THE INVERT OF ',  
     *'CONDUIT ',A10,' LIES ABOVE THE CROWN OF ALL CONDUITS',  
     *' AT JUNCTION ',A10)  
 5395 FORMAT(/,' ===> ERROR   CONDUIT',I10,' HAS CAUSED ZCROWN OF',  
     1       ' JUNCTION',I10,' TO LIE ABOVE THE SPECIFIED GROUND ELEV.')  
 5396 FORMAT(/,' ===> ERROR   CONDUIT ',A10,' HAS CAUSED ZCROWN ',  
     1   'OF JUNCTION ',A10,' TO LIE ABOVE THE SPECIFIED GROUND ELEV.')  
 5420 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,  
     +                                 2X,2(A10,1X),16X,2F7.2)  
 5421 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,2X,2(A10,1X))  
 5422 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,2X,2(A10,1X),  
     +                                           2F8.2,2F7.2)  
 5423 FORMAT(I4,1X,A10,F9.0,A10,F10.2,F10.5,F10.2,F10.2,2X,  
     +2(A10,1X),2F8.2)  
 6000 FORMAT(/,' Reading conduit data.')  
 6050 FORMAT(/,' Reading junction data.')  
 6100 FORMAT(/,' Reading remaining simulation data.')  
 6200 FORMAT(/,' ===> Warning  The upstream and downstream junctions',  
     +' for the following conduits',/,  
     +'                 have been reversed to correspond to the',  
     +' positive flow and decreasing',/  
     +,'                 slope EXTRAN convention.  A negative flow in',  
     +' the output thus means ',/,  
     +'                 the flow was from your original upstream',  
     +' junction to your original',/,  
     +'                 downstream junction.  Any initial flow has',  
     +' been multiplied by -1.',/)  
 6205 FORMAT(13X,I5,'.  Conduit #...',I10,'  has been changed.')  
 6206 FORMAT(13X,I5,'.  Conduit #...',A10,'  has been changed.')  
change  11/97  
 6207 FORMAT(12x,' Conduit #...',I10,' has zero slope.',  
     a'  0.001 feet added to upstream invert.')  
 6208 FORMAT(12x,' Conduit #...',A10,' has zero slope.',  
     a'  0.001 feet added to upstream invert.')  
change  
C  BAC START -- TEMPORARY FORMAT STATEMENTS  
 6335 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',I10,/,  
     a5X,'INPUT N =',F7.4,' ENTK =',F7.4,' EXITK =',F7.4,  
     b' OTHERK =',F7.4,' ADJUSTED N = ',F7.4)  
 6336 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',A10,/,  
     a5X,'INPUT N =',F7.4,' ENTK =',F7.4,' EXITK =',F7.4,  
     b' OTHERK =',F7.4,' ADJUSTED N = ',F7.4)  
 6337 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',I10,/,  
     a5X,'INPUT N =',F7.4,' NEW LENGTH =',F10.2,' ENTK =',F7.4,  
     b' EXITK =',F7.4,' OTHERK =',F7.4,' ADJUSTED N = ',F7.4)  
 6338 FORMAT(' EQUIVALENT N COMPUTED FOR CONDUIT ',A10,/,  
     a5X,'INPUT N =',F7.4,' NEW LENGTH =',F10.2,' ENTK =',F7.4,  
     b' EXITK =',F7.4,' OTHERK =',F7.4,' ADJUSTED N = ',F7.4)  
 6400 FORMAT(' LOSSES INCORPORATED INTO MOMENTUM EQUATION FOR CONDUIT '  
     a,I10,/,' ENTK =',F7.4,' EXITK =',F7.4,' OTHERK =',F7.4)  
 6401 FORMAT(' LOSSES INCORPORATED INTO MOMENTUM EQUATION FOR CONDUIT '  
     a,A10,/,' ENTK =',F7.4,' EXITK =',F7.4,' OTHERK =',F7.4)  
C  BAC END  
CIM CIM START  <><><><><><><><>  
 7000 FORMAT(' ERROR - CONDUIT TYPE NOT VALID FOR CONDUIT ID = '  
     A,  I10,' INPUT NKLASS = ',I10)  
 7001 FORMAT(' ERROR - CONDUIT TYPE NOT VALID FOR CONDUIT ID = '  
     A,  A10,' INPUT NKLASS = ',I10)  
CIM END   <><><><><><><><><><><>  
 7022 FORMAT(10X,'JUNCTION VOLUMES ARE COMPUTED USING SUBROUTINE',  
     1' VOLUME')  
 7024 FORMAT(10X,'JUNCTION VOLUMES ARE COMPUTED BY TRACKING TOTAL',  
     1' VOLUMES DURING THE SIMULATION')  
 7360 FORMAT(/,1H1,/,  
     +' *****************************************************',/,  
     +' *           Additional Junction Data                *',/,  
     +' *****************************************************',//,  
     147X,'BASEFLOW  SURCHARGE',/,  
     2' INP  JUNCTION',34X,'FACTOR   ELEVATION',/,  
     3' NUM    NUMBER',12X,'XLOC',11X,'YLOC     SET',7X,A4,/,  
     4' ---    ------   -------------   ------------  --------',  
     5'  --------')  
 7380 FORMAT(I4,1X,I10,2F15.2,I10,F10.2)  
 7381 FORMAT(I4,1X,A10,2F15.2,I10,F10.2)  
 7365 FORMAT(/,1H1,/,  
     +' *****************************************************',/,  
     +' *           Additional Junction Data                *',/,  
     +' *****************************************************',//,  
     147X,'SURCHARGE',/,  
     2' INP  JUNCTION',33X,'ELEVATION',/,  
     3' NUM    NUMBER',12X,'XLOC',11X,'YLOC',5X,A4,/,  
     4' ---    ------   -------------   ------------  --------')  
 7385 FORMAT(I4,1X,I10,2F15.2,F10.2)  
 7386 FORMAT(I4,1X,A10,2F15.2,F10.2)  
 7387 FORMAT(15X,'WARNING : MAXIMUM SURCHARGE ELEVATION IS LESS',  
     1' THAN GROUND ELEVATION.  PROGRAM WILL RESET TO EQUAL GROUND ',  
     2'ELEVATION')  
C  
 8020 FORMAT(/,5x,'INTERMEDIATE HEADER LINES ARE PRINTED AS IN',  
     a' ORIGINAL PROGRAM')  
 8022 FORMAT(/,5x,'INTERMEDIATE HEADER LINES ARE EXCLUDED FROM',  
     a' JUNCTION AND CONDUIT INPUT AND OUTPUT SUMMARY TABLES')  
 8024 FORMAT(/,5x,'IDS ARE WRITTEN AS IN ORIGINAL PROGRAM ')  
 8026 FORMAT(/,5x,'ALL 10 CHARACTERS AND DIGITS IN IDS ARE',  
     a' WRITTEN THROUGHOUT PROGRAM')  
 8184 FORMAT(/,5x,'JELEV = 0 (DEFAULT). STANDARD INPUTS ARE DEPTHS NOT '  
     a,'ELEVATIONS')  
 8185 FORMAT(/,5x,'JELEV = 1, ZP1 AND ZP2 ON CONDUIT DATA INPUT LINES',  
     a' ARE READ AS ELEVATIONS IN PLACE OF DEPTHS')  
 8186 FORMAT(/,5x,'JELEV = 2, FOLLOWING DATA ARE READ AS ELEVATIONS ',  
     A'IN PLACE OF DEPTHS',/,  
     A5x,'    -  ZP1 AND ZP2 ON CONDUIT DATA INPUT LINES',/,  
     B5x,'    -  INITIAL WATER SURFACE ELEVATION (YO) ON D1 LINES')  
 8187 FORMAT(/,5x,'JELEV = 3, FOLLOWING DATA ARE READ AS ',  
     A'ELEVATIONS IN PLACE OF DEPTHS',/,  
     A5x,'    -  ZP1 AND ZP2 ON CONDUIT DATA INPUT LINES',/,  
     B5x,'    -  INITIAL WATER SURFACE ELEVATION (YO) ON D1 LINES',/,  
     c5x,'    -  SURFACE AREA / ELEVATION DATA ON E2 LINES')  
 8188 FORMAT(/,5x,'JELEV = 4, DEPTHS ARE READ IN PLACE OF ELEVATIONS ',  
     a'THROUGHOUT PROGRAM INPUT.',/,  
     a5x,'THESE ARE CONVERTED TO DEPTHS IN THE PROGRAM.')  
 8200 FORMAT(' ===> ERROR  THE GROUND ELEVATION OF JUNCTION ',I10,  
     *           ' LIES ABOVE THE JUNCTION INVERT ELEVATION.')  
 8201 FORMAT(' ===> ERROR  THE GROUND ELEVATION OF JUNCTION ',A10,  
     *           ' LIES ABOVE THE JUNCTION INVERT ELEVATION.')  
 8887 FORMAT(/,' ERROR   READING OR WRITING NATURAL CHANNEL',  
     +         ' INFORMATION ON NSCRAT(4).')  
 8999 FORMAT(/,' ERROR   THE NATURAL CHANNEL INFORMATION WAS',  
     +         ' NOT PRESENT ON THE NSCRAT(4) FILE.')  
 9010 FORMAT(/,  
     +' ************************************************************',/,  
     +' *               Flap Gate Conduit Information              *',/,  
     +' *               -----------------------------              *',/,  
     +' * POSITIVE FLAP GATE - FLOW ONLY ALLOWED FROM THE UPSTREAM *',/,  
     +' *                      TO THE DOWNSTREAM JUNCTION          *',/,  
     +' * NEGATIVE FLAP GATE - FLOW ONLY ALLOWED FROM THE          *',/,  
     +' *                      DOWNSTREAM TO THE UPSTREAM JUNCTION *',/,  
     +' ************************************************************',//  
     +,'    Conduit   Type of Flap Gate',/,  
     + '    -------   -----------------')  
 9020 FORMAT(1X,I10,A20)  
 9021 FORMAT(1X,A10,A20)  
 4060 FORMAT(' Flows in conduit will be limited to be greater than '  
     a,'zero.')  
 4061 FORMAT(' Flows in conduit will be limited to be less than '  
     a,'zero.')  
 9030 FORMAT(/)  
 9011 FORMAT(//,5x,'WARNING OF POSSIBLE ERROR',/,  
     a5X,'THE FOLLOWING CLOSED CONDUITS HAD NONZERO DATA ENTERED',  
     a' FOR SPHI AND/OR STHETA',/,  
     a5X,'EXTRAN NOW INTERPRETS THESE DATA AS THE MAXIMUM POSITIVE',  
     a' AND/OR NEGATIVE CONDUIT FLOWS AND WILL LIMIT FLOWS IN THESE',  
     a' CONDUITS ACCORDINGLY',/,  
     A5X,'PLEASE MAKE SURE THAT THESE WERE NOT ENTERED BY MISTAKE',//,  
     a5X'MAXIMUM POSITIVE OR NEGATIVE FLOWS IN THE FOLLOWING CONDUITS'  
     b,/,5X,  
     c'WILL BE LIMITED AS SPECIFIED BY SPHI AND STHETA ON C1 LINES'  
     d,//,5X,  
     e'   CONDUIT   FLOW LIMIT',/,1X,  
     f'----------   --------------------')  
 4064 FORMAT(5X,I10,  
     a' Flows will be limited to be less than ',F10.3)  
 4065 FORMAT(5X,I10,  
     a' Flows will be limited to be greater than',F10.3)  
 4074 FORMAT(5X,A10,  
     a' Flows will be limited to be less than ',F10.3)  
 4075 FORMAT(5X,A10,  
     a' Flows will be limited to be greater than',F10.3)  
 4062 FORMAT(11X,' WARNING - Entering negative SPHI to limit flow ',  
     a'may produce unexpected results')  
 4063 FORMAT(11X,' WARNING - Entering positive STHETA to limit flow ',  
     a'may produce unexpected results')  
 9050 FORMAT(/,  
     +       ' With steady-state dry-weather flow computations',/  
     +       '   Maximum steady-state outflow             =', F10.3,  
     +       ' cfs',/,  
     +       '   Maximum steady-state flow imbalance      =', F10.3/  
     +       '   Maximum change in flow at any location   =', F10.3,  
     +       ' cfs',/)  
 9051 FORMAT(/,  
     +       ' With steady-state dry-weather flow computations',/  
     +       '   Maximum steady-state outflow             =', F10.3,  
     +       ' cms',/,  
     +       '   Maximum steady-state flow imbalance      =', F10.3/  
     +       '   Maximum change in flow at any location   =', F10.3,  
     +       ' cms',/)  
 9060 FORMAT(' Surcharge Computations Use Preissman Slot Method'/)  
 4070 FORMAT(' ERROR - ELLIPTICAL PIPE SIZE (DEEP) ENTERED FOR ',  
     .'CONDUIT ',I10,' IS NOT VALID')  
 4071 FORMAT(' ERROR - ELLIPTICAL PIPE SIZE (DEEP) ENTERED FOR ',  
     .'CONDUIT ',A10,' IS NOT VALID')  
 4072 FORMAT(' ERROR - ARCH PIPE SIZE (DEEP) ENTERED FOR ',  
     .'CONDUIT ',I10,' IS NOT VALID')  
 4073 FORMAT(' ERROR - ARCH PIPE SIZE (DEEP) ENTERED FOR ',  
     .'CONDUIT ',A10,' IS NOT VALID')  
 5137 FORMAT(' ERROR - Detailed ASCII output was requested using a ',  
     a'negative INTER but JOUT is Zero',/,  
     b'         Please set JOUT to nonzero and assign ',  
     b'file name.')  
 5138 FORMAT(' ERROR -  Detailed ASCII outut file is opened',  
     a' as a scratch file',/,  
     a'          Please use @ line to save ASCII results for',  
     b' unit associated with JOUT = ',I10)  
 5139 FORMAT(/,5x,'INTER was entered as a negative number.',/,  
     a'  Intermediate output is written to JOUT in ASCII format')  
 5186 FORMAT(/,5X,'JDOWN = 0 - Minimum of normal or critical depth will'  
     a,' be used at free outfalls (I1).')  
 5187 FORMAT(/,5X,'JDOWN = 1 - Critical depth will be used at free ',  
     a'outfall conduits.')  
 5188 FORMAT(/,5X,'JDOWN = 2 - Normal depth will be used at free ',  
     a'outfall conduits.')  
 5189 FORMAT(/,5X,' The number of RATE/VRATE pairs will be read on',  
     a' H1 lines as defined by IPRATE on BB line.')  
 5190 FORMAT(/,5X,'Characteristic depth for M2 and S2 water ',  
     a'surface profiles will be computed as in previous versions ',  
     b'of EXTRAN (IM2 = 0).')  
 5191 FORMAT(/,5X,'Characteristic depth for M2 and S2 water ',  
     a'surface profiles computed using tabular correction ',  
     b'(IM2 = 1).')  
 5192 FORMAT(/,5X,'SEDIMENT DEPTHS WILL BE READ FROM C1 LINES',/,  
     a5x,'AREA, DEPTH, AND ZP ON CONDUIT DATA PRINTOUT HAVE',  
     b' BEEN ADJUSTED FOR SEDIMENT DEPTH.',/,5X,  
     c'NOTE THAT THIS OPTION HAS BEEN IMPLEMENTED ONLY FOR ',  
     d'CIRCULAR CONDUITS')  
 5193 FORMAT(/,5X,'SEDIMENT DEPTHS WILL NOT BE READ FROM C1 LINES')  
 6666 FORMAT(' Start time for hydraulic output....',F6.1,' hours'/  
     &       ' Time interval for hydraulic output.',F6.1,' seconds'/)  
 7010 FORMAT(/,5X,'CONDUIT LENGTHS ON C1 LINE MUST EQUAL IRREGULAR',  
     a' SECTION LENGTH ENTERED ON THE C3 OR X1 LINES (IWLEN = 0)')  
 7020 FORMAT(/,5X,'PROGRAM USES IRREGULAR SECTION LENGTHS SPECIFIED',  
     a' ON THE C3 OR X1 LINES (IWLEN = 1)')  
 7030 FORMAT(/,5X,'PROGRAM USES IRREGULAR SECTION LENGTHS SPECIFIED',  
     a' ON THE C1 LINES (IWLEN = 2)')  
 8000 FORMAT(/,5X,'ERRORS WERE FOUND WHERE THE GROUND ELEVATION IS',  
     1' LESS THAT THE PIPE CROWN ELEVATION',/,  
     25X,'GROUND ELEVATIONS 0.01 FEET ABOVE MAXIMUM CROWN ELEVATIONS',  
     3' ARE LISTED IN THE FOLLOWING JUNCTION DATA TABLE',/,  
	45X,'CORRECT GROUND ELEVATION AND RUN AGAIN')  
 8005 FORMAT(/,5X,'Intermediate continuity output will not be created')  
 8010 FORMAT(/,5X,'Intermediate continuity output will be created',  
     a' every ',I5,' time steps.')  
C check for NCHN 9/1999  C. Moore  
 8040 FORMAT(/,5X,'ERROR - TOO MANY CONDUITS ENTERING JUNCTION',I5,' - '  
     a,I10,/,5X,'MAXIMUM ALLOWED CURRENTLY EQUALS ',I5,/,5X,  
     b'EITHER MODIFY NETWORK OR CHANGE NCHN PARAMETER AND',  
     c' RECOMPILE PROGRAM')  
 8045 FORMAT(/,5X,'ERROR - TOO MANY CONDUITS ENTERING JUNCTION',I5,' - '  
     a,I10,/,5X,'MAXIMUM ALLOWED CURRENTLY EQUALS ',I5,/,5X,  
     b'EITHER MODIFY NETWORK OR CHANGE NCHN PARAMETER AND',  
     c' RECOMPILE PROGRAM')  
C check for negative ZP  9/1999 C. Moore  
 8050 FORMAT(/,5X,'ERROR - ZP ENTERED FOR ',A10,' END OF CONDUIT ',I10,  
     a' IS LESS THAN INVERT ELEVATION OF JUNCTION ',I10,  
     b/,13X,'PIPE INVERT =     ',F10.3,/,13X,'JUNCTION INVERT = ',F10.3)  
 8055 FORMAT(/,5X,'ERROR - ZP ENTERED FOR ',A10,' END OF CONDUIT ',A10,  
     a' IS LESS THAN INVERT ELEVATION OF JUNCTION ',A10,  
     b/,13X,'PIPE INVERT =     ',F10.3,/,13X,'JUNCTION INVERT = ',F10.3)  
C ---  
C=======================================================================  
      END  
ECHO is off.
REM File: INDAT2.FOR  
ECHO is off.
      SUBROUTINE INDAT2  
C	EXTRAN BLOCK  
C     CALLED BY EXTRAN NEAR LINE 199  
C=======================================================================  
C     This subroutine reads data groups E1-I2  
C     except for hydrograph lines in 'INFLOW'.  
C     IT ALSO PERFORMS SOME INITIALIZATION.   ALL NODE-CONDUIT LINKAGES  
C     ARE SET UP AND CONVERTED TO THE INTERNAL NUMBER SYSTEM.  
C     Additional error message placed by WCH, 8/28/92.  
C     Add error check for minimum values of stage-area data, and correct  
C       power function volume calculation, WCH, 12/8/94.  
C     Add option for printing of detailed storage junction input data,  
C       WCH, 12/8/94.  
C     Alter E1 data error check to avoid conflict between Sub. ERROR and  
C       variable ERROR, WCH, 1/23/95.  
C     Correct check for weir/pump outfall junctions, allowing these to  
C       be used, RED, 3/12/95.  
C     Above correction also for outfalls with gates WCH (RED), 3/16/95.  
C     Increase allowable number of connecting channels to a junction,  
C       WCH, 8/4/95.  
C     Print-out correction, WCH (CIM), 3/27/00.  
C     Revise Format 8011/8012.  WCH, 2/12/01.  
C     Fix sequencing problem of F2 data.  WCH from RED, 7/22/04.   
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'BD.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'ORF.INC'  
      INCLUDE 'WEIR.INC'  
      INCLUDE 'BND.INC'  
      INCLUDE 'OUT.INC'  
      INCLUDE 'TIDE.INC'  
      INCLUDE 'HYFLOW.INC'  
      INCLUDE 'VOLDAT.INC'  
CIM BE contains JELEV  
      INCLUDE 'BE.INC'  
cim pp 5/1/97  
CIM      DIMENSION ISWTCH(4)  
CIM 4/30/97 Change to make it less painfull to change program dimensions.  
cim change dimensions of ONAME, WNAME,PNAME,OUTF, and OUTG to the parameter  
cim values defined in TAPES.INC  
      CHARACTER JTYPE(3)*10,ONAME(NEO)*8,WNAME(NEW)*8,  
     +            PNAME(NEP)*8,OUTF(NTG)*8,OUTG(NTG)*8,BMJ*10  
      CHARACTER TMPSTR*8  
CIM START OOOOOOOOOOOO  
      LOGICAL CIRCULAR  
      CHARACTER*10 KCNODE  
      DIMENSION DEEPO(NEO),WIDEO(NEO)  
cim   newklass dimensioned for four basic orifice types: circle side,  
cim   circle bottom, rectangle side, rectangle bottom  
      DIMENSION NEWKLASS(4)  
CIM END  OOOOOOOOOOOO  
      DATA JTYPE/'  CONSTANT','  VARIABLE',' POWER FNC'/  
C=======================================================================  
CIM initialize string variables  
CIM This will work as long as NEO, NEP, NEW, and NTG are less than 1000.  
cim  
CIM initialize ONAME with dimension of NEO  
      DO I = 1,NEO  
      IF (I.LT.10) THEN  
      WRITE(TMPSTR,'(I1)') I  
      ONAME(I) = 'ORF   #'//TMPSTR  
      ELSE  
      IF (I.LT.100) THEN  
      WRITE(TMPSTR,'(I2)') I  
      ONAME(I) = 'ORF  #'//TMPSTR  
      ELSE  
      WRITE(TMPSTR,'(I3)') I  
      ONAME(I) = 'ORF #'//TMPSTR  
      ENDIF  
      ENDIF  
      ENDDO  
CIM initialize WNAME with dimension of NEW  
      DO I = 1,NEW  
      IF (I.LT.10) THEN  
      WRITE(TMPSTR,'(I1)') I  
      WNAME(I) = 'WEIR  #'//TMPSTR  
      ELSE  
      IF (I.LT.100) THEN  
      WRITE(TMPSTR,'(I2)') I  
      WNAME(I) = 'WEIR #'//TMPSTR  
      ELSE  
      WRITE(TMPSTR,'(I3)') I  
      WNAME(I) = 'WEIR#'//TMPSTR  
      ENDIF  
      ENDIF  
      ENDDO  
CIM initialize PNAME with dimension of NEP  
      DO I = 1,NEP  
      IF (I.LT.10) THEN  
      WRITE(TMPSTR,'(I1)') I  
      PNAME(I) = 'PUMP  #'//TMPSTR  
      ELSE  
      IF (I.LT.100) THEN  
      WRITE(TMPSTR,'(I2)') I  
      PNAME(I) = 'PUMP #'//TMPSTR  
      ELSE  
      WRITE(TMPSTR,'(I3)') I  
      PNAME(I) = 'PUMP#'//TMPSTR  
      ENDIF  
      ENDIF  
      ENDDO  
CIM initialize OUTF with dimension of NTG  
      DO I = 1,NTG  
      IF (I.LT.10) THEN  
      WRITE(TMPSTR,'(I1)') I  
      OUTF(I) = 'FREE  #'//TMPSTR  
      ELSE  
      IF (I.LT.100) THEN  
      WRITE(TMPSTR,'(I2)') I  
      OUTF(I) = 'FREE #'//TMPSTR  
      ELSE  
      WRITE(TMPSTR,'(I3)') I  
      OUTF(I) = 'FREE#'//TMPSTR  
      ENDIF  
      ENDIF  
      ENDDO  
CIM initialize OUTG with dimension of NTG  
      DO I = 1,NTG  
      IF (I.LT.10) THEN  
      WRITE(TMPSTR,'(I1)') I  
      OUTG(I) = 'GATE  #'//TMPSTR  
      ELSE  
      IF (I.LT.100) THEN  
      WRITE(TMPSTR,'(I2)') I  
      OUTG(I) = 'GATE #'//TMPSTR  
      ELSE  
      WRITE(TMPSTR,'(I3)') I  
      OUTG(I) = 'GATE#'//TMPSTR  
      ENDIF  
      ENDIF  
      ENDDO  
CIM END  
C=======================================================================  
C#### WCH, 12/8/94.  READ STRICTLY OPTIONAL E0 LINE TO CONTROL PRINTING  
C     OF VARIABLE STORAGE JUNCTION INPUT DATA.  
C     NVSPR =  0 - DON'T ECHO DETAILED STORAGE JUNCTION INPUT DATA.  
C     NVSPR NE 0 - PRINT DETAILED DATA.  
C=======================================================================  
      NVSPR = 0  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'E0') READ(N5,*,ERR=888) CC,NVSPR  
C=======================================================================  
C     READ STORAGE JUNCTION DATA ON DATA GROUP E1  
C=======================================================================  
cim move this up to here  
          IF(METRIC.EQ.1) QCOEF = 43560.0  
          IF(METRIC.EQ.2) QCOEF = 10000.0  
cim  
      DO 640 I = 1,NVSE  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'E1') GO TO 645  
C=======================================================================  
C#### WCH, 12/8/94.  PRINT STORAGE JUNCTION HEADER FOR DETAILED PRINT.  
C=======================================================================  
      IF(NVSPR.NE.0) THEN  
           WRITE(N6,2999)  
           WRITE(N6,5060) ALPHA1,ALPHA2  
           WRITE(N6,5397)  
           ENDIF  
C=======================================================================  
      IF(JCE.EQ.0) THEN  
                   READ(N5,*,ERR=888) CC,JSTORE(I),ZTOP(I),  
     +                                ASTORE(I),NUMST  
      ELSE  
                   READ(N5,*,ERR=888) CC,KSTORE(I),ZTOP(I),  
     +                                ASTORE(I),NUMST  
      ENDIF  
C=======================================================================  
C     READ VARIABLE STORAGE JUNCTION DATA  
C#### WCH, 1/23/95.  WRITE OUT ERROR 119 HERE.  DON'T CALL SUB. ERROR.  
C=======================================================================  
      IF(ASTORE(I).LT.0.0.AND.NUMST.GT.0) THEN  
C####          IF(NUMST.GT.NVST) CALL ERROR(119)  
          IF(NUMST.GT.NVST) THEN  
               WRITE(N6,9119)  
               STOP ' PROGRAM STOPPED BEFORE E2 LINE DATA IN EXTRAN'  
               ENDIF  
C  
          NUMV(I) = NUMST  
          READ(N5,*,ERR=888) CC  
C#### WCH, 12/7/94.  IF USING GOTO888, HELPFUL TO SET CC = 'E2'.  
C####          IF(CC.NE.'E2') GO TO 888  
          IF(CC.NE.'E2') THEN  
               CC = 'E2'  
               GO TO 888  
               ENDIF  
C  
          BACKSPACE N5  
          READ(N5,*,ERR=888) CC,(VCURVE(I,1,J),VCURVE(I,2,J),J=1,NUMST)  
CIM If JELEV = 3 or 4 then convert elevation to depth here.  
	    IF (JELEV.GE.3) THEN  
CIM FIND CORRESPONDING JUNCTION  
          IF (JCE.EQ.0) THEN  
          DO JUNCIM = 1, NJ  
           IF(JSTORE(I).EQ.JUN(JUNCIM))  GO TO 498  
	    ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	    ELSE  
	    DO JUNCIM = 1,NJ  
          IF(KSTORE(I).EQ.AJUN(JUNCIM)) GO TO 498  
	    ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	    ENDIF  
  498 CONTINUE  
		DO J = 1 , NUMST  
	    VCURVE(I,2,J) = VCURVE(I,2,J) - Z(JUNCIM)  
	    ENDDO  
	    ENDIF  
CIM  
          DO 252 JES = 2,NUMST  
C#### WCH, 12/8/94.  PRINT JUNCTION ID WITH WARNING.  
          IF(VCURVE(I,2,JES-1).GT.VCURVE(I,2,JES)) THEN  
               IF(JCE.EQ.0) THEN  
                  WRITE(N6,998) JSTORE(I),  
     1                    VCURVE(I,2,JES-1),VCURVE(I,2,JES)  
               ELSE  
                  WRITE(N6,999) KSTORE(I),  
     1                    VCURVE(I,2,JES-1),VCURVE(I,2,JES)  
               ENDIF  
          ENDIF  
 252      CONTINUE  
C=======================================================================  
C#### WCH, 12/8/94.  CHECK TO BE SURE MIN. DEPTH = 0 AND MIN. AREA > 0.  
C=======================================================================  
          IF(VCURVE(I,2,1).GT.0.0.OR.VCURVE(I,1,1).LE.0.0) THEN  
               IF(JCE.EQ.0) THEN  
                 WRITE(N6,990) JSTORE(I)  
               ELSE  
                 WRITE(N6,991) KSTORE(I)  
               ENDIF  
               IF(VCURVE(I,2,1).GT.0.0) THEN  
                    WRITE(N6,992) VCURVE(I,2,1)  
                    VCURVE(I,2,1) = 0.0  
                    ENDIF  
               IF(VCURVE(I,1,1).LE.0.0) THEN  
                    WRITE(N6,993) VCURVE(I,1,1)  
cim this correction to avoid mixing units  
cim amen is in square feet  
cim area read in as acres or hectares and coverted below.  Should still be acres or hectares here.  
                    VCURVE(I,1,1) = AMEN/QCOEF  
cim  
                    ENDIF  
               ENDIF  
C=======================================================================  
C         INTEGRATE VOLUME CURVE FROM AREA/STAGE DATA  
C=======================================================================  
          VCURVE(I,3,1)         = 0.0  
cim          IF(METRIC.EQ.1) QCOEF = 43560.0  
cim          IF(METRIC.EQ.2) QCOEF = 10000.0  
          VCURVE(I,1,1) = VCURVE(I,1,1)*QCOEF  
          DO 251      J = 2,NUMST  
          VCURVE(I,1,J) = VCURVE(I,1,J)*QCOEF  
  251     VCURVE(I,3,J) = VCURVE(I,3,J-1)+  
     +                    (VCURVE(I,2,J)-VCURVE(I,2,J-1))*  
     +                    (VCURVE(I,1,J)+VCURVE(I,1,J-1))/2.0  
C=======================================================================  
C#### WCH, 12/8/94.  OPTIONAL PRINT-OUT OF VARIABLE AREA DATA.  
C=======================================================================  
          IF(NVSPR.NE.0) THEN  
               IF(JCE.EQ.0) THEN  
                 WRITE(N6,890) JSTORE(I)  
               ELSE  
                 WRITE(N6,891) KSTORE(I)  
               ENDIF  
               IF(METRIC.EQ.1) WRITE(N6,892)  
               IF(METRIC.EQ.2) WRITE(N6,893)  
               WRITE(N6,894) (K,VCURVE(I,2,K),VCURVE(I,1,K)/QCOEF,  
     1                   VCURVE(I,3,K)/1000.0,K=1,NUMST)  
               ENDIF  
C=======================================================================  
          ENDIF  
C=======================================================================  
C     READ VARIABLE STORAGE JUNCTION DATA DEFINED AS A POWER FUNCTION  
C     VCURVE(I,1,1) = COEFFICIENT  
C     VCURVE(I,2,1) = POWER  
C=======================================================================  
      IF(NUMST.LT.0) THEN  
                      NUMV(I)   =   NUMST  
                      ASTORE(I) = -1234.0  
                      READ(N5,*,ERR=888) CC  
                      IF(CC.NE.'E2') GO TO 888  
                      BACKSPACE N5  
                      READ(N5,*,ERR=888) CC,VCURVE(I,1,1),VCURVE(I,2,1)  
C=======================================================================  
C#### WCH, 12/8/94.  OPTIONAL PRINT-OUT OF INPUT DATA.  
C=======================================================================  
                      IF(NVSPR.NE.0) THEN  
                           IF(JCE.EQ.0) THEN  
                             WRITE(N6,895) JSTORE(I),  
     1                       VCURVE(I,1,1),VCURVE(I,2,1)  
                           ELSE  
                             WRITE(N6,896) KSTORE(I),  
     1                       VCURVE(I,1,1),VCURVE(I,2,1)  
                           ENDIF  
                      ENDIF  
C  
                      ENDIF  
  640 CONTINUE  
  645 NSTORE = I-1  
C=======================================================================  
C     WRITE THE PAGE TITLES  
C=======================================================================  
      IF(NSTORE.GT.0) THEN  
                      WRITE(N6,2999)  
                      WRITE(N6,5060) ALPHA1,ALPHA2  
                      WRITE(N6,5398)  
      IF(METRIC.EQ.1) WRITE(N6,5495)  
      IF(METRIC.EQ.2) WRITE(N6,5496)  
C=======================================================================  
C     CONVERT TO INTERNAL NUMBER SYSTEM  
C=======================================================================  
      DO 646 I = 1,NSTORE  
      DO 648 J = 1,NJ  
      IF(JCE.EQ.0.AND.JSTORE(I).EQ.JUN(J))  GO TO 650  
      IF(JCE.EQ.1.AND.KSTORE(I).EQ.AJUN(J)) GO TO 650  
  648 CONTINUE  
      IF(JCE.EQ.0) THEN  
       WRITE(N6,5494) JSTORE(I)  
      ELSE  
       WRITE(N6,5484) KSTORE(I)  
      ENDIF  
      NSTOP     = NSTOP + 1  
  650 JSTORE(I) = J  
      JSKIP(J)  = 0  
cim  zcrown is used to define when things go into surcharge  
cim  I don't think that it is ever used to reduce surface area  
cim  for constant surface area storage nodes.  ZCROWN is set  
cim  to the crown elevation of the highest pipe in INDAT1.  If  
cim  ZTOP is less than ZCROWN defined previously, don't let it  
cim  reduce it below the highest pipe to avoid going to surcharge  
cim  calculations too soon.  
cim      ZCROWN(J) = ZTOP(I)  
      IF (ZTOP(I).GE.ZCROWN(J)) THEN  
         ZCROWN(J) = ZTOP(I)  
      ELSE  
         IF(JCE.EQ.0) THEN  
            WRITE(N6,8005) JSTORE(I),ZTOP(I),ZCROWN(J)  
            ELSE  
            WRITE(N6,8006) KSTORE(I),ZTOP(I),ZCROWN(J)  
            ENDIF  
         ZTOP(I) = ZCROWN(J)  
      ENDIF  
      JJ        = NUMV(I)  
      IF(ZCROWN(J).GT.GRELEV(J)) THEN  
	   WRITE(N6,7005)  
	       GRELEV(J) = ZCROWN(J) + 0.1  
	IF (GRELEV(J).GT.SURELEV(J)) THEN  
	   WRITE(N6,7010)  
	       SURELEV(J) = GRELEV(J)  
	ENDIF  
	ENDIF  
      IF(ASTORE(I).GT.0) THEN  
                         CF  = ASTORE(I)*(ZTOP(I)-Z(J))  
                         AF  = ASTORE(I)  
                         JJJ = 1  
                         ENDIF  
      IF(ASTORE(I).LT.0.AND.JJ.GT.0) THEN  
                                     CF  = VCURVE(I,3,JJ)  
                                     AF  = VCURVE(I,1,JJ)  
                                     JJJ = 2  
                                     ENDIF  
      IF(ASTORE(I).LT.0.AND.JJ.LT.0) THEN  
                                     AF  = VCURVE(I,1,1) *  
     +                                (ZTOP(I)-Z(J))**VCURVE(I,2,1)  
C#### WCH, 12/8/94.  MUST >>INTEGRATE<< POWER FUNCTION TO GET VOLUME  
C     ALSO, USE MINIMUM AREA = AMEN.  
C####                                     CF  = AF*(ZTOP(I) - Z(J))  
                                     CF = AMEN*(ZTOP(I)-Z(J))  
                                     CF = CF + VCURVE(I,1,1) *  
     +             (ZTOP(I)-Z(J))**(VCURVE(I,2,1)+1)/(VCURVE(I,2,1)+1)  
                                     JJJ = 3  
                                     ENDIF  
      LSTORE  = JSTORE(I)  
      IF(JCE.EQ.0) THEN  
       WRITE(N6,5399)  JUN(LSTORE),JTYPE(JJJ),AF,CF,ZTOP(I)  
      ELSE  
       WRITE(N6,5499) AJUN(LSTORE),JTYPE(JJJ),AF,CF,ZTOP(I)  
      ENDIF  
  646 CONTINUE  
      NTL = NTL + NSTORE  
      ENDIF  
C=======================================================================  
C     INITIALIZE NTC AND NTL  
C=======================================================================  
      NTC  = NC  
      NTL  = NC  
      NVOR = 0  
CIM START   OOOOOOOOOO  
      NOGATES = 0  
CIM END  OOOOOOOOOOO  
C=======================================================================  
C     Read orifice data on data group F1.  
C=======================================================================  
cim start  <><><><><><><><><><>  
C     NKLASS(N) = 1, NEWKLASS(1) = 51 - SIDE OUTLET CIRCULAR ORIFICE  
C     NKLASS(N) = 2, NEWKLASS(2) = 52 - BOTTOM OUTLET (SUMP) CIRCULAR ORIFICE  
CIM START OOOOOOOOO  
CIM   NKLASS(N) = 3, NEWKLASS(3) = 53 - SIDE OUTLET RECTANGULAR ORIFICE  
CIM   NKLASS(N) = 4, NEWKLASS(4) = 54 - BOTTOM OUTLET (SUMP) RECTANGULAR ORIFICE  
CIM  END  OOOOOOOO  
      NEWKLASS(1) = 51  
      NEWKLASS(2) = 52  
CIM START  OOOOOOOOO  
      NEWKLASS(3) = 53  
      NEWKLASS(4) = 54  
CIM END  OOOOOOOOO  
cim end      <><><><><><><><>  
C=======================================================================  
C=======================================================================  
      DO 690 I = 1,NEO  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'F1') GO TO 695  
      N = NTC+I  
      IF(JCE.EQ.0) THEN  
          READ(N5,*,ERR=888) CC,(NJUNC(N,K),K=1,2),  
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N)  
          ELSE  
          READ(N5,*,ERR=888) CC,(KJUNC(N,K),K=1,2),  
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N)  
          ENDIF  
CIM START  OOOOOOOOO  
C  MODIFICATION TO READ DEEPO AND WIDEO FOR RECTANGULAR ORIFICE  
      CIRCULAR = .TRUE.  
      IF ((NKLASS(N).EQ.3) .OR.  
     .   (NKLASS(N).EQ.4) .OR.  
     .   (NKLASS(N).EQ.-3) .OR.  
     .   (NKLASS(N).EQ.-4) .OR.  
     .   (NKLASS(N).EQ.13) .OR.  
     .   (NKLASS(N).EQ.14) .OR.  
     .   (NKLASS(N).EQ.23) .OR.  
     .   (NKLASS(N).EQ.24)) THEN  
            CIRCULAR = .FALSE.  
            BACKSPACE N5  
            IF(JCE.EQ.0) THEN  
                   READ(N5,*,ERR=888) CC,(NJUNC(N,K),K=1,2),  
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N),  
     A                       DEEPO(I),WIDEO(I)  
                  ELSE  
                   READ(N5,*,ERR=888) CC,(KJUNC(N,K),K=1,2),  
     +                       NKLASS(N),AORIF(I),CORIF(I),ZU(N),  
     A                       DEEPO(I),WIDEO(I)  
                  ENDIF  
	      IF (AORIF(I).EQ.0.0) AORIF(I) = DEEPO(I)*WIDEO(I)  
            ENDIF  
CIM change this next one to key on CORIF  
CIM   IF CORIF < 0 then gate closes from the bottom meaning that the  
CIM   ZU and ZP change as gate opening changes.  
      IF (CORIF(I).LT.0.0) then  
           CORIF(I) = - CORIF(I)  
           IOINV(I) = 1  
           ELSE  
           IOINV(I) = 0  
           ENDIF  
CIM END  OOOOOOOOOO  
CIM CHANGE FOR JELEV = 4.  ZU is elevation not depth  
	IF (JELEV.EQ.4) THEN  
CIM FIND UPSTREAM OR FROM JUNCTION INVERT ELEVATION  
           IF (JCE.EQ.0) THEN  
                DO JUNCIM = 1, NJ  
                 IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 678  
	          ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	          ELSE  
	          DO JUNCIM = 1,NJ  
                IF(KJUNC(N,1).EQ.AJUN(JUNCIM)) GO TO 678  
	          ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	          ENDIF  
  678      CONTINUE  
	     ZU(N) = ZU(N) - Z(JUNCIM)  
	     ENDIF  
CIM INSERT CHECK FOR NEGATIVE ZU  
	IF (ZU(N).LT.0.0) THEN  
	     WRITE(N6,5442) I  
	     NSTOP = NSTOP + 1  
	     ENDIF  
C=======================================================================  
C     READ F2 DATA GROUP FOR ORIFICES WITH A TIME HISTORY  
C=======================================================================  
      IF(NKLASS(N).LT.0) THEN  
                         NVOR      = NVOR + 1  
                         NKLASS(N) = IABS(NKLASS(N))  
                         READ(N5,*,ERR=888) CC,NTIME,(VORIF(NVOR,J,1),  
     +                     VORIF(NVOR,J,2),VORIF(NVOR,J,3),J=1,NTIME)  
cred                     need place holder for the F2 line orifices  
cred                     otherwise they have to be at the top of the  
cred                     order of orifices - 4/15/2002  
Cwch, 7/22/04.  These variables show up again in INFLOW.   
	                   f2_line(nvor)  = i  
	                   f2_limit(nvor) = ntime                  
					   ENDIF  
CIM START  OOOOOOOO  
CIM=======================================================================  
CIM      READ F3 DATA GROUP FOR ORIFICES WITH TIMED CLOSURE GATE CONTROL  
CIM=======================================================================  
      IF((NKLASS(N).GT.10).AND.NKLASS(N).LT.20) THEN  
           NOGATES=NOGATES+1  
           NKLASS(N) = NKLASS(N)-10  
           IF(JCE.EQ.0) THEN  
                READ(N5,*,ERR=888) CC,ICNODE(I),OOPEN(I),OCLOSE(I),  
     .                                OCAREA(I),ORATE(I),IDIR(I),  
     .                                IOPRNT(I)  
                ELSE  
                READ(N5,*,ERR=888) CC,KCNODE,OOPEN(I),OCLOSE(I),  
     .                                OCAREA(I),ORATE(I),IDIR(I),  
     .                                IOPRNT(I)  
                ENDIF  
CIM   IF JELEV IS 4 THEN CONVERT OOPEN AND OCLOSE FROM ELEVATIONS TO DEPTHS HERE  
           IF (JELEV.EQ.4) THEN  
CIM FIND CONTROL JUNCTION INVERT ELEVATION  
                IF (JCE.EQ.0) THEN  
                     DO JUNCIM = 1, NJ  
                      IF(ICNODE(I).EQ.JUN(JUNCIM))  GO TO 679  
	               ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	               ELSE  
	               DO JUNCIM = 1,NJ  
                      IF(KCNODE.EQ.AJUN(JUNCIM)) GO TO 679  
	               ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	               ENDIF  
  679           CONTINUE  
	          OOPEN(I) = OOPEN(I) - Z(JUNCIM)  
	          OCLOSE(I) = OCLOSE(I) - Z(JUNCIM)  
	          ENDIF  
CIM ADD A CHECK FOR NEGATIVE OOPEN AND OOCLOSE  
	     IF ((OOPEN(I).LT.0.0) .OR. (OCLOSE(I).LT.0.0)) THEN  
	          WRITE(N6,5443) I  
	          NSTOP = NSTOP + 1  
	          ENDIF  
CIM  ECHO PRINT OF TIMED CLOSURE GATED CONTROL HERE  
           IF(JCE.EQ.0) THEN  
                WRITE(N6,660) I,ICNODE(I),OOPEN(I),OCLOSE(I),  
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I)  
                ELSE  
                WRITE(N6,661) I,KCNODE,OOPEN(I),OCLOSE(I),  
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I)  
                ENDIF  
           DO 680 J = 1,NJ  
           IF(JCE.EQ.0.AND.ICNODE(I).EQ.JUN(J))  GO TO 681  
           IF(JCE.EQ.1.AND.KCNODE.EQ.AJUN(J)) GO TO 681  
  680      CONTINUE  
           IF(JCE.EQ.0) THEN  
                WRITE(N6,5445) ICNODE(I)  
                ELSE  
                WRITE(N6,5446) KCNODE  
                ENDIF  
           NSTOP      = NSTOP+1  
CIM   NOTE THAT TIMED CLOSURE GATED CONTROL ORIFICES HAVE NEGATIVE ICNODE  
  681      ICNODE(I) = -J  
           END IF  
CIM=======================================================================  
CIM      READ F4 DATA GROUP FOR ORIFICES WITH HEAD DEPENDENT GATE CONTROL  
CIM=======================================================================  
      IF (NKLASS(N).GT.20) THEN  
           NOGATES=NOGATES+1  
           NKLASS(N) = NKLASS(N)-20  
           IF(JCE.EQ.0) THEN  
                 READ(N5,*,ERR=888) CC,ICNODE(I),OOPEN(I),OCLOSE(I),  
     .                                OCAREA(I),ORATE(I),IDIR(I),  
     .                                IOPRNT(I)  
                 ELSE  
                 READ(N5,*,ERR=888) CC,KCNODE,OOPEN(I),OCLOSE(I),  
     .                                OCAREA(I),ORATE(I),IDIR(I),  
     .                                IOPRNT(I)  
                 ENDIF  
CIM   IF JELEV IS 4 THEN CONVERT OOPEN AND OCLOSE FROM ELEVATIONS TO DEPTHS HERE  
           IF (JELEV.EQ.4) THEN  
CIM FIND CONTROL JUNCTION INVERT ELEVATION  
                IF (JCE.EQ.0) THEN  
                     DO JUNCIM = 1, NJ  
                      IF(ICNODE(I).EQ.JUN(JUNCIM))  GO TO 684  
	               ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	               ELSE  
	               DO JUNCIM = 1,NJ  
                      IF(KCNODE.EQ.AJUN(JUNCIM)) GO TO 684  
	               ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	               ENDIF  
  684           CONTINUE  
	          OOPEN(I) = OOPEN(I) - Z(JUNCIM)  
	          OCLOSE(I) = OCLOSE(I) - Z(JUNCIM)  
	          ENDIF  
CIM ADD A CHECK FOR NEGATIVE OOPEN AND OOCLOSE  
	     IF ((OOPEN(I).LT.0.0) .OR. (OCLOSE(I).LT.0.0)) THEN  
	          WRITE(N6,5443) I  
	          NSTOP = NSTOP + 1  
	          ENDIF  
           IF(OOPEN(I).EQ.OCLOSE(I)) THEN  
      WRITE(N5,*) ' ERROR - OPEN AND CLOSE DEPTHS CAN NOT BE EQUAL ',  
     .'FOR HEAD DEPENDENT GATES (F4 CARD)'  
                NSTOP = NSTOP + 1  
                END IF  
CIM ECHO PRINT OF INPUT DATA FOR HEAD DEPENDENT GATED CONTROL HERE  
           IF(JCE.EQ.0) THEN  
                 WRITE(N6,662) I,ICNODE(I),OOPEN(I),OCLOSE(I),  
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I)  
                 ELSE  
                 WRITE(N6,663) I,KCNODE,OOPEN(I),OCLOSE(I),  
     .                           OCAREA(I),ORATE(I),IDIR(I),IOPRNT(I)  
                 ENDIF  
           DO 685 J = 1,NJ  
           IF(JCE.EQ.0.AND.ICNODE(I).EQ.JUN(J))  GO TO 686  
           IF(JCE.EQ.1.AND.KCNODE.EQ.AJUN(J)) GO TO 686  
  685      CONTINUE  
           IF(JCE.EQ.0) THEN  
                WRITE(N6,5445) ICNODE(I)  
                ELSE  
                WRITE(N6,5446) KCNODE  
                ENDIF  
           NSTOP      = NSTOP+1  
  686      ICNODE(I) = J  
           END IF  
      IF (OCAREA(I).LT.0.00001) OCAREA(I)=0.00001  
      IF (AORIF(I).LT.0.00001)  AORIF(I) =0.00001  
CIM CONVERT RATE TO DELTA AREA PER UNIT TIME (SQ.FT./SECOND)  
      IF (ORATE(I).GT.0.0) THEN  
          ORATE(I)=ABS(AORIF(I)-OCAREA(I))/(ORATE(I)*60.0*60.0)  
          ELSE  
          ORATE(I)=999999999.99  
          ENDIF  
CIM   CHANGE IDIR TO MATCH DEFINITION OF INGATE  
      IF (IDIR(I).EQ.0) ITEMP=0  
      IF (IDIR(I).LT.0) ITEMP=2  
      IF (IDIR(I).GT.0) ITEMP=1  
      IDIR(I)=ITEMP  
CIM END      OOOOOOOOOO  
  690 CONTINUE  
  695 NORIF = I-1  
CIM START     OOOOOOOOO  
CIM   OPEN FILE FOR TEST PRINTOUT  
cim      IF (NOGATES.GT.0) OPEN(UNIT=7,FILE='TEST.OUT',STATUS='UNKNOWN')  
CIM END  OOOOOOOOOOOO  
      NTC   = NTC + NORIF  
      NTL   = NTL + NORIF  
      IF(NORIF.GT.0) THEN  
           IF(METRIC.EQ.1) WRITE(N6,5420)  
           IF(METRIC.EQ.2) WRITE(N6,5421)  
           DO 780 I = 1,NORIF  
           N        = NTC - NORIF + I  
CIM START  OOOOOOOOOO  
           CIRCULAR = ((NKLASS(N).EQ.1) .OR.  
     .   (NKLASS(N).EQ.2) .OR.  
     .   (NKLASS(N).EQ.-1) .OR.  
     .   (NKLASS(N).EQ.-2) .OR.  
     .   (NKLASS(N).EQ.11) .OR.  
     .   (NKLASS(N).EQ.12) .OR.  
     .   (NKLASS(N).EQ.21) .OR.  
     .   (NKLASS(N).EQ.22))  
           IF (CIRCULAR) then  
                IF(JCE.EQ.0) THEN  
                   WRITE(N6,5440) (NJUNC(N,K),K=1,2),NKLASS(N),  
     +                             AORIF(I),CORIF(I),ZU(N)  
                   ELSE  
                   WRITE(N6,5441) (KJUNC(N,K),K=1,2),NKLASS(N),  
     +                             AORIF(I),CORIF(I),ZU(N)  
                   ENDIF  
           ELSE  
           AORIF(I) = WIDEO(I)*DEEPO(I)  
           IF(JCE.EQ.0) THEN  
                WRITE(N6,5440) (NJUNC(N,K),K=1,2),NKLASS(N),  
     +                             AORIF(I),CORIF(I),ZU(N),  
     A                             DEEPO(I),WIDEO(I)  
                ELSE  
                WRITE(N6,5441) (KJUNC(N,K),K=1,2),NKLASS(N),  
     +                             AORIF(I),CORIF(I),ZU(N),  
     A                             DEEPO(I),WIDEO(I)  
                ENDIF  
           ENDIF  
CIM END  OOOOOOOOOOOO  
C=======================================================================  
C     Convert to internal number system.  
C=======================================================================  
      LORIF(I) = N  
      NCOND(N) = N + 90000  
      IF(JCE.EQ.1) ACOND(N) = ONAME(I)  
CIM START  OOOOOOOOOO  
      IF (CIRCULAR) THEN  
           DEEP(N)  = SQRT(4.0*AORIF(I)/3.14159)  
           WIDE(N)  = DEEP(N)  
           AFULL(N) = AORIF(I)  
           RFULL(N) = DEEP(N)/4.0  
           ELSE  
           DEEP(N)  = DEEPO(I)  
           WIDE(N)  = WIDEO(I)  
           AFULL(N) = AORIF(I)  
           RFULL(N) = AFULL(N)/(2.0*DEEPO(I)+2.0*WIDEO(I))  
           ENDIF  
CIM END      OOOOOOOOOOO  
      DDD = DELT  
C BAC START   
C NOTE CHANGE IN DEFINITION OF NEQUAL  
C      IF(NEQUAL.GT.1) DDD = FLOAT(NEQUAL)  
C BAC END    
      CLEN     = 2.0*DDD*SQRT(GRVT*DEEP(N))  
      LEN(N)   = AMAX1(200.,CLEN)  
      CMANN    = CMET(9,METRIC)  
      ROUGH(N) = CMANN*RFULL(N)**.66667/(CORIF(I)*SQRT(LEN(N)*2.0*GRVT))  
CIM START  <><><><><>  
cim            Revise nklass to internal number here  FIRST CHECK FOR VALID  
CIM            RANGE  
      IF (NKLASS(N).LT.1.OR.NKLASS(N).GT.4) THEN  
           IF(JCE.EQ.0) THEN  
                WRITE(N6,7000) (NJUNC(N,K),K=1,2),NKLASS(N)  
                ELSE  
                WRITE(N6,7001) (KJUNC(N,K),K=1,2),NKLASS(N)  
                ENDIF  
           STOP 'ORIFICE TYPE NOT VALID'  
           END IF  
      NKLASS(N)= NEWKLASS(NKLASS(N))  
CIM END <><><><><><>  
CIM START OOOOOOOO  
CIM    BOTTOM OUTLET CONVERSION  
      IF((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) THEN  
           ZU(N) = -0.96*DEEP(N)  
CIM     INVERT ELEVATIONS FOR BOTTOM OUTLET WON'T CHANGE  
           IOINV(I) = 0  
           ENDIF  
CIM END     OOOOOOOOO  
      DO 770 K = 1,2  
      DO 700 J = 1,NJ  
      IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J))  GO TO 720  
      IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J)) GO TO 720  
  700 CONTINUE  
      IF(JCE.EQ.0) THEN  
           WRITE(N6,5450) NJUNC(N,K)  
           ELSE  
           WRITE(N6,5451) KJUNC(N,K)  
           ENDIF  
      NSTOP      = NSTOP+1  
  720 NJUNC(N,K) = J  
      IF(JSKIP(J).EQ.1) THEN  
                        JSKIP(J)   = 0  
                        IF(ZCROWN(J).LT.DEEP(N)) ZCROWN(J) = DEEP(N)  
                        ENDIF  
C=======================================================================  
C     SET ZU(N) FOR BOTTOM OUTLET  
C     SET ZU(N) AND ZD(N) ELEVATIONS  
C     LOWER Z(J) AT UPSTREAM END BY -0.96*DEEP(N)  
C=======================================================================  
      IF(K.EQ.1) THEN  
                 ZU(N) = ZU(N) + Z(J)  
                 ZD(N) = ZU(N) - 0.01/CMET(1,METRIC)  
CIM START  OOOOOOO  
CIM       BOTTOM OUTLET CONVERSION  
                 IF((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) THEN  
CIM END          OOOOOOOO  
                              IF(Y(J).GT.0.0) Y(J) = Y(J) + 0.96*DEEP(N)  
                              Z(J) = ZU(N)  
                         IF(JCE.EQ.0) THEN  
                          WRITE(N6,8011)  JUN(J),Z(J)  
                         ELSE  
                          WRITE(N6,8012) AJUN(J),Z(J)  
                         ENDIF  
                              ENDIF  
                 ENDIF  
C=======================================================================  
C     CHECK GROUND ELEVATION  
C=======================================================================  
      IF(ZU(N)+DEEP(N).GE.GRELEV(J)) THEN  
                                     IF(JCE.EQ.0) THEN  
                                      WRITE(N6,5455) JUN(J)  
                                     ELSE  
                                      WRITE(N6,5456)AJUN(J)  
                                     ENDIF  
                                     NSTOP = NSTOP+1  
                                     ENDIF  
      IF(ZD(N)+DEEP(N).GE.GRELEV(J)) THEN  
                                     IF(JCE.EQ.0) THEN  
                                      WRITE(N6,5455) JUN(J)  
                                     ELSE  
                                      WRITE(N6,5456)AJUN(J)  
                                     ENDIF  
                                     NSTOP = NSTOP+1  
                                     ENDIF  
  730 CONTINUE  
C#### WCH, 8/4/95.  INCREASE NUMBER OF CONNECTING CHANNELS.  
      DO 740 KK = 1,NCHN  
      IF(NCHAN(J,KK)) 760,760,740  
  740 CONTINUE  
      IF (NCHAN(J,KK).NE.0) THEN  
                     IF (JCE.EQ.0) THEN  
                       WRITE(n6,8330) JUN(J)  
                       ELSE  
                       WRITE(n6,8331) AJUN(J)  
                       ENDIF  
                     NSTOP = NSTOP + 1  
      ENDIF  
  760 NCHAN(J,KK) = N  
  770 CONTINUE  
C=======================================================================  
C     CHECK GRAVITY FLOW DIRECTION  
C=======================================================================  
      IF(ZU(N).LT.ZD(N)) THEN  
                         J2    = NJUNC(N,2)  
                         IF(JCE.EQ.0) THEN  
                          WRITE(N6,5458)  JUN(J2)  
                         ELSE  
                          WRITE(N6,5459) AJUN(J2)  
                         ENDIF  
                         NSTOP = NSTOP+1  
                         ENDIF  
  780 CONTINUE  
      DO 790 I = 1,NORIF  
      N        = LORIF(I)  
CIM START OOOOOO  
      CIRCULAR = ((NKLASS(N).EQ.51).OR.(NKLASS(N).EQ.52))  
      IF (CIRCULAR) THEN  
      IF(JCE.EQ.0) THEN  
        WRITE(N6,6010) I,NCOND(N),DEEP(N),LEN(N),  
     +                            ROUGH(N),ZU(N),ZD(N)  
      ELSE  
        WRITE(N6,6011) I,ACOND(N),DEEP(N),LEN(N),  
     +                            ROUGH(N),ZU(N),ZD(N)  
      ENDIF  
      ELSE  
      IF(JCE.EQ.0) THEN  
        WRITE(N6,6012) I,NCOND(N),DEEP(N),WIDE(N),LEN(N),  
     +                            ROUGH(N),ZU(N),ZD(N)  
      ELSE  
        WRITE(N6,6013) I,ACOND(N),DEEP(N),WIDE(N),LEN(N),  
     +                            ROUGH(N),ZU(N),ZD(N)  
      ENDIF  
      END IF  
cim change ioninv(N) to IOINV(I)  
      IF (IOINV(I).EQ.1) WRITE(N6,6014)  
CIM END OOOOOOO  
  790 CONTINUE  
      ENDIF  
C=======================================================================  
C     READ WEIR DATA ON DATA GROUP G1.  
C     THIS ROUTINE HAS BEEN MODIFIED TO TRANSFER WEIR DISCHARGES FROM  
C     NODE TO NODE RATHER THAN FROM NODE TO CONDUIT.  
C=======================================================================  
      DO 820 I = 1,NEW  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'G1') GO TO 840  
      N = NTC+I  
C  BAC START  WWWWWWWWWWWWWWW  
C  READ NEW INPUTS FOR ADDITIONAL WEIR OPTIONS  
CIM  
CIM     KWEIR       : Type of weir.  
CIM                 = 1 Transverse horizontal weir (exponent = 3/2).  
CIM                 = 2 Transverse horizontal weir with tide gate.  
CIM                 = 3 Side flow horizontal weir (exponent = 5/3).  
CIM                 = 4 Side flow horizontal weir with tide gate.  
CIM                 = 5 V-notch or triangular (exponent = 5/2).  
CIM                 = 6 V-notch or triangular with tide gate.  
CIM                 = 7 Trapezoidal (compound exponent)  
CIM                 = 8 Trapezoidal with tide gate.  
C  SINCE THE LINE GROUP AND THE NUMBER OF INPUT FIELDS ON THE LINE  
C  GROUP THAT FOLLOWS THE WEIR LINES VARIES, READS MUST BE MADE IN  
C  TWO PARTS.  
C  IWRPRT IS USED FOR TELLING THE PROGRAM WHICH WRITE STATEMENT TO USE  
C  FOR THE INPUT ECHO OF THE WEIRS.  
      ISUBEQ(I)=0  
      ENDCON(I)=0.0  
      IWRPRT(I)=0  
      COEF2(I)=0.0  
      IF(JCE.EQ.0) THEN  
                   READ(N5,*,ERR=888) CC,(NJUNC(N,K),K=1,2),KWEIR(I),  
     +                             YCREST(I),YTOP(I),WLEN(I),COEF(I),  
     +                             ISUBEQ(I),ENDCON(I),THETAV(I),  
     +                             COEF2(I)  
      ELSE  
                   READ(N5,*,ERR=888) CC,(KJUNC(N,K),K=1,2),KWEIR(I),  
     +                             YCREST(I),YTOP(I),WLEN(I),COEF(I),  
     +                             ISUBEQ(I),ENDCON(I),THETAV(I),  
     +                             COEF2(I)  
      ENDIF  
Cwch, CIM, 3/27/00. SHOULD BE .NE. NOT .EQ.  
      IF(ENDCON(I)+THETAV(I)+COEF2(I).NE.0.0) IWRPRT(I)=1  
CIM   IF JELEV IS 4 THEN CONVERT OOPEN AND OCLOSE FROM ELEVATIONS TO  
C     DEPTHS HERE  
      IF (JELEV.EQ.4) THEN  
CIM FIND UPSTREAM JUNCTION INVERT ELEVATION  
          IF (JCE.EQ.0) THEN  
          DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 819  
	    ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	    ELSE  
	    DO JUNCIM = 1,NJ  
          IF(KJUNC(N,1).EQ.AJUN(JUNCIM)) GO TO 819  
	    ENDDO  
CIM SAVE CHECK FOR NO MATCH FOR LATER  
	    ENDIF  
  819 CONTINUE  
	YCREST(I) = YCREST(I) - Z(JUNCIM)  
	YTOP(I) = YTOP(I) - Z(JUNCIM)  
	ENDIF  
CIM ADD A CHECK FOR NEGATIVE YTOP OR YCREST  
	IF ((YCREST(I).LT.0.0) .OR. (YTOP(I).LT.0.0)) THEN  
	WRITE(N6,5444) I  
	NSTOP = NSTOP + 1  
	ENDIF  
C  BAC END  WWWWWWWWWWW  
  820 CONTINUE  
  840 NWEIR = I-1  
      IF(NWEIR.GT.0) THEN  
                     IF(METRIC.EQ.1) WRITE(N6,5480)  
                     IF(METRIC.EQ.2) WRITE(N6,5481)  
                     DO 1020 I = 1,NWEIR  
                     N1        = NTC+I  
                     LWEIR(I)  = N1  
                     IF(JCE.EQ.0) THEN  
                       NCOND(N1) = 90000 + N1  
                     ELSE  
                       ACOND(N1) = WNAME(I)  
                     ENDIF  
                     COEFS(I)  = 0.0  
C  BAC START  WWWWWWW  
      IF(JCE.EQ.0) THEN  
               IF(IWRPRT(I).EQ.0) THEN  
                                  WRITE(N6,5487)  
     +                            (NJUNC(N1,K),K=1,2),  
     +                            NCOND(N1),KWEIR(I),YCREST(I),  
     +                            YTOP(I),WLEN(I),COEF(I)  
               ELSE  
                                  WRITE(N6,5485)  
     +                            (NJUNC(N1,K),K=1,2),  
     +                            NCOND(N1),KWEIR(I),YCREST(I),  
     +                            YTOP(I),WLEN(I),COEF(I),ISUBEQ(I),  
     +                            ENDCON(I),THETAV(I),COEF2(I)  
               ENDIF  
      ELSE  
               IF(IWRPRT(I).EQ.0) THEN  
                                  WRITE(N6,5488)  
     +                            (KJUNC(N1,K),K=1,2),  
     +                            ACOND(N1),KWEIR(I),YCREST(I),  
     +                            YTOP(I),WLEN(I),COEF(I)  
               ELSE  
                                  WRITE(N6,5486)  
     +                            (KJUNC(N1,K),K=1,2),  
     +                            ACOND(N1),KWEIR(I),YCREST(I),  
     +                            YTOP(I),WLEN(I),COEF(I),ISUBEQ(I),  
     +                            ENDCON(I),THETAV(I),COEF2(I)  
               ENDIF  
      ENDIF  
C  BAC END  WWWWWW  
                     DO 875 K = 1,2  
                     IF(JCE.EQ.0.AND.NJUNC(N1,K).EQ.0)   GO TO 875  
                     IF(JCE.EQ.1.AND.KJUNC(N1,K).EQ.' ') GO TO 875  
                     DO 870 J = 1,NJ  
                     IF(JCE.EQ.0.AND.NJUNC(N1,K).EQ.JUN(J))  GO TO 871  
                     IF(JCE.EQ.1.AND.KJUNC(N1,K).EQ.AJUN(J)) GO TO 871  
  870                CONTINUE  
                     IF(JCE.EQ.0) THEN  
                       WRITE(N6,5490) NJUNC(N1,K)  
                     ELSE  
                       WRITE(N6,5491) KJUNC(N1,K)  
                     ENDIF  
                     NSTOP       = NSTOP+1  
  871                NJUNC(N1,K) = J  
cim   check for downstream node being higher than weir elevation  
                     IF (K.EQ.2) THEN  
                     WELEV = YCREST(I) + Z(NJUNC(N1,1))  
                     IF (Z(NJUNC(N1,2)).GE.WELEV) THEN  
                     IF (JCE.EQ.0) THEN  
                         WRITE(N6,8332) I,JUN(NJUNC(N1,1)),  
     a                   JUN(NJUNC(N1,2)),Z(NJUNC(N1,2)),WELEV  
                     ELSE  
                         WRITE(N6,8333) I,AJUN(NJUNC(N1,1)),  
     a                   AJUN(NJUNC(N1,2)),Z(NJUNC(N1,2)),WELEV  
                     ENDIF  
 8332 FORMAT(' ERROR = Weir Number ',I10,' FROM NODE ',I10,  
     1' TO NODE ',I10,/,  
     2' Invert elevation of downstream node = ',F10.3,  
     3' is greater than elevation of weir crest = ',F10.3,'.',/,  
     4' This can cause erroneous results.  Set downstream node invert',  
     5' elevation to be less than weir crest and adjust ZP on',  
     6' connecting pipes.')  
 8333 FORMAT(' ERROR = Weir Number ',I10,' FROM NODE ',A10,  
     1' TO NODE ',A10,/,  
     2' Invert elevation of downstream node = ',F10.3,  
     3' is greater than elevation of weir crest = ',F10.3,'.',/,  
     4' This can cause erroneous results.  Set downstream node invert',  
     5' elevation to be less than weir crest and adjust ZP on',  
     6' connecting pipes.')  
                     NSTOP = NSTOP + 1  
                     ENDIF  
                     ENDIF  
                     DO 873 KK   = 1,NCHN  
                     IF(NCHAN(J,KK)) 874,874,873  
  873                CONTINUE  
cim write a warning  
                     WRITE(*,*) J,' ',AJUN(J),KK  
                     IF (NCHAN(J,KK).GE.0) THEN  
                     IF (JCE.EQ.0) THEN  
                       WRITE(n6,8330) JUN(J)  
                       ELSE  
                       WRITE(n6,8331) AJUN(J)  
                       ENDIF  
                     NSTOP = NSTOP + 1  
                     ENDIF  
  874                NCHAN(J,KK) = N1  
  875                CONTINUE  
 1020                CONTINUE  
                     NTL = NTL + NWEIR  
                     ENDIF  
C=======================================================================  
C     READ PUMP DATA ON DATA GROUP H1  
C  
C     IPTYP = 1   Off-line pump with wet well (program will  
C                 set pump junction invert to -100).  
C                 Off-line pump operates on wet well volume.  
C                 Note:  Only one pipe can be connected to a  
C                        type 1 pump node.  
C  
C     IPTYP = 2   In-line lift pump.  In-line pump operates on  
C                 head at pumped junction.  
C  
C     IPTYP = 3   Three-point head-discharge pump curve.  Pump  
C                 rate varies linearly based on head difference  
C                 between discharge and pumped junctions.  
C  
C     IPTYP = 4   Variable-speed in line pump.  Pump rate varies  
C                 linearly based on depth in pumped junction.  
C  
C     IPTYP = 5   Constant speed lift station type pump.  Pump rate  
C                 is entered for individual pumps.  Pumps stay on  
C                 until depth drops to POFF level.  When pumps come  
C                 on the rate increases linearly from zero to PRATE  
C                 over PONDELAY seconds.  Implemented by C. Moore of  
C                 CDM  6/99.  
C=======================================================================  
CIM CHANGE TO PRINT IF NUMBER OF PUMPS EXCEED NEP 6/97  
      DO 1060 I = 1,NEP+1  
C  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'H1') GO TO 1080  
C print error message  
      IF(I.GT.NEP) THEN  
      WRITE(N6,8010) NEP  
      STOP 'TOO MANY PUMPS, SEE ERROR MESSAGE IN OUTPUT FILE'  
      ENDIF  
CIM PP 5/1/97 various changes for reading optional NPRATE parameter  
      READ(N5,*,ERR=888) CC,IPTYP(I)  
      NPRATE(I) = 3  
C     INITIALIZE PUMP STATUS TO OFF  
C     USE FOR TYPE 3 and 5  
      DO K=1,MAXPRA  
	IPOPR(K,I) = -1  
	TIMEON(K,I) = 0.0  
	ENDDO  
      BACKSPACE N5  
      N = NTL + I  
      IF (IPRATE.EQ.0) THEN  
       SELECT CASE (IPTYP(I))  
       CASE (1)  
        IF(JCE.EQ.0) THEN  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),VWELL(I)  
        ELSE  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),VWELL(I)  
        ENDIF  
       CASE (2)  
        IF(JCE.EQ.0) THEN  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     1                (VRATE(I,K),K=1,2)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1040  
	    ENDDO  
 1040      DO K = 1,2  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ELSE  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     1                (VRATE(I,K),K=1,2)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1041  
	    ENDDO  
 1041     DO K=1,2  
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	    ENDDO  
	  ENDIF  
        ENDIF  
cim  ADD A CHECK FOR NEGATIVE VRATES  
      IF((VRATE(I,1).LT.0.0).OR.(VRATE(I,2).LT.0.0)) THEN  
	WRITE(N6,5447) I  
	NSTOP = NSTOP + 1  
	ENDIF  
       CASE (3)  
        IF(JCE.EQ.0) THEN  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),VWELL(I),PON(I),POFF(I)  
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1042  
	    ENDDO  
 1042      PON(I) = PON(I) - Z(JUNCIM)  
           POFF(I) = POFF(I) - Z(JUNCIM)  
	  ENDIF  
        ELSE  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),VWELL(I),PON(I),POFF(I)  
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1043  
	    ENDDO  
 1043      PON(I) = PON(I) - Z(JUNCIM)  
           POFF(I) = POFF(I) - Z(JUNCIM)  
	  ENDIF  
        ENDIF  
CIM ADD A CHECK FOR NEGATIVE PON OR POFF  
        IF((PON(I).LT.0.0).OR.(POFF(I).LT.0.0)) THEN  
	   WRITE(N6,5448) I  
			NSTOP = NSTOP + 1  
	  ENDIF  
       CASE (4)  
	PON(I) = 0.0  
	POFF(I) = 0.0  
        IF(JCE.EQ.0) THEN  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),PON(I),POFF(I)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1044  
	    ENDDO  
 1044      DO K = 1,3  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ELSE  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),PON(I),POFF(I)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1045  
	    ENDDO  
 1045     DO K=1,3  
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	    ENDDO  
	  ENDIF  
        ENDIF  
cim  ADD A CHECK FOR NEGATIVE VRATES  
      DO K=1,3  
      IF(VRATE(I,K).LT.0.0) THEN  
	WRITE(N6,5447) I  
	NSTOP = NSTOP + 1  
	ENDIF  
	ENDDO  
c     New type 5 pump  
       CASE (5)  
        IF(JCE.EQ.0) THEN  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I)  
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 1046  
	    ENDDO  
 1046      POFF(I) = POFF(I) - Z(JUNCIM)  
           DO K = 1,3  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ELSE  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),(PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I)  
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 1047  
	    ENDDO  
 1047      POFF(I) = POFF(I) - Z(JUNCIM)  
           DO K = 1,3  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ENDIF  
CIM ADD A CHECK FOR NEGATIVE VRATES OR POFF  
        IF(POFF(I).LT.0.0) THEN  
	   WRITE(N6,5448) I  
			NSTOP = NSTOP + 1  
	  ENDIF  
	DO K=1,3  
	   IF (VRATE(I,K).LT.0.0) THEN  
	   WRITE(N6,5447) I  
	ENDIF  
	ENDDO  
	ENDSELECT  
        ELSE  
C this repeats above code when IPRATE is used  
        SELECT CASE (IPTYP(I))  
        CASE (1)  
         IF(JCE.EQ.0) THEN  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I)),  
     4                VWELL(I)  
         ELSE  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I)),  
     3                VWELL(I)  
         ENDIF  
        CASE (2)  
        IF(JCE.EQ.0)  THEN  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I)-1)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8040  
	    ENDDO  
 8040      DO K=1,NPRATE(I)-1  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ELSE  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I)-1)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8041  
	    ENDDO  
 8041     DO K=1,NPRATE(I)-1  
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	    ENDDO  
	  ENDIF  
        ENDIF  
cim  ADD A CHECK FOR NEGATIVE VRATES  
      DO K = 1,NPRATE(I) - 1  
      IF (VRATE(I,K).LT.0.0) THEN  
	WRITE(N6,5447) I  
	NSTOP = NSTOP + 1  
	ENDIF  
	ENDDO  
        CASE(3)  
        IF(JCE.EQ.0)  THEN  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I)),  
     4                VWELL(I),PON(I),POFF(I)  
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8042  
	    ENDDO  
 8042      PON(I) = PON(I) - Z(JUNCIM)  
           POFF(I) = POFF(I) - Z(JUNCIM)  
	  ENDIF  
        ELSE  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I)),  
     4                VWELL(I),PON(I),POFF(I)  
CIM  CONVERT PON AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8043  
	    ENDDO  
 8043      PON(I) = PON(I) - Z(JUNCIM)  
           POFF(I) = POFF(I) - Z(JUNCIM)  
	  ENDIF  
        ENDIF  
CIM ADD A CHECK FOR NEGATIVE PON OR POFF  
        IF((PON(I).LT.0.0).OR.(POFF(I).LT.0.0)) THEN  
	   WRITE(N6,5448) I  
			NSTOP = NSTOP + 1  
	  ENDIF  
        CASE(4)  
	PON(I) = 0.0  
	POFF(I) = 0.0  
        IF(JCE.EQ.0) THEN  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     3                (VRATE(I,K),K=1,NPRATE(I))  
     4                ,PON(I),POFF(I)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8044  
	    ENDDO  
 8044      DO K = 1,NPRATE(I)  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ELSE  
                      READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,NPRATE(I)),  
     2                (VRATE(I,K),K=1,NPRATE(I)),PON(I),POFF(I)  
CIM CONVERT VRATE FROM ELEVATION TO DEPTH FOR JELEV = 4  
        IF (JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8045  
	    ENDDO  
 8045     DO K=1,NPRATE(I)  
            VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	    ENDDO  
	  ENDIF  
        ENDIF  
cim  ADD A CHECK FOR NEGATIVE VRATES  
      DO K=1,NPRATE(I)  
      IF(VRATE(I,K).LT.0.0) THEN  
	WRITE(N6,5447) I  
	NSTOP = NSTOP + 1  
	ENDIF  
	ENDDO  
c     New type 5 pump  
       CASE (5)  
        IF(JCE.EQ.0) THEN  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (NJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I)  
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(NJUNC(N,1).EQ.JUN(JUNCIM))  GO TO 8046  
	    ENDDO  
 8046      POFF(I) = POFF(I) - Z(JUNCIM)  
           DO K = 1,NPRATE(I)  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ELSE  
                  READ(N5,*,ERR=888) CC,IPTYP(I),  
     1                (KJUNC(N,K),K=1,2),NPRATE(I),  
     2                (PRATE(I,K),K=1,3),  
     2                (VRATE(I,K),K=1,3),POFF(I),PONDELAY(I)  
CIM  CONVERT VRATE AND POFF TO DEPTHS IF JELEV = 4  
                  IF(JELEV.EQ.4) THEN  
	    DO JUNCIM = 1, NJ  
           IF(KJUNC(N,1).EQ.AJUN(JUNCIM))  GO TO 8047  
	    ENDDO  
 8047      POFF(I) = POFF(I) - Z(JUNCIM)  
           DO K = 1,NPRATE(I)  
           VRATE(I,K) = VRATE(I,K) - Z(JUNCIM)  
	     ENDDO  
	  ENDIF  
        ENDIF  
CIM ADD A CHECK FOR NEGATIVE VRATES OR POFF  
        IF(POFF(I).LT.0.0) THEN  
	   WRITE(N6,5448) I  
			NSTOP = NSTOP + 1  
	  ENDIF  
	DO K=1,NPRATE(I)  
	   IF (VRATE(I,K).LT.0.0) THEN  
	   WRITE(N6,5447) I  
	ENDIF  
	ENDDO  
        END SELECT  
        ENDIF  
CIM      ISWTCH(IPTYP(I)) = IPTYP(I)  
 1060 CONTINUE  
 1080 NPUMP = I - 1  
C=======================================================================  
C     PRINT PUMP NODES  
C=======================================================================  
      IF(NPUMP.GT.0) THEN  
cim pp 5/1/97  change format of pump printout  
cim Simply print one pump at a time in order that they were input.  
cim Delete all lines associated with original input  
      WRITE(N6,5560)  
      DO I = 1,NPUMP  
      N         = NTL+I  
      IF(JCE.EQ.0) THEN  
        WRITE(N6,5562) I,(NJUNC(N,K),K=1,2)  
        ELSE  
        WRITE(N6,5564) I,(KJUNC(N,K),K=1,2)  
      ENDIF  
      SELECT CASE (IPTYP(I))  
      CASE (1)  
C=======================================================================  
C     PRINT OFF-LINE PUMP DATA IPTYP = 1  
C=======================================================================  
       IF(METRIC.EQ.1) THEN  
          WRITE(N6,5566) VWELL(I)  
          WRITE(N6,5568)  
          ELSE  
          WRITE(N6,5570) VWELL(I)  
          WRITE(N6,5572)  
        ENDIF  
        WRITE(N6,5574) 0.0,VRATE(I,1),PRATE(I,1)  
        WRITE(N6,5574) (VRATE(I,K-1),VRATE(I,K),PRATE(I,K),  
     1                   K=2,NPRATE(I))  
CIM CHECK THAT VRATES ARE IN INCREASING ORDER.  
        DO K=2,NPRATE(I)  
           IF (VRATE(I,K).LT.VRATE(I,K-1)) THEN  
             WRITE(N6,9010)  
             NSTOP = NSTOP+1  
           ENDIF  
        ENDDO  
      CASE (2)  
C=======================================================================  
C     PRINT IN-LINE PUMP DATA IPTYP = 2  
C=======================================================================  
        WRITE(N6,5576)  
        IF(METRIC.EQ.1) THEN  
          WRITE(N6,5578)  
          ELSE  
          WRITE(N6,5580)  
        ENDIF  
        WRITE(N6,5574) 0.0,VRATE(I,1),PRATE(I,1)  
        WRITE(N6,5574) (VRATE(I,K-1),VRATE(I,K),PRATE(I,K),  
     1                  K=2,NPRATE(I)-1)  
        WRITE(N6,5582) VRATE(I,NPRATE(I)-1),PRATE(I,NPRATE(I))  
CIM CHECK THAT VRATES ARE IN INCREASING ORDER.  
        DO K=2,NPRATE(I)-1  
           IF (VRATE(I,K).LT.VRATE(I,K-1)) THEN  
             WRITE(N6,9010)  
             NSTOP = NSTOP+1  
           ENDIF  
        ENDDO  
      CASE (3)  
C=======================================================================  
C     PRINT PUMP CURVE DATA IPTYP = 3  
C=======================================================================  
        IF(METRIC.EQ.1) THEN  
          WRITE(N6,5584) PON(I),POFF(I)  
          WRITE(N6,5586)  
          ELSE  
          WRITE(N6,5588) PON(I),POFF(I)  
          WRITE(N6,5590)  
        ENDIF  
        WRITE(N6,5592) (VRATE(I,K),PRATE(I,K),K=1,NPRATE(I))  
        WRITE(N6,5600)  
C#######################################################################  
C CHECK FOR FLAT PUMP CURVE.  CANNOT HAVE ADJACENT VRATES EQUAL  
C THIS AVOIDS ZERO DIVIDE IN SUBROUTINE BOUND WCH, 8/28/92  
C#######################################################################  
CIM ALSO CHECK THAT VRATES ARE IN DECREASING ORDER  
        DO K=1,NPRATE(I)-1  
           IF(VRATE(I,K).EQ.VRATE(I,K+1)) THEN  
             WRITE(N6,5575)  
             NSTOP = NSTOP+1  
           ENDIF  
           IF(VRATE(I,K).LT.VRATE(I,K+1)) THEN  
             WRITE(N6,9020)  
             NSTOP = NSTOP+1  
           ENDIF  
       ENDDO  
      CASE (4)  
C=======================================================================  
C     PRINT VARIABLE SPEED PUMP CURVE DATA IPTYP = 4  
C=======================================================================  
        WRITE(N6,5594)  
        IF(METRIC.EQ.1) THEN  
          WRITE(N6,5596)  
          ELSE  
          WRITE(N6,5598)  
        ENDIF  
        WRITE(N6,5592) (VRATE(I,K),PRATE(I,K),K=1,NPRATE(I))  
        WRITE(N6,5600)  
        IF(METRIC.EQ.1) THEN  
          WRITE(N6,5602) PRATE(I,1),VRATE(I,1)  
          WRITE(N6,5604) PRATE(I,NPRATE(I)),VRATE(I,NPRATE(I))  
          ELSE  
          WRITE(N6,5606) VRATE(I,1),PRATE(I,1)  
          WRITE(N6,5608) PRATE(I,NPRATE(I)),VRATE(I,NPRATE(I))  
        ENDIF  
C#######################################################################  
C CHECK FOR FLAT PUMP CURVE.  CANNOT HAVE ADJACENT VRATES EQUAL  
C THIS AVOIDS ZERO DIVIDE IN SUBROUTINE BOUND WCH, 8/28/92  
C#######################################################################  
C CHECK THAT VRATES INCREASE  
        DO K=1,NPRATE(I)-1  
           IF(VRATE(I,K).EQ.VRATE(I,K+1)) THEN  
             WRITE(N6,5575)  
             NSTOP = NSTOP+1  
           ENDIF  
           IF(VRATE(I,K).GT.VRATE(I,K+1)) THEN  
           WRITE(N6,9010)  
           NSTOP = NSTOP+1  
           ENDIF  
        ENDDO  
c initialize to off  
	IPOPR(1,I)=-1  
	IF ((PON(I).EQ.0.0).AND.(POFF(I).EQ.0.0)) THEN  
	PON(I) = -0.1  
	POFF(I) = -0.2  
	ELSE  
	WRITE(N6,8400) PON(I),POFF(I)  
	ENDIF  
	CASE (5)  
C=======================================================================  
C     PRINT CONSTANT SPEED LIFT STATION TYPE PUMP DATA IPTYP = 5  
C=======================================================================  
	WRITE(N6,8100)  
	DO K=1,NPRATE(I)  
	IF (METRIC.EQ.1) THEN  
      WRITE(N6,8102) I,PRATE(I,K),'CFS',VRATE(I,K),'FT'  
	ELSE  
	WRITE(N6,8102) I,PRATE(I,K),'M3S',VRATE(I,K),'M '  
	END IF  
	enddo  
	IF (METRIC.EQ.1) THEN	  
	WRITE(N6,8104) POFF(I),'FT',PONDELAY(I)  
	ELSE  
	WRITE(N6,8104) POFF(I),'M ',PONDELAY(I)  
	ENDIF  
      CASE DEFAULT  
        WRITE(N6,5576)  
        NSTOP = NSTOP+1  
      END SELECT  
      ENDDO  
C=======================================================================  
C                   CONVERT TO INTERNAL NUMBER SYSTEM  
C=======================================================================  
                    DO 1240 I = 1,NPUMP  
                    N         = NTL+I  
                    LPUMP(I)  = N  
                    NCOND(N)  = N + 90000  
                    IF(JCE.EQ.1) ACOND(N)  = PNAME(I)  
                    DO 1220 K = 1,2  
                    DO 1180 J = 1,NJ  
                    IF(JCE.EQ.0.AND.NJUNC(N,K).EQ.JUN(J))  GO TO 1190  
                    IF(JCE.EQ.1.AND.KJUNC(N,K).EQ.AJUN(J)) GO TO 1190  
 1180               CONTINUE  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5610) NJUNC(N,K)  
                    ELSE  
                      WRITE(N6,5611) KJUNC(N,K)  
                    ENDIF  
                    NSTOP      = NSTOP+1  
 1190               NJUNC(N,K) = J  
                    DO 1195 KK = 1,NCHN  
                    IF(NCHAN(J,KK)) 1200,1200,1195  
 1195               CONTINUE  
      IF (NCHAN(J,KK).NE.0) THEN  
                     IF (JCE.EQ.0) THEN  
                       WRITE(n6,8330) JUN(J)  
                       ELSE  
                       WRITE(n6,8331) AJUN(J)  
                       ENDIF  
                     NSTOP = NSTOP + 1  
      ENDIF  
 1200               NCHAN(J,KK) = N  
                    IF(IPTYP(I).GE.2) GO TO 1220  
                    IF(KK.LE.2)       GO TO 1220  
                    IF(K.EQ.2)        GO TO 1220  
                    IF(JCE.EQ.0) THEN  
                     WRITE(N6,5615)  JUN(J)  
                    ELSE  
                     WRITE(N6,5614) AJUN(J)  
                    ENDIF  
                    NSTOP = NSTOP + 1  
 1220               CONTINUE  
C=======================================================================  
C                   SET INFLOW INDEX FOR PUMP NODE  
C=======================================================================  
                    JP  = NJUNC(N,1)  
                    IF(IPTYP(I).GE.2) GO TO 1235  
                    JSKIP(JP) = 1  
                    Z(JP)     = -100.0  
 1235               CONTINUE  
                    JPFUL(I)  = 1  
 1240               CONTINUE  
                    NTL       = NTL + NPUMP  
                    ENDIF  
CIM OK HAVE READ WEIRS ORIFICES AND PUMPS, NOW CHECK IF ALL NODES  
CIM ARE CONNECTED TO AT LEAST ONE PIPE AND QUIT IF ANY AREN'T  
      INCON = 0  
      DO J=1,NJ  
      IF (NCHAN(J,1).EQ.0) THEN  
        INCON = INCON + 1  
        JSKIP(J) = 1  
        IF (JCE.EQ.0) THEN  
          WRITE(N6,5350) JUN(J)  
        ELSE  
          WRITE(N6,5351) AJUN(J)  
        ENDIF  
      ENDIF  
      ENDDO  
      IF (INCON.GT.0) THEN  
      WRITE(N6,5352) INCON  
      WRITE(*,5352) INCON  
      STOP  
      ENDIF  
CIM END  
C=======================================================================  
C     READ DATA FOR OUTFALLS WITHOUT TIDE GATES ON DATA GROUP I1  
C=======================================================================  
      NFREE     = 0  
cimtide  JTIDE is not initialized.  Do so here just to be certain.  
cimtide  
      do i=1,nee  
      jtides(nee) = 0  
      enddo  
cimtide  
cim print error message  
      DO 1280 I = 1,NTG+1  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'I1') GO TO 1300  
C print error message  
      IF(I.GT.NTG) THEN  
      WRITE(N6,8015) NTG  
      STOP 'TOO MANY FREE OUTFALLS SEE ERROR MESSAGE IN OUTPUT FILE'  
      ENDIF  
      IF(JCE.EQ.0) THEN  
           READ(N5,*,ERR=888) CC,JFREE(I),NBCF(I)  
      ELSE  
           READ(N5,*,ERR=888) CC,KFREE(I),NBCF(I)  
      ENDIF  
      NFREE = NFREE + 1  
      IF(NPUMP.GT.0) THEN  
               DO 1340 K = 1,NPUMP  
               N         = LPUMP(K)  
               JDN       = NJUNC(N,2)  
               IF(JCE.EQ.1) BMJ       = KJUNC(N,2)  
               IF(JCE.EQ.0.AND.JUN(JDN).EQ.JFREE(I))  JSKIP(JDN) = 2  
               IF(JCE.EQ.1.AND.AJUN(JDN).EQ.KFREE(I)) JSKIP(JDN) = 2  
C              IF(JSKIP(JDN).EQ.2)   ZCROWN(JDN) = 2.0 + Z(JDN)  
 1340          CONTINUE  
               ENDIF  
C=======================================================================  
C     CHECK FOR WEIR OUTFALLS WITHOUT TIDE GATES  
C=======================================================================  
      IF(NWEIR.GT.0) THEN  
               DO 1350 K = 1,NWEIR  
               N         = LWEIR(K)  
               J         = NJUNC(N,1)  
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1)  
C#### RED, 3/12/95.  Compare JUN(J) with JFREE, not J with JFREE.  
C###               IF(JCE.EQ.0.AND.J.EQ.JFREE(I))   THEN  
               IF(JCE.EQ.0.AND.JUN(J).EQ.JFREE(I)) THEN  
                                                JTIDES(J) = NBCF(I)  
                                                NFREE     = NFREE - 1  
                                                GO TO 1350  
                                                ENDIF  
               IF(JCE.EQ.1.AND.BMJ.EQ.KFREE(I)) THEN  
                                                JTIDES(J) = NBCF(I)  
                                                NFREE     = NFREE - 1  
                                                GO TO 1350  
                                                ENDIF  
 1350          CONTINUE  
               ENDIF  
C=======================================================================  
C     CHECK FOR PUMP OUTFALLS.  
C=======================================================================  
      IF(NPUMP.GT.0) THEN  
               DO 1375 K = 1,NPUMP  
               N         = LPUMP(K)  
               J         = NJUNC(N,1)  
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1)  
C#### RED, 3/12/95.  Compare JUN(J) with JFREE, not J with JFREE.  
C###               IF(JCE.EQ.0.AND.J.EQ.JFREE(I))   THEN  
               IF(JCE.EQ.0.AND.JUN(J).EQ.JFREE(I)) THEN  
                                                JTIDES(J) = NBCF(I)  
                                                NFREE     = NFREE - 1  
                                                GO TO 1375  
                                                ENDIF  
               IF(JCE.EQ.1.AND.BMJ.EQ.KFREE(I)) THEN  
                                                JTIDES(J) = NBCF(I)  
                                                NFREE     = NFREE - 1  
                                                GO TO 1375  
                                                ENDIF  
 1375          CONTINUE  
               ENDIF  
 1280 CONTINUE  
 1300 CONTINUE  
C=======================================================================  
C     PRINT OUTFLOW NODES  
C=======================================================================  
      IF(NFREE.GT.0) THEN  
                     WRITE(N6,5616)  
                     IF(JCE.EQ.0) THEN  
                        WRITE(N6,5620) (JFREE(I),NBCF(I),I=1,NFREE)  
                     ELSE  
                        WRITE(N6,5621) (KFREE(I),NBCF(I),I=1,NFREE)  
                     ENDIF  
C=======================================================================  
C                    CONVERT TO INTERNAL NUMBER SYSTEM  
C=======================================================================  
                     DO 1390 I = 1,NFREE  
                     DO 1360 J = 1,NJ  
                     IF(JCE.EQ.0.AND.JFREE(I).EQ.JUN(J))  GO TO 1380  
                     IF(JCE.EQ.1.AND.KFREE(I).EQ.AJUN(J)) GO TO 1380  
 1360                CONTINUE  
                     IF(JCE.EQ.0) THEN  
                       WRITE(N6,5630) JFREE(I)  
                     ELSE  
                       WRITE(N6,5631) KFREE(I)  
                     ENDIF  
                     NSTOP      = NSTOP + 1  
 1380                JFREE(I)   = J  
C=======================================================================  
C                   CHECK FREE BC'S FOR MULTIPLE INPUT CONDUITS  
C=======================================================================  
                     IF(NCHAN(J,2).GT.0) THEN  
                              IF(JCE.EQ.0) THEN  
                               WRITE(N6,1853)  JUN(J)  
                              ELSE  
                               WRITE(N6,1854) AJUN(J)  
                              ENDIF  
                              NSTOP     = NSTOP + 1  
                              ENDIF  
                     JTIDES(J)  = NBCF(I)  
                     N          = NTL + I  
                     NJUNC(N,1) = J  
                     NJUNC(N,2) = 0  
                     IF(JCE.EQ.1) KJUNC(N,1) = AJUN(J)  
                     IF(JCE.EQ.1) KJUNC(N,2) = 'BOUNDARY  '  
                     NCHAN(J,2) = N  
                     NCOND(N)   = N + 90000  
                     IF(JCE.EQ.1) ACOND(N)   = OUTF(I)  
                     IF(JSKIP(J).EQ.0) JSKIP(J)   = 1  
 1390                CONTINUE  
                     NTL        = NTL + NFREE  
                     ENDIF  
C=======================================================================  
C     READ DATA FOR OUTFALLS WITH TIDE GATES ON DATA GROUP I2  
C=======================================================================  
      NGATE     = 0  
cim print error message  
      DO 1420 I = 1,NTG+1  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'I2') GO TO 1440  
C print error message  
      IF(I.GT.NTG) THEN  
      WRITE(N6,8020) NTG  
      STOP 'TOO MANY OUTFALLS WITH TIDE GATES - SEE ERROR MESSAGE IN OUT  
     +PUT FILE'  
      ENDIF  
      IF(JCE.EQ.0) THEN  
       READ(N5,*,ERR=888) CC,JGATE(I),NBCG(I)  
      ELSE  
       READ(N5,*,ERR=888) CC,KGATE(I),NBCG(I)  
      ENDIF  
      NGATE = NGATE + 1  
C=======================================================================  
C     CHECK FOR WEIR OUTFALLS WITH TIDE GATES  
C=======================================================================  
      IF(NWEIR.GT.0) THEN  
               DO 1450 K = 1,NWEIR  
               N         = LWEIR(K)  
               J         = NJUNC(N,1)  
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1)  
C#### WCH (RED), 3/16/95. Compare JUN(J) with JGATE, not J with JGATE.  
C####               IF(JCE.EQ.0.AND.J.EQ.JGATE(I))   THEN  
               IF(JCE.EQ.0.AND.JUN(J).EQ.JGATE(I)) THEN  
                                                JTIDES(J) = NBCG(I)  
                                                NGATE     = NGATE - 1  
                                                GO TO 1450  
                                                ENDIF  
               IF(JCE.EQ.1.AND.BMJ.EQ.KGATE(I)) THEN  
                                                JTIDES(J) = NBCG(I)  
                                                NGATE     = NGATE - 1  
                                                GO TO 1450  
                                                ENDIF  
 1450          CONTINUE  
               ENDIF  
C=======================================================================  
C     CHECK FOR PUMP OUTFALLS WITH TIDE GATES  
C=======================================================================  
      IF(NPUMP.GT.0) THEN  
               DO 1475 K = 1,NPUMP  
               N         = LPUMP(K)  
               J         = NJUNC(N,1)  
               IF(JCE.EQ.1) BMJ       = KJUNC(N,1)  
C#### WCH (RED), 3/16/95. Compare JUN(J) with JGATE, not J with JGATE.  
C####               IF(JCE.EQ.0.AND.J.EQ.JGATE(I))   THEN  
               IF(JCE.EQ.0.AND.JUN(J).EQ.JGATE(I)) THEN  
                                                JTIDES(J) = NBCG(I)  
                                                NGATE     = NGATE - 1  
                                                GO TO 1475  
                                                ENDIF  
               IF(JCE.EQ.1.AND.BMJ.EQ.KGATE(I)) THEN  
                                                JTIDES(J) = NBCG(I)  
                                                NGATE     = NGATE - 1  
                                                GO TO 1475  
                                                ENDIF  
 1475          CONTINUE  
               ENDIF  
 1420 CONTINUE  
 1440 CONTINUE  
CIM 4/00 PRINT WARNING IF NO BOUNDARIES ARE SPECIFIED (NO I1 OR I2 LINES FOUND)  
	IF ((NFREE.EQ.0).AND.(NGATE.EQ.0)) WRITE(N6,8500)  
C=======================================================================  
C     PRINT TIDE GATE NODES  
C=======================================================================  
      IF(NGATE.GT.0) THEN  
                     WRITE(N6,5656)  
                     IF(JCE.EQ.0) THEN  
                       WRITE(N6,5660) (JGATE(I),NBCG(I),I=1,NGATE)  
                     ELSE  
                       WRITE(N6,5661) (KGATE(I),NBCG(I),I=1,NGATE)  
                     ENDIF  
C=======================================================================  
C                    CONVERT TO INTERNAL NUMBER SYSTEM  
C=======================================================================  
                     DO 1510 I = 1,NGATE  
                     DO 1480 J = 1,NJ  
                     IF(JCE.EQ.0.AND.JGATE(I).EQ.JUN(J))  GO TO 1500  
                     IF(JCE.EQ.1.AND.KGATE(I).EQ.AJUN(J)) GO TO 1500  
 1480                CONTINUE  
                     IF(JCE.EQ.0) THEN  
                      WRITE(N6,5662) JGATE(I)  
                     ELSE  
                      WRITE(N6,5663) KGATE(I)  
                     ENDIF  
                     NSTOP      = NSTOP + 1  
 1500                JGATE(I)   = J  
C=======================================================================  
C                   CHECK TIDAL BC'S FOR MULTIPLE INPUT CONDUITS  
C=======================================================================  
                     IF(NCHAN(J,2).GT.0) THEN  
                              IF(JCE.EQ.0) THEN  
                               WRITE(N6,1853)  JUN(J)  
                              ELSE  
                               WRITE(N6,1854) AJUN(J)  
                              ENDIF  
                              NSTOP     = NSTOP + 1  
                              ENDIF  
                     JTIDES(J)  = NBCG(I)  
                     N          = NTL + I  
                     NJUNC(N,1) = J  
                     NJUNC(N,2) = 0  
                     IF(JCE.EQ.1) KJUNC(N,1) = AJUN(J)  
                     IF(JCE.EQ.1) KJUNC(N,2) = 'BOUNDARY  '  
                     NCHAN(J,2) = N  
                     NCOND(N)   = N + 90000  
                     IF(JCE.EQ.1) ACOND(N)   = OUTG(I)  
                     JSKIP(J)   = 1  
 1510                CONTINUE  
                     NTL        = NTL + NGATE  
                     ENDIF  
C=======================================================================  
C     PRINT WEIR OUTFALL NODES  
C=======================================================================  
      IF(NWEIR.GT.0) THEN  
                     ILOOP      = 0  
                     DO 1470 K  = 1,NWEIR  
                     N          = LWEIR(K)  
                     J          = NJUNC(N,1)  
                     JJ         = NJUNC(N,2)  
                     IF(JJ.LE.0) THEN  
                          ILOOP = ILOOP + 1  
                          IF(ILOOP.EQ.1) WRITE(N6,6660)  
                          IF(JCE.EQ.0) THEN  
                            WRITE(N6,6665)  JUN(J),JTIDES(J)  
                          ELSE  
                            WRITE(N6,6670) AJUN(J),JTIDES(J)  
                          ENDIF  
                          ENDIF  
 1470                CONTINUE  
                     ENDIF  
C=======================================================================  
C     PRINT PUMP OUTFALL NODES  
C=======================================================================  
      IF(NPUMP.GT.0) THEN  
                     ILOOP      = 0  
                     DO 1570 K  = 1,NPUMP  
                     N          = LPUMP(K)  
                     J          = NJUNC(N,1)  
                     JJ         = NJUNC(N,2)  
                     IF(JJ.LE.0) THEN  
                        ILOOP = ILOOP + 1  
                        IF(ILOOP.EQ.1) WRITE(N6,6680)  
                        IF(JCE.EQ.0) THEn  
                          WRITE(N6,6665)  JUN(J),JTIDES(J)  
                        ELSE  
                          WRITE(N6,6670) AJUN(J),JTIDES(J)  
                        ENDIF  
                        ENDIF  
 1570                CONTINUE  
                     ENDIF  
C=======================================================================  
C     INTERNAL CONNECTIVITY INFORMATION  
C=======================================================================  
      WRITE(N6,2999)  
      WRITE(N6,5060) ALPHA1,ALPHA2  
      WRITE(N6,5665)  
      IF(JCE.EQ.0) THEN  
        WRITE(N6,5670)  
      ELSE  
        WRITE(N6,5671)  
      ENDIF  
      N1        = NC+1  
      DO 1525 N = N1,NTL  
      J1        = NJUNC(N,1)  
      J2        = NJUNC(N,2)  
      IF(J2.GT.0.AND.JCE.EQ.0) J2 = JUN(J2)  
      IF(JCE.EQ.0) THEN  
        WRITE(N6,5675) NCOND(N),JUN(J1),J2  
      ELSE  
        WRITE(N6,5685) ACOND(N),KJUNC(N,1),KJUNC(N,2)  
      ENDIF  
 1525 CONTINUE  
      IF(NJ.GT.NEE) THEN  
                    WRITE(N6,5676) NEE  
                    NSTOP = NSTOP+1  
                    ENDIF  
      IF(NTL.GT.NEE) THEN  
                    WRITE(N6,5677) NEE  
                    NSTOP = NSTOP+1  
                    ENDIF  
      RETURN  
 888  CALL IERROR  
C=======================================================================  
C#### WCH, 12/8/94.  NEW 890 - 999.  
  890 FORMAT(/' DETAILED DATA FOR VARIABLE AREA/TABULAR INPUT JUNCTION',  
     1 1X,I10,/,' POINT    DEPTH       AREA     VOLUME')  
  891 FORMAT(/' DETAILED DATA FOR VARIABLE AREA/TABULAR INPUT JUNCTION',  
     1 1X,A10,/,' POINT    DEPTH       AREA     VOLUME')  
  892 FORMAT(' NUMBER      FT         AC    1000-FT3',/,  
     1        ' -------------------------------------')  
  893 FORMAT(' NUMBER       M         HA     1000-M3',/,  
     1        ' -------------------------------------')  
  894 FORMAT(I6,F10.3,2E11.4)  
  895 FORMAT(/' INPUT DATA FOR VARIABLE AREA/POWER FUNCTION JUNCTION',  
     1 1X,I10,/,' COEFFICIENT =',F10.3,/,' EXPONENT    =',F10.3)  
  896 FORMAT(/' INPUT DATA FOR VARIABLE AREA/POWER FUNCTION JUNCTION',  
     1 1X,A10,/, ' COEFFICIENT =',F10.3,/,' EXPONENT    =',F10.3)  
  990 FORMAT(/,'  WARNING FOR VARIABLE AREA STORAGE JUNCTION NO. '  
     1,I10)  
  991 FORMAT(/,'  WARNING FOR VARIABLE AREA STORAGE JUNCTION NO. '  
     1,A10)  
  992 FORMAT(' LOWEST DEPTH = ',F9.4,'. MUST BE = 0.  VALUE SET TO 0.')  
  993 FORMAT( ' LOWEST AREA = ',F9.4,'. MUST BE > 0.  VALUE SET TO AMEN  
     1(LINE B2).')  
  998 FORMAT(/,' WARNING  FOR JUNCTION ',I10,' AREA DECREASES BETWEEN',  
     1' STAGES',F10.3,' AND ',F10.3)  
  999 FORMAT(/,' WARNING  FOR JUNCTION ',A10,' AREA DECREASES BETWEEN',  
     1' STAGES',F10.3,' AND ',F10.3)  
 1853 FORMAT(/,' ===> ERROR   OUTFALL JUNCTION ',I10,' HAS TWO OR',/,  
     +         '                MORE CONNECTING CONDUITS.')  
 1854 FORMAT(/,' ===> ERROR   OUTFALL JUNCTION ',A10,' HAS TWO OR',/,  
     +         '                MORE CONNECTING CONDUITS.')  
2999  FORMAT(/,  
     1       '1',40(2H--)/' ','ENVIRONMENTAL PROTECTION AGENCY',13X,40H*  
     2***   EXTENDED TRANSPORT PROGRAM   ****,8X,'WATER RESOURCES DIVISI  
     3ON',/,' ','WASHINGTON, D.C.            ',16X,4H****,32X,4H****,8X,  
     4'CAMP DRESSER & MCKEE INC.',/,' ','                ',28X,4H****,  
     56X,'   ANALYSIS MODULE  ',6X,4H****,8X,'ANNANDALE, VIRGINIA')  
 5060 FORMAT(/,5X,A80,/,5X,A80,/)  
 5397 FORMAT(//,  
     +' ******************************************************',/,  
     +' *          DETAILED STORAGE JUNCTION DATA            *',/,  
     +' ******************************************************',/)  
 5398 FORMAT(//,  
     +' ******************************************************',/,  
     +' *          STORAGE JUNCTION DATA SUMMARY             *',/,  
     +' ******************************************************',/)  
 5399 FORMAT(7X,I10,A10,2F18.2,F11.3)  
 5499 FORMAT(7X,A10,A10,2F18.2,F11.3)  
CIM START  OOOOOOO  
 5420 FORMAT(//,  
     +' *********************************************',/,  
     +' *              ORIFICE DATA                 *',/,  
     +' *********************************************',//,  
     *'       FROM         TO                AREA      DISCHARGE   HEIGH  
     +T ABOVE         RECTANGULAR ORIFICE',/,  
     *'   JUNCTION   JUNCTION      TYPE     (FT2)    COEFFICIENT  JUNCTI  
     +ON (FT)         DEPTH          WIDTH',/,  
     *'   --------   --------      ----     -----    -----------  ------  
     +-------        ------          -----')  
 5421 FORMAT(//,  
     +' *********************************************',/,  
     +' *              ORIFICE DATA                 *',/,  
     +' *********************************************',//,  
     *'       FROM         TO                AREA      DISCHARGE   HEIGH  
     +T ABOVE         RECTANGULAR ORIFICE',/,  
     *'   JUNCTION   JUNCTION      TYPE    (MET2)    COEFFICIENT  JUNCTI  
     +ON  (M)         DEPTH          WIDTH',/,  
     *'   --------   --------      ----     -----    -----------  ------  
     +-------        ------          -----')  
 5440 FORMAT(1X,3I10,F10.2,F15.3,3F15.3)  
 5441 FORMAT(1X,2A10,I10,F10.2,F15.3,3F15.3)  
 5442 FORMAT(' ERROR ** ORIFICE ZP HEIGHT ABOVE UPSTREAM',  
     a' NODE INVERT IS LESS THAN ZERO.'  
     a,/,'          ORIFICE NUMBER = ', I10)  
 5443	FORMAT(' ERROR ** OOPEN OR OCLOSE IS LESS THAN ZERO',  
     a' FOR ORIFICE NUMBER ',I10)  
 5444 FORMAT(' ERROR ** YTOP OR YCREST IS LESS THAN ZERO FOR WEIR',  
     A' NUMBER ',I10)  
 5445 FORMAT(/,' ====> ERROR   GATED ORIFICE CONTROL JUNCTION ',I10,  
     1' IS NOT CONTAINED IN JUNCTION DATA')  
 5446 FORMAT(/,' ====> ERROR   GATED ORIFICE CONTROL JUNCTION ',A10,  
     1' IS NOT CONTAINED IN JUNCTION DATA')  
 5447 FORMAT(' ERROR ** VRATE IS LESS THAN ZERO FOR PUMP NUMBER ',I10)  
 5448 FORMAT(' ERROR ** PON OR POFF IS LESS THAN ZERO FOR PUMP',  
     A' NUMBER ',I10)  
 5449 FORMAT(' ERROR ** IPTYP EQUALS ',I4,' WHICH IS NOT A VALID',  
     A' PUMP TYPE')  
CIM END     OOOOOOOO  
 5450 FORMAT(/,' ====> ERROR   ORIFICE JUNCTION ',I10,  
     1' IS NOT CONTAINED IN JUNCTION DATA')  
 5451 FORMAT(/,' ====> ERROR   ORIFICE JUNCTION ',A10,  
     1' IS NOT CONTAINED IN JUNCTION DATA')  
 5455 FORMAT(/,' ====> ERROR  ORIFICE TOP LIES ABOVE GROUND ELEVATION  
     . AT JUNCTION ',I10)  
 5456 FORMAT(/,' ====> ERROR  ORIFICE TOP LIES ABOVE GROUND ELEVATION  
     . AT JUNCTION ',A10)  
 5458 FORMAT(/,' ====> ERROR  ORIFICE OUTLET AT JUNCTION ',I10,  
     1' IS HIGHER THAN INLET')  
 5459 FORMAT(/,' ====> ERROR  ORIFICE OUTLET AT JUNCTION ',A10,  
     1' IS HIGHER THAN INLET')  
C  BAC START WWWWWWW  
 5480 FORMAT(//,  
     +' *********************************************',/,  
     +' *                 WEIR DATA                 *',/,  
     +' *********************************************',//,  
     *'     FROM       TO        LINK               CREST       WEIR   '  
     *,'   WEIR        DISCHARGE   SUBMERGENCE  NUMBER OF END  V-NOTCH '  
     *,'ANGLE  SECOND DISCHARGE',/,  
     *'   JUNCTION  JUNCTION    NUMBER      TYPE  HEIGHT(FT)   TOP(FT) '  
     *,' LENGTH(FT)   COEFFICIENT   EQUATION    CONTRACTIONS   OR SIDE '  
     *,'SLOPE    COEFFICIENT',/,  
     *'   --------  --------    ------      ----  ----------   ------- '  
     *,' ----------   -----------  -----------  -------------  --------'  
     *,'-----  ----------------')  
C    *'       FROM        TO      LINK                 CREST      WEIR  
C    *      WEIR     DISCHARGE',/,  
C    *'   JUNCTION  JUNCTION    NUMBER      TYPE  HEIGHT(FT)   TOP(FT)  
C    *LENGTH(FT)   COEFFICIENT',/,  
C    *'   --------  --------    ------      ----  ----------   -------  
C    *----------   -----------')  
 5481 FORMAT(//,  
     +' *********************************************',/,  
     +' *                 WEIR DATA                 *',/,  
     +' *********************************************',//,  
     *'     FROM       TO        LINK                CREST       WEIR  '  
     *,'    WEIR       DISCHARGE   SUBMERGENCE  NUMBER OF END  V-NOTCH '  
     * ,'ANGLE  SECOND DISCHARGE',/,  
     *'   JUNCTION  JUNCTION    NUMBER      TYPE   HEIGHT(M)    TOP(M) '  
     *,'  LENGTH(M)   COEFFICIENT   EQUATION    CONTRACTIONS   OR SIDE '  
     *,'SLOPE    COEFFICIENT',/,  
     *'   --------  --------    ------      ----   ---------    ------ '  
     *,'  ---------   -----------  -----------  -------------  --------'  
     *,'-----  ----------------')  
C    *'       FROM        TO      LINK                 CREST      WEIR  
C    *      WEIR     DISCHARGE',/,  
C    *'   JUNCTION  JUNCTION    NUMBER      TYPE  HEIGHT (M)   TOP (M)  
C    *LENGTH (M)   COEFFICIENT',/,  
C    *'   --------  --------    ------      ----  ----------   -------  
C    *----------   -----------')  
 5485 FORMAT(1X,3I10,I10,F12.2,F10.2,F12.2,F14.4,7X,I1,10X,F5.1,7X,  
     +F13.4,F17.2)  
 5486 FORMAT(1X,3A10,I10,F12.2,F10.2,F12.2,F14.4,7X,I1,10X,F5.1,7X,  
     +F13.4,F17.2)  
C  BAC END   WWWWW  
 5487 FORMAT(1X,4I10,F12.2,F10.2,F12.2,F14.4)  
 5488 FORMAT(1X,3A10,I10,F12.2,F10.2,F12.2,F14.4)  
 5490 FORMAT(/,' ====> ERROR  WEIR JUNCTION',I10,  
     1       ' IS NOT CONTAINED IN JUNCTION DATA')  
 5491 FORMAT(/,' ====> ERROR  WEIR JUNCTION ',A10,  
     1       ' IS NOT CONTAINED IN JUNCTION DATA')  
 5484 FORMAT(/,' ====> ERROR  STORAGE JUNCTION ',A10,  
     1' IS NOT CONTAINED IN JUNCTION DATA')  
 5494 FORMAT(/,' ====> ERROR  STORAGE JUNCTION ',I10,  
     1' IS NOT CONTAINED IN JUNCTION DATA')  
 5495 FORMAT(  
     +'                                MAXIMUM OR          PEAK OR     '  
     +,'   CROWN  ',/,  
     +' STORAGE JUNCTION  JUNCTION  CONSTANT SURFACE   CONSTANT VOLUME '  
     +,' ELEVATION',/,  
     +'   NUMBER OR NAME      TYPE     AREA (FT2)        (CUBIC FEET)  '  
     +,'    (FT)  ',/,  
     +'   --------------  --------  ----------------   --------------- '  
     +,' ---------')  
 5496 FORMAT(  
     +'                                MAXIMUM OR          PEAK OR     '  
     +,'   CROWN  ',/,  
     +' STORAGE JUNCTION  JUNCTION  CONSTANT SURFACE   CONSTANT VOLUME '  
     +,' ELEVATION',/,  
     +'   NUMBER OR NAME      TYPE     AREA  (M2)        (CUBIC MET.)  '  
     +,'     (M)  ',/,  
     +'   --------------  --------  ----------------   --------------- '  
     +,' ---------')  
CIM PP  NEW PUMP OUTPUT 5/1/97  
 5560 FORMAT(//,  
     +' *********************************************',/,  
     +' *                 PUMP DATA                 *',/,  
     +' *********************************************',//)  
 5562 FORMAT(5X,'PUMP NUMBER ',I3,' PUMPED JUNCTION = ',I10,  
     1'    RECEIVING JUNCTION = ',I10)  
 5564 FORMAT(5X,'PUMP NUMBER ',I3,' PUMPED JUNCTION = ',A10,  
     1'    RECEIVING JUNCTION = ',A10)  
 5566 FORMAT(/,5X,'OFF-LINE PUMP (IPTYP = 1)   INITIAL STORAGE',  
     1' VOLUME = ',F10.3,' CU. FT.')  
 5570 FORMAT(/,5X,'OFF-LINE PUMP (IPTYP = 1)   INITIAL STORAGE',  
     1' VOLUME = ',F10.3,' CU. M.')  
 5568 FORMAT(/,'          WET WELL VOLUMES',/,  
     1'          GREATER THAN         AND LESS            PUMPING',/,  
     2'           OR EQUAL              THAN                RATE',/,  
     3'            (FT^3)              (FT^3)              (CFS)')  
 5576 FORMAT(/,5X,'IN-LINE PUMP (IPTYP = 2)')  
 5578 FORMAT(/,'          PUMPED JUNCTION DEPTHS',/,  
     1'          GREATER THAN         AND LESS            PUMPING',/,  
     2'           OR EQUAL              THAN                RATE',/,  
     3'             (FT)                (FT)               (CFS)')  
 5574 FORMAT(3F20.3)  
 5582 FORMAT(F20.3,20X,F20.3)  
 5584 FORMAT(/,5X,'PUMP CURVE DATA (IPTYP = 3)   PUMP ON AT JUNCTION',  
     1' DEPTH = ',F10.3,' FEET.   PUMP OFF AT JUNCTION DEPTH = ',  
     2F10.3,' FEET.')  
 5586 FORMAT(/,  
     1'                                                   PUMPING',/,  
     2'          JUNCTION HEAD DIFFERENCE                   RATE',/,  
     3'                   (FEET)                           (CFS)')  
 5592 FORMAT(F25.3,F30.3)  
 5594 FORMAT(/,5X,'VARIABLE SPEED PUMP CURVE DATA (IPTYP = 4)')  
 5596 FORMAT('                      PUMPED',/,  
     1'                     JUNCTION                      PUMPING',/,  
     2'                      DEPTH                          RATE',/,  
     3'                       (FT)                         (CFS)')  
 5600 FORMAT('          Pumping rate is linearly interpolated from ',  
     1'the above values.')  
 5602 FORMAT('          Pumping rate equals ',F10.3,' cfs for depths ',  
     1'less than ',F10.3,' feet.')  
 5604 FORMAT('          Pumping rate equals ',F10.3,' cfs for depths ',  
     1'greater than ',F10.3,' feet.')  
 5572 FORMAT(/,'         WET WELL VOLUMES',/,  
     1'          GREATER THAN         AND LESS            PUMPING',/,  
     2'           OR EQUAL              THAN                RATE',/,  
     3'             (M^3)               (M^3)              (M3/S)')  
 5580 FORMAT(/,'          PUMPED JUNCTION DEPTHS',/,  
     1'          GREATER THAN         AND LESS            PUMPING',/,  
     2'           OR EQUAL              THAN                RATE',/,  
     3'             (M)                 (M)                (M3/S)')  
 5588 FORMAT(/,5X,'PUMP CURVE DATA (IPTYP = 3)   PUMP ON AT JUNCTION',  
     1' DEPTH = ',F10.3,' METERS.   PUMP OFF AT JUNCTION DEPTH = ',  
     2F10.3,' METERS.')  
 5590 FORMAT(/,  
     1'                                                   PUMPING',/,  
     2'          JUNCTION HEAD DIFFERENCE                   RATE',/,  
     3'                  (METERS)                          (M3/S)')  
 5598 FORMAT(/,'                      PUMPED',/,  
     1'                     JUNCTION                      PUMPING',/,  
     2'                      DEPTH                          RATE',/,  
     3'                        (M)                         (M3/S)')  
 5606 FORMAT('          Pumping rate equals ',F10.3,' M3/S for depths ',  
     1'less than ',F10.3,' meters.')  
 5608 FORMAT('          Pumping rate equals ',F10.3,' M3/S for depths ',  
     1'greater than ',F10.3,' meters.')  
 5575 FORMAT(/,' ====> ERROR  CANNOT HAVE EQUAL VRATE (HEAD) VALUES',  
     *' ON PUMP CURVE (TO AVOID ZERO DIVIDE UPON INTERPOLATION).',/,  
     *'       MUST PROVIDE AT LEAST MINIMAL HEAD DIFFERENCE.')  
 8100 FORMAT(/,5X,'LIFT STATION TYPE PUMP DATA (IPTYP = 5)',/)  
 8102 FORMAT(10X,'PUMP #',I2,' HAS A CAPACITY OF ',F10.3,A3,  
     1' AND STARTS AT A DEPTH OF ',F10.3,A2)  
 8104 FORMAT(/,10X,'ALL PUMPS TURN OFF WHEN DEPTH EQUALS ',F10.3,A2,/,  
     110X,'PUMPS DELAY',F10.3,' SECONDS TO INCREASE FROM ZERO FLOW',  
     2' TO CAPACITY')  
CIM  
 9010 FORMAT(\,' ===> ERROR  VRATES MUST BE INPUT IN INCREASING ',  
     a'ORDER FOR IPTYP 1, 2, AND 4 PUMPS.')  
 9020 FORMAT(\,' ===> ERROR  VRATES MUST BE INPUT IN DECREASING ',  
     a'ORDER FOR IPTYP 3 PUMPS.')  
CIM  
 5610 FORMAT(/,' ====> ERROR  PUMP JUNCTION ',I10,  
     +     ' IS NOT CONTAINED IN THE JUNCTION DATA')  
 5611 FORMAT(/,' ====> ERROR  PUMP JUNCTION ',A10,  
     +     ' IS NOT CONTAINED IN THE JUNCTION DATA')  
 5615 FORMAT(/,' ====> ERROR   MORE THAN ONE PIPE IS INFLUENT TO OFF-  
     .LINE PUMP JUNCTION ',I10)  
 5614 FORMAT(/,' ====> ERROR   MORE THAN ONE PIPE IS INFLUENT TO OFF-  
     .LINE PUMP JUNCTION ',A10)  
 8010 FORMAT ('ERROR ==> The number of pumps exceeds the maximum',  
     +' allowed by the program dimensions (NEP = ',I10,')',/,10X,  
     +'Change NEP in TAPES.INC and recompile')  
 5616 FORMAT(//,  
     +' **************************************************',/,  
     +' *          FREE OUTFALL DATA (DATA GROUP I1)     *',/,  
     +' *         BOUNDARY CONDITION ON DATA GROUP J1    *'/,  
     +' **************************************************',/)  
 5620 FORMAT(' OUTFALL AT JUNCTION....',I10,  
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10)  
 5621 FORMAT(' OUTFALL AT JUNCTION....',A10,  
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10)  
 5630 FORMAT(/,' ====> ERROR   FREE OUTFALL JUNCTION ',I10,' IS NOT',  
     1       ' CONTAINED IN JUNCTION DATA')  
 5631 FORMAT(/,' ====> ERROR   FREE OUTFALL JUNCTION ',A10,' IS NOT',  
     1       ' CONTAINED IN JUNCTION DATA')  
 8015 FORMAT ('ERROR ==> The number of free outfall exceeds the ',  
     +'maximum number',  
     +' allowed by the program dimensions (NTG = ',I10,')',/,10X,  
     +'Change NTG in TAPES.INC and recompile')  
 5656 FORMAT(//,  
     +' ***********************************************',/,  
     +' *    TIDE GATE OUTFALL DATA (DATA GROUP I2)   *',/,  
     +' *      BOUNDARY CONDITION ON DATA GROUP J1    *'/,  
     +' ***********************************************',/)  
 5660 FORMAT(' OUTFALL AT JUNCTION....',I10,  
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10)  
 5661 FORMAT(' OUTFALL AT JUNCTION... ',A10,  
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10)  
 5662 FORMAT(/,' ====> ERROR   TIDE GATE JUNCTION ',I10,' IS NOT',  
     1       ' CONTAINED IN JUNCTION DATA')  
 5663 FORMAT(/,' ====> ERROR   TIDE GATE JUNCTION ',A10,' IS NOT',  
     1       ' CONTAINED IN JUNCTION DATA')  
 8020 FORMAT ('ERROR ==> The number of outfall with tide gates ',  
     +'exceeds the maximum number',  
     +' allowed by the program dimensions (NTG = ',I10,')',/,10X,  
     +'Change NTG in TAPES.INC and recompile')  
 5665 FORMAT(//,  
     +' **************************************************',/,  
     +' *        INTERNAL CONNECTIVITY INFORMATION       *',/,  
     +' **************************************************',/)  
 5670 FORMAT('          CONDUIT     JUNCTION     JUNCTION',/,  
     +       '          -------     --------     --------')  
 5671 FORMAT('     CONDUIT      JUNCTION     JUNCTION',/,  
     +       '     -------      --------     --------')  
 5675 FORMAT(4X,I11,2I13)  
 5676 FORMAT(/,' ====> ERROR  TOTAL NUMBER OF JUNCTIONS(INCLUDING WEI  
     1RS) EXCEED PROGRAM DIMENSIONS, NEE =',I4)  
 5677 FORMAT(/,' ====> ERROR  TOTAL NUMBER OF LINKS EXCEEDS PROGRAM D  
     1IMENSIONS, NEE =',I4)  
 5685 FORMAT(5X,A10,3X,A10,3X,A10)  
CIM START OOOOOOOOOO  
 6010 FORMAT(/,' ====> EQUIVALENT CIRCULAR PIPE INFORMATION ',  
     .       'FOR ORIFICE # ',I7,/,  
     .       '       CONDUIT NUMBER..........................',I10,/,  
     .       '       PIPE DIAMETER........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.5,/,  
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/,  
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4)  
 6011 FORMAT(/,' ====> EQUIVALENT CIRCULAR PIPE INFORMATION ',  
     .       'FOR ORIFICE # ',I7,/,  
     .       '       CONDUIT NAME........................... ',A10,/,  
     .       '       PIPE DIAMETER........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.5,/,  
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/,  
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4)  
 6012 FORMAT(/,' ====> EQUIVALENT RECTANGULAR PIPE INFORMATION',  
     .       ' FOR ORIFICE # ',I7,/,  
     .       '       CONDUIT NUMBER..........................',I10,/,  
     .       '       PIPE DEPTH...........................',F12.2,/,  
     .       '       PIPE WIDTH...........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.5,/,  
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/,  
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4)  
 6013 FORMAT(/,' ====> EQUIVALENT RECTANGULAR PIPE INFORMATION ',  
     .               'FOR ORIFICE # ',I7,/,  
     .       '       CONDUIT NAME........................... ',A10,/,  
     .       '       PIPE DEPTH...........................',F12.2,/,  
     .       '       PIPE WIDTH...........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.5,/,  
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/,  
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4)  
 6014 FORMAT(/,'       INVERT CHANGES AS GATE OPENS AND CLOSES')  
  660 FORMAT(/,' ====> TIME CLOSURE GATE DATA FOR ORIFICE # ',I7,/,  
     .       '       CONTROL JUNCTION NAME............... ',I10,/,  
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/,  
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/,  
     .       '       CLOSED AREA..........................',F12.2,/,  
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/,  
     .       '       DIRECTION CONTROL....................',I12,/,  
     .       '       PRINT OPTION.........................',I12)  
  661 FORMAT(/,' ====> TIME CLOSURE GATE DATA FOR ORIFICE # ',I7,/,  
     .       '       CONTROL JUNCTION NAME............... ',A10,/,  
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/,  
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/,  
     .       '       CLOSED AREA..........................',F12.2,/,  
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/,  
     .       '       DIRECTION CONTROL....................',I12,/,  
     .       '       PRINT OPTION.........................',I12)  
  662 FORMAT(/,' ====> HEAD DEPENDENT CLOSURE GATE DATA FOR ORIFICE # '  
     .       ,I7,/,  
     .       '       CONTROL JUNCTION NAME............... ',I10,/,  
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/,  
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/,  
     .       '       CLOSED AREA..........................',F12.2,/,  
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/,  
     .       '       DIRECTION CONTROL....................',I12,/,  
     .       '       PRINT OPTION.........................',I12)  
  663 FORMAT(/,' ====> HEAD DEPENDENT CLOSURE GATE DATA FOR ORIFICE # '  
     .       ,I7,/,  
     .       '       CONTROL JUNCTION NAME............... ',A10,/,  
     .       '       DEPTH AT WHICH GATE OPENS............',F12.2,/,  
     .       '       DEPTH AT WHICH GATE CLOSES...........',F12.2,/,  
     .       '       CLOSED AREA..........................',F12.2,/,  
     .       '       MINIMUM CLOSURE TIME (HOURS).........',F12.5,/,  
     .       '       DIRECTION CONTROL....................',I12,/,  
     .       '       PRINT OPTION.........................',I12)  
CIM END   OOOOOOOOOO  
CIM START <><><><><><><>  
 5350 FORMAT(/,' ===> JUNCTION ',I10,  
     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT, PUMP STATION, ',  
     2         'WEIR, OR ORIFICE.')  
 5351 FORMAT(/,' ===> JUNCTION ',A10,  
     1         ' IS NOT ASSOCIATED WITH ANY CONDUIT, PUMP STATION, ',  
     2         'WEIR, OR ORIFICE.')  
 5352 FORMAT(/,' ERROR  ',I5,' JUNCTIONS ARE NOT CONNECTED ',/,  
     1         ' RUN IS STOPPED')  
 7000 FORMAT(' ERROR - ORIFICE TYPE NOT VALID FOR ORIFICE ',  
     A'NJUNC1 = ',I10,' NJUNC2 = ',I10,' NKLASS = ',I10)  
 7001 FORMAT(' ERROR - ORIFICE TYPE NOT VALID FOR ORIFICE ',  
     A'KJUNC1 = ',A10,' KJUNC2 = ',A10,' NKLASS = ',I10)  
CIM END     <><><><><><>  
 6660 FORMAT(//,  
     +' ***********************************************',/,  
     +' *               WEIR OUTFALL DATA             *',/,  
     +' *      BOUNDARY CONDITION ON DATA GROUP J1    *'/,  
     +' ***********************************************',/)  
 6665 FORMAT(' WEIR OUTFALL AT JUNCTION....',I10,  
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10)  
 6670 FORMAT(' WEIR OUTFALL AT JUNCTION... ',A10,  
     +       ' HAS BOUNDARY CONDITION NUMBER...',I10)  
 6680 FORMAT(//,  
     +' ***********************************************',/,  
     +' *               PUMP OUTFALL DATA             *',/,  
     +' *      BOUNDARY CONDITION ON DATA GROUP H1    *'/,  
     +' ***********************************************',/)  
C#### WCH, 1/23/95.  
 7005 FORMAT(15X,'WARNING - ZCROWN IS GREATER THAN GROUND ELEVATION.',  
     1'  GROUND ELEVATION IS SET TO ZCROWN + 0.1')  
 7010 FORMAT(15X,'WARNING - MAXIMUM SURCHARGE ELEVATION IS LESS THAN',  
     1' GROUND ELEVATION.  SURCHARGE ELEVATION IS SET EQUAL TO THE',  
     2' GROUND ELEVATION')  
 9119 FORMAT(/,' ERROR ===> NUMST on line E1 is greater than allowed by  
     1 NVST on the parameter statement on TAPES.INC')  
 8005 FORMAT(/,' WARNING ===> At storage junction ',I10,' the user ',  
     +'input ZTOP equals ',F10.3,/,14X,' which is less than the top ',  
     +'of the highest pipe entering the junction (',f10.3,')',/,14X,  
     +' ZTOP is set equal to highest crown elevation')  
 8006 FORMAT(/,' WARNING ===> At storage junction ',A10,' the user ',  
     +'input ZTOP equals ',F10.3,/,14X,' which is less than the top ',  
     +'of the highest pipe entering the junction (',F10.3,')',/,14X,  
     +' ZTOP is set equal to highest crown elevation')  
 8011 FORMAT(' >>NOTE, ROUTINE ADJUSTMENT of downstream orifice junction  
     a- Invert of junction ID ',I10,' was lowered to equal ',F10.3,  
     b' to allow for bottom outlet orifice.  Connecting channel slopes n  
     cot affected.')  
 8012 FORMAT(' >>NOTE, ROUTINE ADJUSTMENT of downstream orifice junction  
     a- Invert of junction ID ',A10,' was lowered to equal ',F10.3,  
     b' to allow for bottom outlet orifice.  Connecting channel slopes n  
     cot affected.')  
 8330 FORMAT('ERROR - TOO MANY CONDUITS ENTERING JUNCTION ',I10,/,  
     +'Change connectivity or increase NCHN in TAPES.INC and ',  
     +'recompile program or add dummy links.')  
 8331 FORMAT('ERROR - TOO MANY CONDUITS ENTERING JUNCTION ',A10,/,  
     +'Change connectivity or increase NCHN in TAPES.INC and ',  
     +'recompile program or add dummy links.')  
 8400	FORMAT(10X,'PUMP TURNS ON WHEN DEPTH EQUALS  ',F10.3,'FEET',/,  
     1       10X,'PUMP TURNS OFF WHEN DEPTH EQUALS ',F10.3,'FEET')  
 8500 FORMAT(5X,'WARNING - NO BOUNDARY WAS SPECIFIED ON I1 OR I2 LINES.'  
     A,'  MOST MODELS WILL HAVE AT LEAST ONE BOUNDARY SPECIFIED')  
C=======================================================================  
      END  
ECHO is off.
REM File: INDAT3.FOR  
ECHO is off.
      SUBROUTINE INDAT3  
C	EXTRAN BLOCK  
C	CALLED BY EXTRAN NEAR LINE 200  
C=======================================================================  
C     THIS SUBROUTINE READS DATA GROUPS J1-J4, EXCEPT FOR THE INPUT  
C          HYDROGRAPH LINES READ BY SUBROUTINE INFLOW.  IT ALSO PERFORMS  
C          SOME INITIALIZATION.  ALL NODE-CONDUIT LINKAGES ARE  
C          SET UP AND CONVERTED TO THE INTERNAL NUMBER SYSTEM.  
C     CORRECTION TO J4 READ BY WCH, 4/1/93  
C     CORRECTION FOR INITIAL DATE BY RED, 5/12/93  
C     CONVERT OPTIONAL USER-INPUT INITIAL DATE TO JULIAN, WCH, 4/11/94.  
C     ENHANCE ERROR MESSAGE FOR MIS-MATCH OF INPUT NODES, WCH, 11/10/94.  
C     ADD PRINT-OUT FOR K2 INPUT LOCATION LIST AND CHECK FOR DUPLICATE  
C       LOCATIONS ON THAT LIST, WCH, 10/17/95.  
C     ALLOW MIS-MATCH OF INTERFACE FILE JUNCTIONS AND EXTRAN JUNCTIONS.  
C       EXTRAN WILL IGNORE INFLOW FROM UN-MATCHED JUNCTS, WCH, 10/17/95.  
C     COMPUTE CORRECT TIME DISPLACEMENT FOR EXTRAN STARTING DATE/TIME  
C       WHEN USING HOT START WITH INTERFACE FILE, WCH, 7/25/96.  
C     SET INITIAL DATE (IDATEZ) TO B1-LINE VALUE (IDATZ) IF  
C       IDATZ ENTERED AS NEGATIVE NUMBER, WCH, 11/12/99.  
C     IMPROVE ERROR CHECK AND MESSAGES FOR K_ LINES 9/8/00 CIM  
C     ADD ERROR MESSAGE FOR NTIDE = 4.  WCH, 3/26/01.  
C     ALSO USE B1 TZERO IF NEGATIVE IDATZ, RED, 5/7/01.  
C	ERROR MESSAGE FOR INCOMPATIBLE $ANUM. WCH, 4/18/02.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'BD.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'ORF.INC'  
      INCLUDE 'WEIR.INC'  
      INCLUDE 'BND.INC'  
      INCLUDE 'OUT.INC'  
      INCLUDE 'TIDE.INC'  
      INCLUDE 'HYFLOW.INC'  
CIM  NEW COMMON FOR WRITING OF RESULTS TO ASCII FILE  
      INCLUDE 'CWRITE.INC'  
CIM  
      DIMENSION LOCNOS(NIE)  
      CHARACTER KSW(NEH)*10,KOCNOS(NIE)*10  
C======================================================================  
C     Read tidal boundary data on data gouups J1-J4.  
C======================================================================  
      M2S2      = 0  
      DO 1800 I = 1,NTE  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.NE.'J1') GO TO 1801  
      IF(I.EQ.1) WRITE(N6,5710)  
      READ(N5,*,ERR=888) CC,NTIDE(I)  
      M2S2 = M2S2 + 1  
C======================================================================  
C     NTIDE = 1  NO CONTROL WATERSURFACE AT THE OUTFALLS  
C             2  OUTFALL CONTROL WATER SURFACE AT CONSTANT ELEVATION=A1  
C             3  TIDE COEFFICIENTS READ BY PROGRAM FROM INPUT FILE  
C             4  COMPUTE TIDE COEFFICIENTS  
cimtide  
C             5  Stage-time history of water surface elevations input  
C                by user on J3 line.  
C             6  Stage time histories of water surface elevation input  
C                on separate file (NSCRAT4)  
cimtide  
C======================================================================  
      IF(NTIDE(I).EQ.1) WRITE(N6,5715) I  
      IF(NTIDE(I).EQ.2) THEN  
C J2 line  
             READ(N5,*,ERR=888) CC,A1(I)  
             IF(METRIC.EQ.1) WRITE(N6,5790) I,A1(I)  
             IF(METRIC.EQ.2) WRITE(N6,5791) I,A1(I)  
             PHLAGS(I) = 0.0  
             ENDIF  
      IF(NTIDE(I).EQ.3) THEN  
C J2 line  
         READ(N5,*,ERR=888) CC,A1(I),W(I),A2(I),  
     1                      A3(I),A4(I),A5(I),A6(I),A7(I)  
         WRITE(N6,5780) I,A1(I),A2(I),A3(I),A4(I),A5(I),A6(I),A7(I),W(I)  
         W(I)      = 2.0*3.14159/W(I)  
         PHLAGS(I) = 0.0  
         ENDIF  
C======================================================================  
C     READ DATA GROUPS J2, J3 AND J4  
C======================================================================  
      IF(NTIDE(I).EQ.4) THEN  
C J2 line  
         READ(N5,*,ERR=888) CC,A1(I),W(I)  
C J3 line  
         READ(N5,*,ERR=888) CC,KO,NI,NCHTID,DELTA  
         NUMTID(I)  = NI  
         IF(DELTA.LE.0.0) THEN  
                          IF(METRIC.EQ.1) DELTA = 0.005  
                          IF(METRIC.EQ.2) DELTA = 0.001524  
                          ENDIF  
C#### WCH, 4/1/93  INSERT CHECK ON NUMBER OF DATA POINTS.  
         IF(NI.GT.NTVAL) THEN  
           WRITE (N6,5707) I,NTIDE(I),NI,NTVAL  
           NSTOP = NSTOP + 1  
           ENDIF  
Cwch, 3/26/01.  If KO = 1 then NI should = 4 for Sub. TIDCF to work OK.  
         IF(KO.EQ.1.AND.NI.NE.4) THEN  
	     WRITE (N6,5708) I,NI  
	     NSTOP = NSTOP + 1  
	     ENDIF  
         DO 1765  K = 1,NI,5  
         J1         = K + 4  
         IF(J1.GT.NI) J1 = NI  
C J4 line  
 1765    READ(N5,*,ERR=888) CC,(TT(J),YY(J),J=K,J1)  
         CALL TIDCF(KO,NI,NCHTID,I,DELTA)  
         ENDIF  
C=======================================================================  
C        READ DOWNSTREAM BOUNDARY STAGE INFORMATION  
C        READ DATA GROUPS J3 AND J4  
C=======================================================================  
      IF(NTIDE(I).EQ.5) THEN  
C J3 line  
         READ(N5,*,ERR=888) CC,KO,NI,NCHTID  
C#######################################################################  
C  WCH, 4/1/93.  FIX J4 READ WITH NTIDE=5 TO READ 5 VALUES PER LINE,  
C                WITH LINE IDENTIFIER.  
C#######################################################################  
         IF(NI.GT.NTVAL) THEN  
           WRITE (N6,5707) I,NTIDE(I),NI,NTVAL  
           NSTOP = NSTOP + 1  
           ENDIF  
         DO 1770  K = 1,NI,5  
         J1 = K + 4  
         IF(J1.GT.NI) J1 = NI  
C J4 line  
 1770    READ(N5,*,ERR=888) CC,(STIDE(I,1,J),STIDE(I,2,J),J=K,J1)  
C  
         IF(NCHTID.EQ.1) THEN  
                   IF(METRIC.EQ.1) WRITE(N6,1780) I  
                   IF(METRIC.EQ.2) WRITE(N6,1785) I  
                   WRITE(N6,1790) (J,STIDE(I,1,J),STIDE(I,2,J),J=1,NI)  
                   ENDIF  
         NUMTID(I) = NI  
         PHLAGS(I) = 0.0  
         ENDIF  
cimtide  
C=======================================================================  
C        READ DOWNSTREAM BOUNDARY STAGE INFORMATION FROM SEPARATE FILE  
C        NTIDE = 6  
C        CALL INTIDEF TO INITIALIZE TIDE STUFF  
C=======================================================================  
      IF(NTIDE(I).EQ.6) CALL INTIDEF  
CIMTIDE  
 1800 CONTINUE  
 1801 CONTINUE  
C=======================================================================  
C     CHECK JTIDES ARRAY FOR BC'S NOT INPUT ON J1-J4 DATA GROUPS  
C=======================================================================  
      DO 1850 J = 1,NJ  
      IF(JTIDES(J).LE.M2S2) GO TO 1850  
cimtide  
      if(jtides(j).gt.10000) go to 1850  
cimtide  
      IF(JCE.EQ.0) THEN  
        WRITE(N6,1851)  JUN(J),JTIDES(J)  
      ELSE  
       WRITE(N6,1852) AJUN(J),JTIDES(J)  
      ENDIF  
      NSTOP     = NSTOP + 1  
 1850 CONTINUE  
C=======================================================================  
C     SET PRINT : PLOT ARRAYS IN INTERNAL NUMBER SYSTEM  
C=======================================================================  
      IF(NQPRT.GT.0) THEN  
               DO 1550 K = 1,NQPRT  
               DO 1540 N = 1,NTL  
               IF(JCE.EQ.0.AND.NCOND(N).EQ.CPRT(K))   GO TO 1545  
               IF(JCE.EQ.1.AND.ACOND(N).EQ.AOUT(K,2)) GO TO 1545  
 1540          CONTINUE  
               IF(JCE.EQ.0) THEN  
                 WRITE(N6,5678) CPRT(K)  
               ELSE  
                 WRITE(N6,5679) AOUT(K,2)  
               ENDIF  
               NSTOP   = NSTOP+1  
 1545          CPRT(K) = N  
 1550          CONTINUE  
               ENDIF  
C=======================================================================  
      IF(LPLT.GT.0) THEN  
                    DO 1620 K = 1,LPLT  
                    DO 1580 N = 1,NTL  
                    IF(JCE.EQ.0.AND.NCOND(N).EQ.KPLT(K))   GO TO 1600  
                    IF(JCE.EQ.1.AND.ACOND(N).EQ.AOUT(K,4)) GO TO 1600  
 1580               CONTINUE  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5680) KPLT(K)  
                    ELSE  
                      WRITE(N6,5681) AOUT(K,4)  
                    ENDIF  
                    NSTOP = NSTOP+1  
                    GO TO 1620  
 1600               KPLT(K) = N  
 1620               CONTINUE  
                    ENDIF  
C=======================================================================  
      IF(NHPRT.GT.0) THEN  
                     DO 1660 I = 1,NHPRT  
                     DO 1650 J = 1,NJ  
                     IF(JCE.EQ.0.AND.JUN(J).EQ.JPRT(I))    GO TO 1655  
                     IF(JCE.EQ.1.AND.AJUN(J).EQ.AOUT(I,1)) GO TO 1655  
 1650                CONTINUE  
                     IF(JCE.EQ.0) THEN  
                      WRITE(N6,5690) JPRT(I)  
                     ELSE  
                      WRITE(N6,5691) AOUT(I,1)  
                     ENDIF  
                     NSTOP   = NSTOP+1  
 1655                JPRT(I) = J  
 1660                CONTINUE  
                     ENDIF  
C=======================================================================  
      IF(NPLT.GT.0) THEN  
                    DO 1720 N = 1,NPLT  
                    DO 1680 J = 1,NJ  
                    IF(JCE.EQ.0.AND.JUN(J).EQ.JPLT(N)) GO TO 1700  
                    IF(JCE.EQ.1.AND.AJUN(J).EQ.AOUT(N,3)) GO TO 1700  
 1680               CONTINUE  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5700) JPLT(N)  
                    ELSE  
                      WRITE(N6,5701) AOUT(N,3)  
                    ENDIF  
                    NSTOP = NSTOP+1  
                    GO TO 1720  
 1700               JPLT(N) = J  
 1720               CONTINUE  
                    ENDIF  
C=======================================================================  
      IF(NSURF.GT.0) THEN  
                     DO 1730 K = 1,NSURF  
                     DO 1740 N = 1,NTL  
                     IF(JCE.EQ.0.AND.NCOND(N).EQ.JSURF(K))  GO TO 1735  
                     IF(JCE.EQ.1.AND.ACOND(N).EQ.AOUT(K,5)) GO TO 1735  
 1740                CONTINUE  
                     IF(JCE.EQ.0) THEN  
                       WRITE(N6,5705) JSURF(K)  
                     ELSE  
                       WRITE(N6,5706) AOUT(K,5)  
                     ENDIF  
                     NSTOP = NSTOP+1  
                     GO TO 1730  
 1735                JSURF(K) = N  
 1730                CONTINUE  
                     ENDIF  
C=======================================================================  
CIM WRITING OF RESULTS TO ASCII FILE  
CIM  FIRST FIND CONDUIT NUMBER FOR ALL FLOWOUT OR AFLWOUT  
      IF(NOFLOW.GT.0) THEN  
                     DO 1751 K = 1,NOFLOW+NOFDUP  
                     DO 1750 N = 1,NTL  
                     IF(JCE.EQ.0.AND.NCOND(N).EQ.FLOWOUT(K))  GO TO 1755  
                     IF(JCE.EQ.1.AND.ACOND(N).EQ.AFLWOUT(K))  GO TO 1755  
 1750                CONTINUE  
                     IF(JCE.EQ.0) THEN  
                       WRITE(N6,5805) FLOWOUT(K)  
                     ELSE  
                       WRITE(N6,5806) AFLWOUT(K)  
                     ENDIF  
                     NSTOP = NSTOP+1  
                     GO TO 1751  
 1755                FLOWOUT(K) = N  
 1751                CONTINUE  
CIM NOW FIND REFERENCE FOR DUPLICATES  
                     DO 1760 K =1,NOFDUP  
                     DO 1761 N = 1,NOFLOW  
                     NN = FLOWOUT(N)  
CIM                  WRITE(N6,*) K,N,NN,ACOND(NN),AFLOWREF(K)  
                     IF (JCE.EQ.0.AND.NCOND(NN).EQ.FLOWREF(K))  
     1                             GO TO 1766  
                     IF (JCE.EQ.1.AND.ACOND(NN).EQ.AFLOWREF(K))  
     1                             GO TO 1766  
 1761                CONTINUE  
                     IF (JCE.EQ.0) THEN  
                       WRITE(N6,6807) FLOWREF(K),K  
                     ELSE  
                       WRITE(N6,6808) AFLOWREF(K),K  
                     ENDIF  
                     NSTOP = NSTOP + 1  
                     GO TO 1760  
 1766                FLOWREF(K) = N  
 1760                CONTINUE  
                     ENDIF  
CIM END  
C======================================================================  
C     Conduit roughness initialization.  
C======================================================================  
      DO 1820 N = 1,NTC  
 1820 ROUGH(N)  = GRVT*ROUGH(N)**2/CMET(9,METRIC)**2  
C======================================================================  
C     Hydrograph input initialization.  
C======================================================================  
      DO 1840  L = 1,NIE  
      DO 1840 K  = 1,2  
 1840 QTAPE(L,K) = 0.0  
      DO 1841  L = 1,NEH  
      JSW(L)     = 0  
      DO 1841  K = 1,2  
 1841 QCARD(L,K) = 0.0  
C======================================================================  
C     Read input hydrograph information (disk file).  
C======================================================================  
      LOCATS = 0  
      TIMDAY = TZERO  
C#### WCH, 4/11/94.  CODE TO CONVERT INITIAL YR/MO/DAY TO JULIAN.  
CWCH, 11/12/99. USE B1-LINE IDATZ IF ENTERED AS NEGATIVE NUMBER.  
	IISIGN = ISIGN(1,IDATZ)  
	IDATZ  = IABS(IDATZ)  
      MYEAR  = IDATZ/10000  
      MDAY   = IDATZ - MYEAR*10000  
      MMNTH  = MDAY/100  
      MDAY   = MDAY - MMNTH*100  
      IF (MYEAR.LT.100) MYEAR = MYEAR+1900  
      JULDAY = 1000*MYEAR + JDATE(MDAY,MMNTH,MYEAR)  
      IDATEZ = JULDAY  
	IDATZ  = IDATEZ  
C####     JULDAY = 88001  
C  
      IF(LAST.GT.0) THEN  
C#### WCH, 7/25/96.  
                    TZEROX = TZERO  
                    CALL INFACE(1,LAST)  
C=======================================================================  
Cwch, 4/18/02.  Add error check for incompatible JCE.  
C	Allow program to continue but warn of impending error.   
C=======================================================================  
                    IF(NJCE.NE.JCE) THEN  
	                   WRITE(N6,4005)   
	                   WRITE(*,4005)  
	    ENDIF  
C#######################################################################  
C#### WCH, 7/25/96.  ALWAYS START AT DATE GIVEN ON INTERFACE  
C     FILE, PLUS TZERO (HOURS) GIVEN ON LINE B1.  
C=======================================================================  
c                    IF(JREDO.EQ.1.OR.JREDO.EQ.3) THEN  
cim doesn't this next line double count TZERO???  
Cim                       TZEROS = TZEROX + TZERO  
                         TZEROS = TZEROX  
                         TIMDAY = TZERO  
CWCH, 11/12/99. USE B1-LINE IDATZ IF ENTERED AS NEGATIVE NUMBER.  
cred            also use the B1 line for the starting time of the  
cred            day and not the interface starting time if the   
cred            date on line B1 is entered as a negative - 5/7/01  
					   IF(IISIGN.LT.0) THEN  
					     IDATEZ = IDATZ  
	                     TZEROS = TZEROX  
                           TIMDAY = TZEROX  
	                     ENDIF  
                         JULDAY = IDATEZ  
C=======================================================================  
C     NDATE computes new Julian date (JDAY) and time of day (TMDAY, sec)  
C     by adding TZEROS (sec) to current Julian date (JULDAY) and time  
C     of day (TIMDAY, sec).  
C=======================================================================  
                         CALL NDATE(TZEROS,JDAY,TMDAY)  
                         JULDAY = JDAY  
                         TIMDAY = TMDAY  
C=======================================================================  
C     DATED computes year, month, day etc. from current Julian day and  
C     time of day.  
C=======================================================================  
                         CALL DATED  
                         WRITE(N6,5815) JULDAY,NYEAR,MONTH,NDAY,  
     +                      TIMDAY/3600.,TZEROX/3600.  
c                         ELSE  
c                         TIMDAY = TZERO  
c                         JULDAY = IDATEZ  
ccim add call to dated  
c                         CALL DATED  
c                         ENDIF  
C======================================================================  
C                   CONVERT TO INTERNAL NUMBERS  
C======================================================================  
                    DO 1920 L = 1,LOCATS  
                    DO 1880 J = 1,NJ  
                    IF(JCE.EQ.0.AND.NLOC(L).EQ.JUN(J)) GO TO 1900  
                    IF(JCE.EQ.1.AND.KAN(L).EQ.AJUN(J)) GO TO 1900  
 1880               CONTINUE  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5820) NLOC(L)  
                    ELSE  
                      WRITE(N6,5821) KAN(L)  
                    ENDIF  
C#### WCH, 10/17/95.  CHANGE TO WARNING IF NO MATCH.  
C####                    NSTOP   = NSTOP + 1  
                    NLOC(L) = 0  
                    GO TO 1920  
 1900               NLOC(L) = J  
 1920               CONTINUE  
                    ENDIF  
      write(n6,*) ' TZERO = ',JULDAY,timday  
C======================================================================  
C     Read input hydrograph data (lines) on data groups K1-K3.  
C======================================================================  
      IF(NJSW.GT.0) THEN  
C======================================================================  
C    >>>>>>>>>>>>> READ LINE K1 <<<<<<<<<<<<<<<<<  
C======================================================================  
                    READ(N5,*,ERR=888) CC,NINC  
CIM### 9/8/00   ADD CHECK FOR K1 LINE  
      IF (CC.NE.'K1') THEN  
      NSTOP = NSTOP + 1  
CIM   5/15/2000 Improve error statment  
      WRITE(N6,6000) CC  
      ENDIF  
C#### WCH, 10/17/95.  ADD PRINT OF NINC.  
                    WRITE(N6,5064) NINC  
                    DO 1970  L = 1,NJSW,NINC  
                                   L1 = L + NINC - 1  
                    IF(L1.GT.NJSW) L1 = NJSW  
C======================================================================  
C    >>>>>>>>>>>>> READ DATA GROUP K2 <<<<<<<<<<<<<  
C======================================================================  
                    IF(JCE.EQ.0) THEN  
                                 READ(N5,*,ERR=888) CC,(JSW(LL),LL=L,L1)  
                    ELSE  
                                 READ(N5,*,ERR=888) CC,(KSW(LL),LL=L,L1)  
                    ENDIF  
CIM### 9/8/00      ADD CHECK FOR K2 LINE  
      IF (CC.NE.'K2') THEN  
      NSTOP = NSTOP + 1  
CIM   5/15/2000 Improve error statment  
      WRITE(N6,6010) CC  
      ENDIF  
 1970 CONTINUE  
CIM### 9/8/00     NEXT LINE SHOULD BE K3 CHECK IT  
      READ(N5,*) CC  
      BACKSPACE (N5)  
      IF (CC.NE.'K3') THEN  
      NSTOP = NSTOP + 1  
CIM   5/15/2000 Improve error statment  
      WRITE(N6,6020) CC  
      ENDIF  
C#######################################################################  
C#### WCH, 10/17/95.  PRINT K2 INPUT LOCATIONS AND CHECK FOR DUPLICATE  
C     LOCATIONS.  DO NOT ALLOW IDENTICAL LOCATION TO BE INPUT TWICE,  
C     CONTRARY TO USER'S MANUAL INSTRUCTIONS, P. 30.  
C=======================================================================  
                    IF(JCE.EQ.0) THEN  
                        WRITE (N6,5065) (JSW(L),L=1,NJSW)  
                    ELSE  
                        WRITE (N6,5066) (KSW(L),L=1,NJSW)  
                    ENDIF  
                    IF(NJSW.GT.1) THEN  
                         NJSWW = NJSW - 1  
                         DO 1975 K = 1,NJSWW  
                         LL = K + 1  
                         DO 1975 L = LL,NJSW  
                         IF(JCE.EQ.0.AND.JSW(K).NE.JSW(L)) GO TO 1975  
                         IF(JCE.EQ.1.AND.KSW(K).NE.KSW(L)) GO TO 1975  
C=======================================================================  
C     HERE IF THERE IS A DUPLICATION OF NUMBERS.  
C=======================================================================  
                         IF(JCE.EQ.0) THEN  
                           WRITE(N6,5067) JSW(K)  
                         ELSE  
                           WRITE(N6,5068) KSW(K)  
                         ENDIF  
                         NSTOP = NSTOP + 1  
 1975                    CONTINUE  
                         ENDIF  
C  
                    WRITE(N6,2999)  
                    WRITE(N6,5060) ALPHA1,ALPHA2  
C======================================================================  
C                   Convert to internal numbers  
C======================================================================  
                    DO 2020 L = 1,NJSW  
                    DO 1980 J = 1,NJ  
                    IF(JCE.EQ.0.AND.JSW(L).EQ.JUN(J))  GO TO 2000  
                    IF(JCE.EQ.1.AND.KSW(L).EQ.AJUN(J)) GO TO 2000  
 1980               CONTINUE  
                    IF(JCE.EQ.0) THEN  
                      WRITE(N6,5820) JSW(L)  
                    ELSE  
                      WRITE(N6,5821) KSW(L)  
                    ENDIF  
                    NSTOP  = NSTOP + 1  
                    GO TO 2020  
 2000               JSW(L) = J  
 2020               CONTINUE  
                    ENDIF  
C======================================================================  
C     Determine outflow nodes.  
C======================================================================  
      IF(NEXT.GT.0) THEN  
                    N1        = NTC + 1  
                    I         = 0  
                    DO 2045 N = N1,NTL  
                    IF(NJUNC(N,2).NE.0) GO TO 2045  
                    I         = I + 1  
                    IF(JCE.EQ.0) THEN  
                      LOCNOS(I) = JUN(NJUNC(N,1))  
                    ELSE  
                      KOCNOS(I) = AJUN(NJUNC(N,1))  
                    ENDIF  
 2045               CONTINUE  
                    MJSW    = I  
                    IF(MJSW.GT.NIE) WRITE(N6,5850)  
                    IF(MJSW.EQ.0) NSTOP = NSTOP + 1  
                    ENDIF  
C======================================================================  
C     Write file headers for output hydrograph.  
C======================================================================  
      IF(NEXT.GT.0) THEN  
C#### RED, 5/12/93. GIVE EXTRAN A NON-ZERO INITIAL DATE.  
C#### WCH, 4/11/94. 88001 IS DEFAULT ONLY IF NO USER-SUPPLIED VALUE.  
C#### WCH                    IF(LAST.EQ.0) IDATEZ = 88001  
                    REWIND NEXT  
                    NPOLL = 0  
                    WRITE(NEXT) MJSW,NPOLL  
                    IF(JCE.EQ.0) THEN  
                      WRITE(NEXT) (LOCNOS(I),I=1,MJSW)  
                    ELSE  
                      WRITE(NEXT) (KOCNOS(I),I=1,MJSW)  
                    ENDIF  
                    SOURCE = 'EXTRAN BLOCK'  
                    QQCONV = QCONV  
                    QCONV  = CMET(8,METRIC)  
                    TITLE(3) = ALPHA1  
                    TITLE(4) = ALPHA2  
                    CALL INFACE(2,NEXT)  
                    QCONV    = QQCONV  
                    ENDIF  
CIM### 9/8/00  
cim  move opening of NFOUT to here.  6/20000  
                    IF (IFLBIN.EQ.1) THEN  
cim here if IFLBIN = 1  
                          CLOSE(NFOUT,STATUS='DELETE')  
                          OPEN(NFOUT,FILE=FFNAME(53),FORM='UNFORMATTED',  
     +                        STATUS='UNKNOWN')  
C=======================================================================  
C     Write file headers for output hydrograph.  
C=======================================================================  
                         REWIND NFOUT  
                         NPOLL = 0  
                         WRITE(NFOUT) NOFLOW+NOFDUP,NPOLL  
                         IF(JCE.EQ.0) THEN  
                           WRITE(NFOUT) (FLOWOUT(N),N=1,NOFLOW+NOFDUP)  
                         ELSE  
                           WRITE(NFOUT) (AFLWOUT(N),N=1,NOFLOW+NOFDUP)  
                         ENDIF  
                         SOURCE = 'EXTRAN BLOCK'  
                         QQCONV = QCONV  
                         QCONV  = CMET(8,METRIC)  
                         TITLE(3) = ALPHA1  
                         TITLE(4) = ALPHA2  
                         CALL INFACE(2,NFOUT)  
                         QCONV    = QQCONV  
                         ENDIF  
      IF(NSTOP.GT.0) THEN  
                     WRITE(N6,5920) NSTOP  
                     STOP  
                     ENDIF  
C  
C======================================================================  
 1780 FORMAT(/,  
     +' ******************************************',/,  
     +' *  DOWNSTREAM BOUNDARY STAGE INFORMATION *',/,  
     +' *  FOR BOUNDARY CONDITION # ',I5,'.       *',/,  
     +' ******************************************',//,  
     +'  NO.  TIME(HR) STAGE(FT)  NO.  TIME(HR) STAGE(FT)  NO.  TIME(HR)  
     + STAGE(FT)',/,  
     +'  ---  -------- --------   ---  -------- ---------  ---  --------  
     + ---------')  
 1785 FORMAT(/,  
     +' ******************************************',/,  
     +' *  DOWNSTREAM BOUNDARY STAGE INFORMATION *',/,  
     +' *  FOR BOUNDARY CONDITION # ',I5,'.       *',/,  
     +' ******************************************',//,  
     +'  NO.  TIME(HR) STAGE (M)  NO.  TIME(HR) STAGE (M)  NO.  TIME(HR)  
cred99 STAGE(FT)',/,  - wrong label - 9/9/99  
     + STAGE (M)',/,  
     +'  ---  -------- --------   ---  -------- ---------  ---  --------  
     + ---------')  
 1790 FORMAT(3(I5,F10.2,F10.3))  
 1851 FORMAT(/,' ===> ERROR   JUNCTION ',I10,' HAD A BOUNDARY ',/,  
     +         ' CONDITION # (',I5,') NOT INPUT ON DATA GROUPS J1-J4')  
 1852 FORMAT(/,' ===> ERROR   JUNCTION ',A10,' HAD A BOUNDARY ',/,  
     +         ' CONDITION # (',I5,') NOT INPUT ON DATA GROUPS J1-J4')  
 2999 FORMAT(/,  
     1       '1',40(2H--)/' ','ENVIRONMENTAL PROTECTION AGENCY',13X,40H*  
     2***   EXTENDED TRANSPORT PROGRAM   ****,8X,'WATER RESOURCES DIVISI  
     3ON',/,' ','WASHINGTON, D.C.            ',16X,4H****,32X,4H****,8X,  
     4'CAMP DRESSER & MCKEE INC.',/,' ','                ',28X,4H****,  
     56X,'   ANALYSIS MODULE  ',6X,4H****,8X,'ANNANDALE, VIRGINIA')  
Cwch, 4/18/02.  
 4005 FORMAT(/,' ERROR SAME ALPHANUMERIC OPTION ($ANUM) WAS NOT USED IN  
     1 EXTRAN',/,' AS IN BLOCK THAT CREATED INTERFACE FILE.',/,  
	2' PROGRAM CONTINUES BUT UNPREDICTABLE ERROR WILL SOON RESULT.')  
 5060 FORMAT(/,5X,A80,/,5X,A80,/)  
C#### WCH, 10/17/95.  FIVE NEW FORMAT STATEMENTS.  
 5064 FORMAT (/,  
     1' **************************************************',/,  
     2' *   LINE-INPUT HYDROGRAPHS (DATA GROUPS K1-K3)   *',/,  
     3' *                                                *',/,  
     4' *    Expect ',I3,' junction IDs on each K2 line.    *',/,  
     5' **************************************************')  
 5065 FORMAT (/,' NJSW INPUT LOCATIONS FROM K2 LINES:',/,(8(I10,1X)))  
 5066 FORMAT (/,' NJSW INPUT LOCATIONS FROM K2 LINES:',/,(8(A10,1X)))  
 5067 FORMAT (/,' *** ERROR  INPUT LOCATION ',I10,' IS DUPLICATED LATER  
     1 IN K2 LIST.',/,' ALLOW LOCATION TO BE USED ONLY ONCE.  PROGRAM WI  
     2LL STOP BELOW.')  
 5068 FORMAT (/,' *** ERROR  INPUT LOCATION ',A10,' IS DUPLICATED LATER  
     1 IN K2 LIST.',/,' ALLOW LOCATION TO BE USED ONLY ONCE.  PROGRAM WI  
     2LL STOP BELOW.')  
C#### WCH, 7/25/96.  
 5815 FORMAT(/,' >>> STARTING DATE AND TIME OF EXTRAN RUN ARE:',/,  
     2' JULIAN DATE:',I8,/,  
     3' YR/MO/DA:   ',I4,'/',I2,'/',I2,/,  
     4' TIME OF DAY:',F7.3,' HRS',/,  
     5' THIS IS',F7.3,' HOURS BEYOND INTERFACE FILE STARTING TIME',/,  
     6' AS PROVIDED BY TZERO ON LINE B1.')  
 5678 FORMAT(/,' ====> ERROR  CONDUIT',I10,  
     1' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN CONDUIT DATA')  
 5679 FORMAT(/,' ====> ERROR  CONDUIT ',A10,  
     1     ' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN CONDUIT DATA')  
 5680 FORMAT(/,' ====> ERROR  CONDUIT ',I10,  
     1' REQUESTED FOR PLOTTING IS NOT CONTAINED IN CONDUIT DATA')  
 5681 FORMAT(/,' ====> ERROR  CONDUIT ',A10,  
     1     ' REQUESTED FOR PLOTTING IS NOT CONTAINED IN CONDUIT DATA')  
 5690 FORMAT(/,' ====> ERROR  JUNCTION ',I10,  
     1     ' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN JUNCTION DATA')  
 5691 FORMAT(/,' ====> ERROR  JUNCTION ',A10,  
     1 ' REQUESTED FOR PRINTOUT IS NOT CONTAINED IN JUNCTION DATA')  
 5700 FORMAT(/,' ====> ERROR  JUNCTION ',I10,  
     1  ' REQUESTED FOR PLOTTING IS NOT CONTAINED IN JUNCTION DATA')  
 5701 FORMAT(/,' ====> ERROR  JUNCTION ',A10,  
     1  ' REQUESTED FOR PLOTTING IS NOT CONTAINED IN JUNCTION DATA')  
 5705 FORMAT(/,' ====> ERROR  CONDUIT ',I10,  
     1' REQUESTED FOR PLOTTING WATER SURFACE SLOPE IS NOT CONTAINED',  
     2' IN CONDUIT DATA')  
 5706 FORMAT(/,' ====> ERROR  CONDUIT ',A10,  
     1' REQUESTED FOR PLOTTING WATER SURFACE SLOPE IS NOT CONTAINED',  
     2' IN CONDUIT DATA')  
CIM WRITING OF FLOW TO FILE  
 5805 FORMAT(/,' ====> ERROR  CONDUIT ',I10,  
     1' REQUESTED FOR WRITING OF FLOWS TO ASCII FILE IS NOT CONTAINED',  
     2' IN CONDUIT DATA')  
 5806 FORMAT(/,' ====> ERROR  CONDUIT ',A10,  
     1' REQUESTED FOR WRITING OF FLOWS TO ASCII FILE IS NOT CONTAINED',  
     2' IN CONDUIT DATA')  
6807  FORMAT(/,' ====> ERROR  REFERENCE CONDUIT ',I10,  
     1' IS NOT CONTAINED IN CONDUITS REQUESTED ON B9 LINE FOR',  
     2' DUPLICATE CONDUIT NUMBER ',I10)  
6808  FORMAT(/,' ====> ERROR  REFERENCE CONDUIT ',A10,  
     1' IS NOT CONTAINED IN CONDUITS REQUESTED ON B9 LINE FOR',  
     2' DUPLICATE CONDUIT NUMBER ',I10)  
CIM END  
 5707 FORMAT(/,' ====> ERROR  FOR BOUNDARY CONDITION NO. ',I3,  
     1' AND NTIDE = ',I2,':',/,' NI =',I4,' TIME/STAGE POINTS GREATER TH  
     2AN NTVAL = ',I3, 'ALLOWED.  NTVAL VALUE SET IN TAPES.INC')  
Cwch, 3/26/01  
 5708 FORMAT(/,' ====> ERROR  FOR BOUNDARY CONDITION NO. ',I3,/,  
     1' FOR NTIDE = 4 AND KO = 1, SHOULD HAVE NI = 4.  ACTUAL NI =',I4,  
	2/,' ENTER ONLY 4 TIME-STAGE PAIRS FOR THIS CASE.  ELSE, USE KO = 0  
	3.')  
 5710 FORMAT(1H1,/,  
     +' *****************************************************',/,  
     +' *        BOUNDARY CONDITON INFORMATION              *',/,  
     +' *                 DATA GROUPS J1-J4                 *',/,  
     +' *****************************************************',//)  
 5715 FORMAT(/,' BC NUMBER..',I10,  
     +         ' HAS NO CONTROL WATER SURFACE.')  
 5780 FORMAT(/,  
     +' ******************************************',/,  
     +' *     USER SUPPLIED TIDAL COEFFICIENTS   *',/,  
     +' *  FOR BOUNDARY CONDITION # ',I5,'.       *',/,  
     +' ******************************************',/,  
     +' TIDAL COEFFICIENTS.........',7F10.4,  
     +' TIDAL PERIOD (HOURS).......',F10.2)  
 5790 FORMAT(/,' BC NUMBER..',I10,  
     +         ' CONTROL WATER SURFACE ELEVATION IS..',F10.2,' FEET.')  
 5791 FORMAT(/,' BC NUMBER..',I10,  
     +         ' CONTROL WATER SURFACE ELEVATION IS..',F10.2,' METERS.')  
C#### WCH, 11/10/94.  ENHANCE ERROR MESSAGES IN 5820 AND 5821.  
C#### WCH, 10/17/95.  CHANGE 5220,5821 ERROR MESSAGES TO WARNING MESGS.  
 5820 FORMAT(/,' ==> WARNING  PROGRAM CANNOT MATCH HYDROGRAPH AT NODE  
     1',   I10,' TO JUNCTION',/,' DATA.  EXTRAN WILL IGNORE INFLOW FROM  
     2THIS JUNCTION AND CONTINUE SIMULATION.')  
 5821 FORMAT(/,' ==> WARNING  PROGRAM CANNOT MATCH HYDROGRAPH AT NODE  
     1',   A10,' TO JUNCTION',/,' DATA.  EXTRAN WILL IGNORE INFLOW FROM  
     2THIS JUNCTION AND CONTINUE SIMULATION.')  
 5830 FORMAT(3X,I5,'/',F7.2,7(3X,I5,'/',F7.2))  
 5850 FORMAT(/,' ====> ERROR  MORE THAN NIE OUTFALL JUNCTIONS.')  
 5920 FORMAT(//,' ====> ERROR  EXECUTION TERMINATED BECAUSE OF ',  
     *I3,' DATA ERROR(S).')  
CIM### 9/8/00 CHECK FOR K1,K2,AND K3  
CIM   5/15/2000 Improve error statment  
 6000 FORMAT(/,' ====> ERROR  DID NOT FIND K1 LINE',/,  
     a         '       Program was looking for a K1 line but found a',  
     b' line that starts with ',a2,/,  
     c         '       instead.  Error probably occurs in earlier',  
     d' data lines.')  
 6010 FORMAT(/,' ====> ERROR  DID NOT FIND K2 LINE',/,  
     a         '       Program was looking for a K2 line but found a',  
     b' line that starts with ',a2,/,  
     c         '       instead.  Error probably occurs in earlier',  
     d' data lines.')  
 6020 FORMAT(/,' ====> ERROR  DID NOT FIND K3 LINE',/,  
     a         '       Program was looking for a K3 line but found a',  
     b' line that starts with ',a2,/,  
     c         '       instead.  Error probably occurs in earlier',  
     d' data lines.')  
C=======================================================================  
      RETURN  
 888  CALL IERROR  
      END  
ECHO is off.
REM File: INFACE.FOR  
ECHO is off.
      SUBROUTINE INFACE(IDO,NTAPE)  
C     USED BY ALL BLOCKS TO WRITE/READ INTERFACE FILE  
C=======================================================================  
C     This subroutine reads or writes the header information  
C     for a SWMM interface file.  Created FEBRUARY, 1987  
C     by Robert E. Dickinson.  Last updated December, 1990.  
C     Updated 4/13/93 by WCH for minor format change.  
C     Added and updated error messages, WCH, 9/8/93 and 11/23/93.  
C     Alter IOSTAT number for Lahey, WCH, 8/4/95.  
C     Check number of interface locations against array dimension,  
C     CIM 9/8/00  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      CHARACTER KJN*10  
      DIMENSION JN(NIE),KJN(NIE)  
C=======================================================================  
C     Read interface headers.  
C=======================================================================  
      IF(IDO.EQ.0) THEN  
           REWIND NTAPE  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(1)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(2)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) IDATEZ,TZERO  
           IYRZ = IDATEZ/1000  
           IF (IYRZ.LT.100) THEN  
           IDATEZ = IDATEZ - IYRZ*1000  
           IYRZ = IYRZ + 1900  
           IDATEZ = IDATEZ + IYRZ*1000  
           ENDIF  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(3)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(4)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) SOURCE,LOCATS,  
     1        NQUAL,TRIBA,NJCE  
           IF(NJCE.EQ.0)READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1        (NLOC(I),I=1,LOCATS)  
           IF(NJCE.EQ.1)READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1        (KAN(I),I=1,LOCATS)  
           IF(NQUAL.GT.0) THEN  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (PNAME(J),J=1,NQUAL)  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (PUNIT(J),J=1,NQUAL)  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (NDIM(J),J=1,NQUAL)  
                ENDIF  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) QCONV  
           ENDIF  
C=======================================================================  
C     Read and write interface headers.  
C=======================================================================  
      IF(IDO.EQ.1) THEN  
           REWIND NTAPE  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(1)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(2)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) IDATEZ,TZERO  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(3)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) TITLE(4)  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) SOURCE,LOCATS,  
     1        NQUAL,TRIBA,NJCE  
           WRITE(N6,1)  TITLE(1),TITLE(2)  
           WRITE(N6,2)  TITLE(3),TITLE(4)  
           WRITE(N6,3)  SOURCE  
           IYRZ = IDATEZ/1000  
           IF (IYRZ.LT.100) THEN  
           IDATEZ = IDATEZ - IYRZ*1000  
           IYRZ = IYRZ + 1900  
           IDATEZ = IDATEZ + IYRZ*1000  
           ENDIF  
           WRITE(N6,4)  IDATEZ,TZERO  
           WRITE(N6,5)  LOCATS,NQUAL,TRIBA,NJCE  
C=======================================================================  
C     Read sequence of location numbers.  
C=======================================================================  
           IF(NJCE.EQ.0) THEN  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (NLOC(I),I=1,LOCATS)  
                WRITE(N6,6) (NLOC(I),I=1,LOCATS)  
                ELSE  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (KAN(I),I=1,LOCATS)  
                WRITE(N6,66) (KAN(I),I=1,LOCATS)  
                ENDIF  
           IF(NQUAL.GT.0) THEN  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (PNAME(J),J=1,NQUAL)  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (PUNIT(J),J=1,NQUAL)  
                READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1             (NDIM(J),J=1,NQUAL)  
                WRITE(N6,7) (J,PNAME(J),PUNIT(J),NDIM(J),J=1,NQUAL)  
                ENDIF  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  QCONV  
           WRITE(N6,8)                   QCONV  
           ENDIF  
C=======================================================================  
C     Write interface headers.  
C=======================================================================  
      IF(IDO.EQ.2) THEN  
           REWIND NTAPE  
           READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000) NEWOUT,NPOLL  
CIM###  Check that NEWOUT doesn't exceed NIE  6/16/2000  
      IF (NEWOUT.GT.NIE) THEN  
      WRITE(*,7000) NEWOUT,NIE  
      WRITE(N6,7000) NEWOUT,NIE  
      STOP  
      ENDIF  
CIM###  
           IF(JCE.EQ.0) READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1        (JN(I),I=1,NEWOUT)  
           IF(JCE.EQ.1) READ(NTAPE,ERR=999,IOSTAT=IOS,END=2000)  
     1        (KJN(I),I=1,NEWOUT)  
           REWIND NTAPE  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(1)  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(2)  
           IYRZ = IDATEZ/1000  
           IF (IYRZ.LT.100) THEN  
           IDATEZ = IDATEZ - IYRZ*1000  
           IYRZ = IYRZ + 1900  
           IDATEZ = IDATEZ + IYRZ*1000  
           ENDIF  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) IDATEZ,TZERO  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(3)  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) TITLE(4)  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS) SOURCE,NEWOUT,NPOLL,TRIBA,JCE  
           IF(JCE.EQ.0) WRITE(NTAPE,ERR=998,IOSTAT=IOS)  
     1        (JN(I),I=1,NEWOUT)  
           IF(JCE.EQ.1) WRITE(NTAPE,ERR=998,IOSTAT=IOS)  
     1        (KJN(I),I=1,NEWOUT)  
           IF(NPOLL.GT.0) THEN  
                WRITE(NTAPE,ERR=998,IOSTAT=IOS) (PNAME(J),J=1,NPOLL)  
                WRITE(NTAPE,ERR=998,IOSTAT=IOS) (PUNIT(J),J=1,NPOLL)  
                WRITE(NTAPE,ERR=998,IOSTAT=IOS) (NDIM(J),J=1,NPOLL)  
                ENDIF  
           WRITE(NTAPE,ERR=998,IOSTAT=IOS)   QCONV  
           ENDIF  
      RETURN  
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY.  
  998 WRITE(N6,1998) NTAPE,FFNAME(IOUTCT+25),MOD(IOS,256)  
      STOP  
  999 WRITE(N6,1999) NTAPE,FFNAME(INCNT),MOD(IOS,256)  
      STOP  
C#### WCH, 9/8/93  
 2000 WRITE(N6,2010) NTAPE,FFNAME(INCNT)  
      WRITE(*,2010)  NTAPE,FFNAME(INCNT)  
      STOP  
C=======================================================================  
1     FORMAT(//,  
     1' ###########################################',/,  
     2' # Header information from interface file: #',/,  
     3' ###########################################',//,  
     4 ' Title from first computational block:',/,1X,A80,/,1X,A80)  
2     FORMAT(/,' Title from immediately preceding computational block:',  
     1 /,1X,A80,/,1X,A80)  
3     FORMAT(/,  
     1 ' Name of preceding block:................',A20)  
4     FORMAT(  
     1 ' Initial Julian date (IDATEZ)......................',I8,/,  
     2 ' Initial time of day in seconds (TZERO)............',F8.1)  
C#### WCH, 4/13/93.  VERY MINOR FORMAT CHANGE FOR AREA.  
5     FORMAT(' No. transfered input locations....................',I8,/,  
     1       ' No. transfered pollutants.........................',I8,/,  
     2       ' Size of total catchment area (acres)..............',  
     2 F10.2,  
     3     /,' ID numbers (JCE=0) or alphanumeric (JCE=1)........',I8)  
6     FORMAT(/,' #################################################',/,  
     1' # Element numbers of interface inlet locations: # ',/,  
     2' #################################################',/,  
     3(9(1X,I10)))  
7     FORMAT(/,' #########################################',/,  
     1' # Quality parameters on interface file: #',/,  
     2' #########################################',//,  
     3 ' No. Name      Units     Type of units',/,  
     4 ' --- ----      -----     -------------',/,  
     5 (1X,I2,2X,A8,2X,A8,I7))  
8     FORMAT (/,' Conversion factor to cfs for flow units',/,  
     1           ' on interface file.  Multiply by: ',F11.5)  
   66 FORMAT(/,' #################################################',/,  
     1' # Element numbers of interface inlet locations: # ',/,  
     2' #################################################',/,  
     3(9(1X,A10)))  
C#### WCH, 11/23/93  
 1998 FORMAT(/,' ===> Error   Writing the interface file on unit # ',  
     1    I3,/,'      File name... ',A60,/,  
     2         '      Fortran error number =',I5,'. Run stopped.')  
 1999 FORMAT(/,' ===> Error   Reading the interface file on unit # ',  
     1    I3,/,'      File name... ',A60,/,  
     2         '      Fortran error number =',I5,'. Run stopped.')  
C#### WCH, 9/8/93.  
 2010 FORMAT(/,' ERROR.  End-of-file reached unexpectedly while reading  
     1header information on',/,' interface file on unit no.',I3,  
     2'. File name = ',A20,/,' Check to see that this file is the proper  
     3 interface file.  Run stopped.')  
CIM### 9/8/00  
 7000 FORMAT(/,' ERROR.  Number of locations for which data are to be',  
     a' written to interface',/,9X,  
     b'file exceeds maximum allowed by program dimensions.  Subdivide'  
     c,/,9X,'model or increase program dimensions.',/,9X,  
     d'Number of interface locations = ',I10,/,9X,  
     d'Maximum allowed (NIE)         = ',I10)  
C=======================================================================  
      END  
ECHO is off.
REM File: INFIL.FOR  
ECHO is off.
      SUBROUTINE INFIL  
C     TRANSPORT BLOCK  
C     CALLED BY INTRAN NEAR LINE 1191  
C=======================================================================  
C     ROUTINE TO INPUT INFILTRATION PARAMETERS AND CALCULATE  
C     INFILTRATION INPUT TO MANHOLES OR OTHER NON-CONDUITS.  
C     UPDATED SEPTEMBER 1981 BY W.C.H.  
C     UPDATED NOVEMBER 1988 BY R.E.D.  
C     UPDATED NOVEMBER 1992 BY WCH TO CORRECT METRIC CONVERSION  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TABLES.INC'  
      INCLUDE 'NAMES.INC'  
      INCLUDE 'HUGO.INC'  
      INCLUDE 'NEW81.INC'  
      DIMENSION NDD(12),NDXDAY(380)  
C=======================================================================  
C>>>>>>>>>>>> READ DATA GROUP K1 <<<<<<<<<<<<  
C=======================================================================  
      READ (N5,*,ERR=888) CC,DINFIL,GINFIL,RINFIL,RSMAX,  
     +                      (CPINF(I),I=1,NPOLL)  
C=======================================================================  
C>>>>>>>>>>>> READ DATA GROUP K2 <<<<<<<<<<<<  
C=======================================================================  
      READ (N5,*,ERR=888) CC,(NDD(I),I=1,12)  
                      CMET3 = 1.0  
      IF(METRIC.EQ.2) CMET3 = 35.31  
      WRITE (N6,600)  
      IF(METRIC.EQ.1) WRITE(N6,601) DINFIL,GINFIL,RINFIL,RSMAX  
      IF(METRIC.EQ.2) WRITE(N6,602) DINFIL,GINFIL,RINFIL,RSMAX  
      IF(NPOLL.GT.0)  WRITE(N6,603) (I,PNAME(I),CPINF(I),  
     +                               PUNIT(I),I=1,NPOLL)  
      NDYUD = JULDAY - 1000*(JULDAY/1000)  
      WRITE (N6,606) (I,NDD(I),I=1,12)  
      SINFIL = 0.0  
      IF(GINFIL.GT.0.0) GO TO 50  
      IF(RSMAX.LE.0.0) GO TO 200  
C=======================================================================  
C     HERE, WILL USE DEGREE-DAYS TO CALC. RESIDUAL MOISTURE MELT.  
C     DEGREE DAYS IN DEG. F * DAYS ONLY (NO METRIC).  
C=======================================================================  
      MFREZ = 0  
      MLTBE = 0  
      MLTEN = 0  
C=======================================================================  
C     PLACE MONTHLY VALUES AT MIDDLE OF MONTH  
C=======================================================================  
      II            = 0  
      DO 100 I      = 1,12  
      NDDAY         = II+15  
      NDXDAY(NDDAY) = NDD(I)  
      II            = II+30  
  100 CONTINUE  
C=======================================================================  
C     INTERPOLATE FOR FIRST AND LAST 15 DAYS OF 'YEAR'  
C=======================================================================  
      NX  = 345  
      NY1 = NDXDAY(345)  
      NY2 = NDXDAY(15)  
      NX1 = 345  
      NX2 = 375  
      DO 110 I   = 1,30  
      NX         = NX+1  
      NY         = ((NY2-NY1)*(NX-NX1))/30 + NY1  
      NDXDAY(NX) = NY  
  110 CONTINUE  
C=======================================================================  
C     CONVERT LAST 15 DAYS TO FIRST 15  
C=======================================================================  
      NX        = 360  
      DO 120 I  = 1,15  
      NX        = NX+1  
      NDXDAY(I) = NDXDAY(NX)  
  120 CONTINUE  
C=======================================================================  
C     INTERPOLATE FROM NDDAY=16 THRU NDDAY=344  
C=======================================================================  
      K   = 1  
      NX  = 16  
      NX1 = 15  
      NX2 = 45  
  130 NY1 = NDXDAY(NX1)  
      NY2 = NDXDAY(NX2)  
      NY  = ((NY2-NY1)*(NX-NX1))/30 + NY1  
      NDXDAY(NX) = NY  
      K  = K+1  
      NX = NX+1  
      IF(K.LE.30) GO TO 130  
      NX1 = NX1+30  
      NX2 = NX2+30  
      K   = 1  
      IF(NX2.LE.345) GO TO 130  
C=======================================================================  
C     DETERMINE BEGINNING OF FREEZING PERIOD(MFREZ)  
C=======================================================================  
      DO 150 I = 1,360  
      IF(NDXDAY(I).GT.750) GO TO 160  
  150 CONTINUE  
  160 MFREZ = I  
C=======================================================================  
C     IF STORM DAY IS PRIOR TO FREEZING, SET SINFIL=0.0  
C=======================================================================  
      IF(NDYUD.LE.MFREZ) GO TO 200  
C=======================================================================  
C     STORM OCCURED AFTER FREEZING BEGAN  
C=======================================================================  
      NTOT = 0  
      DO 170 I = MFREZ,360  
      IF(NDXDAY(I).LE.750) GO TO 175  
  170 NTOT   = NTOT+(NDXDAY(I)-750)  
  175 NAREA1 = NTOT  
      MLTBE  = I  
      NTOT   = 0  
      IF(NDYUD.LT.MLTBE) GO TO 200  
      DO 180 I = MLTBE,360  
      NTOT     = NTOT+(750-NDXDAY(I))  
      IF(NTOT.GE.NAREA1) GO TO 185  
  180 CONTINUE  
C=======================================================================  
C     IF EQUAL AREA NOT REACHED SET MLTEN=360  
C=======================================================================  
  185 MLTEN = I  
      IF(NDYUD.GE.MLTEN) GO TO 200  
C=======================================================================  
C     CALCULATE SINFIL  
C=======================================================================  
      XMLTBE = MLTBE  
      XNDYUD = NDYUD  
      XMLTEN = MLTEN  
      XXARG  = ((XNDYUD-XMLTBE)/(XMLTEN-XMLTBE))*3.1416  
      SINFIL = RSMAX*SIN(XXARG)  
      IF(METRIC.EQ.1) WRITE (N6,610) SINFIL  
      IF(METRIC.EQ.2) WRITE (N6,611) SINFIL  
      GO TO 40  
  200 SINFIL = 0.0  
   40 QINF   = RINFIL+SINFIL+DINFIL  
      GO TO 60  
   50 QINF = GINFIL  
   60 CONTINUE  
      OPINF   = 0.0  
      OPNFIL  = 0.0  
      DO 70 K = 1,NE  
      M       = JR(K)  
      NTPE      = NTYPE(M)  
      IF(KLASS(NTPE).LE.2) OPINF = SQRT(AFULL(M))*DIST(M)+OPINF  
   70 CONTINUE  
      IF(METRIC.EQ.1) WRITE (N6,615) QINF  
      IF(METRIC.EQ.2) WRITE (N6,616) QINF  
      WRITE (N6,620) DINFIL,GINFIL,SINFIL,RINFIL  
      WRITE (N6,630)  
      IF(METRIC.EQ.1) WRITE (N6,631)  
      IF(METRIC.EQ.2) WRITE (N6,632)  
C  
      SUM     = 0.0  
      DO 80 K = 1,NE  
      M       = JR(K)  
      NTPE      = NTYPE(M)  
      IF(KLASS(NTPE).LE.2) THEN  
                         OPNFIL     = SQRT(AFULL(M))*DIST(M)  
                         OP         = OPNFIL/OPINF  
                         QQINF      = QINF*OP  
                         MI         = INUE(M,1)  
C###### WCH, 11/93  
C SHOULD MULTIPLY BY CMET3, NOT DIVIDE  
C######  
                         QINFIL(MI) = QINFIL(MI) + QQINF*CMET3  
                         SUM        = SUM + QQINF  
                         IF(JCE.EQ.0) WRITE(N6,640) NOE(M),  
     +                                              QQINF,OP,NOE(MI)  
                         IF(JCE.EQ.1) WRITE(N6,641) KOE(M),  
     +                                              QQINF,OP,KOE(MI)  
                         ENDIF  
   80 CONTINUE  
      WRITE(N6,645) SUM  
      RETURN  
  888 CALL IERROR  
C=======================================================================  
  500 FORMAT (2X,F8.0,7F10.0)  
  501 FORMAT (2X,I3,11I5)  
  600 FORMAT(1H1,/,  
     1' *******************************************************',/,  
     2' * INFILTRATION APPORTIONMENT THROUGH CONDUIT NETWORK. *',/,  
     3' *              INPUT TO SUBROUTINE INFIL:             *',/,  
     4' *******************************************************'/)  
  601 FORMAT(' DINFIL =',F10.4,' CFS. BASE DRY-WEATHER INFILTRATION.',/,  
     1' GINFIL =',F10.4,' CFS. GROUNDWATER INFILTRATION.',/,  
     2' RINFIL =',F10.4,' CFS. RAINWATER INFILTRATION.',/,  
     3' RSMAX  =',F10.4,' CFS. PEAK RESIDUAL MOISTURE (TO BE MELTED).')  
  602 FORMAT (' DINFIL =',F10.4,' CU M/SEC. BASE DRY-WEATHER INFILTRATIO  
     1N.',/,  
     2' GINFIL =',F10.4,' CU M/SEC. GROUNDWATER INFILTRATION.',/,  
     3' RINFIL =',F10.4,' CU M/SEC. RAINWATER INFILTRATION.',/,  
     4' RSMAX  =',F10.4,' CU M/SEC. PEAK RESIDUAL MOISTURE (TO BE MELTED  
     5).')  
  603 FORMAT(//,  
     1' ************************************************',/,  
     2' * CONCENTRATION OF POLLUTANTS IN INFILTRATION: *',/,  
     3' ************************************************',//,  
     1' NO.   NAME    CONCENTRATION   UNITS',/,  
     2' ---   ----    -------------   -----',/,  
     3           4(1X,I2,2X,A8,F13.3,4X,A8,/))  
  606 FORMAT (//,  
     1' ***************************************************',/  
     1' * DEGREE-DAYS (DEG F * DAYS), JANUARY - DECEMBER: *',/,  
     2' ***************************************************',/,  
     3        1X,6(I5,' = ',I5),/,1X,6(I5,' = ',I5))  
  610 FORMAT (//,' CALCULATED MELT INFILTRATION (SINFIL) =',F10.4,  
     1 ' CFS.')  
  611 FORMAT (//,' CALCULATED MELT INFILTRATION (SINFIL) =',F10.4,  
     1 ' CU M/SEC.')  
  615 FORMAT (//,10X,'TOTAL AREA INFILTRATION (CFS) =',F10.4,', DUE TO:  
     1',//,  
     2 10X,'BASE FLOW',5X,'GROUND WATER',11X,'    MELT',5X,'  RAIN',/,  
     3 10X,'---------',5X,'------------',11X,'    ----',5X,'  ----')  
  616 FORMAT (//,10X,'TOTAL AREA INFILTRATION (CU M/SEC) =',F10.4,  
     1 ', DUE TO:',//,  
     2 10X,'BASE FLOW',5X,'GROUND WATER',11X,'    MELT',5X,'  RAIN',/,  
     3 10X,'---------',5X,'------------',11X,'    ----',5X,'  ----')  
  620 FORMAT(10X,F9.4,5X,F12.4,11X,F8.4,3X,F8.4,//)  
  630 FORMAT (/,  
     1' ******************************************',/,  
     1' * APPORTIONED INFILTRATION (BY RELATIVE  *',/,  
     3' * CONDUIT PERIMETER AREA):               *',/,  
     1' ******************************************',//,  
     112X,'   INFILTRATION',15X,'  PROPORTION  ',T58,'INFIL.INPUT AT')  
  631 FORMAT (1X,'ELEMENT NO.',10X,'(CFS)',15X,'OF TOT. INFIL.',T58,  
     1'UPSTREAM ELE.NO.',/,1X,'-----------',5X,'----------',15X,  
     2'--------------',T58,'----------------',/)  
  632 FORMAT (1X,'ELEMENT NO.',10X,'(CMS)',15X,'OF TOT. INFIL.',T58,  
     1'UPSTREAM ELE.NO.',/,1X,'-----------',10X,'-----',15X,  
     2'--------------',T58,'----------------',/)  
  640 FORMAT(1X,I10,5X,F12.6,12X,F8.4,T63,I10)  
  641 FORMAT(1X,A10,5X,F12.6,12X,F8.4,T63,A10)  
  645 FORMAT(' TOTAL INFIL ',3X,F12.6)  
C=======================================================================  
      END  
  
ECHO is off.
REM File: INFLOW.FOR  
ECHO is off.
      SUBROUTINE INFLOW  
C	EXTRAN BLOCK  
C     CALLED BY TRANSX NEAR LINE 497  
C=======================================================================  
C     THIS SUBROUTINE SELECTS THE EXTRAN INPUT HYDROGRAPH  
C     ORDINATE FROM OFF-LINE FILES AND/OR USER INPUT (K3 LINES).  
C=======================================================================  
C     WCH, 6/16/94.  CORRECT USER INPUT OPTION FOR POSSIBILITY OF  
C       MULTIPLE VALUES FOR SAME JUNCTION (P. 30 OF EXTRAN MANUAL).  
C     WCH (SACHA HENCHMAN, METCALF AND EDDY, BOSTON), 10/17/95.  
C       REMOVE ABOVE FIX BY REMOVING DO 4010 LOOP, TO AVOID ADDING 50%  
C       MORE INFLOW WHEN USING BOTH INTERFACE FILE INPUT AND K3 INPUT.  
C       KEEP TRACK SEPARATELY OF INFLOWS FROM INTERFACE FILE (QINN)  
C       AND INFLOWS FROM K3 LINES (QINNK3) TO AVOID DOUBLE COUNTING.  
C       DO NOT ALLOW MULTIPLE INFLOWS FOR SAME JUNCTION ON K3 LINES.  
C     WCH, 10/17/95.  ALLOW MIS-MATCH OF EXTRAN AND INTERFACE FILE  
C       JUNCTIONS.  
C     WCH, 7/3/02. FIX HARD-WIRED MIN. ORIFICE LENGTH TO 200 FT OR   
C       200/3.28 M.   
C     WCH for Mitch Heineman, 7/20/04. ADD CHECK ON TOLCS1 TO OPTIONALLY  
C       AVOID PRINTOUTS FOR CHANGES IN STEADY-STATE CONDITION.   
C     WCH, 7/20/04. INTERPOLATION TIME CHECK FROM RED, 2/24/03.   
C     WCH (RED), 7/22/04. Fix problem of F2 line sequencing.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'OUT.INC'  
      INCLUDE 'ORF.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'HYFLOW.INC'  
      INCLUDE 'MOBFF.INC'  
      DIMENSION LSWIT(NIE),NSWIT(NIE),MSWIT(NIE),  
     +                                ORTIME(NVORF),NORPLC(NVORF)  
      CHARACTER*10 NSWIT,MSWIT  
C=======================================================================  
C     Define statement function for linear interpolation.  
C=======================================================================  
      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1)  
C=======================================================================  
C     Initialize new QINN, QINNK3 and QIN arrays.  
C=======================================================================  
      DO 40 J   = 1,NJ  
cim  change for variable base flows  
cim   QIN(J)    = QINST(J)  
      QIN(J)    = QINST(J)*BFFMONTH(1,IWHICH(J))  
      QINN(J,1) = QINN(J,2)  
      QINN(J,2) = 0.0  
C#### WCH, 10/17/95.  ADD NEW QINNK3  
      QINNK3(J,1) = QINNK3(J,2)  
      QINNK3(J,2) = 0.0  
   40 CONTINUE  
C=======================================================================  
C     Calculate new depth and pipe length for an orifice with a  
C               time history.  
C=======================================================================  
      IF(NVOR.GT.0) THEN  
                    DO 9000 M = 1,NVOR  
cred  To handle sequencing of F2 lines, 4/15/02.   
Cwch, 7/22/04. Worry a bit that NORPLC is never initialized.   
                    mm        = f2_line(m)  
                    N         = LORIF(mm)  
C                    N         = LORIF(M)  
                    JJ        = NORPLC(M)  
                    IF(JJ.EQ.0) JJ = 1  
C                    DO 8990 J      = JJ,NVOTIM  
                    DO 8990 J      = JJ,f2_limit(m)  
                    IF(TIME/3600.0.GE.VORIF(M,J,1)) GO TO 8991  
 8990               CONTINUE  
                    GO TO 9000  
 8991               CONTINUE  
                    IF(ORTIME(M).GT.TIME/3600.0) GO TO 9000  
                    ORTIME(M) = VORIF(M,J,1)  
                    NORPLC(M) = J + 1  
                    ZZ        = 0.96*DEEP(N)  
cim begin OOOO  
CIM  adjustment for CIRCULAR orifices  
                    if (NKLASS(N).EQ.51.OR.NKLASS(N).EQ.52) THEN  
                    DEEPOLD   = DEEP(N)  
                    DEEP(N)   = SQRT(4.0*VORIF(M,J,3)/3.14159)  
                    WIDE(N)   = DEEP(N)  
                    AFULL(N)  = VORIF(M,J,3)  
                    RFULL(N)  = DEEP(N)/4.0  
CIM CHANGE INVERT  
CIM  NOTE  ZU + DEEPOLD = OLD CROWN ELEV.  
CIM        ZU + DEEPOLD - DEEP = new invert elev.  
                    IF (IOINV(M).EQ.1) then  
                    ZU(N) = ZU(N)+DEEPOLD-DEEP(N)  
                    ZD(N) = ZD(N)+DEEPOLD-DEEP(N)  
                    ENDIF  
                    ELSE  
CIM   ADJUST ONLY DEPTH FOR RECTANGULAR ORIFICE, WIDTH REMAINS UNCHANGED  
                    DEEPOLD   = DEEP(N)  
                    DEEP(N)   = VORIF(M,J,3)/WIDE(N)  
                    AFULL(N)  = VORIF(M,J,3)  
                    RFULL(N)  = AFULL(N)/(2.0*DEEP(N)+2.0*WIDE(N))  
CIM CHANGE INVERT  
CIM  NOTE  ZU + DEEPOLD = OLD CROWN ELEV.  
CIM        ZU + DEEPOLD - DEEP = new invert elev.  
                    IF (IOINV(M).EQ.1) then  
                    ZU(N) = ZU(N)+DEEPOLD-DEEP(N)  
                    ZD(N) = ZD(N)+DEEPOLD-DEEP(N)  
                    ENDIF  
                    END IF  
CIM END   OOOOOOO  
                                    DDD = DELT  
C BAC START     
C                    IF(NEQUAL.GT.1) DDD = FLOAT(NEQUAL)  
C BAC END     
                    CLEN      = 2.0*DDD*SQRT(GRVT*DEEP(N))  
Cwch, 7/2/03. Set minimum length = 200 ft or 200/3.28 m.  
C                    LEN(N)    = AMAX1(200.0,CLEN)  
                    LEN(N)    = AMAX1(200.0/CMET(1,METRIC),CLEN)  
                    CMANN     = CMET(9,METRIC)  
                    ROUGH(N)  = CMANN*RFULL(N)**.66667/  
     +                         (VORIF(M,J,2)*SQRT(LEN(N)*2.0*GRVT))  
                    DO 700 J = 1,NJ  
                    IF(JCE.EQ.0.AND.NJUNC(N,1).EQ.JUN(J))  GO TO 720  
                    IF(JCE.EQ.1.AND.KJUNC(N,1).EQ.AJUN(J)) GO TO 720  
  700               CONTINUE  
CIM START  OOOOOOOOOOOO  
CIM MODIFY TO INCLUDE RECTANGULAR BOTTOM OUTLET ORIFICE  
CIM ALSO MODIFY PRINT STATEMENT TO INCLUDE MODIFIED WIDTH  
  720               IF((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54)) THEN  
                       ZU(N)      = ZU(N) - 0.96*DEEP(N) + ZZ  
                       Z(J)       = ZU(N)  
                       ZD(N)      = ZU(N) - 0.01/CMET(1,METRIC)  
                       IF(JCE.EQ.0) WRITE(N6,6010) M,NCOND(N),DEEP(N),  
     +                              WIDE(N),LEN(N),ROUGH(N),ZU(N),  
     +                              ZD(N),TIME/3600.0  
                       IF(JCE.EQ.1) WRITE(N6,6011) M,ACOND(N),DEEP(N),  
     +                              WIDE(N),LEN(N),ROUGH(N),ZU(N),  
     +                              ZD(N),TIME/3600.0  
                       ELSE  
                       IF(JCE.EQ.0) WRITE(N6,6015) M,NCOND(N),DEEP(N),  
     +                               WIDE(N),LEN(N),ROUGH(N),TIME/3600.0  
                       IF(JCE.EQ.1) WRITE(N6,6016) M,ACOND(N),DEEP(N),  
     +                               WIDE(N),LEN(N),ROUGH(N),TIME/3600.0  
                       ENDIF  
CIM    CORRECTION    ROUGH NEEDS TO BE MODIFIED (SEE INDAT3)  
      ROUGH(N)  = GRVT*ROUGH(N)**2/CMET(9,METRIC)**2  
 9000               CONTINUE  
                    ENDIF  
CIM END  OOOOOO  
C=======================================================================  
C     Conditional time for first time step.  
C=======================================================================  
      IF(MTIME.EQ.1) THEN  
                     JDAY  = IDATEZ  
                     TMDAY = TZERO  
                     TEND  = TZERO  
                     IF(METRIC.EQ.1) THEN  
                                     QQCONV = QCONV  
                                     ELSE  
                                     QQCONV = QCONV/CMET(8,METRIC)  
                                     ENDIF  
                     ENDIF  
C=======================================================================  
C     Interface file hydrograph ordinates are interpolated.  
C     Note that in most cases, there is no interface file ordinate  
C     at time zero.  Hydrograph ordinate at time zero is implicitly  
C     assumed to equal zero.  
C=======================================================================  
      IF(LOCATS.EQ.0) THEN  
         NEWQTAPE = 1  
         ELSE  
cim      IF(LOCATS.GT.0) THEN  
 1000    IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GT.TMDAY)) THEN  
            DO 4523 I  = 1,LOCATS  
            QTAPE(I,1) = QTAPE(I,2)  
 4523       CONTINUE  
            IF(NQUAL.LE.0) THEN  
               READ(LAST,END=205) JDAY,TMDAY,  
     +                DELTA,(QTAPE(I,2),I=1,LOCATS)  
               ELSE  
               READ(LAST,END=205) JDAY,TMDAY,  
     +                DELTA,(QTAPE(I,2),(PDUM,J=1,NQUAL),I=1,LOCATS)  
               ENDIF  
            TREF = TIME/3600.0  
            CALL NTIME(JDAY,TMDAY,TFILE)  
            IF(TFILE.LT.0.0) GO TO 1000  
            TFILE      = TFILE/3600.0  
            DO 1400 I  = 1,LOCATS  
 1400       QTAPE(I,2) = QTAPE(I,2)*QQCONV  
C ### RHF 12/20/96 SET FLAG IF INFLOWS CHANGE  
C   NEWQTAPE IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY  
            IF (ISOLSKIP .EQ. 1) THEN  
               NEWQTAPE = 1  
               DO 1450 I = 1,LOCATS  
               DELTFLOW = ABS(QTAPE(I,1)-QTAPE(I,2))  
               IF (DELTFLOW.GT.TOLCS2) NEWQTAPE = 0  
c     write(n6,*) 'inflow0',tstart,deltflow,tolcs2,newqtape  
 1450          CONTINUE  
               ENDIF  
C ---  
            ENDIF  
C=======================================================================  
C     Interpolate flow values.  
C=======================================================================  
         THR        = TIME/3600.0 - TREF  
         DO 1500 L  = 1,LOCATS  
         KSWIT      = NLOC(L)  
C#### WCH, 10/17/95.  CHECK FOR ZERO NLOC (NO EXTRAN JUNCTION).  
         IF(KSWIT.GT.0) THEN  
            IF(JCE.EQ.0) LSWIT(L)   =  JUN(KSWIT)  
            IF(JCE.EQ.1) MSWIT(L)   = AJUN(KSWIT)  
            ELSE  
            IF(JCE.EQ.0) LSWIT(L)   = 0  
            IF(JCE.EQ.1) MSWIT(L)   = KAN(L)  
            ENDIF  
 1500    CONTINUE  
Cwch (MCH), 7/20/04. Turn of some prints when TOLCS1 < 0.  
C     Requested by Mitch Heineman to avoid lenthy steady state output.  
C      IF(MOD(MTIME,INTER).EQ.0) THEN  
         IF(MOD(MTIME,INTER).EQ.0.AND.TOLCS1.GE.0) THEN  
            IF(METRIC.EQ.1) WRITE(N6,5000) TIME/3600.0  
            IF(METRIC.EQ.2) WRITE(N6,5001) TIME/3600.0  
            IF(JCE.EQ.0) WRITE(N6,5830)(LSWIT(L),QTAPE(L,2),L=1,LOCATS)  
            IF(JCE.EQ.1) WRITE(N6,5833)  
     1	      (ADJUSTR(MSWIT(L)),QTAPE(L,2),L=1,LOCATS)  
            ENDIF  
C=======================================================================  
         DO 4570 L = 1,LOCATS  
         J         = NLOC(L)  
C#### WCH, 10/17/95.  CHECK FOR NO NLOC = 0 (NO EXTRAN JUNCTION).  
         IF(J.EQ.0) GO TO 4570  
         QQ1       = QTAPE(L,1)  
         QQ2       = QTAPE(L,2)  
         IF(TFILE.EQ.0.0) THEN  
            QINN(J,2) = QQ2  
            QIN(J)    = QIN(J) + QQ1/2.0 + QQ2/2.0  
            ELSE  
            QEND      = QLINTP(QQ1,QQ2,0.0,TFILE,THR)  
            QINN(J,2) = QEND  
            QIN(J)    = QIN(J) + QINN(J,1)/2.0 + QEND/2.0  
            ENDIF  
 4570    CONTINUE  
         ENDIF  
C=======================================================================  
C     Line hydrograph input values are interpolated.  
C=======================================================================  
      IF(NJSW.EQ.0) THEN  
      NEWQCARD = 1  
      ELSE  
cim      IF(NJSW.GT.0) THEN  
C=======================================================================  
C     New input data required.  
C=======================================================================  
      IF(MTIME.EQ.1) THEN  
               READ(N5,*,ERR=888,END=889) CC  
               IF(CC.NE.'K3') THEN  
                              WRITE(N6,9100) TIME/3600.0  
                              STOP  
                              ENDIF  
               BACKSPACE N5  
               READ(N5,*,ERR=888,END=889)CC,TSTART,(QCARD(L,2),L=1,NJSW)  
               WRITE(N6,4999)  
               DO 2500 L     = 1,NJSW  
               KSWIT         = JSW(L)  
C#### WCH, 10/17/95.  FROM SUB. INDAT3, JSW() CANNOT BE ZERO.  THIS  
C     CODE NOT NEEDED.  
C####               IF(KSWIT.EQ.0) THEN  
C####                              WRITE(*,*) L,KSWIT,NJSW  
C####                              PAUSE  
C####                              ENDIF  
C#### WCH (M&E, BOSTON), 10/17/95.  USE NEW QINNK3() AND DON'T  
C     ADD QINST HERE.  
C####               QINN(KSWIT,1) = QCARD(L,2) + QINST(KSWIT)  
               QINNK3(KSWIT,1) = QCARD(L,2)  
               IF(JCE.EQ.0) LSWIT(L)  = JUN(KSWIT)  
 2500          IF(JCE.EQ.1) NSWIT(L)  = AJUN(KSWIT)  
               IF(METRIC.EQ.1) WRITE(N6,5831) TSTART  
               IF(METRIC.EQ.2) WRITE(N6,5832) TSTART  
               IF(JCE.EQ.0) WRITE(N6,5830)(LSWIT(L),QCARD(L,2),L=1,NJSW)  
               IF(JCE.EQ.1) WRITE(N6,5833)  
     1		 (ADJUSTR(NSWIT(L)),QCARD(L,2),L=1,NJSW)  
               TSTART = 3600.0*TSTART  
               TEND   = TSTART  
C ### RHF 12/20/96 SET FLAG IF INFLOWS CHANGE  
C   NEWQCARD IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY  
               IF (ISOLSKIP .EQ. 1) THEN  
                    NEWQCARD = 1  
                    DO 3100 I = 1,NJSW  
                    DELTFLOW = ABS(QCARD(I,1)-QCARD(I,2))  
                    IF (DELTFLOW.GT.TOLCS2) NEWQCARD = 0  
c     write(n6,*) 'inflow1',tstart,deltflow,tolcs2,newqcard  
 3100               CONTINUE  
                    ENDIF  
C ---  
               ENDIF  
C======================================================================  
 6666 CONTINUE  
      IF(TIME-TEND.GT.0.0) THEN  
               TSTART     = TEND  
               DO 300 L   = 1,NJSW  
  300          QCARD(L,1) = QCARD(L,2)  
               READ(N5,*,END=889,ERR=888,IOSTAT=IREADE) CC  
	         IF(IREADE.NE.0) GO TO 889  
c this next line shouldn't be needed  
c	         IF(EOF(N5)) GO TO 889  KAI DIDN'T LIKE THIS   
               IF(CC.NE.'K3') THEN  
                              WRITE(N6,9100) TIME/3600.0  
                              STOP  
                              ENDIF  
               BACKSPACE N5  
               READ(N5,*,END=889,ERR=888,IOSTAT=IREADE)   
     1		 CC,TEND,(QCARD(L,2),L=1,NJSW)  
	         IF(IREADE.NE.0) GO TO 889  
c this next line shouldn't be needed  
c	         IF(EOF(N5)) GO TO 889  
               WRITE(N6,5999)  
               DO 3000 L              = 1,NJSW  
               KSWIT                  = JSW(L)  
               IF(JCE.EQ.0) LSWIT(L)  = JUN(KSWIT)  
 3000          IF(JCE.EQ.1) NSWIT(L)  = AJUN(KSWIT)  
               IF(METRIC.EQ.1) WRITE(N6,5831) TEND  
               IF(METRIC.EQ.2) WRITE(N6,5832) TEND  
               IF(JCE.EQ.0) WRITE(N6,5830)(LSWIT(L),QCARD(L,2),L=1,NJSW)  
               IF(JCE.EQ.1) WRITE(N6,5833)  
     1		              (ADJUSTR(NSWIT(L)),QCARD(L,2),L=1,NJSW)  
               WRITE(N6,5999)  
               TEND = 3600.0*TEND  
C ### RHF 12/20/96 SET FLAG IF INFLOWS CHANGE  
C   NEWQCARD IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY  
      IF (ISOLSKIP .EQ. 1) THEN  
      NEWQCARD = 1  
      DO 3101 I = 1,NJSW  
      DELTFLOW = ABS(QCARD(I,1)-QCARD(I,2))  
      IF (DELTFLOW.GT.TOLCS2) NEWQCARD = 0  
c     write(n6,*) 'inflow2',tstart,deltflow,tolcs2,newqcard  
 3101 continue  
      ENDIF  
C ---  
               GO TO 6666  
               ENDIF  
C=======================================================================  
C     No new input data required.  
C=======================================================================  
         DO 4000 L = 1,NJSW  
         J         = JSW(L)  
         QQ1       = QCARD(L,1)  
         QQ2       = QCARD(L,2)  
         T         = TIME/3600.0  
         T1        = TSTART/3600.0  
         T2        = TEND/3600.0  
Cwch, 7/20/04.  Seems unlikely, but...  
cred     fix for the bill medina identified problem of T1 being the   
cred     same as T2 in the flow interpolation equation - 2/24/2003  
         if(t2.gt.t1) then  
                 QQ        = QLINTP(QQ1,QQ2,T1,T2,T)  
                 else  
                 qq        = QQ2  
                 endif  
C         QQ        = QLINTP(QQ1,QQ2,T1,T2,T)  
         QINNK3(J,2) = QQ  
C#### WCH, 6/16/94.  NEED TO ADD QINN(J,1)/2 IN SEPARATE LOOP IN ORDER  
C    NOT TO ADD IT TWICE IN EVENT OF DUPLICATE INPUT NODES.  
C#### 4000    QIN(J)    = QIN(J) + QINN(J,1)/2.0 + QQ/2.0  
C#### WCH (M&E, BOSTON), 10/17/95.  KEEP K3 CONTRIBUTION SEPARATE  
C     USING NEW VARIABLE QINNK3(J, ).  
C     ALSO, DO NOT ALLOW MULTIPLE INPUTS FOR SAME JUNCTION IN K3 LINES.  
C  
 4000    QIN(J)    = QIN(J) + QQ/2.0 + QINNK3(J,1)/2.0  
C  
C#### WCH (M&E, BOSTON), 10/17/95.  REMOVE THIS LOOP BECAUSE HALF OF  
C    INFLOW IS ALREADY ADDED IN DO 4570 AND DO 4000, AND QINN(J,1)  
C    STARTS OUT WITH OLD INSTANT. INPUT DUE TO DO 40 LOOP.  SO, DO NOT  
C    ALLOW MULTIPLE INPUTS FOR SAME JUNCTION IN K3 LINES.  
C####         DO 4010 J = 1,NJ  
C#### 4010    QIN(J)    = QIN(J) + QINN(J,1)/2.0  
         ENDIF  
C=======================================================================  
      RETURN  
  888 CALL IERROR  
	STOP  
  889	WRITE(N6,9200) TIME/3600.0  
	TEND = 999999999.9  
      DO L=1,NJSW  
	QCARD(L,1)=0.0  
      QCARD(L,2)=0.0  
	ENDDO  
	RETURN  
C=======================================================================  
  205 DO 2000 L  = 1,LOCATS  
      QTAPE(L,1) = 0.0  
2000  QTAPE(L,2) = 0.0  
      WRITE(N6,9200) TIME/3600.0  
      JDAY       = 9999999  
      TMDAY      = 0.0  
      RETURN  
C=======================================================================  
 4980 FORMAT(/,' TZERO is later in time than last record on tape from  
     1interface file.')  
 4999 FORMAT(/,1X,40(2H# ))  
 5000 FORMAT(/,' ===> System inflows (file) at ',F8.2,' hours',  
     *' (  Junction / Inflow, cfs)',/)  
 5001 FORMAT(/,' ===> System inflows (file) at ',F8.2,' hours',  
     *' (  Junction / Inflow, cu m/s)',/)  
 5830 FORMAT(6(1X,I10,'/',1PE9.2))  
 5833 FORMAT(6(1X,A10,'/',1PE9.2))  
 5831 FORMAT(' ===> System inflows (data group K3) at ',F8.2,  
     +          ' hours ( Junction / Inflow,cfs )',/)  
 5832 FORMAT(' ===> System inflows (data group K3) at ',F8.2,  
     +          ' hours ( Junction / Inflow,cu m/s )',/)  
 5999 FORMAT(1X,40(2H# ))  
CIM START OOOOOOOOO  
 6010 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I9,/,  
     .       '       CONDUIT NUMBER..........................',I10,/,  
     .       '       PIPE DEPTH...........................',F12.2,/,  
     .       '       PIPE WIDTH...........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.4,/,  
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/,  
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4,/,  
     .       '       SIMULATION TIME IN HOURS.............',F12.4)  
 6011 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I9,/,  
     .       '       CONDUIT NANE............................',A10,/,  
     .       '       PIPE DEPTH...........................',F12.2,/,  
     .       '       PIPE WIDTH...........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.4,/,  
     .       '       INVERT ELEVATION AT UPSTREAM END.....',F12.4,/,  
     .       '       INVERT ELEVATION AT DOWNSTREAM END...',F12.4,/,  
     .       '       SIMULATION TIME IN HOURS.............',F12.4)  
 6015 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I7,/,  
     .       '       INTERNAL CONDUIT NUMBER.................',I10,/,  
     .       '       PIPE DEPTH...........................',F12.2,/,  
     .       '       PIPE WIDTH...........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.4,/,  
     .       '       SIMULATION TIME IN HOURS.............',F12.4)  
 6016 FORMAT(/,' ====> EQUIVALENT PIPE INFORMATION FOR ORIFICE # ',I7,/,  
     .       '       CONDUIT NAME............................',A10,/,  
     .       '       PIPE DEPTH...........................',F12.2,/,  
     .       '       PIPE WIDTH...........................',F12.2,/,  
     .       '       PIPE LENGTH..........................',F12.2,/,  
     .       '       MANNINGS ROUGHNESS...................',F12.4,/,  
     .       '       SIMULATION TIME IN HOURS.............',F12.4)  
CIM END     OOOOOOOOO  
 9100 FORMAT(/,' ===> Error  ',F12.5,  
     +        ' hours.')  
 9200 FORMAT(/,' ===> Warning  End of input file reached at time = ',  
     +         F6.1,' hours.',/,  
     +'                 Simulation continues with zero inflow.',/)  
C=======================================================================  
      END  
ECHO is off.
REM File: INITAL.FOR  
ECHO is off.
      SUBROUTINE INITAL  
C	TRANSPORT BLOCK  
C	CALLED BY INTRAN NEAR LINE 1209  
C=======================================================================  
C     ROUTINE INITIALIZES FLOWS, AREAS, AND CONCENTRATIONS TO VALUES  
C     CORRESPONDING TO DRY WEATHER FLOW PLUS INFILTRATION.  
C     WHEN THERE ARE NO INITIAL VALUES OF DWF OR INFIL, VALUES REMAIN 0.0  
C  
C     LAST UPDATED AUGUST 1989 AND MAY 1993 BY R.E.D.  
C     BE SURE TO INITIALIZE STORAGE CONCENTRATIONS, WCH, 10/6/93.  
C     For linked DO-BOD, print out initial reaeration, etc.  WCH, 7/6/01.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TABLES.INC'  
      INCLUDE 'DRWF.INC'  
      INCLUDE 'HUGO.INC'  
      INCLUDE 'NEW81.INC'  
      INCLUDE 'TST.INC'  
CIMT  INCLUDE COMMON THAT INCLUDES PMANN  
      INCLUDE 'NEWTR.INC'  
CIMT  
Cwch, 7/6/01  
      INCLUDE 'TRANWQ.INC'  
C=======================================================================  
CIMT  SUM2 dimensioned to MQUAL  
      DIMENSION SUM2(MQUAL),QO(NET),QI(NET),QO1(NET),QO2(NET)  
      DIMENSION WELL1(NET),WELL2(NET)  
CIMT changed format for writting results  
CIMT  DIMENSION FIRMAT(13),KIRMAT(13),EFMT(2)  
CIMT  CHARACTER FIRMAT*4,KIRMAT*4,EFMT*4  
      CHARACTER BMJ*10  
      EQUIVALENCE (QO1(1),QMAX(1)),(QO2(1),QFULL(1))  
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2))  
      EQUIVALENCE (WELL1(1),SLOPE(1)),(WELL2(1),ROUGH(1))  
CIMT      DATA FIRMAT/'(I6,','I7,3','F10.','3,2X',',F9.','3,1X',',F9.',  
CIMT     1            '3,1X',',F9.','3,1X',',F9.','3,1X',')   '/  
CIMT      DATA KIRMAT/'(A9,','I4,3','F10.','3,2X',',F9.','3,1X',',F9.',  
CIMT     1            '3,1X',',F9.','3,1X',',F9.','3,1X',')   '/  
CIMT      DATA EFMT/',1X,','E9.3'/  
C=======================================================================  
      WRITE (N6,900)  
      IF(NPOLL.LE.0) THEN  
           WRITE (N6,905)  
           IF(METRIC.EQ.1) WRITE (N6,906)  
           IF(METRIC.EQ.2) WRITE (N6,907)  
	     WRITE(N6,908)  
Cwch, 7/6/01  
           ELSEIF(NWQ.EQ.0) THEN  
                WRITE (N6,905) (PNAME(K),K=1,NPOLL)  
                IF(METRIC.EQ.1) WRITE (N6,906) (PUNIT(K),K=1,NPOLL)  
                IF(METRIC.EQ.2) WRITE (N6,907) (PUNIT(K),K=1,NPOLL)  
	          WRITE(N6,908) ('--------',K=1,NPOLL)  
           ELSEIF(NWQ.EQ.1) THEN  
                WRITE (N6,9015) (PNAME(K),K=1,NPOLL)  
                IF(METRIC.EQ.1) WRITE (N6,9016) (PUNIT(K),K=1,NPOLL)  
                IF(METRIC.EQ.2) WRITE (N6,9017) (PUNIT(K),K=1,NPOLL)  
	          WRITE(N6,9018) ('--------',K=1,NPOLL)  
           ENDIF  
CIMT      IF(NPOLL.GT.0) THEN  
CIMT      DO 200 K = 1,NPOLL  
CIMT      IF(NDIM(K).NE.1) GO TO 200  
CIMT      NNX         = 2 + 2*K  
CIMT      DO 190 I    = 1,2  
CIMT      MMX         = NNX + I  
CIMT      KIRMAT(MMX) = EFMT(I)  
CIMT  190 FIRMAT(MMX) = EFMT(I)  
CIMT  200 CONTINUE  
CIMT      ENDIF  
C=======================================================================  
C     SET UP METRIC CONVERSION FACTORS.  
C     MULTIPLY FIRST UNITS TO OBTAIN SECOND UNITS.  
C=======================================================================  
      IF(METRIC.EQ.1) THEN  
                      CMET1 = 1.0  
                      CMET2 = 1.0  
                      CMET3 = 1.0  
                      ELSE  
                      CMET1 = 3.281  
C=======================================================================  
C                     SQ M TO SQ FT.  
C=======================================================================  
                      CMET2 = 10.764  
                      CMET3 = 35.31  
                      ENDIF  
      N        = 0  
      DO 100 I = 1,NE  
      M        = JR(I)  
      NTPE       = NTYPE(M)  
      IF(NTPE.EQ.22) KSTOR = KSTORE(M)  
C=======================================================================  
C     SUM UPSTREAM FLOWS AND POLLUTANT INFLOWS.  
C=======================================================================  
      SUM1    = 0.0  
      IF(NPOLL.GT.0) THEN  
                     DO 10 K = 1,NPOLL  
   10                SUM2(K) = 0.0  
                     ENDIF  
      DO 20 J = 1,3  
      L       = INUE(M,J)  
      NTPEU     = NTYPE(L)  
      IF(L.GT.NE) GO TO 20  
CIM THIS LINE NEEDS TO BE MODIFIED TO ROUTE FLOWS FOR   
CIM TYPE 27  
      IF(NTPEU.LE.20.OR.NTPEU.EQ.27) THEN  
                    QQ   = Q(L,2,1)*BARREL(L)  
                    ELSE  
                    KK   = GEOM3(L)  
                    BMJ  = KGEOM(L)  
                    QQ   = QO2(L)  
                    IF(JCE.EQ.0.AND.NOE(M).EQ.KK)  QQ = QO1(L)  
                    IF(JCE.EQ.1.AND.KOE(M).EQ.BMJ) QQ = QO1(L)  
                    ENDIF  
      IF(NPOLL.GT.0) THEN  
                     DO 25 K = 1,NPOLL  
   25                SUM2(K) = SUM2(K) + CPOL2(L,1,K) * QQ  
                     ENDIF  
      SUM1 = SUM1 + QQ  
   20 CONTINUE  
      KHR     = JHR + 1  
      IF(KHR.GT.24) KHR = 24  
                         QMAN    =  0.0  
CIM  CHANGE FOR VARIABLE BASE FLOW IN TRANSPORT  
CIM  CHANGE MADE TO INCLUDE MONTHLY FLOW FACTOR TO DETERMINE  
CIM  BASE FLOWS IN INITIAL CONDITIONS  
CIM  
      IF(NTPE.EQ.19) QMAN    = DIST(M)*BFFMONTH(1,NINT(GEOM3(M)))  
CIM                                        ------------------------  
CIM  
CIM      IF(NTYPE(M).EQ.19) QMAN    = DIST(M)  
cim  monthly variation in DWF  
      IF (NTPE.EQ.19) THEN  
	    BFF = BFFMONTH(2,NINT(GEOM3(M)))  
	ELSE  
	    BFF = 1.0  
	ENDIF  
      QQQ      = QDWF(M)*DVDWF(KDAY)*HVDWF(KHR)  
cim  monthly variation  
     a           * BFF  
cims  
      SUM1     = SUM1 + QINFIL(M) + QMAN + QQQ  
      Q(M,1,1) = SUM1/BARREL(M)  
      Q(M,2,1) = Q(M,1,1)  
      IF(Q(M,1,1).LT.0.0) Q(M,1,1) = 0.0  
      IF(Q(M,2,1).LT.0.0) Q(M,2,1) = 0.0  
      IF(NPOLL.GT.0.AND.SUM1.GT.0.0) THEN  
           DO 35 K = 1,NPOLL  
           IF(K.EQ.1) SUM2(K) = SUM2(K)+WDWF(M,K)*DVBOD(KDAY)*  
     1                  HVBOD(KHR)*DVDWF(KDAY)*HVDWF(KHR)  
cim monthly variation  
     2                  * BFF  
cim  
           IF(K.EQ.2) SUM2(K) = SUM2(K)+WDWF(M,K)*DVSS(KDAY)*  
     1                  HVSS(KHR)*DVDWF(KDAY)*HVDWF(KHR)  
cim monthly variation  
     2                  * BFF  
cim  
           IF(K.EQ.3) SUM2(K) = SUM2(K)+WDWF(M,K)*1.0*HVCOLI(KHR)*  
     1                     DVDWF(KDAY)*HVDWF(KHR)  
cim monthly variation  
     2                  * BFF  
cim  
           PMAN = 0.0  
CIMT           IF(NTYPE(M).EQ.19) THEN  
CIMT                         IF(K.EQ.1) PMAN = GEOM1(M)  
CIMT                         IF(K.EQ.2) PMAN = SLOPE(M)  
CIMT                         IF(K.EQ.3) PMAN = ROUGH(M)  
CIMT                         IF(K.EQ.4) PMAN = GEOM2(M)  
CIMT                         ENDIF  
CIM CHANGE FOR MONTHLY BASE FLOW FACTORS  
cim note that geom1 ...  are now mass not concentration  
CIM     
CIMT Change for additional constituents  
      IF(NTPE.EQ.19)  PMAN = PMANN(M,K)*BFFMONTH(1,NINT(GEOM3(M)))  
CIMT  
           SUM2(K)      = SUM2(K) + PMAN + CPINF(K)*QINFIL(M)  
           CPOL1(M,1,K) = SUM2(K)/SUM1  
CIMQP   INITIAL INITIAL OUTFLOW FOR TYPE 27 Quality Splitting Elements  
      IF(NTPE.EQ.27) CPOL1(M,1,K) = CPOL1(M,1,K) * DRATIO(M,K)  
CIMQP  
           CPOL2(M,1,K) = CPOL1(M,1,K)  
           IF(NTPE.EQ.22.AND.PTC0(KSTOR,K).GT.0.0)  
     1                               CPOL2(M,1,K) = PTC0(KSTOR,K)  
   35      CONTINUE  
           ELSE  
C#######################################################################  
C     WCH, 10/6/93.  DON'T MISS OUT ON INITIALIZING STORAGE VOLUME  
C       CONCENTRATIONS JUST BECAUSE THERE'S NO INFLOW.  
C=======================================================================  
           IF(NPOLL.GT.0.AND.SUM1.LE.0.0.AND.NTPE.EQ.22) THEN  
                DO 38 K = 1,NPOLL  
   38           CPOL2(M,1,K) = PTC0(KSTOR,K)  
                ENDIF  
           ENDIF  
C=======================================================================  
C     ASSUME ALL DWF IS NON-DIVERTED IN A FLOW DIVIDER TYPE ELEMENT.  
C=======================================================================  
C   MODIFIY TO INCLUDE TYPE 26 FLOW SPLIT  
      IF(NTPE.EQ.21.OR.NTPE.EQ.23.OR.NTPE.EQ.26) THEN  
                               QO1(M) = SUM1  
                               QO2(M) = 0.0  
                               ENDIF  
C=======================================================================  
C     LIFT STATION.  
C=======================================================================  
      IF(NTPE.EQ.20) THEN  
                   WELL1(M) = WELL2(M)  
                   IF(Q(M,2,1).GT.DIST(M)) THEN  
                                           Q(M,2,1) = DIST(M)  
                                           WELL1(M) = GEOM1(M)  
                                           WELL2(M) = WELL1(M)  
                                           ENDIF  
                   ENDIF  
C=======================================================================  
C     STORAGE UNIT.  
C=======================================================================  
      IF(NTPE.EQ.22) THEN  
C#### RED, 5/25/93.  REMOVE THIS LINE:    NITER = 1  
                   CALL ROUTE(D1,Q1)  
                   ENDIF  
C=======================================================================  
C     BACKWATER ELEMENT. ALL INITIAL FLOW IS  
C                        THROUGH THE INTERMEDIATE CONDUITS.  
C=======================================================================  
      IF(NTPE.EQ.25) THEN  
                   QO1(M)   = 0.0  
                   QO2(M)   = SUM1  
                   ENDIF  
      VELINT   = 0.0  
      A(M,1,1) = 0.0  
	DD       = 0.0  
C=======================================================================  
C     DETERMINE INITIAL FLOW AREA FOR CONDUITS.  
C=======================================================================  
      IF(KLASS(NTPE).LE.2) THEN  
           PS       = Q(M,1,1)/QFULL(M)  
           CALL FINDA(PS,A(M,1,1))  
           A(M,2,1) = A(M,1,1)  
	     A(M,1,2) = A(M,1,1)  
	     A(M,2,2) = A(M,1,1)  
	     Q(M,2,1) = Q(M,1,1)  
	     Q(M,2,2) = Q(M,1,1)  
           VELINT   = VEL(Q(M,1,1),A(M,1,1))  
Cwch, 7/6/01.  Add depth.  
           DD   = DEPTH(A(M,1,1)/AFULL(M))  
	     IF(NTPE.NE.10.AND.NTPE.NE.12) THEN  
	          DD = DD*GEOM1(M)  
	          ELSEIF(NTPE.EQ.10) THEN  
C     Modified basket handle  
                     DD = DD*(GEOM1(M)+GEOM2(M)/2.0)  
	          ELSEIF(NTPE.EQ.12) THEN  
C     Rectangular, round bottom  
                     DD = DD*P2(M)*DIST(M)  
                ENDIF  
	     ENDIF  
      W1              = SUM1/CMET3  
      IF(NTPE.EQ.22) W1 = QO(M)  
      W2              = A(M,1,1)/CMET2  
      W3              = VELINT/CMET1  
	W4              = DD/CMET1  
C=======================================================================  
Cwch, 7/6/01.  For linked DO-BOD, print out inital Ka values.  
C=======================================================================  
      IF(NWQ.EQ.1) THEN  
	   IF(KLASS(NTPE).LE.2.OR.NTPE.EQ.22) THEN  
	     CALL QUALPARM(ASURF,ASSETL,DBAR,DBARSETL,VELL,CS,WAVG)  
           CALL REAERATE(DECAY2,DBAR,VELL,WIND(M),TAIR(M),TWATER(M),REA,  
     1THETA(3),KWIND,KOVAR,GNUW,GNUA,RHOW,RHOA,DMOLEC,XLAMBDA,ZEE,CAPPA,  
     2 GAMMAZ,UTSTAR,PRESURE,UCSTAR,CAPPA3,CDRAG,IYZ,DELG1,ZZERO,USTAR,  
     3 CAYEL,DECAY2W,SALINITY,G1,ZAA,N6,DECAY2F)  
           IF(JCE.EQ.0.AND.NPOLL.GT.0) WRITE(N6,7011) NOE(M),NTPE,  
     1        W1,W2,W3,W4,DBAR/CMET1,WAVG/CMET1,CS,  
     2        DECAY2F*86400.,DECAY2W*86400.,(CPOL2(M,1,K),K=1,NPOLL)  
           IF(JCE.EQ.1.AND.NPOLL.GT.0) WRITE(N6,7012) KOE(M),NTPE,  
     1        W1,W2,W3,W4,DBAR/CMET1,WAVG/CMET1,CS,  
     2        DECAY2F*86400.,DECAY2W*86400.,(CPOL2(M,1,K),K=1,NPOLL)  
	     ELSE  
           IF(JCE.EQ.0) WRITE(N6,7021) NOE(M),NTPE,W1,  
     +                            (CPOL2(M,1,K),K=1,NPOLL)  
           IF(JCE.EQ.1) WRITE(N6,7022) KOE(M),NTPE,W1,  
     +                            (CPOL2(M,1,K),K=1,NPOLL)  
           ENDIF  
         ELSE  
CIMT  CHANGE FORMAT ON OUTPUTS  7001 was FIRMAT and 7002 was KIRMAT      
      IF(JCE.EQ.0.AND.NPOLL.LT.1) WRITE(N6,7001) NOE(M),NTPE,W1,W2,W3,W4  
      IF(JCE.EQ.1.AND.NPOLL.LT.1) WRITE(N6,7002) KOE(M),NTPE,W1,W2,W3,W4  
      IF(JCE.EQ.0.AND.NPOLL.GT.0) WRITE(N6,7001) NOE(M),NTPE,W1,W2,W3,W4  
     +                            ,(CPOL2(M,1,K),K=1,NPOLL)  
      IF(JCE.EQ.1.AND.NPOLL.GT.0) WRITE(N6,7002) KOE(M),NTPE,W1,W2,W3,W4  
     +                            ,(CPOL2(M,1,K),K=1,NPOLL)  
	   ENDIF       
  100 CONTINUE  
      RETURN  
C=======================================================================  
  900 FORMAT(1H1,/,  
     1' ************************************************************',/,  
     2' * ELEMENT FLOWS, AREAS, AND CONCENTRATIONS ARE INITIALIZED *',/,  
     3' *         TO DRY WEATHER FLOW AND INFILTRATION VALUES.     *',/,  
     4' ************************************************************',//  
     5)  
CIM SET MAXIMUM NUMBER TO 99  
CWCH, 9/27/99.  USE WIDTH-12 FIELDS, IN CASE OF LARGE BACTERIA NOS.   
  905 FORMAT (3X,' ELEMENT',9X,'FLOW',6X,'AREA',5X,'VELOCITY',  
     + '    DEPTH ',99(4X,A8))  
  906 FORMAT (5X, 'NUMBER  TYPE   (CFS)    (SQ FT)   (FT/SEC)',   
     + '     (FT) ', 99(4X, A8))  
  907 FORMAT (5X, 'NUMBER  TYPE   (CMS)    (SQ M)     (M/SEC)',   
     + '     (M)  ', 99(4X, A8))  
  908 FORMAT (5X,'------  ----   -----    ------    -------- ',  
     + '  ------- ',99(4x,A8))  
 7001 FORMAT(I10,I6,4F10.3,1X,99F12.3)  
 7002 FORMAT(A10,I6,4F10.3,1X,99F12.3)  
Cwch, 7/6/01  
 7011 FORMAT(I10,I6,9F10.3,1X,99F12.3)  
 7012 FORMAT(A10,I6,9F10.3,1X,99F12.3)  
 7021 FORMAT(I10,I6,F10.3,81X,99F12.3)  
 7022 FORMAT(A10,I6,F10.3,81X,99F12.3)  
 9015 FORMAT (3X,' ELEMENT',9X,'FLOW',6X,'AREA',5X,'VELOCITY',  
     + '    DEPTH ',' AVG DEPTH',' TOP WIDTH','  SAT. DO ',  
     2 '  FLOW Ka ','  WIND Ka ',99(4X,A8))  
 9016 FORMAT (5X, 'NUMBER  TYPE   (CFS)    (SQ FT)   (FT/SEC)',   
     1 '     (FT) ','     (FT) ','     (FT) ','   (MG/L) ',  
     2 '  (1/DAY) ','  (1/DAY) ',99(4X, A8))  
 9017 FORMAT (5X, 'NUMBER  TYPE   (CMS)    (SQ M)     (M/SEC)',   
     1 '     (M)  ','     (M)  ','     (M)  ','   (MG/L) ',  
     2 '  (1/DAY) ','  (1/DAY) ',99(4X, A8))  
 9018 FORMAT (5X,'------  ----   -----    ------    -------- ',  
     1 '  -------', '  --------','  --------','  --------',  
     2 '  --------','  --------',99(4x,A8))  
C=======================================================================  
      END  
ECHO is off.
REM File: INTCHR.FOR  
ECHO is off.
      FUNCTION INTCHR(J1)  
C     RAIN BLOCK  
C     CALLED BY GTRAIN NEAR LINE 969  
C=======================================================================  
C     Change a character to an integer.  
C=======================================================================  
      CHARACTER*1 J1(3)  
      INTEGER      I(3)  
      INTCHR   = 0  
      DO 100 J = 1,3  
      I(J)     = ICHAR(J1(J)) - 48  
100   INTCHR   = INTCHR + I(J)*10**(3-J)  
      RETURN  
      END  
ECHO is off.
REM File: NDATE.FOR  
ECHO is off.
      SUBROUTINE NDATE(TIME,JDAY,TMDAY)  
C#######################################################################  
C     THIS SUBROUTINE CALCULATES THE NEW JULIAN DAY AND TIME OF DAY  
C     RESULTING FROM ADDING TIME TO THE EXISTING JULDAY AND TIMDAY  
C  
C     JDAY  = NEW JULIAN DAY  
C     TMDAY = NEW TIME OF DAY IN SECONDS  
C     TIME  = TIME INCREMENT IN SECONDS  
C#######################################################################  
      INCLUDE 'STIMER.INC'  
C=======================================================================  
      TMDAY = TIMDAY + TIME  
      JDAY  = JULDAY  
 100  IF(TMDAY.GE.86400.0) THEN  
                TMDAY = TMDAY - 86400.0  
                JDAY  = JDAY + 1  
                JYEAR = JDAY/1000  
                IDAY  = JDAY - 1000*JYEAR  
                IF (JYEAR.LT.100) JYEAR = JYEAR + 1900  
                IF(MOD(JYEAR,4).EQ.0.AND.IDAY.GE.367.OR.  
     +             MOD(JYEAR,4).NE.0.AND.IDAY.GE.366) THEN  
                                         JYEAR  = JYEAR + 1  
                                         JDAY   = JYEAR*1000 + 1  
                                         ENDIF  
                ENDIF  
      IF(TMDAY.GE.86400.0) GO TO 100  
      RETURN  
      END  
  
ECHO is off.
REM File: NHEAD.FOR  
ECHO is off.
      SUBROUTINE NHEAD(N,NL,NH,HEAD1,HEAD2,QP,AREA,VEL,HRAD,  
     +                          ANH,ANL,RNL,RNH,IDOIT,KINK,AS1)  
C     EXTRAN BLOCK  
C	CALLED BY _ROUTE ROUTINES AND ELSEWHERE  
C=======================================================================  
C     This subroutine performs the following functions:  
C       1 - Converts NODAL depths to pipe depths.  
C       2 - Assigns conduit surface areas to upstream and downstream  
C           junctions depending on depth and flow conditions. Note that  
C           a surface area is not assigned to orifice or weir links.  
C       3 - Computes average conduit hydraulic parameters AREA, VEL, HRAD  
C           used to compute flow in _ROUTE routines.  
C  
C     WCH, 11/16/93.  CORRECT MID-CHANNEL WIDTH VALUE FOR NORMAL  
C       SUBCRITICAL FLOW CASE.  
C     RED, 12/31/93.  CORRECTION FOR INTEGER IDOIT VALUE.  
C     WCH, 12/7/94.  ADD RED COMMENTS, SET FASNH = 1.0 ALWAYS, AND  
C       MAKE SEVERAL CODE CHANGES TO CORRESPOND TO RED CODE.  
C     WRM, 07/01/1997 CREATED NHEAD FROM HEAD BY ADDING ARGUMENT AS1  
C       AND CHANGING ALL OCCURANCES OF AS->AS1. REDUCTIONS INTO AS1  
C       ARE NO LONGER IN COMMON AND CAN THUS BE PERFORMED IN PARALLEL.  
C     WCH, 7/20/04. CHANGE AREA WEIGHTING FOR CASE CR2, CRITICAL FLOW  
C       DOWNSTREAM.   
C     WCH, 7/20/04. KEEP ALL SURFACE AREA WHEN FASHN<1 IN CASE=SUB.  
C     WCH (RED), 7/23/04. ADD OPTION FOR AREA ETC. WEIGHTING FOR   
C       CASE=SUB.  
C  
C   Revised by Chuck Moore (CDM Annandale to improve computational  
C   efficiency.  Gives results identical to original program.  
C   Revised by C. Moore and Brett Cunningham to improve consistency  
C   in calculations.  Major revision to improve calculation of  
C   representative or average pipe characteristics to provide  
C   consistent flow calculations in _ROUTE subroutines.  
C  
C   Definition of terms.  
C     Downstream end of pipe is the end with the lowest pipe invert  
C     elevation.  
C  
C                                       UPSTREAM  DOWNSTREAM  
C  
C     Junction                             NL        NH  
C     Junction invert elevation            Z(NL)     Z(NH)  
C     Conduit invert elevation             ZU(N)     ZD(N)  
C     Flow elevation                       HEAD1     HEAD2  
C     Flow depth in conduit                YNL       YNH  
C  
C     IDOIT = 0, Means a dry pipe and no flow calculation.  
C     Note, HEAD1 = Z(NL) + Y(NL) in calling subroutines, and ZU not  
C     necessarily = Z(NL).  
C     Also, HEAD2 = Z(NH) + Y(NH) in calling subroutines, and ZD not  
C     necessarily = Z(NH).  
C  
C     Assigns pipes to one of four conditions:  
C     SUB - Depths of flow at both the upstream and downstream ends  
C           is are greater than the critical and normal flow depths.  
C           Use depths at upstream and downstream junctions for depths  
C           at upstream and downstream ends of conduit.  Assigns 1/2 of  
C           conduit surface area to upstream and downstream junctions.  
C     CR1 - Reverse flow and depth at upstream junction is less than  
C           critical flow depth.  Flow must pass through critical at  
C           upstream end.  
C           Use critical flow depth at upstream end, junction depth  
C           at downstream end.  Flow must pass through critical at  
C           downstream end.  Apply conduit surface area to downstream  
C           junction.  
C     CR2 - Positive flow and depth at downstream junction is less than  
C           critical or normal depth.  Assign minimum of normal or  
C           critical depth to downstream end of conduit and junction  
C           elevation at the upstream end.  Flow must pass through  
C           critical or normal depth at downstream end.  Assign conduit  
C           surface area to upstream junction.  
C     DR1 - If pipe is completely dry, set all parameters to small  
C           values and return.  
C           If the depth in the downstream end is such that there is  
C           water in the pipe, set depth at downstream end to junction  
C           depth.  Set depth at upstream end to small value.  Estimate  
C           actual surface area in pipe and assign to downstream junction.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'BD.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'OUT.INC'  
      DIMENSION AS1(NEE)  
CIMspeed  don't have character if statements  
CIM  make KINK integer  
cim  make appropriate changes to array link in other parts of program  
cim  add variables DR1, SUB, CR1, and CR2 to new common in OUT.INC  
cim  initialize in parameter statement  
cim      CHARACTER*3 KINK  
C=======================================================================  
      YNL   = HEAD1 - ZU(N)  
cim limit ynl and ynh to crown of pipe and to be greater than zero  
      YNL   = AMIN1(YNL,DEEP(N) + 2.0 * fudge)  
      YNL   = AMAX1(YNL,fudge)  
      YNH   = HEAD2 - ZD(N)  
      YNH   = AMIN1(YNH,DEEP(N) + 2.0 * fudge)  
      YNH   = AMAX1(YNH,fudge)  
      FASNH = 1.0  
      IDOIT = 1  
CIM SPEED MOVE FUDGE INITIALIZATION TO TRANSX      FUDGE = 0.0001  
CIM fudge now equals 0.00001  
CIM REDO THESE IF STATEMENTS  
      IF(YNL.GT.FUDGE.AND.YNH.GT.FUDGE) THEN  
C=======================================================================  
C     Computations for YNL > 0.0, YNH > 0.0   start  
C     Elevation in both upstream and downstream junctions is  
C     greater than the pipe invert  
C=======================================================================  
C              FLOW = QP < 0.0  ==> ADVERSE FLOW  
C=======================================================================  
C :(    Eliminate checks between pipe invert elevation and invert  
C :(    elevation of adjacent node.  By definition, the elevation of  
C :(    all pipes must be greater than or equal to the junction invert.  
C :(    Only sump type orifices can have inverts less than upstream  
C :(    conduit.  Note that there is special code below for sump orifice,  
C :(    this orifice code may need to be modified to account for the  
C :(    commenting out of these lines.  
C :(      The conduit is SUB if the invert elevation of  
C :(      the upstream junction is less than the invert elevation  
C :(      of the conduit, and subcritical or critical otherwise.  
C         SUB if upstream junction depth is greater than the  
C         critical conduit depth.  
C         CR1 if upstream junction depth is less than the  
C         critical conduit depth.  
C=======================================================================  
           IF(QP.LT.0.0) THEN  
                IF(ZU(N)-Z(NL).LE.FUDGE) THEN  
                     KINK = SUB  
                     ELSE  
                     CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM)  
C####                     IF(YC-YNL.LE.FUDGE) KINK = SUB  
C####                     IF(YC-YNL.GT.FUDGE) KINK = CR1  
C#### WCH (RED), 12/7/94.  CHANGE TO FORM USED BY RED.  
                     IF(YC+ZU(N)-HEAD1.LE.FUDGE) KINK = SUB  
                     IF(YC+ZU(N)-HEAD1.GT.FUDGE) KINK = CR1  
                     ENDIF  
C                ENDIF  (change end if to else below)  
C=======================================================================  
C               FLOW = QP > 0.0   ==> POSITIVE FLOW  
C=======================================================================  
C         CR2 if the downstream junction depth is less than the  
C         minimum of critical or normal conduit depth.  
C         SUB if the downstream junction depth is greater than the  
C         maximum of critical or normal conduit depth.  
C         If the downstream depth is between normal and critical,  
C         calculate the value of weighting variable FASNH.  
C=======================================================================  
CIM change to else           IF(QP.GE.0.0) THEN  
                ELSE  
c   ZD should not be less than Z (maybe orifices)  
                IF(ZD(N)-Z(NH).LE.FUDGE) THEN  
                     KINK = SUB  
                     ELSE  
                     CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM)  
                     Y2 = AMIN1(YC,YNORM)  
C$$$$$  Brett Cunningham  change FUDGE to -FUDGE below  
                     IF(Y2-YNH.GT.FUDGE) THEN  
                         KINK = CR2  
C$$$$$  Brett Cunningham  change FUDGE to -FUDGE below?????  
                         ELSE IF(YNH-AMAX1(YC,YNORM).GT.FUDGE) THEN  
                             KINK = SUB  
                         ELSE  
C=======================================================================  
C     Variable FASNH accounts for case in which downstream depth, YNH,  
C     is between critical and normal depth of entering pipe.  Idea is  
C     if YNH ~ Ycrit then FASNH ~ small and don't use much pipe area  
C     for this junction since entering flow is very near critical.  If  
C     YNH ~ Ynorm, then FASNH ~ 1.0 and use most of pipe area for this  
C     junction since entering flow is near normal.  However, must  
C     check for QP = 0 and YNH = 0 ==> Ycrit = Ynorm = YNH = 0.  In  
C     this case, assume downstream flow will be close to critical  
C     and set FASNH = 0.  
C=======================================================================  
C#### WCH, 12/7/94.  CHECK FOR ZERO DENOMINATOR.  
                         IF(ABS(YNORM-YC).GT.FUDGE) THEN  
                              FASNH = (YNH-Y2)/ABS(YNORM-YC)  
                              ELSE  
                              FASNH = 0.0  
                              ENDIF  
                         ENDIF  
                     ENDIF  
                ENDIF  
cimspeedy           ENDIF  
cimspeedy       End of Computations for YNL > 0.0, YNH > 0.0  
cim  
           else  
           IF(YNL.LE.FUDGE.AND.YNH.LE.FUDGE) THEN  
C=======================================================================  
C     DRY PIPE-> depth in upstream and downstream junctions is less than  
C     the pipe invert elevation.  
C  
C=======================================================================  
cim don't think that this should be done but not too sure  
cim take out for now 6/97  
c           HEAD1     = HEAD2  
                YMID      = FUDGE  
                KINK      = DR1  
                ANH       = FUDGE  
                ANL       = FUDGE  
                RNL       = FUDGE  
                BMID      = FUDGE  
C#### WCH (RED), 12/7/94.  Add AMID and RMID.  
                AMID      = FUDGE  
                RMID      = FUDGE  
                AREA      = FUDGE  
                VEL       = 0.0  
                QO(N)     = 0.0  
                HRAD      = FUDGE  
C#### RED (WCH), 12/31/93.  CORRECT INTEGER IDOIT TO BE ZERO.  
C####    IDOIT     = FUDGE  
                IDOIT     = 0  
                AOVERB(N) = FUDGE  
C#### WCH, 12/7/94.  RED CODE USES SAME CALC. FOR NKLASS = 10.  
C####           IF(NKLASS(N).LE.9)  THEN  
                AS1(NL) = AS1(NL) + BMID*LEN(N)/2.0  
                AS1(NH) = AS1(NH) + BMID*LEN(N)/2.0  
C####                ENDIF  
C####           IF(NKLASS(N).EQ.10) AS1(NL) = AS1(NL) + BMID*LEN(N)/2.0  
c     write(n6,*) 1,n,qp,ynl,ynh,ymid,kink  
                RETURN  
C  end of dry pipe calculations.  
cim speedy           ENDIF  
                elseif (YNH.GT.FUDGE) THEN  
C=======================================================================  
C     YNL LE 0, YNH.GT.0  
C     YNL < 0.0, YNH > 0.0  
C     Elevation at upstream junction is less than US conduit invert.  
C     Elevation at downstream junction is greater than DS conduit invert.  
C     If downstream HGL is less than the invert of the upstream  
C     end of the conduit, the conduit has no flow, use condition DR1  
C     If downstream HGL is greater than the invert of the upstream  
C     end of the conduit, flow is in reverse direction, assign critical  
C     depth to upstream end, use condition CR1.  
C=======================================================================  
CIMSPEED      IF(YNL.LE.FUDGE) THEN  
                     IF(HEAD2-ZU(N).LT.FUDGE) THEN  
                          KINK = DR1  
                          ELSE IF(ZU(N).LE.Z(NL)) THEN  
                            KINK = SUB  
                          ELSE  
                          CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM)  
                          KINK = CR1  
                          ENDIF  
cimspeed           ENDIF  
C=======================================================================  
C     YNH LE 0, YNL GT 0  
C     YNL > 0.0, YNH < 0.0  
C     Here elevation in downstream node is less than DS pipe invert and  
C     elevation in upstream node is greater than US pipe invert.  
C     Always minimum of critical or normal downstream, CR2  
C     RED added the following code..  
C     If upstream HGL is less than the invert of the downstream  
C     end of conduit + fudge, conduit is dry (RED code) (very flat pipe)  
C     1 - This should never ever happen.  If the upstream pipe invert end  
C         by definition is always greater than or equal to the elevation of  
C         the downstream invert, then if the elevation is greater than the  
C         upstream invert it must alway be greater than the invert of the  
C         downstrea invert.  
C     2-  The way that the program assigns YNL to fudge in DR1 part of the  
C         code is not correct even if this could occur.  
C         Comment these lines out.  
C=======================================================================  
                else  
cimspeed      IF(YNH.LE.FUDGE) THEN  
C#### WCH (RED), 12/7/94.  ADD ADDITIONAL IF INVOLVING HEAD1 AND GOTO2000.  
C :*         IF(HEAD1-ZD(N).LT.FUDGE) THEN  
C :*            KINK = DR1  
                IF(ZD(N).LE.Z(NH)) THEN  
                     KINK = SUB  
                     ELSE  
                     CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM)  
                     Y2 = AMIN1(YC,YNORM)  
                     KINK = CR2  
                     ENDIF  
                GO TO 2000  
                ENDIF  
            ENDIF  
C=======================================================================  
C     SPECIAL CONDITION FOR SUMP ORIFICES  
C=======================================================================  
C#### WCH, 12/7/94.  THIS IF-GROUP HAS BEEN COMMENTED OUT IN OSU/EPA  
C     CODE. UN-COMMENT (USE FORTRAN LINES) TO CORRESPOND TO RED CODE.  
C     WCH: AGREE WITH THESE LINES.  ELSE IF DOWNSTREAM INVERT, ZD, <  
C     INVERT OF DOWNSTREAM JUNCTION, Z(NH) OR Z(J) BELOW, THEN  
C     EQUIVALENT ORIFICE CONDUIT WILL ALWAYS "SEE" A DOWNSTREAM DEPTH  
C     OF AT LEAST THE POSITIVE DIFFERENCE, Z(NH) - ZD WHEN IN FACT THE  
C     DEPTH SHOULD BE ZERO.  THESE STATEMENTS ALSO KEEP INITIAL VOLUME  
C     IN ORIFICE PIPE SET AT ZERO VALUE (OR AS CLOSE AS POSSIBLE USING  
C     FUDGE VALUE FOR CROSS SECTIONAL AREA).  
CIM START  OOOOOOOOOOO  
CIM   MODIFY TO INCLUDE RECTANGULAR BOTTOM OUTLET ORIFICE  
C=======================================================================  
      IF(((NKLASS(N).EQ.52).OR.(NKLASS(N).EQ.54))  
CIM END OOOOOOOOOOO  
     A    .AND.YNL.LE.0.96*DEEP(N)) THEN  
              J   = NJUNC(N,2)  
              YNH = HEAD2 - Z(J)  
              IF(YNH.LE.FUDGE) THEN  
                               CALL DEPTHX(N,NKLASS(N),QP,YC,YNORM)  
                               Y2 = AMIN1(YC,YNORM)  
                               KINK  = CR2  
                               ELSE  
                               KINK  = SUB  
                               ENDIF  
              ENDIF  
C=======================================================================  
C     'NORMAL SITUATION' HALF SURFACE AREA AT EACH END  
C=======================================================================  
C#### WCH, 12/7/94.  NOTE, RED CODE HAS SPECIAL SITUATION FOR OUTFALL  
C     CONDUITS.  OSU/EPA CODE DOES NOT HAVE VARIABLE HTAS.  
C  
C      IF(HTAS(NL).GT.0.AND.HTAS(NH).GT.0) THEN  
C                                    IF(KINK.EQ.CRT1) KINK = SUBN  
C                                    IF(KINK.EQ.CRT2) KINK = SUBN  
C                                    ENDIF  
C=======================================================================  
C#### WCH (RED), 12/7/94.  CREATE STMT 2000.  
C  
 2000 CONTINUE  
CIM SPEEDY IF(KINK.EQ.SUB) THEN  
      SELECT CASE (KINK)  
      CASE (SUB)  
CIM SPEEDY  
change ----------------------------------------------------------------  
CHANGE DEFAULT CASE IS TO USE MIDDLE VALUE  
C  
change           YMID = 0.5*(YNL+YNH)  
         FACTOR = 0.5  
CHANGE  This is correction for YMID, do only if called for by IM2  
         IF (IM2.EQ.1) THEN  
CHANGE  IF Q is positive and HGL slope is greater than bottom slope  
            IF ((QP.GT.0.0).AND.((HEAD1-HEAD2)-(ZU(N)-ZD(N)).  
     1                                      GT.0.0)) THEN  
CHANGE YNORM GT YC INDICATES MILD BOTTOM SLOPE - This is M2 condition....  
               IF(YNORM.GT.YC) THEN  
                  FACTOR = RM2INTER(YNL,YNH,YNORM,YC,NKLASS(N),DEEP(N))  
                  ELSEIF  (YNORM.LT.YC) THEN  
CHANGE THIS IS FOR STEEP BOTTOM SLOPE S2 drawdown condition  
                    FACTOR = RS2INTER(YNL,YC,YNORM,YC,NKLASS(N),DEEP(N))  
                  ELSE  
CHANGE ALSO TRAP FOR CRITICAL BOTTOM SLOPE (YNORM=YC) to avoid zero divide  
                  FACTOR = 0.5  
                  ENDIF  
               ENDIF  
            ENDIF  
         YMID = YNH + (YNL-YNH)*FACTOR  
CHANGE  
change ----------------------------------------------------------------  
         IF(YMID.LT.FUDGE) YMID = FUDGE  
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL)  
C#### WCH, 11/16/93.  SERIOUS ERROR.  CHANGE "WIDTH" TO BMID  
C####         CALL HYDRAD(N,NKLASS(N),YMID,HRAD,AREA,WIDTH)  
Cwch, 7/23/04         CALL HYDRAD(N,NKLASS(N),YMID,HRAD,AREA,BMID)  
         CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID)  
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH)  
C#### WCH, 12/7/94.  RED CODE DOES NOT DISTIGUISH BETWEEN KLASS 10  
C     AND OTHERS.  
C  
C####           IF(NKLASS(N).LE.9) THEN  
         AS1(NL) = AS1(NL)+0.25*(BNL+BMID)*LEN(N)  
         AS1(NH) = AS1(NH)+0.25*(BMID+BNH)*LEN(N)*FASNH  
Cwch, 7/20/04. If FASNH < 1, add remaining area, i.e., area not added   
C     to downstream node, to upstream node. Optional, from AA line.   
      IF(FASNH.LT.1.0.AND.NFASNH.EQ.1) AS1(NL) = AS1(NL) +   
     1    0.25*(BMID+BNH)*LEN(N)*(1.0-FASNH)  
C####                ENDIF  
C####           IF(NKLASS(N).EQ.10)AS1(NL) = AS1(NL) + BMID*LEN(N)  
C=======================================================================  
C#### WCH, 12/7/94.  RED CODE OMITS FOLLOWING LINES UP TO RETURN AND  
C     USES COMPLEX WEIGHTING CALCULATION AT END.  DON'T USE  
C     RED CODE UNTIL BETTER UNDERSTOOD BY WCH.  THUS, LEAVE THESE LINES.  
C=======================================================================  
change ----------------------------------------------------------------  
change           AREA      = 0.50*(ANL+ANH)  
change           HRAD      = 0.50*(RNL+RNH)  
change           WIDTH     = 0.50*(BNL+BNH)  
Cwch, 7/23/04         WIDTH = BMID  
change  
change ----------------------------------------------------------------  
Cwch, 7/23/04. Add option for three different weighting schemes, for  
C     backward and forward compatibility.  From RED.  
C     NAVER = 1 is SWMM3 (1/4,1/2,1/4)  
C     NAVER = 2 is SWMM4 (0,1,0) = default  
C     NAVER = 3 is SWMM5 (1/6,2/3,1/6)   
cred  move to the past on the areas of links - 2/27/2003  
      AREA  = wup(naver)*ANL+wmd(naver)*AMID+wdn(naver)*ANH  
      HRAD  = wup(naver)*RNL+wmd(naver)*RMID+wdn(naver)*RNH  
      WIDTH = wup(naver)*BNL+wmd(naver)*BMID+wdn(naver)*BNH  
C  
         HRAD      = AMAX1(HRAD,FUDGE)  
         WIDTH     = AMAX1(WIDTH,FUDGE)  
         VEL       = QP/AREA  
         AOVERB(N) = AREA/WIDTH  
c     write(n6,*) 2,n,qp,ynl,ynh,ymid,kink  
         RETURN  
cim speedy           ENDIF  
C=======================================================================  
C     CRITICAL SECTION UPSTREAM AND SURFACE AREA DOWNSTREAM  
C=======================================================================  
cim speedy      IF(KINK.EQ.CR1) THEN  
      CASE (CR1)  
cim speedy  
         HEAD1 = YC + ZU(N)  
         YNL   = YC  
change ----------------------------------------------------------------  
c  
CHANGE DEFAULT CASE IS TO USE MIDDLE VALUE  
C  
change           YMID = 0.5*(YNL+YNH)  
         FACTOR = 0.5  
CHANGE  This is correction for YMID, do only if called for by IM2  
         IF (IM2.EQ.1) THEN  
CHANGE  IF Q is positive and HGL slope is greater than bottom slope  
            IF ((QP.GT.0.0).AND.((HEAD1-HEAD2)-(ZU(N)-ZD(N)).  
     1                                     GT.0.0)) THEN  
CHANGE YNORM GT YC INDICATES MILD BOTTOM SLOPE - This is M2 condition....  
               IF(YNORM.GT.YC) THEN  
                  FACTOR = RM2INTER(YNL,YNH,YNORM,YC,NKLASS(N),DEEP(N))  
                  ELSEIF  (YNORM.LT.YC) THEN  
CHANGE THIS IS FOR STEEP BOTTOM SLOPE S2 drawdown condition  
                    FACTOR = RS2INTER(YNL,YC,YNORM,YC,NKLASS(N),DEEP(N))  
                  ELSE  
CHANGE ALSO TRAP FOR CRITICAL BOTTOM SLOPE (YNORM=YC) to avoid zero divide  
                  FACTOR = 0.5  
                  ENDIF  
               ENDIF  
            ENDIF  
         YMID = YNH + (YNL-YNH)*FACTOR  
CHANGE  
change ----------------------------------------------------------------  
         IF(YMID.LE.FUDGE) YMID = FUDGE  
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL)  
         CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID)  
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH)  
C#### WCH, 12/7/94.  RED USES COEF OF 0.5, NOT 0.25.  
C####           AS1(NH) = AS1(NH) + 0.25*(BMID+BNH)*LEN(N)  
         AS1(NH) = AS1(NH) + 0.5*(BMID+BNH)*LEN(N)  
cim speedy           ENDIF  
C=======================================================================  
C     CRITICAL SECTION DOWNSTREAM AND SURFACE AREA UPSTREAM  
C=======================================================================  
cim speedy      IF(KINK.EQ.CR2) THEN  
      CASE (CR2)  
cim speedy  
         YNH   = Y2  
         HEAD2 = YNH + ZD(N)  
change ----------------------------------------------------------------  
CHANGE DEFAULT CASE IS TO USE MIDDLE VALUE  
C  
change           YMID = 0.5*(YNL+YNH)  
         FACTOR = 0.5  
CHANGE  This is correction for YMID, do only if called for by IM2  
         IF (IM2.EQ.1) THEN  
CHANGE  IF Q is positive and HGL slope is greater than bottom slope  
            IF ((QP.GT.0.0).AND.((HEAD1-HEAD2)-(ZU(N)-ZD(N)).  
     1                                GT.0.0)) THEN  
CHANGE YNORM GT YC INDICATES MILD BOTTOM SLOPE - This is M2 condition....  
               IF(YNORM.GT.YC) THEN  
                  FACTOR = RM2INTER(YNL,YNH,YNORM,YC,NKLASS(N),DEEP(N))  
                  ELSEIF  (YNORM.LT.YC) THEN  
CHANGE THIS IS FOR STEEP BOTTOM SLOPE S2 drawdown condition  
                    FACTOR = RS2INTER(YNL,YC,YNORM,YC,NKLASS(N),DEEP(N))  
                  ELSE  
CHANGE ALSO TRAP FOR CRITICAL BOTTOM SLOPE (YNORM=YC) to avoid zero divide  
                  FACTOR = 0.5  
                  ENDIF  
               ENDIF  
            ENDIF  
         YMID = YNH + (YNL-YNH)*FACTOR  
CHANGE  
change ----------------------------------------------------------------  
         IF(YMID.LE.FUDGE) YMID = FUDGE  
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL)  
         CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID)  
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH)  
C=======================================================================  
Cwch, 7/20/04. After extensive consideration by Bob Dickinson, with   
C     input from Larry Roesener and others, the consensus (RED, WCH,  
C     LAR, TedB) is that *all* surface area of pipe should go to  
C     upstream node when downstream node is critical or supercritical,  
C     regardless of status of upstream node.  Hence, coefficient below  
C     should be 0.50, not 0.25.  
C=======================================================================  
C         AS1(NL) = AS1(NL) + 0.25*(BNL+BMID)*LEN(N)  
         AS1(NL) = AS1(NL) + 0.50*(BNL+BMID)*LEN(N)  
cim speedy           ENDIF  
C=======================================================================  
C     DRY UPSTREAM AND SURFACE AREA DOWNSTREAM  
C=======================================================================  
cim speedy      IF(KINK.EQ.DR1) THEN  
      CASE (DR1)  
cim speedy  
CIM BAC This next statement seems to be a total screw up,  
CIM  No reason to change upstream head to downstream head  
CIM           HEAD1 = HEAD2  
         YNL   = FUDGE  
C#### WCH, 12/7/94.  RED CODE DIFFERS CONSIDERABLY.  
C     BELOW, COMMENT OUT OLD LINES AND INCLUDE COMMENT FOR EACH  
C     NEW RED LINE.  BASICALLY, DON'T USE MID (YMID, ETC.) VALUES.  
C####           YMID  = HEAD2-0.5*(ZU(N)+ZD(N))  
C####           IF(YMID.LT.FUDGE) YMID = FUDGE  
CIM if YNL = fudge simply set others to fudge and get on with it.?  
         CALL HYDRAD(N,NKLASS(N),YNL,RNL,ANL,BNL)  
cim              RNL = FUDGE  
cim              ANL = FUDGE  
cim              BNL = FUDGE  
CIM  
C####           CALL HYDRAD(N,NKLASS(N),YMID,RMID,AMID,BMID)  
         CALL HYDRAD(N,NKLASS(N),YNH,RNH,ANH,BNH)  
C####           AREA      = 0.25*(ANL+2.0*AMID+ANH)  
C####           HRAD      = 0.5*(RMID+RNH)  
C#### WCH, 12/7/94.  NEW AREA =   AND HRAD =.  
cim note that if ANL is FUDGE then AREA will be FUDGE  
         AREA      = SQRT(ANL*ANH)  
         AREA      = AMAX1(AREA,FUDGE)  
cim set HRAD to that of downstream end?  
         HRAD      = RNH  
         HRAD      = AMAX1(HRAD,FUDGE)  
C  
         VEL       = 0.0  
         QO(N)     = 0.0  
         IDOIT     = 0  
         AOVERB(N) = FUDGE  
C#### WCH, 12/7/94.  RED INCLUDES CALC. FOR HGL NOT IN OSU/EPA CODE. OMIT.  
C####         HGL(N,1)  = YNL + ZU(N)  
C####         HGL(N,2)  = YNH + ZD(N)  
C#### OLD OSU/EPA CODE:  
C####           AS1(NH) = AS1(NH) + 0.25*(BMID+BNH)*LEN(N)  
C####           IF(ZU(N)-Z(NL).LT.FUDGE) AS1(NL) =  
C####     +                            AS1(NL) + 0.25*(BNL+BMID)*LEN(N)  
C#### NEW RED CODE.  
cim seems like this overestimates area, entire length won't be flooded to  
cim width of downstream end.  
         AS1(NH)    = AS1(NH) + BNH*LEN(N)  
cim  seems like this next line double counts conduit area. Again ZU(N)  
cim  shou not be less than Z(NL)  
           IF(ZU(N)-Z(NL).LT.FUDGE) AS1(NL) = AS1(NL) + BNL*LEN(N)  
C#### OSU/EPA CODE DOES NOT INCLUDE LINK(N)  
C####           LINK(N)   = KINK  
C  
c     write(n6,*) 3,n,qp,ynl,ynh,ymid,kink  
         RETURN  
cim speedy           ENDIF  
      END SELECT  
cim speedy  
C=======================================================================  
C     COMPUTE CROSS-SECTION AREA, VELOCITY * HYDRAULIC RADIUS  
C=======================================================================  
C#### WCH, 12/7/94.  HERE, RED CODE USES COMPLEX WEIGHTING TO CALCULATE  
C     AREA, HRAD AND WIDTH.  DO NOT USE UNTIL BETTER UNDERSTOOD BY WCH.  
C     SO THIS CODE REMAINS UNCHAGED.  
C=======================================================================  
change ----------------------------------------------------------------  
c      AREA  = 0.25*(ANL+2.0*AMID+ANH)  
c      HRAD  = 0.25*(RNL+2.0*RMID+RNH)  
c      WIDTH = 0.25*(BNL+2.0*BMID+BNH)  
      AREA = AMID  
      HRAD = RMID  
      WIDTH = BMID  
change  
change ----------------------------------------------------------------  
      HRAD  = AMAX1(HRAD,FUDGE)  
      WIDTH = AMAX1(WIDTH,FUDGE)  
      IF(AREA.LE.FUDGE) THEN  
           VEL       = 0.0  
           QO(N)     = 0.0  
           IDOIT     = 0  
           AREA      = FUDGE  
           AOVERB(N) = FUDGE  
           ELSE  
           VEL       = QP/AREA  
           AOVERB(N) = AREA/WIDTH  
           IF(VEL.GT.50.0)  VEL =  50.0  
           IF(VEL.LT.-50.0) VEL = -50.0  
           ENDIF  
c     write(n6,*) 4,n,qp,ynl,ynh,ymid,kink  
      RETURN  
      END  
ECHO is off.
REM File: NTIME.FOR  
ECHO is off.
      SUBROUTINE NTIME(JDAY,TMDAY,TRAIN)  
C#######################################################################  
C     CALCULATE THE TIME DIFFERENCE IN SECONDS BETWEEN JDAY AND TMDAY  
C     AND THE EXISTING JULDAY AND TIMDAY  
C  
C     JDAY   = JULIAN DAY  
C     TMDAY  = TIME OF DAY IN SECONDS  
C     TRAIN  = TIME DIFFERENCE IN SECONDS (+ or -)  
C     TRAIN is positive if JDAY/TMDAY > JULDAY/TIMDAY.  
C#######################################################################  
      INCLUDE 'STIMER.INC'  
      JYEAR = JDAY/1000  
      IYEAR = JULDAY/1000  
      LDAY  = JDAY   - JYEAR*1000  
      KDAY  = JULDAY - IYEAR*1000  
      IF (JYEAR.LT.100) THEN  
           JYEAR = JYEAR + 1900  
           JDAY = LDAY + JYEAR*1000  
           ENDIF  
      IF (IYEAR.LT.100) THEN  
           IYEAR = IYEAR + 1900  
           JULDAY = KDAY + IYEAR*1000  
           ENDIF  
      JDIFF = 0  
C=======================================================================  
C     IYEAR AND JYEAR ARE DIFFERENT YEARS  
C=======================================================================  
      IF(JYEAR.GT.IYEAR) THEN  
           IY    = IYEAR  + 1  
           JY    = JYEAR  - 1  
           IF(JY.GE.IY) THEN  
                   DO 100 KYEAR = IY,JY  
                                         ID = 365  
                   IF(MOD(KYEAR,4).EQ.0) ID = 366  
                   JDIFF = JDIFF + ID  
 100               CONTINUE  
                   ENDIF  
           JDIFF = JDIFF + LDAY  
                                 ID = 365  
           IF(MOD(IYEAR,4).EQ.0) ID = 366  
           JDIFF = JDIFF + ID - KDAY  
           ENDIF  
C=======================================================================  
C     IYEAR AND JYEAR ARE DIFFERENT YEARS  
C=======================================================================  
      IF(JYEAR.LT.IYEAR) THEN  
           IY    = IYEAR  - 1  
           JY    = JYEAR  + 1  
           IF(IY.GE.JY) THEN  
                   DO 200 KYEAR = JY,IY  
                                         ID = 365  
                   IF(MOD(KYEAR,4).EQ.0) ID = 366  
                   JDIFF = JDIFF - ID  
 200               CONTINUE  
                   ENDIF  
           JDIFF = JDIFF - KDAY  
                                 ID = 365  
           IF(MOD(JYEAR,4).EQ.0) ID = 366  
           JDIFF = JDIFF - ID + LDAY  
           ENDIF  
C=======================================================================  
C     IYEAR AND JYEAR ARE THE SAME YEAR  
C=======================================================================  
      IF(JYEAR.EQ.IYEAR) THEN  
                         JDIFF = LDAY - KDAY  
                         ENDIF  
C=======================================================================  
C     CALCULATE DIFFERENCE IN SECONDS  
C=======================================================================  
      TDIFF = TMDAY - TIMDAY  
      TRAIN = FLOAT(JDIFF)*86400.0 + TDIFF  
      RETURN  
      END  
ECHO is off.
REM File: OUTPUT.FOR  
ECHO is off.
      SUBROUTINE OUTPUT  
C       EXTRAN BLOCK  
C       CALLED BY EXTRAN NEAR LINE 207  
C=======================================================================  
C     Subroutine prints output and controls the printer/plot routines.  
C     WCH, 11/29/93.  Correct metric depth/diameter units to meters.  
C     WCH, 8/4/95.  Don't print junction outflows < 0.001 cf or cm.  
C     CIM, 9/8/00.  Write threshold table and allow more hours in output  
C     WCH, 2/9/01.  Include corrections for output of upstream and  
C       downstream heads, and slope, for conduits, suggested by  
C       Nerkez Gavranovic, Sydney, Australia. (Comment = cng)  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'JUNC.INC'  
      INCLUDE 'PIPE.INC'  
      INCLUDE 'LAB.INC'  
      INCLUDE 'OUT.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'HYFLOW.INC'  
      INCLUDE 'FCHAN.INC'  
CIM 1/99 CHANGE FOR BA OUTPUT CONTROLS    - OUTPUT CONTROLS  
      INCLUDE 'BALINES.INC'  
	INCLUDE 'TRANAID.INC'  
C=======================================================================  
      DIMENSION FMAX(NPO),FMEAN(NPO),FMIN(NPO),YY(201,2)  
      DIMENSION GMAX(NPO),GMEAN(NPO),GMIN(NPO),NPT(2),X(201,2),  
     +          PSF(NPO,2)  
Cwch, 2/9/01.  Add VER5  
      CHARACTER TP*1,VER1*10,VER2*10,VER3*10,VER4*10,VER5*10,  
     +               YER1*10,YER2*10,YER3*10,YER4*10,BMJ*10  
      CHARACTER ASTER*1,XID*1,POUND*1,DOLLAR*1  
      DATA VER1/' CONDUIT  '/,VER2/' FLOW IN  '/,VER3/'   CFS    ' /,  
     +     VER4/'  CU M/S  '/,VER5/' SLOPE(%) ' /  
      DATA YER1/' JUNCTION '/,YER2/'WATER SURF'/,YER3/' ELEV(FT) ' /,  
     +     YER4/' ELEV(M)  '/  
      DATA TP/' '/,ASTER/'*'/,POUND/'#'/,DOLLAR/'$'/  
C=======================================================================  
C     Write Junction inflows.  
C=======================================================================  
      WRITE(N6,5002)  
      WRITE(N6,5004)  
      IF(METRIC.EQ.1) WRITE(N6,5007)  
      IF(METRIC.EQ.2) WRITE(N6,4995)  
      SUMQIN  = 0.0  
      DO 19 J = 1,NJ  
      IF(QQI(J).LE.0.0) GO TO 19  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,5003)  JUN(J),QQI(J)  
	ELSE  
	  WRITE(N6,5013) AJUN(J),QQI(J)  
	ENDIF  
C       This next line was needed when having  
C     flows on K3 lines and flows on table  
C     causes a NAN.  
c      IF (ISNAN(QOU(J))) QOU(J) = 0.0  
C  Print when node has a positive QQI and a  
C  negative QOU  
	IF (QOU(J).LT.0.0)  
     1WRITE(N6,*)'THE ABOVE NODE HAS A POSITIVE QQI AND A',  
     2' NEGATIVE QOU.'  
      SUMQIN    = SUMQIN  + QQI(J)  
  19  CONTINUE  
      DO 20 J = 1,NJ  
      IF(QOU(J).GE.0.0) GO TO 20  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,5003)  JUN(J),-QOU(J)  
	ELSE  
	  WRITE(N6,5013) AJUN(J),-QOU(J)  
	ENDIF  
      SUMQIN    = SUMQIN  - QOU(J)  
  20  CONTINUE  
C=======================================================================  
C     Write Junction outflows.  
C=======================================================================  
      IF(METRIC.EQ.1) WRITE(N6,5005)  
      IF(METRIC.EQ.2) WRITE(N6,4998)  
      SUMOUT   = 0.0  
      DO 119 J = 1,NJ  
C#### WCH, 8/4/95.  DO NOT PRINT OUTFLOWS < 0.001 CU FT OR CU M.  
C     THAT IS, INCREASE FROM CHECK FOR .LE.0 TO .LE.0.0001.  
      IF(QOU(J).LE.0.0001) GO TO 119  
cim try leaving 0.0  
cim      IF(QOU(J).LE.0.0) GO TO 119  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,5003)  JUN(J),QOU(J)  
	ELSE  
	  WRITE(N6,5013) AJUN(J),QOU(J)  
	ENDIF  
      SUMOUT   = SUMOUT + QOU(J)  
  119 CONTINUE  
C=======================================================================  
C     PRINT CONTINUITY SUMMARY  
C=======================================================================  
      IF(METRIC.EQ.1) WRITE(N6,5001) VINIT,SUMQIN,VINIT+SUMQIN  
      IF(METRIC.EQ.2) WRITE(N6,4999) VINIT,SUMQIN,VINIT+SUMQIN  
      IF(METRIC.EQ.1) WRITE(N6,5008) SUMOUT  
      IF(METRIC.EQ.2) WRITE(N6,4997) SUMOUT  
      IF(METRIC.EQ.1) WRITE(N6,5009) VLEFT,VLEFT+SUMOUT  
      IF(METRIC.EQ.2) WRITE(N6,4996) VLEFT,VLEFT+SUMOUT  
      SUME   = VINIT + SUMQIN  
      PCTERR = (SUME - SUMOUT - VLEFT) / SUME * 100.0  
      WRITE(N6,5006) PCTERR  
CIM TEST OF ALTERNATIVE CALCULATION OF FINAL VOLUME  
C   COMPUTED BY TRACKING TOTAL VOLUME IN EACH JUNCTION  
	VLEFT2 = 0.0  
	DO  N   = 1,NTC  
	VLEFT2 = VLEFT2 + VOL(N)  
	ENDDO  
	PCTERR2 = (SUME - SUMOUT - VLEFT2) / SUME * 100.0  
      WRITE(N6,7000) VLEFT2,PCTERR2  
cim write continuity error to console  
      WRITE(*,6006) PCTERR  
cim intercon  call fintercon to output results  
      call fintercon  
cim end  
C  
C******** PRINT FULL FLOW SUMMARY IF REQUIRED  
C  
      DO IWFA=1,NTL  
       IF(IFULL(IWFA).GT.0) GO TO 47  
      ENDDO  
       GO TO 49  
   47    WRITE(N6,5047)  
      DO 48 IWF=IWFA,NTL  
	 IF(IFULL(IWF).GT.0) THEN  
	 IF (JCE.EQ.0) THEN  
	       WRITE(N6,5048) NCOND(IWF),NFIRST(IWF),  
     *                        FHOUR(IWF),NLAST(IWF),FLHOUR(IWF)  
	 ELSE  
	       WRITE(N6,5049) ACOND(IWF),NFIRST(IWF),  
     *                        FHOUR(IWF),NLAST(IWF),FLHOUR(IWF)  
	 ENDIF  
	 ENDIF  
   48 CONTINUE  
      WRITE(N6,5050)  
   49 CONTINUE  
      NOUT     = NSCRAT(1)  
C=======================================================================  
C     PRINT H.G.L. AND WATER DEPTH AT NODES  
C=======================================================================  
      IF(NHPRT.GT.0) THEN  
      DO 100 I = 1,NHPRT  
      FMEAN(I) = 0.0  
      FMAX(I)  = 0.0  
      FMIN(I)  = 1.0E30  
      GMEAN(I) = 0.0  
      GMAX(I)  = 0.0  
      GMIN(I)  = 1.0E30  
      MJPRT    = JPRT(I)  
      JPRT(I)  = JUN(MJPRT)  
  100 PRGEL(I) = GRELEV(MJPRT)  
      DO 125 I = 1,NHPRT,5  
      REWIND NOUT  
cim change nout to unformatted sequential  
      READ(NOUT) JCE,NHPRT,NQPRT,NSURF  
C=======================================================================  
C     READ THE HEADER INFORMATION ON THE NOUT FILE  
C=======================================================================  
      IF(JCE.EQ.0) THEN  
      IF(NHPRT.GT.0) READ(NOUT) (N1,J=1,NHPRT)  
      IF(NQPRT.GT.0) READ(NOUT) (N1,J=1,NQPRT)  
      IF(NSURF.GT.0) READ(NOUT) (N1,J=1,NSURF)  
      ELSE  
      IF(NHPRT.GT.0) READ(NOUT) (BMJ,J=1,NHPRT)  
      IF(NQPRT.GT.0) READ(NOUT) (BMJ,J=1,NQPRT)  
      IF(NSURF.GT.0) READ(NOUT) (BMJ,J=1,NSURF)  
      ENDIF  
      IF(METRIC.EQ.1) WRITE(N6,5020)  
      IF(METRIC.EQ.2) WRITE(N6,5030)  
      WRITE(N6,5000)  ALPHA1,ALPHA2  
      IT = I + 4  
      IF(IT.GT.NHPRT) IT = NHPRT  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,5040) (TP,JPRT(L),L=I,IT)  
	ELSE  
	  WRITE(N6,5041) (TP,AOUT(L,1),L=I,IT)  
	ENDIF  
      WRITE(N6,5060) (TP,PRGEL(L),L=I,IT)  
      WRITE(N6,5061) (TP,L=I,IT)  
      WRITE(N6,5062) (TP,L=I,IT)  
      LT       = MIN0(I+4,NHPRT)  
      IF(LTIME.GT.0) THEN  
      DO 120 L = 1,LTIME  
      IF(JPRINT.EQ.1) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                    K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT),  
     +                              (PSF(J,1),PSF(J,2),J=1,NSURF)  
      IF(JPRINT.EQ.2) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                     K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT)  
      IF(JPRINT.EQ.3) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                                                 K=1,NHPRT)  
      IF(JPRINT.EQ.4) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                   K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF)  
      IF(JPRINT.EQ.5) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J),  
     +                   J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF)  
      IF(JPRINT.EQ.6) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),  
     +                                        PRTV(J),J=1,NQPRT)  
      IF(JPRINT.EQ.7) READ(NOUT) TIME,MINUTE,JSEC,  
     +                                (PSF(J,1),PSF(J,2),J=1,NSURF)  
      DO 110 K = I,LT  
      FMEAN(K) = FMEAN(K) + PRTH(K)  
      GMEAN(K) = GMEAN(K) + PRTY(K)  
      IF(PRTH(K).GT.FMAX(K)) FMAX(K) = PRTH(K)  
      IF(PRTY(K).GT.GMAX(K)) GMAX(K) = PRTY(K)  
      IF(PRTH(K).LT.FMIN(K)) FMIN(K) = PRTH(K)  
      IF(PRTY(K).LT.GMIN(K)) GMIN(K) = PRTY(K)  
 110  CONTINUE  
      LTIMEH   = IFIX(TIME/3600.0)  
      WRITE(N6,5080) LTIMEH,MINUTE,JSEC,(PRTH(K),PRTY(K),K=I,LT)  
  120 CONTINUE  
      DENOM = FLOAT(LTIME)  
      ELSE  
      DENOM = 1.0  
      ENDIF  
      WRITE(N6,5243) (FMEAN(K)/DENOM,GMEAN(K)/DENOM,K=I,LT)  
      WRITE(N6,5245) (FMAX(K),GMAX(K),K=I,LT)  
      WRITE(N6,5250) (FMIN(K),GMIN(K),K=I,LT)  
      WRITE(N6,6666)  
  125 CONTINUE  
      ENDIF  
C=======================================================================  
C     COMPUTE AND PRINT SUMMARY STATISTICS FOR JUNCTIONS  
C=======================================================================  
      IBAD     = 1  
      JBAD     = 1  
      YMAX     = 0.0  
      IXPLAN   = 0  
CIM 1/99  Skip printing of page headers if JHEAD = 1  
CIM print first header line  
      WRITE(N6,750)  
      WRITE(N6,5000) ALPHA1,ALPHA2  
      IF(METRIC.EQ.1) WRITE(N6,751)  
      IF(METRIC.EQ.2) WRITE(N6,749)  
      DO 700 J = 1,NJ  
      IF(JHEAD.EQ.0.AND.MOD(J,40).EQ.0) THEN  
      WRITE(N6,750)  
      WRITE(N6,5000) ALPHA1,ALPHA2  
      IF(METRIC.EQ.1) WRITE(N6,751)  
      IF(METRIC.EQ.2) WRITE(N6,749)  
      END IF  
C=======================================================================  
C     COMPUTE FEET MAXIMUM DEPTH IS BELOW GROUND ELEVATION  
C=======================================================================  
		    FTBLG = GRELEV(J)-(DEPMAX(J)+Z(J))  
C=======================================================================  
C PRINT SYMBOL IF INFLOW OCCURS AT SURFACE FLOODING LOCATION  
C=======================================================================  
      XID = TP  
      IF(FTBLG.LE.0.0) THEN  
		       FTBLG = 0.0  
		       DO 703 I = 1,LOCATS  
		       IF(J.EQ.NLOC(I)) XID = ASTER  
  703                  CONTINUE  
		       DO 704 I = 1,NJSW  
		       IF(J.EQ.JSW(I).AND.XID.EQ.TP) XID = POUND  
		       IF(J.EQ.JSW(I).AND.XID.EQ.ASTER) XID = DOLLAR  
  704                  CONTINUE  
		       IF(XID.NE.TP) IXPLAN = 1  
		       ENDIF  
C=======================================================================  
C     COMPUTE FEET OF SURCHARGE AT MAXIMUM DEPTH  
C=======================================================================  
			SURMAX = DEPMAX(J)+Z(J)-ZCROWN(J)  
      IF(SURMAX.LE.0.0) SURMAX = 0.0  
C=======================================================================  
C     PRINT JUNCTION STATISTICS  
C=======================================================================  
      SURLEN(J) = SURLEN(J)/60.0  
      FLDLEN(J) = FLDLEN(J)/60.0  
      YTOT(J)   = YTOT(J)/FLOAT(NTCYC)  
      YDEV(J)   = 100.0*YDEV(J)/FLOAT(NTCYC)  
      YTOT(J)   = YTOT(J)   + Z(J)  
      DEPMAX(J) = DEPMAX(J) + Z(J)  
      IF(YDEV(J).GT.YMAX) THEN  
			  JBAD = J  
			  YMAX = YDEV(J)  
			  ENDIF  
CIM CHANGE TO PRINT 10 CHARACTERS AND DIGITS  
	IF (JP10.EQ.0) THEN  
CIM THESE ARE ORIGINAL FORMATS  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,752) JUN(J),GRELEV(J),ZCROWN(J),  
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J),  
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J)  
	ELSE  
	  WRITE(N6,762) AJUN(J),GRELEV(J),ZCROWN(J),  
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J),  
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J)  
	ENDIF  
	ELSE  
CIM THESE ARE MODIFIED FORMATS  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,6752) JUN(J),GRELEV(J),ZCROWN(J),  
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J),  
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J)  
	ELSE  
	  WRITE(N6,6762) AJUN(J),GRELEV(J),ZCROWN(J),  
     1                   YTOT(J),YDEV(J),DEPMAX(J),IDHR(J),IDMIN(J),  
     1                   SURMAX,FTBLG,XID,SURLEN(J),FLDLEN(J),ASMAXX(J)  
	ENDIF  
	ENDIF  
  700 CONTINUE  
      IF(IXPLAN.NE.0) WRITE(N6,770)  
      IF(IXPLAN.NE.0) WRITE(N6,771)  
CIM ### 9/8/00  
C=======================================================================  
C     PRINT JUNCTION ELEVATION SUMMARY STATISTICS  
C=======================================================================  
      CALL WRTETHRESH  
C=======================================================================  
C     PRINT FLOWS * VELOCITIES IN PIPES  
C=======================================================================  
      IF(NQPRT.GT.0) THEN  
      AMULT    = FLOAT(JNTER)  
      DO 140 I = 1,NQPRT  
      L        = CPRT(I)  
      FMEAN(I) = 0.0  
      FMAX(I)  = 0.0  
      FMIN(I)  = 1.0E30  
      GMEAN(I) = 0.0  
      GMAX(I)  = 0.0  
      GMIN(I)  = 1.0E30  
  140 CPRT(I)  = NCOND(L)  
      DO 160 I = 1,NQPRT,5  
      REWIND NOUT  
      READ(NOUT) JCE,NHPRT,NQPRT,NSURF  
C=======================================================================  
C     READ THE HEADER INFORMATION ON THE NOUT FILE  
C=======================================================================  
      IF(JCE.EQ.0) THEN  
      IF(NHPRT.GT.0) READ(NOUT) (N1,J=1,NHPRT)  
      IF(NQPRT.GT.0) READ(NOUT) (N1,J=1,NQPRT)  
      IF(NSURF.GT.0) READ(NOUT) (N1,J=1,NSURF)  
      ELSE  
      IF(NHPRT.GT.0) READ(NOUT) (BMJ,J=1,NHPRT)  
      IF(NQPRT.GT.0) READ(NOUT) (BMJ,J=1,NQPRT)  
      IF(NSURF.GT.0) READ(NOUT) (BMJ,J=1,NSURF)  
      ENDIF  
      IF(METRIC.EQ.1) WRITE(N6,5100)  
      IF(METRIC.EQ.2) WRITE(N6,5101)  
      WRITE(N6,5000) ALPHA1,ALPHA2  
		      IT = I + 4  
      IF(IT.GT.NQPRT) IT = NQPRT  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,5120) (TP,CPRT(L),L=I,IT)  
	ELSE  
	  WRITE(N6,5130) (TP,AOUT(L,2),L=I,IT)  
	ENDIF  
      WRITE(N6,5121) (TP,L=I,IT)  
      WRITE(N6,5122) (TP,L=I,IT)  
      LT       = MIN0(I+4,NQPRT)  
      IF(LTIME.GT.0) THEN  
      DO 165 L = 1,LTIME  
      IF(JPRINT.EQ.1) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                    K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT),  
     +                              (PSF(J,1),PSF(J,2),J=1,NSURF)  
      IF(JPRINT.EQ.2) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                     K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT)  
      IF(JPRINT.EQ.3) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                                                 K=1,NHPRT)  
      IF(JPRINT.EQ.4) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                   K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF)  
      IF(JPRINT.EQ.5) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J),  
     +                   J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF)  
      IF(JPRINT.EQ.6) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J),  
     +                                                 J=1,NQPRT)  
      IF(JPRINT.EQ.7) READ(NOUT) TIME,MINUTE,JSEC,  
     +                                (PSF(J,1),PSF(J,2),J=1,NSURF)  
      DO 170 K = I,LT  
      FMEAN(K) = FMEAN(K) + PRTQ(K)  
      GMEAN(K) = GMEAN(K) + PRTV(K)  
      IF(PRTQ(K).GT.FMAX(K)) FMAX(K) = PRTQ(K)  
      IF(PRTV(K).GT.GMAX(K)) GMAX(K) = PRTV(K)  
      IF(PRTQ(K).LT.FMIN(K)) FMIN(K) = PRTQ(K)  
      IF(PRTV(K).LT.GMIN(K)) GMIN(K) = PRTV(K)  
 170  CONTINUE  
      LTIMEH   = IFIX(TIME/3600.0)  
      IF(METRIC.EQ.1) WRITE(N6,5140) LTIMEH,MINUTE,JSEC,  
     +                               (PRTQ(K),PRTV(K),K=I,LT)  
      IF(METRIC.EQ.2) WRITE(N6,5141) LTIMEH,MINUTE,JSEC,  
     +                               (PRTQ(K),PRTV(K),K=I,LT)  
  165 CONTINUE  
      DENOM = FLOAT(LTIME)  
      ELSE  
      DENOM = 1.0  
      ENDIF  
      IF(METRIC.EQ.1) THEN  
		WRITE(N6,5142) (FMEAN(K)/DENOM,GMEAN(K)/DENOM,K=I,LT)  
		WRITE(N6,5145) (FMAX(K),GMAX(K),K=I,LT)  
		WRITE(N6,5150) (FMIN(K),GMIN(K),K=I,LT)  
		WRITE(N6,5144) (FMEAN(K)*DELT*AMULT,K=I,LT)  
		ELSE  
		WRITE(N6,5143) (FMEAN(K)/DENOM,GMEAN(K)/DENOM,K=I,LT)  
		WRITE(N6,5146) (FMAX(K),GMAX(K),K=I,LT)  
		WRITE(N6,5151) (FMIN(K),GMIN(K),K=I,LT)  
		WRITE(N6,5144) (FMEAN(K)*DELT*AMULT,K=I,LT)  
		ENDIF  
      WRITE(N6,6666)  
  160 CONTINUE  
      ENDIF  
C=======================================================================  
C     Compute and print summary statistics for conduits.  
C=======================================================================  
CIM 1/99 eliminate header lines if JHEAD =1  
CIM write first header line  
				   WRITE(N6,800)  
				   WRITE(N6,5000) ALPHA1,ALPHA2  
CIM 1/99 MODIFY HEADER TO GO WITH EXPANDED FORMATS  
      IF(JP10.EQ.0) THEN  
CIM THESE ARE ORIGINAL FORMATS  
				    IF(METRIC.EQ.1) THEN  
										 WRITE(N6,801)  
				      ELSE  
						   WRITE(N6,799)  
				      ENDIF  
	ELSE  
CIM MODIFIED FORMATS  
				    IF(METRIC.EQ.1) THEN  
										 WRITE(N6,6801)  
				      ELSE  
						   WRITE(N6,6799)  
				      ENDIF  
	ENDIF  
      DO 900 N = 1,NTL  
      IF(JHEAD.EQ.0.AND.MOD(N,40).EQ.0) THEN  
				   WRITE(N6,800)  
				   WRITE(N6,5000) ALPHA1,ALPHA2  
	IF(JP10.EQ.0) THEN  
CIM THESE ARE ORIGINAL HEADER FORMATS  
				   IF(METRIC.EQ.1) THEN  
										 WRITE(N6,801)  
				     ELSE  
						   WRITE(N6,799)  
				     ENDIF  
	ELSE  
CIM MODIFIED FORMATS  
				   IF(METRIC.EQ.1) THEN  
										 WRITE(N6,6801)  
				     ELSE  
						   WRITE(N6,6799)  
				     ENDIF  
	ENDIF  
      ENDIF  
C=======================================================================  
C     COMPUTE DESIGN VELOCITY AND FLOW IN CONDUIT  
C     COMPUTE RATIO OF MAX TO DESIGN FLOW IN CONDUIT  
C=======================================================================  
      IF(N.LE.NTC) THEN  
			     QRATIO = 0.0  
	 IF(QFULL(N).GT.0.0) QRATIO = QMAXX(N)/QFULL(N)  
C=======================================================================  
C        COMPUTE MAX WATER DEPTH ABOVE CONDUIT INVERT AT BOTH ENDS  
C=======================================================================  
	 SLOPE     = (ZU(N)-ZD(N))/LEN(N)  
	 VDSGN     = SQRT(GRVT*SLOPE/ROUGH(N))*RFULL(N)**0.6666667  
	 DMAXNL    = PMAX(N,1) - ZU(N)  
	 DMAXNH    = PMAX(N,2) - ZD(N)  
	 SUPLEN(N) = SUPLEN(N)/60.0  
	 IF(METRIC.EQ.1) VHGHT = DEEP(N)*12.0  
C#### WCH, 11/29/93.  CORRECT METRIC DIAMETER/DEPTH OUTPUT TO METERS.  
	 IF(METRIC.EQ.2) VHGHT = DEEP(N)  
	 ELSE  
	 SLOPE     = 1.0E20  
	 ENDIF  
C=======================================================================  
C     Print conduit statistics.  
C=======================================================================  
CIM 1/99 WRITE ALL 10 DIGITS AND CHARACTERS  
	IF(JP10.EQ.0) THEN  
CIM WRITE ORIGINAL FORMAT STATEMENTS  
      IF(SLOPE.LT.1.0E10) THEN  
	       IF(JCE.EQ.0.OR.N.GT.NC) WRITE(N6,802)  
     2                      NCOND(N),QFULL(N),VDSGN,VHGHT,  
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N),  
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH,  
     2                      SUPLEN(N),SLOPE  
	       IF(JCE.EQ.1.AND.N.LE.NC) WRITE(N6,812)  
     2                      ACOND(N),QFULL(N),VDSGN,VHGHT,  
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N),  
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH,  
     2                      SUPLEN(N),SLOPE  
	       ELSE  
	       IF(JCE.EQ.0) WRITE(N6,803) NCOND(N),QMAXX(N),  
     +                                    IQHR(N),IQMIN(N)  
	       IF(JCE.EQ.1) WRITE(N6,813) ACOND(N),QMAXX(N),  
     +                                    IQHR(N),IQMIN(N)  
	       ENDIF  
	ELSE  
CIM WRITE MODIFIED FORMAT STATEMENTS  
      IF(SLOPE.LT.1.0E10) THEN  
	       IF(JCE.EQ.0.OR.N.GT.NC) WRITE(N6,6802)  
     2                      NCOND(N),QFULL(N),VDSGN,VHGHT,  
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N),  
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH,  
     2                      SUPLEN(N),SLOPE  
	       IF(JCE.EQ.1.AND.N.LE.NC) WRITE(N6,6812)  
     2                      ACOND(N),QFULL(N),VDSGN,VHGHT,  
     2                      QMAXX(N),IQHR(N),IQMIN(N),VMAXX(N),  
     2                      IVHR(N),IVMIN(N),QRATIO,DMAXNL,DMAXNH,  
     2                      SUPLEN(N),SLOPE  
	       ELSE  
	       IF(JCE.EQ.0) WRITE(N6,6803) NCOND(N),QMAXX(N),  
     +                                    IQHR(N),IQMIN(N)  
	       IF(JCE.EQ.1) WRITE(N6,6813) ACOND(N),QMAXX(N),  
     +                                    IQHR(N),IQMIN(N)  
	       ENDIF  
	ENDIF  
  900 CONTINUE  
C=======================================================================  
C     Print conduit link conditions.  
C=======================================================================  
      QMAX     = 0.0  
CIM 1/99 ELIMINATE INTERMEDIATE HEADER LINES IF JHEAD = 1  
CIM WRITE FIRST HEADER LINE HERE  
				   IF(METRIC.EQ.1) WRITE(N6,940)  
				   IF(METRIC.EQ.2) WRITE(N6,941)  
      DO 950 N = 1,NTL  
      IF(JHEAD.EQ.0.AND.MOD(N,40).EQ.0) THEN  
				   IF(METRIC.EQ.1) WRITE(N6,940)  
				   IF(METRIC.EQ.2) WRITE(N6,941)  
				   ENDIF  
      QMEAN    = QTOT(N)/FLOAT(NTCYC)  
      QDEV(N)  = 100.0*QDEV(N)/FLOAT(NTCYC)  
      QTOT(N)  = QTOT(N)*RDELT  
      IF(N.LE.NTC) THEN  
      IF(QDEV(N).GT.QMAX) THEN  
			  IBAD = N  
			  QMAX = QDEV(N)  
			  ENDIF  
      IF(JCE.EQ.0) THEN  
		     WRITE(N6,955) NCOND(N),CTIME(N,1)/60.0,  
     +                           CTIME(N,2)/60.0,CTIME(N,3)/60.0,  
     +                           CTIME(N,4)/60.0,QMEAN,QDEV(N),QTOT(N),  
     +                           HMAX(N),AMAX(N)  
	ELSE  
		   WRITE(N6,965) ACOND(N),CTIME(N,1)/60.0,  
     +                           CTIME(N,2)/60.0,CTIME(N,3)/60.0,  
     +                           CTIME(N,4)/60.0,QMEAN,QDEV(N),QTOT(N),  
     +                           HMAX(N),AMAX(N)  
	ENDIF  
      ELSE  
      IF(JCE.EQ.0) THEN  
	    WRITE(N6,975) NCOND(N),QMEAN,QTOT(N)  
	ELSE  
	  WRITE(N6,985) ACOND(N),QMEAN,QTOT(N)  
	ENDIF  
      ENDIF  
  950 CONTINUE  
      WRITE(N6,9400)  
      IF(JCE.EQ.0) THEN  
		     WRITE(N6,9410) NCOND(IBAD),QDEV(IBAD),  
     +                                       JUN(JBAD),YDEV(JBAD)  
	ELSE  
		   WRITE(N6,9420) ACOND(IBAD),QDEV(IBAD),  
     +                                       AJUN(JBAD),YDEV(JBAD)  
	ENDIF  
C=======================================================================  
C     Printer plot package.  
C=======================================================================  
      HORIZ(1) = '  CLOCK TIME IN HOURS. '  
      HORIZ(2) = '                       '  
      HTITLE(1)= 'PLOT OF JUNCTION ELEVATION  '  
      HTITLE(2)= '                            '  
C=======================================================================  
C     Plot Junction water surface elevations.  
C=======================================================================  
      IF(NPLT.GT.0) THEN  
		VERT1 = YER1  
		VERT2 = YER2  
		IF(METRIC.EQ.1) VERT3 = YER3  
		IF(METRIC.EQ.2) VERT3 = YER4  
		NPT(1)   = NPTOT  
		NPT(2)   = 0  
		DO 200 N = 1,NPLT  
		J        = JPLT(N)  
		NJUN     = JUN(J)  
		CALL CURVE(TPLT,YPLT(1,N),NPT,1,NJUN,AJUN(J))  
		IF(METRIC.EQ.1) WRITE(N6,2000) Z(J),ZCROWN(J),GRELEV(J)  
  200           IF(METRIC.EQ.2) WRITE(N6,2001) Z(J),ZCROWN(J),GRELEV(J)  
		ENDIF  
C=======================================================================  
C     Plot conduit flows.  
C=======================================================================  
      IF(LPLT.GT.0) THEN  
		    HTITLE(1) = ' PLOT OF CONDUIT FLOW'  
		    HTITLE(2)= '                      '  
		    VERT1 = VER1  
		    VERT2 = VER2  
		    IF(METRIC.EQ.1) VERT3 = VER3  
		    IF(METRIC.EQ.2) VERT3 = VER4  
		    NPT(1)   = NPTOT  
		    NPT(2)   = 0  
		    DO 280 N = 1,LPLT  
		    L        = KPLT(N)  
		    NKON     = NCOND(L)  
  280               CALL CURVE(TPLT,QPLT(1,N),NPT,1,NKON,ACOND(L))  
		    ENDIF  
C=======================================================================  
C     Plot water surface slopes.  
C=======================================================================  
      IF(NSURF.GT.0.AND.LTIME.GT.0) THEN  
         MP    = (LTIME+200)/200  
c  
cng   plot of junction elevations + slope  
c  
         DO 123 M = 1, NSURF  
         REWIND NOUT  
         READ(NOUT) JCE,NHPRT,NQPRT,NSURF  
C=======================================================================  
C     READ THE HEADER INFORMATION ON THE NOUT FILE  
C=======================================================================  
         IF(JCE.EQ.0) THEN  
            IF(NHPRT.GT.0) READ(NOUT) (N1,J=1,NHPRT)  
            IF(NQPRT.GT.0) READ(NOUT) (N1,J=1,NQPRT)  
            IF(NSURF.GT.0) READ(NOUT) (N1,J=1,NSURF)  
            ELSE  
            IF(NHPRT.GT.0) READ(NOUT) (BMJ,J=1,NHPRT)  
            IF(NQPRT.GT.0) READ(NOUT) (BMJ,J=1,NQPRT)  
            IF(NSURF.GT.0) READ(NOUT) (BMJ,J=1,NSURF)  
            ENDIF  
         KO        = 0  
         DO 6000 L = 1,LTIME  
         IF(JPRINT.EQ.1) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                    K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT),  
     +                              (PSF(J,1),PSF(J,2),J=1,NSURF)  
         IF(JPRINT.EQ.2) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                     K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT)  
         IF(JPRINT.EQ.3) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                                                 K=1,NHPRT)  
      I   F(JPRINT.EQ.4) READ(NOUT) TIME,MINUTE,JSEC,(PRTY(K),PRTH(K),  
     +                   K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF)  
         IF(JPRINT.EQ.5) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J),  
     +                   J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF)  
         IF(JPRINT.EQ.6) READ(NOUT) TIME,MINUTE,JSEC,(PRTQ(J),PRTV(J),  
     +                                                 J=1,NQPRT)  
         IF(JPRINT.EQ.7) READ(NOUT) TIME,MINUTE,JSEC,  
     +                                (PSF(J,1),PSF(J,2),J=1,NSURF)  
         IF(MOD(L,MP).EQ.0) THEN  
			 KO         = KO + 1  
			 TPLT(KO)   = TIME/3600.0  
			 X(KO,1)    = TIME/3600.0  
			 X(KO,2)    = TIME/3600.0  
			 J          = JSURF(M)  
			 YY(KO,1)   = PSF(M,1)  
			 YY(KO,2)   = PSF(M,2)  
c  
cng  qplt chaneged to [%] - was it used before ?  
c  
			 QPLT(KO,1) = 100.0*(PSF(M,1)-PSF(M,2))/LEN(J)  
			 ENDIF  
 6000    CONTINUE  
         HTITLE(1) = 'PLOT OF JUNCTION ELEVATIONS'  
         HTITLE(2) = 'AT EACH END OF THE CONDUIT '  
         VERT1     = YER1  
         VERT2     = YER2  
         IF(METRIC.EQ.1) VERT3 = YER3  
         IF(METRIC.EQ.2) VERT3 = YER4  
         L         = JSURF(M)  
         NKON      = NCOND(L)  
         NPT(1)    = KO  
         NPT(2)    = KO  
         CALL CURVE(X,YY,NPT,2,NKON,ACOND(L))  
         WRITE(N6,9380)  
         NPT(2)    = 0  
         HTITLE(1) = 'PLOT OF WATER SURFACE SLOPE'  
         HTITLE(2) = '                           '  
         VERT1     = VER1  
         VERT3     = VER5  
         CALL CURVE(TPLT,QPLT,NPT,1,NKON,ACOND(L))  
  123    CONTINUE  
         ENDIF  
C  
      RETURN  
C=======================================================================  
cim 10/98  change to avoid strings that wrap around which  
c          is not handled well by all compilers  
  749 FORMAT(3X,  
     +'                     UPPERMOST    MEAN             MAXIMUM ',  
     +'    TIME   METERS OF   METERS MAX.      LENGTH    LENGTH   ',  
     +'  MAXIMUM',/,2X,  
     +'            GROUND  PIPE CROWN  JUNCTION  JUNCTION JUNCTION',  
     +'     OF     SURCHARGE    DEPTH IS         OF        OF     ',  
     +' JUNCTION',/,2X,  
     +' JUNCTION ELEVATION  ELEVATION ELEVATION   AVERAGE   ELEV. ',  
     +'  OCCURENCE   AT MAX    BELOW GROUND   SURCHARGE  FLOODING ',  
     +'     AREA',/,2X,  
     6'   NUMBER     (M)        (M)       (M)    % CHANGE     (M) ',  
     +'  HR. MIN.  ELEVATION    ELEVATION      (MIN)      (MIN)   ',  
     +' (SQ.MET)',/,2X,  
     +' -------- --------- ----------  -------- --------- --------',  
     +'  ---------  ---------   ------------  ---------  -------- ',  
     +' --------')  
  750 FORMAT(/,1H1,/,  
     +' ************************************************************',/,  
     +' *   J U N C T I O N   S U M M A R Y   S T A T I S T I C S  *',/,  
     +' ************************************************************',/)  
  751 FORMAT(3X,  
     +'                     UPPERMOST    MEAN             MAXIMUM ',  
     +'    TIME     FEET OF     FEET MAX.      LENGTH    LENGTH   ',  
     +'  MAXIMUM',/,2X,  
     +'            GROUND  PIPE CROWN  JUNCTION  JUNCTION JUNCTION',  
     +'     OF     SURCHARGE    DEPTH IS         OF        OF     ',  
     +' JUNCTION',/,2X,  
     +' JUNCTION ELEVATION  ELEVATION ELEVATION   AVERAGE   ELEV. ',  
     +'  OCCURENCE   AT MAX    BELOW GROUND   SURCHARGE  FLOODING ',  
     +'     AREA',/,2X,  
     6'   NUMBER    (FT)       (FT)       (FT)   % CHANGE   (FT)  ',  
     +'  HR. MIN.  ELEVATION    ELEVATION      (MIN)      (MIN)   ',  
     +'  (SQ.FT)',/,2X,  
     +' -------- --------- ----------  -------- --------- --------',  
     +'  ---------  ---------   ------------  ---------  -------- ',  
     +' --------')  
cim modify format to include 10 characters  
  752 FORMAT(1X,I8,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2,  
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3)  
  762 FORMAT(1X,A8,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2,  
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3)  
CIM WRITE ALL 10 CHARACTERS AND DIGITS  
 6752 FORMAT(1X,I10,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2,  
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3)  
 6762 FORMAT(1X,A10,1X,F9.2,2X,F9.2,F10.2,1X,F9.4,F9.2,I6,I5,3X,F8.2,  
     2       4X,F10.2,A1,1X,F9.1,2X,F8.1,1PE11.3)  
  770 FORMAT(/,5X,'WARNING.  INFLOW TO EXTRAN OCCURED AT JUNCTION THAT',  
     *' EXPERIENCED SURFACE FLOODING.',/,  
     *5X,'IF THIS INFLOW OCCURED SIMULTANEOUSLY WITH FLOODING, WATER W',  
     *'ILL NOT ENTER EXTRAN',/,  
     *5X,'AND IS LOST FROM SIMULATION EXCEPT FOR CONTINUITY CHECK.',/,  
     *5X,'USER MAY WISH TO CONSIDER EFFECTS ON UPSTREAM CHANNELS/PIPES',  
     *' NOT MODELED IN EXTRAN.')  
  771 FORMAT(/,5X,'ASTERISK (*) => INFLOW AT JUNCTION WITH INFLOW FROM',  
     *' SWMM INTERFACE FILE.',/,  
     *5X,'POUND (#)    => INFLOW AT JUNCTION WITH INFLOW FROM K3 GROUP',  
     *'.',/,  
     *5X,'DOLLAR ($)   => INFLOW AT JUNCTION WITH INFLOWS FROM BOTH SO',  
     *'URCES.',//,  
     *5X,'NOTE THAT CONSTANT JUNCTION INFLOWS CAN ENHANCE FLOODING.')  
  800 FORMAT(/,1H1,/,  
     +' ***********************************************************',/,  
     +' *   C O N D U I T   S U M M A R Y   S T A T I S T I C S   *',/,  
     +' ***********************************************************',/)  
C#### WCH, 11/29/93.  CHANGE DIAMETER/DEPTH PRINT TO METERS.  
  799 FORMAT(/,  
     +1X,'                             CONDUIT   MAXIMUM     TIME  ',  
     +'     MAXIMUM    TIME      RATIO OF   MAXIMUM DEPTH ABOVE ',  
     +' LENGTH CONDUIT',/,  
     +1X,'          DESIGN    DESIGN  VERTICAL  COMPUTED      OF   ',  
     +'   COMPUTED      OF       MAX. TO   INV. AT CONDUIT ENDS ',  
     +' OF NORM  SLOPE',/,  
     +1X,'CONDUIT     FLOW   VELOCITY   DEPTH     FLOW   OCCURRENCE',  
     +'    VELOCITY  OCCURRENCE   DESIGN  UPSTREAM   DOWNSTREAM ',  
     +'   FLOW',/,  
     +1X,' NUMBER    (CMS)     (M/S)      (M)    (CMS)    HR.  MIN.',  
     +'     (MPS)    HR.  MIN.    FLOW       (M)        (M)     ',  
     +'  (MIN)   (M/M)',/,  
     +1X,' ------  -------  --------  --------   -------  ---------',  
     +'-   -------  ----------   -------  --------    --------- ',  
     +'  -----  ------')  
  801 FORMAT(/,  
     +1X,'                             CONDUIT   MAXIMUM     TIME   ',  
     +'    MAXIMUM    TIME      RATIO OF   MAXIMUM DEPTH ABOVE ',  
     +' LENGTH CONDUIT',/,  
     +1X,'          DESIGN    DESIGN  VERTICAL  COMPUTED      OF    ',  
     +'  COMPUTED      OF       MAX. TO   INV. AT CONDUIT ENDS ',  
     +' OF NORM  SLOPE',/,  
     +1X,'CONDUIT     FLOW   VELOCITY   DEPTH     FLOW   OCCURRENCE ',  
     +'   VELOCITY  OCCURRENCE   DESIGN  UPSTREAM   DOWNSTREAM ',  
     +'   FLOW',/,  
     +1X,' NUMBER    (CFS)     (FPS)     (IN)    (CFS)    HR.  MIN. ',  
     +'    (FPS)    HR.  MIN.    FLOW      (FT)       (FT)     ',  
     +'  (MIN) (FT/FT)',/,  
     +1X,' ------  -------  --------  --------   -------  ----------',  
     +'   -------  ----------   -------  --------    --------- ',  
     +'  -----  ------')  
 6801   FORMAT(/,  
     1'                                   CONDUIT   MAXIMUM  ',  
     2'     TIME      MAXIMUM      TIME   RATIO OF  MAXIMUM ',  
     3'DEPTH ABOVE    LENGTH  CONDUIT',/,  
     4'               DESIGN    DESIGN   VERTICAL   COMPUTED ',  
     5'      OF       COMPUTED      OF     MAX. TO  INV. AT ',  
     6'CONDUIT ENDS  OF NORM   SLOPE ',/,  
     7'   CONDUIT      FLOW    VELOCITY     DEPTH     FLOW   ',  
     8'  OCCURRENCE   VELOCITY  OCCURRENCE DESIGN  UPSTREAM ',  
     9'  DOWNSTREAM    FLOW          ',/,  
     1'   NUMBER       (CFS)     (F/S)      (IN)     (CFS)   ',  
     2'   HR.  MIN.    (F/S)    HR.  MIN.    FLOW      (FT) ',  
     3'      (FT)      (MIN)  (FT/FT)',/,  
     4' ----------  ---------- -------- --------- -----------',  
     5' ----- ----- --------- ----- ----- -------- -------- ',  
     6'----------- --------- -------- ')  
 6799   FORMAT(/,  
     1'                                   CONDUIT   MAXIMUM  ',  
     2'     TIME      MAXIMUM      TIME   RATIO OF  MAXIMUM ',  
     3'DEPTH ABOVE    LENGTH  CONDUIT',/,  
     4'               DESIGN    DESIGN   VERTICAL   COMPUTED ',  
     5'      OF       COMPUTED      OF     MAX. TO  INV. AT ',  
     6'CONDUIT ENDS  OF NORM   SLOPE ',/,  
     7'   CONDUIT      FLOW    VELOCITY     DEPTH     FLOW   ',  
     8'  OCCURRENCE   VELOCITY  OCCURRENCE DESIGN  UPSTREAM ',  
     9'  DOWNSTREAM    FLOW          ',/,  
     1'   NUMBER       (CMS)     (M/S)       (M)     (CMS)   ',  
     2'   HR.  MIN.    (M/S)    HR.  MIN.    FLOW      (M)  ',  
     3'      (M)       (MIN)   (M/M) ',/,  
     4' ----------  ---------- -------- --------- -----------',  
     5' ----- ----- --------- ----- ----- -------- -------- ',  
     6'----------- --------- -------- ')  
cim original formats  
  802 FORMAT(' ',I7,1PE9.2,2X,0PF8.2,1X,F9.3,1X,1PE9.2,I6,I6,2X,  
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5)  
  803 FORMAT(' ',I7,1X,'   UNDEF',2(2X,'   UNDEF'),1X,1PE9.2,I6,I6)  
  813 FORMAT(' ',A10,' UNDEF',2(2X,'   UNDEF'),1X,1PE9.2,I6,I6)  
CWCH, 9/27/99.  Increase conduit ID field to 8 for now (to A8 from A7)  
  812 FORMAT(' ',A8,1PE9.2,2X,0PF8.2,1X,F9.3,1X,1PE9.2,I6,I6,2X,  
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5)  
cim revised formats  
 6802 FORMAT(1X,I10,1X,1PE11.4,1X,0PF8.2,1X,F9.3,1X,1PE11.4,I6,I6,2X,  
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5)  
 6803 FORMAT(1X,I10,7X,'UNDEF',4X,'UNDEF',5X,'UNDEF',1X,1PE11.4,I6,I6)  
 6813 FORMAT(1X,A10,7X,'UNDEF',4X,'UNDEF',5X,'UNDEF',1X,1PE11.4,I6,I6)  
 6812 FORMAT(1X,A10,1X,1PE11.4,1X,0PF8.2,1X,F9.3,1X,1PE11.4,I6,I6,2X,  
     +             0PF8.2,I6,I6,2(1X,F8.2),4X,F8.2,3X,F7.1,2X,F7.5)  
cim  
  940 FORMAT(/,1H1,/,10X,  
     +' **************************************************',/,10X,  
     +' * SUBCRITICAL AND CRITICAL FLOW ASSUMPTIONS FROM *',/,10X,  
     +' * SUBROUTINE HEAD.  SEE FIGURE 5-4 IN THE EXTRAN *',/,10X,  
     +' *       MANUAL FOR FURTHER INFORMATION.          *',/,10X,  
     *' **************************************************',//,  
     +'               LENGTH     LENGTH       LENGTH       LENGTH ',/,  
     +'                 OF         OF        OF UPSTR. OF DOWNSTR.  ',  
     +'      MEAN                   TOTAL     MAXIMUM     MAXIMUM',/,  
     +'    CONDUIT     DRY     SUBCRITICAL    CRITICAL   CRITICAL   ',  
     +'      FLOW     AVERAGE        FLOW   HYDRAULIC  CROSS SECT',/,  
     +'     NUMBER   FLOW(MIN)  FLOW(MIN)    FLOW(MIN)   FLOW(MIN)  ',  
     +'     (CFS)    % CHANGE    CUBIC FT  RADIUS(FT)   AREA(FT2)',/,  
     +'    -------  ---------- -----------   ---------   ---------  ',  
     +'  --------   ---------   ---------  ---------   ----------')  
  941 FORMAT(/,1H1,/,10X,  
     +' **************************************************',/,10X,  
     +' * SUBCRITICAL AND CRITICAL FLOW ASSUMPTIONS FROM *',/,10X,  
     +' * SUBROUTINE HEAD.  SEE FIGURE 5-4 IN THE EXTRAN *',/,10X,  
     +' *       MANUAL FOR FURTHER INFORMATION.          *',/,10X,  
     *' **************************************************',//,  
     +'               LENGTH     LENGTH       LENGTH       LENGTH ',/,  
     +'                 OF         OF        OF UPSTR. OF DOWNSTR.  ',  
     +'      MEAN                   TOTAL     MAXIMUM     MAXIMUM',/,  
     +'    CONDUIT     DRY     SUBCRITICAL    CRITICAL    CRITICAL  ',  
     +'      FLOW     AVERAGE        FLOW   HYDRAULIC  CROSS SECT',/,  
     +'     NUMBER   FLOW(MIN)  FLOW(MIN)    FLOW(MIN)   FLOW(MIN)  ',  
     +'     (CMS)    % CHANGE   CUBIC MET RADIUS(MET)  AREA(SQ.M)',/,  
     +'    -------  ---------- -----------   ---------   ---------  ',  
     +'  --------   ---------   ---------  ---------   ----------')  
  955 FORMAT(1X,I10,5F12.2,F12.4,1PE12.4,0PF12.4,F12.4)  
  965 FORMAT(1X,A10,5F12.2,F12.4,1PE12.4,0PF12.4,F12.4)  
  975 FORMAT(1X,I10,4('   UNDEFINED'),F12.2,12X,1PE12.4)  
  985 FORMAT(1X,A10,4('   UNDEFINED'),F12.2,12X,1PE12.4)  
 2000 FORMAT(/,20X,'INVERT ELEV -',F8.2,' FEET',/,20X,  
     .             ' CROWN ELEV -',F8.2,' FEET',/,20X,  
     .             'GROUND ELEV -',F8.2,' FEET')  
 2001 FORMAT(/,20X,'INVERT ELEV -',F8.2,' METERS',/,20X,  
     .             ' CROWN ELEV -',F8.2,' METERS',/,20X,  
     .             'GROUND ELEV -',F8.2,' METERS')  
 4995 FORMAT(4X,'JUNCTION',2X,' INFLOW, CU M',/,  
     +       4X,'--------',2X,'-------------')  
 4997 FORMAT(' *******************************************************',  
     +     /,' * TOTAL SYSTEM OUTFLOW         = ',1PE14.4,' CU M  *')  
 4996 FORMAT(' * VOLUME LEFT IN SYSTEM        = ',1PE14.4,' CU M  *',/,  
     +       ' * OUTFLOW + FINAL VOLUME       = ',1PE14.4,' CU M  *',/,  
     +       ' *******************************************************')  
 4998 FORMAT(/,4X,'JUNCTION',2X,'OUTFLOW, CU M',/,  
     +       4X,'--------',2X,'-------------')  
 4999 FORMAT(/,  
     1    ' *******************************************************',/,  
     1       ' * INITIAL SYSTEM VOLUME        = ',1PE14.4,' CU M  *',/,  
     1       ' * TOTAL SYSTEM INFLOW VOLUME   = ',1PE14.4,' CU M  *',/,  
     2       ' * INFLOW + INITIAL VOLUME      = ',1PE14.4,' CU M  *')  
 5000 FORMAT(/,10X,A80,/,10X,A80,/)  
 5001 FORMAT(/,  
     1    ' *******************************************************',/,  
     1       ' * INITIAL SYSTEM VOLUME        = ',1PE14.4,' CU FT *',/,  
     1       ' * TOTAL SYSTEM INFLOW VOLUME   = ',1PE14.4,' CU FT *',/,  
     2       ' * INFLOW + INITIAL VOLUME      = ',1PE14.4,' CU FT *')  
 5002 FORMAT(/,1H1,/,  
     +' ***************************************************',/,  
     +' * EXTRAN CONTINUITY BALANCE AT THE LAST TIME STEP *',/,  
     +' ***************************************************',/)  
 5003 FORMAT(2X,I10,1PE14.4)  
 5013 FORMAT(2X,A10,1PE14.4)  
 5004 FORMAT(  
     +' ************************************************',/,  
     +' * JUNCTION INFLOW, OUTFLOW OR STREET FLOODING *',/,  
     +' ************************************************',/)  
 5005 FORMAT(/,4X,'JUNCTION',2X,'OUTFLOW, FT3',/,  
     +       4X,'--------',2X,'------------')  
 5006 FORMAT(' * ERROR IN CONTINUITY, PERCENT = ',F14.2,'       *',/,  
     +    ' *******************************************************')  
 7000 FORMAT(//,  
     1' TEST WRITE OF ALTERNATIVE CONTINUITY ERROR CALCULATION',/,  
     1' VOLUME LEFT IN SYSTEM       = ',1PE14.4,' CU. FT.',/,  
	1' ERROR IN CONTINUITY PERCENT = ',F14.2)  
 6006 FORMAT(' ===> Continuity error (percent): ',F10.2)  
  311 FORMAT(' ===> Elapsed Time  (minutes)   : ',F24.3)  
 5007 FORMAT(4X,'JUNCTION',2X,' INFLOW, FT3',/,  
     +       4X,'--------',2X,'------------')  
 5008 FORMAT(  
     +   ' *******************************************************',/,  
     +       ' * TOTAL SYSTEM OUTFLOW         = ',1PE14.4,' CU FT *')  
 5009 FORMAT(' * VOLUME LEFT IN SYSTEM        = ',1PE14.4,' CU FT *',/,  
     +       ' * OUTFLOW + FINAL VOLUME       = ',1PE14.4,' CU FT *',/,  
     +       ' *******************************************************')  
 5020 FORMAT(/,1H1,/,  
     +' #########################################################',/,  
     +' #  T i m e  H i s t o r y  o f  t h e  H. G. L. ( Feet) #',/,  
     +' #########################################################',/)  
 5030 FORMAT(/,1H1,/,  
     +' ##########################################################',/,  
     +' #  T i m e  H i s t o r y  o f  t h e  H. G. L. (meters) #',/,  
     +' ##########################################################',/)  
 5040 FORMAT('          ',5(A1,' Junction:',I10))  
 5041 FORMAT('          ',5(A1,' Junction:',A10))  
 5047 FORMAT(//,16(2H- ),' SUMMARY OF FULL FLOW CHANNEL WARNINGS ',  
     *21(2H- ),//,  
     *'   OPEN CHANNEL   TIME STEP OF FIRST   TIME OF FIRST',  
     *'   TIME STEP OF LAST   TIME OF LAST',/,  
     *'      NUMBER          OCCURRENCE        OCCURRENCE  ',  
     *'      OCCURRENCE        OCCURRENCE',/,  
     *42X,'(HOURS)',28X,'(HOURS)',/,  
     *'   ------------   ------------------   -------------',  
     *'   -----------------   ------------')  
 5048 FORMAT(1X,I10,13X,I5,13X,F6.2,13X,I5,11X,F6.2)  
 5049 FORMAT(1X,A10,13X,I5,13X,F6.2,13X,I5,11X,F6.2)  
 5050 FORMAT(/,  
     A3X,'THE PROGRAM USES FULL DEPTH CHANNEL CHARACTERISTICS',  
     A' TO COMPUTE FLOW THROUGH THE TRAPEZOIDAL, IRREGULAR, OR ',/,  
     B3X,'PARABOLIC/POWER FUNCTION CONDUIT WHEN THE COMPUTED DEPTHS ',  
     C'EXCEED MAXIMUM DEPTH.  THIS WILL AFFECT THE MAXIMUM',/,  
     D3X,'COMPUTED HEAD AND FLOWS IN THE MODEL.  IT IS HIGHLY ',  
     E'RECOMMENDED THAT THE MODELED CROSS SECTIONS BE EXTENDED',/,  
     F3X,'TO ELIMINATE THESE FULL FLOW CHANNEL WARNINGS')  
 5060 FORMAT('    Time  ',5(A1,'   Ground:',F10.2))  
 5061 FORMAT('  Hr:Mn:Sc',5(A1,' Elevation     Depth'))  
 5062 FORMAT('  --------',5(A1,' ---------     -----'),/)  
 5080 FORMAT (' ',I3,':',I2,':',I2,5(F11.2,F10.2))  
 5100 FORMAT(/,1H1,/,  
     +' #############################################',/,  
     +' #     Time History of Flow and Velocity     #',/,  
     +' #    Q(cfs), Vel(ft/s), Total(cubic feet)   #',/,  
     +' #############################################',/)  
 5101 FORMAT(/,1H1,/,  
     +' #############################################',/,  
     +' #     Time History of Flow and Velocity     #',/,  
     +' #    Q(cms), Vel(m/s), Total(cubic meters)  #',/,  
     +' #############################################',/)  
 5120 FORMAT(/,'    Time  ',5(A1,' Conduit:',I10))  
 5121 FORMAT('  Hr:Mn:Sc',5(A1,'     Flow    Veloc.'))  
 5122 FORMAT('  --------',5(A1,'     ----    ------'))  
 5130 FORMAT(/,'   Time   ',5(A1,' Conduit:',A10))  
 5140 FORMAT(1H ,I3,':',I2,':',I2,5(F10.2,F10.2))  
 5141 FORMAT(1H ,I3,':',I2,':',I2,5(F10.4,F10.4))  
 5142 FORMAT('     Mean ',5(F10.2,F10.2))  
 5143 FORMAT('     Mean ',5(F10.4,F10.4))  
 5144 FORMAT('    Total ',5(1PE10.3,10X))  
 5145 FORMAT('  Maximum ',5(F10.2,F10.2))  
 5146 FORMAT('  Maximum ',5(F10.4,F10.4))  
 5150 FORMAT('  Minimum ',5(F10.2,F10.2))  
 5151 FORMAT('  Minimum ',5(F10.4,F10.4))  
 5243 FORMAT('     Mean ',5(F11.2,F10.2))  
 5245 FORMAT('  Maximum ',5(F11.2,F10.2))  
 5250 FORMAT('  Minimum ',5(F11.2,F10.2))  
 6666 FORMAT(/)  
cim 7000 FORMAT(200(I10,1X))  
cim 7010 FORMAT(200(A10,1X))  
cim 7020 FORMAT(E12.5,2I7,200(E12.5,1X))  
 9380 FORMAT(/,20X,'Upstream ==> Asterisk  Downstream ===> Plus')  
 9400 FORMAT(/,  
     +' ************************************************************',/,  
     +' * AVERAGE % CHANGE IN JUNCTION OR CONDUIT IS DEFINED AS:   *',/,  
     +' * CONDUIT  % CHANGE ==> 100.0 ( Q(n+1) - Q(n) ) / Qfull    *',/,  
     +' * JUNCTION % CHANGE ==> 100.0 ( Y(n+1) - Y(n) ) / Yfull    *',/,  
     +' ************************************************************')  
 9410 FORMAT(/,  
     +'  The Conduit with the largest average change... ',I10,  
     +' had',F10.3,' percent',/,  
     +' The Junction with the largest average change... ',I10,  
     +' had',F10.3,' percent',/)  
 9420 FORMAT(/,  
     +'  The Conduit with the largest average change... ',A10,  
     +' had',F10.3,' percent',/,  
     +' The Junction with the largest average change... ',A10,  
     +' had',F10.3,' percent',/)  
C=======================================================================  
      END  
ECHO is off.
REM File: PPLOT.FOR  
ECHO is off.
      SUBROUTINE PPLOT(IX,IY,K,NPLOT,ALPLOT)  
C=======================================================================  
C     THIS PART OF GRAPHING ROUTINES PRINTS THE 51 BY 101 ARRAY, A,  
C               OF POINTS.  
C     IT ALSO ASSIGNS SYMBOLS TO THE ARRAY AND PRINTS TITLES, LABELS.  
C     THIS SUBROUTINE LAST MODIFIED MARCH, 1988 BY RED.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'PLTARY.INC'  
      INCLUDE 'CONTR.INC'  
      INCLUDE 'LAB.INC'  
C=======================================================================  
      CHARACTER ALPLOT*10,SYM(9)*1  
      DATA SYM/'*','+','''','X','.','2',' ','I','-'/  
C=======================================================================  
C     PLACE PROPER SYMBOL IN ARRAY LOCATION.  
C=======================================================================  
      IF(K-99) 10,20,240  
   10 A(51-IY,IX+1) = SYM(K)  
      RETURN  
C=======================================================================  
C     PRINT TOTAL ARRAY, A, PLUS LABELS AND TITLES.  
C=======================================================================  
   20 CONTINUE  
      I  = 0  
      J2 = 1  
      WRITE(N6,31)  
      DO 180 II = 1,6  
      I         = I+1  
      IF(YLAB(1).LE.100000.0) THEN  
                              WRITE(N6,90) YLAB(II),(A(I,J),J=1,101)  
                              ELSE IF(YLAB(1).GT.100000.0) THEN  
                              WRITE(N6,100) YLAB(II),(A(I,J),J=1,101)  
                              ELSE  
                              WRITE(N6,95) YLAB(II),(A(I,J),J=1,101)  
                              ENDIF  
      IF(II.EQ.6) GO TO 190  
C=======================================================================  
      DO 170 JJ = J2,9  
      I         = I+1  
      IF(I.EQ.24) THEN  
                  WRITE(N6,120) VERT1,(A(I,J),J=1,101)  
                  ENDIF  
      IF(I.EQ.26) THEN  
                  WRITE(N6,120) VERT2,(A(I,J),J=1,101)  
                  ENDIF  
      IF(I.EQ.28) THEN  
                  WRITE(N6,120) VERT3,(A(I,J),J=1,101)  
                  ENDIF  
      IF(I.NE.24.AND.I.NE.26.AND.I.NE.28) WRITE(N6,160) (A(I,J),J=1,101)  
  170 CONTINUE  
      J2 = 1  
  180 CONTINUE  
  190 CONTINUE  
      WRITE(N6,200) XLAB  
      IF(JCE.EQ.0) WRITE(N6,210) NPLOT,HORIZ(1),HORIZ(2)  
      IF(JCE.EQ.1) WRITE(N6,211) ALPLOT,HORIZ(1),HORIZ(2)  
      WRITE(N6,30) HTITLE  
      RETURN  
C=======================================================================  
C     INITIALIZE PLOT OUTLINE.  
C=======================================================================  
  240 DO 260 I = 1,50  
      DO 250 J = 1,101  
  250 A(I,J)   = SYM(7)  
      A(I,1)   = SYM(8)  
      A(I,101) = SYM(8)  
  260 CONTINUE  
      DO 270 J = 1,101  
      A(1,J)   = SYM(9)  
  270 A(51,J)  = SYM(9)  
      DO 280 I = 1,101,10  
      A(1,I)   = SYM(8)  
  280 A(51,I)  = SYM(8)  
      DO 290 I = 11,41,10  
      A(I,1)   = SYM(9)  
      A(I,101) = SYM(9)  
  290 CONTINUE  
C=======================================================================  
   30 FORMAT(/,18X,A30,1X,A30)  
   31 FORMAT(/,'1')  
   90 FORMAT(' ',F14.3,1X,101A1)  
   95 FORMAT(' ',F14.6,1X,101A1)  
  100 FORMAT(' ',1PE14.2,1X,101A1)  
  120 FORMAT(1X,A10,5X,101A1)  
  160 FORMAT(16X,101A1)  
  200 FORMAT(F18.1,10F10.1)  
  210 FORMAT(/,18X,'LOCATION NO. : ',I9,1X,A30,2X,A30)  
  211 FORMAT(/,17X,'LOCATION NO. : ',A10,1X,A30,2X,A30)  
C=======================================================================  
      RETURN  
      END  
ECHO is off.
REM File: PSI.FOR  
ECHO is off.
      FUNCTION PSI(ALPHA)  
C     TRANSPORT BLOCK  
C=======================================================================  
C     FINDS Q/QFULL (PSI) GIVEN A/AFULL (ALPHA) FOR FUNCTIONAL Q-A CURVE  
C  
C     UPDATED (NEW COMMON) BY W.C.H., SEPTEMBER 1981.  
C     USE QCURVE(4), NOT (3) FOR FLOW.  WCH, 7/6/01.   
C     FIX MAX NUMBER OF TABULAR POINTS FOR UNLIKELY BUT POSSIBLE ERROR.  
C       WCH, 5/24/02.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'PSIDPS.INC'  
      INCLUDE 'TABLES.INC'  
      INCLUDE 'HUGO.INC'  
      INCLUDE 'NEW81.INC'  
      INCLUDE 'FLODAT.INC'  
C=======================================================================  
      PSI = 0.0  
      IF(ALPHA.LE.0.0) RETURN  
      NTPE  = NTYPE(M)  
C=======================================================================  
C     CALL SPECIAL ROUTINE TO GET HIGH ACCURACY AT LOW FLOWS  
C=======================================================================  
      IF(NTPE.EQ.1) THEN  
                  ALF = ALPHA  
                  CALL CIRCLE(ALF,PS,DN,1)  
                  PSI = PS  
                  RETURN  
                  ENDIF  
C=======================================================================  
C     SPECIAL FUNCTIONAL FORM FOR RECTANGULAR CONDUITS.  
C=======================================================================  
      IF(NTPE.EQ.2) THEN  
                  R = P5(M)  
                  IF(ALPHA.GT.ALFMAX(NTPE)) THEN  
                           PSI = P4(M)+(ALPHA-ALFMAX(NTPE))*  
     1                           (1.0-P4(M))/(1.0-ALFMAX(NTPE))  
                           RETURN  
                           ENDIF  
                  AAA = 2.0*R*ALPHA+1.0  
                  CATH = (ALPHA*P7(M)/AAA)**0.6666667  
                  PSI  = ALPHA*CATH  
                  RETURN  
                  ENDIF  
C=======================================================================  
C     FUNCTIONAL FORM FOR MODIFIED BASKET-HANDLE.  
C=======================================================================  
      IF(NTPE.EQ.10) THEN  
                   AA = ALPHA*AFULL(M)  
                   IF (AA.GT.GEOM3(M)) THEN  
                          RH = RADH(AA)  
                          PSI = 1.49/ROUGH(M)*AA*RH**0.6666667/P1(M)  
                          RETURN  
                          ENDIF  
                   ALF  = AA/GEOM3(M)  
                   R    = GEOM1(M)/GEOM2(M)  
                   AAA  = 2.0*ALF*R+1.0  
                   CATH = (ALF*P7(M)/AAA)**0.6666667*P6(M)  
                   PSI  = ALF*CATH  
                   RETURN  
                   ENDIF  
C=======================================================================  
C     FUNCTIONAL FORM FOR RECTANGULAR, TRIANGULAR BOTTOM.  
C=======================================================================  
      IF(NTPE.EQ.11) THEN  
                   AB = GEOM3(M)*GEOM2(M)/2.0  
                   AA = ALPHA*AFULL(M)  
                   IF (AA.LE.AB) THEN  
                                 PSI = P7(M)*ALPHA**1.333333  
                                 RETURN  
                                 ENDIF  
                   IF (ALPHA.GT.ALFMAX(NTPE)) THEN  
                           PSI = P4(M)+(ALPHA-ALFMAX(NTPE))*  
     1                           (1.0-P4(M))/(1.0-ALFMAX(NTPE))  
                           RETURN  
                           ENDIF  
                   AAA = GEOM3(M)/P5(M)-GEOM3(M)+(2.0*GEOM1(M) -  
     1                   GEOM3(M))*ALPHA  
                   CATH = (ALPHA*P6(M)/AAA)**0.6666667  
                   PSI = ALPHA*CATH  
                   RETURN  
                   ENDIF  
C=======================================================================  
C     FUNCTIONAL FORM FOR RECTANGULAR, ROUND BOTTOM.  
C=======================================================================  
      IF(NTPE.EQ.12) THEN  
                   AA = ALPHA*AFULL(M)  
                   IF(AA.GT.P6(M)) THEN  
                            IF (ALPHA.GT.ALFMAX(NTPE)) THEN  
                                PSI = P4(M)+(ALPHA-ALFMAX(NTPE))*  
     1                                (1.0-P4(M))/(1.0-ALFMAX(NTPE))  
                                RETURN  
                                ENDIF  
                            D1 = GEOM3(M)*P5(M)+2.0*GEOM1(M)+GEOM2(M)  
                            D2 = GEOM3(M)*P5(M)+2.0/GEOM2(M)*  
     1                           (AFULL(M)*ALPHA-P6(M))  
                            CATH = (ALPHA*D1/D2)**0.6666667  
                            PSI  = ALPHA*CATH  
                            RETURN  
                            ENDIF  
                   ALF = ALPHA*AFULL(M)/(3.1415965*GEOM3(M)*GEOM3(M))  
                   IF(ALF.LT.0.04) THEN  
                                   CALL CIRCLE (ALF,PS,DN,1)  
                                   PSI = PS  
                                   PSI = PSI*P7(M)  
                                   RETURN  
                                   ENDIF  
                   I = IFIX(ALF/0.02) + 1  
                   PSI = QNORM(1,I)+(QNORM(1,I+1)-QNORM(1,I))/0.02*  
     1                              (ALF-ANORM(1,I))  
                   PSI = PSI*P7(M)  
                   RETURN  
                   ENDIF  
C=======================================================================  
C    FUNCTIONAL FORM FOR TRAPEZOID  
C=======================================================================  
      IF(NTPE.EQ.13) THEN  
                   AA   = ALPHA * AFULL(M)  
                   AAA  = (-GEOM2(M) + SQRT(GEOM2(M)**2 +  
     1                     4.0 * AA/GEOM3(M))) * 0.5 * GEOM3(M)  
                   CATH =  AA/(GEOM2(M) + AAA * P5(M))/P6(M)  
                   PSI  = ALPHA * CATH**0.6666667  
                   RETURN  
                   ENDIF  
C=======================================================================  
C     INCLUDE TABULAR PSI CALC. IN CASE PSI IS CALLED BY KLASS=2 CONDUIT  
Cwch, 3/14/02. This same code for power function and natural channels.  
C     NTPE also = 16 for these two channels (changed from 14 and 15 in   
C     Sub. INTRAN).    
C=======================================================================  
      IF(NTPE.EQ.16) THEN  
                   KK = NQC(M)  
                   DALPHA = QCURVE(KK,2,2) - QCURVE(KK,2,1)  
                   I      = IFIX(ALPHA/DALPHA + 1.0)  
                   IF(I.GE.26) I = 25  
Cwch, 7/6/01. Use QCURVE(4), not (3) for flow.   
                   PSI    = QCURVE(KK,4,I) + (QCURVE(KK,4,I+1) -  
     1                      QCURVE(KK,4,I)) / DALPHA *  
     2                     (ALPHA - QCURVE(KK,2,I))  
                   ELSE  
                   DALPHA = ANORM(NTPE,2) - ANORM(NTPE,1)  
                   I      = IFIX(ALPHA/DALPHA + 1.0)  
Cwch, 5/24/02. Should not be in this ELSE-location, but in case we are,  
C     should use MM(MTPE) as max, not 26.   
C                   IF(I.GE.26) I = 25  
                   IF(I.GE.MM(NTPE)) I = MM(NTPE) - 1  
                   PSI    = QNORM(NTPE,I) + (QNORM(NTPE,I+1) -  
     1                      QNORM(NTPE,I))/DALPHA*(ALPHA-ANORM(NTPE,I))  
                   ENDIF  
      RETURN  
      END  
ECHO is off.
REM File: QHYDRO.FOR  
ECHO is off.
      SUBROUTINE QHYDRO  
C	RUNOFF BLOCK  
C	CALLED BY SUBROUTINE RUNOFF NEAR LINE 224  
C=======================================================================  
C     QHYDRO was created NOVEMBER, 1981 BY R.DICKINSON  
C     last updated December, 1990.  
C     Updated 4/93 by WCH to correct land-use input and print-out  
C       from groups L1 and L2 and slight format modifications.  
C     WCH, 9/3/93. Add quality input for infiltration/inflow.  
C     WCH (Warren Chrusciel), 9/28/93.  Fix metric conversion for QFACT3.  
C     WCH, 9/29/93.  Add warning and code for too many J2 lines.  
C     WCH, 11/15/93.  Change loop for IEND to NQSS + 2 from NRQ + 2.  
C     WCH, 10/19/95.  Add warning messages for L1 and M1 lines.  
C     WCH, 8/14/96.  Correct units conversion for RCOEF for KWASH > 0.  
C     CIM, 4/1/99.  Changes to increase maximum number of constituents  
C                   from 10 to MQUAL  
C     WCH, 12/20/00. Add variables for overland flow quality.  
C     WCH, 1/18/01. Fix J4 output.  
C     WCH, 2/10.01. Add input for BMP removal in channels, new line J7.  
C     WCH (RED), 5/8/01. Fix loop for reading L1-L2 lines.  
C     WCH, 3/29/02. Fix warning message printout re. L2 lines. Slightly  
C      alter constituent printout to avoid asterisks for too-big fields.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'SUBCAT.INC'  
      INCLUDE 'QUALTY.INC'  
      INCLUDE 'NEW88.INC'  
      INCLUDE 'NEW89.INC'  
      INCLUDE 'GRWTR.INC'  
C#### WCH, 9/93  
      INCLUDE 'RDII.INC'  
Cwch, 12/20/00.  And increase dimension of XINJ3 to 12.  
      INCLUDE 'OVERLAND.INC'  
      DIMENSION XINJ2(6),RJLAND(6),DJLAND(6),  
     1          XINJ3(12),DNQS(10),RNQS(MQUAL),EROS(5),REROS(5),  
     2          DEROS(5),SUBQL(MQUAL+2),DSUBQL(MQUAL+2),RSUBQL(MQUAL+2)  
Cwch, 2/10/01.  
      DIMENSION GREMV(MQUAL)  
	CHARACTER*10 KGNAME  
      CHARACTER JDLINK(2)*16,IDASH*4,ISTAR*4,ISPACE*4,KKN*10,  
     1          JDBET(3)*20,JDFDB(3)*16,JDTBC(5)*16,JDTWC(3)*20  
      DATA IDASH/'----'/,ISTAR/'****'/,ISPACE/'    '/  
      DATA JDLINK/' NO SNOW LINKAGE','BUILDUP FOR SNOW'/  
      DATA JDBET/'   POWER LINEAR(0) ',' EXPONENTIAL(1)    ',  
     1           ' MICHAELIS MENTEN(2)'/  
      DATA JDFDB/'CHAN. LENGTH(0) ','        AREA(1) ',  
     1           '    CONSTANT(2) '/  
C#### WCH, 9/9/93. REMOVE ONE BLANK FROM BEFORE "RATG" AND COSMETIC.  
      DATA JDTWC/'  POWER EXPONEN.(0) ',' RATG CURVE NO UL(1)',  
     1           '  RATING CURVE UL(2)'/  
      DATA JDTBC/' FRACT. BLDUP(0)',' POWER-LINEAR(1)',  
     1           '  EXPONENTIAL(2)',' MICH. MENTEN(3)',  
     2           '   NO BUILDUP(4)'/  
C=======================================================================  
      DO 50     I = 1,MQUAL  
      NDIM(I)     = 0  
      DO 50     J = 1,NLU  
      KEY(J,I)    = 0  
      KALC(J,I)   = 0  
      KWASH(J,I)  = 0  
      TEMPLD(J,I) = 0.0  
      KACGUT(J,I) = 0  
      WASHPO(J,I) = 0.0  
      CONCRN(J,I) = 0.0  
      RCOEF(J,I)  = 0.0  
      RCOEFX(J,I) = 0.0  
 50   CBFACT(J,I) = 0.0  
C=======================================================================  
C#### WCH, 10/19/95.  Add check for possible error of calling quality  
C     routines with no quality data.  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'M1') THEN  
           WRITE(N6,6001)  
           STOP  
           ENDIF  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>> READ DATA GROUP JJ <<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'JJ') THEN  
                     READ(N5,*,ERR=888) CC,IMUL  
                     IF(IMUL.LT.0) CALL ERROR(143)  
                     ELSE  
                     IMUL = 0  
                     ENDIF  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>> READ DATA GROUP J1 <<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,NQS,JLAND,IROS,IROSAD,DRYDAY,CBVOL,  
     1                   DRYBSN,RAINIT,REFFDD,KLNBGN,KLNEND  
      IF(CC.NE.'J1') CALL ERROR(140)  
CIM move these checks up to here  
      IF(NQS.LE.0)  CALL ERROR(3)  
      IF(NQS.GT.MQUAL) CALL ERROR(4)  
      IF(NQS.EQ.MQUAL.AND.IROS.EQ.1) CALL ERROR(5)  
      IF(IMUL.EQ.0) N1 = 1  
      IF(IMUL.GT.0) N1 = JLAND  
C=======================================================================  
C     Add an erosion constituent if IROS = 1.  
C=======================================================================  
      IF(IROS.GT.0) THEN  
cim                    NQS        =  NQS + 1  
                    PNAME(NQS+1) = KEROS(1)  
                    PUNIT(NQS+1) = KEROS(2)  
                    NDIM(NQS+1)  = 0  
cim                    NQS = NQS - 1  
                    ENDIF  
      NQSS = NQS  
      IF(KLNEND.LE.0)   KLNEND = 367  
      IF(DRYBSN.LE.0.0) THEN  
                        WRITE(N6,1623) DRYBSN  
                        DRYBSN = 1.0  
                        ENDIF  
C=======================================================================  
C     Write the quality input data.  
C=======================================================================  
      IF(IPRN(7).EQ.0) THEN  
        IF(METRIC.EQ.1) WRITE(N6,1180) NQS,JLAND,CBVOL  
        IF(METRIC.EQ.2) WRITE(N6,1190) NQS,JLAND,CBVOL  
        IF(IROS.EQ.0) WRITE(N6,1590) IROS  
        IF(IROS.EQ.1) WRITE(N6,1600) IROS  
        IF(IROS.EQ.1) WRITE(N6,1610) IROSAD  
        IF(METRIC.EQ.1.AND.IROS.EQ.1) WRITE(N6,1615) RAINIT  
        IF(METRIC.EQ.2.AND.IROS.EQ.1) WRITE(N6,1616) RAINIT  
                                      WRITE(N6,1620) DRYDAY  
        WRITE(N6,1625) DRYBSN  
        WRITE(N6,1630) REFFDD  
        WRITE(N6,1635) KLNBGN,KLNEND  
        ENDIF  
      CBVOL  = CBVOL  * CMET(8,METRIC)  
      RAINIT = RAINIT / CMET(5,METRIC)  
C=======================================================================  
C     Set the default limits and default ratio for land use.  
C=======================================================================  
      DO 1045 J = 1,6  
      DJLAND(J) = 0.0  
 1045 RJLAND(J) = 1.0  
      DJLAND(1) = 1.0E35  
C=======================================================================  
C     Read in JLAND land use data groups.  
C=======================================================================  
      IF(JLAND.LE.0)   CALL ERROR(1)  
      IF(JLAND.GT.NLU) CALL ERROR(2)  
      J          = 0  
      DO 1070 JJ = 1,500  
      J          = J + 1  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP J2 <<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,LNAME(J),METHOD(J),JACGUT(J),  
     1                      (XINJ2(K),K=1,6)  
      IF(CC.NE.'J2') CALL ERROR(141)  
C=======================================================================  
C     SET THE NEW DEFAULT VALUES -- METHOD(J) = -2  
C=======================================================================  
      IF( METHOD(J).EQ.-2 ) THEN  
                            DO 1055 K = 1,6  
 1055                       IF(XINJ2(K).GT.0.0) DJLAND(K)=XINJ2(K)  
                            J = J - 1  
                            GO TO 1070  
                            ENDIF  
C=======================================================================  
C     SET THE NEW RATIO  -- METHOD(J) = - 1  
C=======================================================================  
      IF(METHOD(J).EQ.-1) THEN  
                          DO 1060 K = 1,6  
 1060                     IF(XINJ2(K).GT.0.0) RJLAND(K)=XINJ2(K)  
                          J = J - 1  
                          GO TO 1070  
                          ENDIF  
C=======================================================================  
C     MULTIPLY BY THE RATIOS AND ASSIGN DEFAULT VALUES  
C=======================================================================  
      DO 1067 K = 1,6  
      IF(XINJ2(K).LE.0.0) XINJ2(K) = DJLAND(K)  
 1067                     XINJ2(K) = XINJ2(K) * RJLAND(K)  
      DDLIM(J)  = XINJ2(1)  
      DDPOW(J)  = XINJ2(2)  
      DDFACT(J) = XINJ2(3)  
      CLFREQ(J) = XINJ2(4)  
      AVSWP(J)  = XINJ2(5)  
      DSLCL(J)  = XINJ2(6)  
      IF(METHOD(J).LT.0.OR.METHOD(J).GT.2)    CALL ERROR(8)  
      IF(JACGUT(J).LT.0.OR.JACGUT(J).GT.2)    CALL ERROR(9)  
C#######################################################################  
C     WCH, 9/29/93.  ADD CODE FOR MORE J2 LINES THAN VALUE OF JLAND.  
C=======================================================================  
      IF(J.EQ.JLAND.AND.JLAND.EQ.NLU) GO TO 1071  
      IF(J.LT.JLAND) GO TO 1070  
C=======================================================================  
C     READ NEXT LINE TO SEE IF IT IS ANOTHER LAND USE LINE.  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'J2') THEN  
           JLAND = JLAND + 1  
           WRITE(N6,6018) J,JLAND  
           IF(JLAND.GT.NLU) CALL ERROR(2)  
           IF(IMUL.GT.0) N1 = JLAND  
           GO TO 1070  
           ELSE  
           GO TO 1071  
           ENDIF  
 1070 CONTINUE  
 1071 CONTINUE  
C=======================================================================  
C     SET THE DEFAULT VALUES AND DEFAULT RATIOS  
C     FOR THE BUILDUP PARAMETERS AND NQS PARAMETERS  
C=======================================================================  
      DO 1072 I = 1,10  
      DNQS(I)   = 0.0  
1072  RNQS(I)   = 1.0  
C=======================================================================  
C     Read in the NQS quality constituents.  
C=======================================================================  
      K          = 0  
      DO 1075 KK = 1,500  
      K          = K + 1  
      DO 1090  J = 1,N1  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP J3 <<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
Cwch, 12/20/00.  Add REMOVE and DECAY (XINJ3(11 and 12))  
C=======================================================================  
      READ(N5,*,ERR=888) CC,PNAME(K),PUNIT(K),NDIM(K),KALC(J,K),  
     1                      KWASH(J,K),KACGUT(J,K),LINKUP(J,K),  
     2                      (XINJ3(L),L=1,12)  
      IF(CC.NE.'J3') CALL ERROR(142)  
C=======================================================================  
C     SET THE NEW DEFAULT VALUES -- KALC(J,K) = -2  
C=======================================================================  
         IF(KALC(J,K).EQ.-2) THEN  
                             DO 1076 I = 1,12  
 1076                        IF(XINJ3(I).GT.0.0) DNQS(I) = XINJ3(I)  
                             K         = K - 1  
                             GO TO 1075  
                             ENDIF  
C=======================================================================  
C     Set the new ratio  -- KALC(J,K) = -1  
C=======================================================================  
       IF(KALC(J,K).EQ.-1) THEN  
                           DO 1078 I = 1,12  
 1078                      IF(XINJ3(I).GT.0.0) RNQS(I) = XINJ3(I)  
                           K         = K - 1  
                           GO TO 1075  
                           ENDIF  
1079  DO 1080 I      = 1,10  
      IF(XINJ3(I).LT.0.0) XINJ3(I) = DNQS(I)  
1080  XINJ3(I)       = XINJ3(I)    * RNQS(I)  
      QFACT(J,1,K)   = XINJ3(1)  
      QFACT(J,2,K)   = XINJ3(2)  
      QFACT(J,3,K)   = XINJ3(3)  
      QFACT(J,4,K)   = XINJ3(4)  
      QFACT(J,5,K)   = XINJ3(5)  
      WASHPO(J,K)    = XINJ3(6)  
C#### WCH, 4/13/93.  CHECK FOR EXTREME VALUE OF WASHPO.  
        IF(WASHPO(J,K).GT.25.) WRITE(N6,6017) J,K,WASHPO(J,K)  
      RCOEF(J,K)     = XINJ3(7)  
      CBFACT(J,K)    = XINJ3(8)  
      CONCRN(J,K)    = XINJ3(9)  
      REFF(J,K)      = XINJ3(10)  
Cwch, 12/20/00.   Note, later convert QDECAY from 1/day to 1/s.  
	REMOVE(J,K)    = XINJ3(11)  
	IF(J.EQ.1) QDECAY(K) = XINJ3(12)  
1090  CONTINUE  
      IF(K.EQ.NQS) GO TO 1175  
1075  CONTINUE  
1175  CONTINUE  
      IF(RAINIT.LT.0.AND.IROS.EQ.1)   CALL ERROR(7)  
C=======================================================================  
C     Write the land use data.  
C=======================================================================  
      IF(IPRN(7).EQ.0) WRITE(N6,1639)  
      IF(IPRN(7).EQ.0) WRITE(N6,1640)  
      DO 1645 J = 1,JLAND  
      JET       = METHOD(J) + 1  
      JAM       = JACGUT(J) + 1  
      IF(IPRN(7).EQ.0) WRITE(N6,1641)  
     1                 LNAME(J),JDBET(JET),JDFDB(JAM),DDLIM(J),DDPOW(J),  
     2                 DDFACT(J),CLFREQ(J),AVSWP(J),DSLCL(J)  
C=======================================================================  
C     Make the units conversion from metric input to U.S. Standard units  
C     for DDLIM and DDFACT.  
C=======================================================================  
                      CLB = 1.0  
      IF(METRIC.EQ.2) CLB = 1000.0/453.7  
      IF(JACGUT(J).EQ.0) DDLIM(J) = DDLIM(J) *  
     1                              CLB/CMET(1,METRIC)  
      IF(JACGUT(J).EQ.1) DDLIM(J) = DDLIM(J) * CLB/CMET(2,METRIC)  
      IF(JACGUT(J).EQ.2) DDLIM(J) = DDLIM(J) * CLB  
      IF(METHOD(J).LE.0) THEN  
                         IF(JACGUT(J).EQ.0) DDFACT(J) = DDFACT(J) *  
     1                                           CLB/CMET(1,METRIC)  
                         IF(JACGUT(J).EQ.1) DDFACT(J) = DDFACT(J) *  
     1                                           CLB/CMET(2,METRIC)  
                         IF(JACGUT(J).EQ.2) DDFACT(J) = DDFACT(J)*CLB  
                         ENDIF  
 1645 CONTINUE  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP J4 <<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      DO 1647 I = 1,MQUAL  
      DO 1647 J = 1,MQUAL  
 1647 F1(I,J)   = 0.0  
 1650 READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'J4') THEN  
                     READ(N5,*,ERR=888) CC,KTO,KFROM,FIN1  
                     IF(KTO.GT.0) F1(KTO,KFROM) = FIN1  
                     GO TO 1650  
                     ENDIF  
C=======================================================================  
C     Write the constituent data.  
C=======================================================================  
      IF(IPRN(7).EQ.0) THEN  
         WRITE(N6,1660)  
         DO 2000 K = 1,NQS,5  
         DO 1990 J = 1,N1  
         KK        = K + 4  
         IF(NQS.LT.KK)  KK = NQS  
         WRITE(N6,2001) (PNAME(I),I=K,KK)  
         WRITE(N6,2002) (ISPACE,I=K,KK)  
         WRITE(N6,2003) (PUNIT(I),I=K,KK)  
         WRITE(N6,2004) (NDIM(I),I=K,KK)  
         WRITE(N6,2006) (KALC(J,I),I=K,KK)  
         WRITE(N6,2205) (JDTBC(KALC(J,I)+1),I=K,KK)  
         WRITE(N6,2007) (KWASH(J,I),I=K,KK)  
         WRITE(N6,2206) (JDTWC(KWASH(J,I)+1),I=K,KK)  
         WRITE(N6,2008) (KACGUT(J,I),I=K,KK)  
C#### WCH 4/12/93.  SHOULD PRINT JDFDB, NOT JDTBC.  
         WRITE(N6,2207) (JDFDB(KACGUT(J,I)+1),I=K,KK)  
         WRITE(N6,2009) (LINKUP(J,I),I=K,KK)  
         WRITE(N6,2208) (JDLINK(LINKUP(J,I)+1),I=K,KK)  
         WRITE(N6,2209) (QFACT(J,1,I),I=K,KK)  
         WRITE(N6,2500) (QFACT(J,2,I),I=K,KK)  
         WRITE(N6,2501) (QFACT(J,3,I),I=K,KK)  
         WRITE(N6,2502) (QFACT(J,4,I),I=K,KK)  
         WRITE(N6,2503) (QFACT(J,5,I),I=K,KK)  
         WRITE(N6,2504) (WASHPO(J,I),I=K,KK)  
         WRITE(N6,2505) (RCOEF(J,I),I=K,KK)  
         WRITE(N6,2506) (CBFACT(J,I),I=K,KK)  
         WRITE(N6,2507) (CONCRN(J,I),I=K,KK)  
         WRITE(N6,2508) (REFF(J,I),I=K,KK)  
Cwch, 12/20/00  
         WRITE(N6,2510) (REMOVE(J,I),I=K,KK)  
	   WRITE(N6,2511) (QDECAY(I),I=K,KK)  
         WRITE(N6,2509) (J,I=K,KK)  
1990     CONTINUE  
2000     CONTINUE  
         ENDIF  
Cwch, 12/20/00.  Convert decay rate to 1/s from 1/day.  
      DO I = 1,NQS  
	     QDECAY(I) = QDECAY(I)/86400.  
           ENDDO  
C=======================================================================  
C     Make the units conversion from Metric input to U.S. Customary units  
C=======================================================================  
      IF(METRIC.EQ.2) THEN  
           DO 2700 K = 1,NQS  
           DO 2690 J = 1,N1  
           IF(KWASH(J,K).EQ.0) RCOEF(J,K) = RCOEF(J,K)*  25.4 **  
     1                                             WASHPO(J,K)  
C#### WCH, 8/14/96.  WRONG CONVERSION.  SHOULD >DIVIDE<, NOT MULTIPLY.  
C####           IF(KWASH(J,K).GT.0) RCOEF(J,K) = RCOEF(J,K)*35.315 **  
           IF(KWASH(J,K).GT.0) RCOEF(J,K) = RCOEF(J,K)/35.315 **  
     1                                             WASHPO(J,K)  
C  
           IF(KALC(J,K).EQ.0.OR.KALC(J,K).EQ.4) GO TO 2700  
C  
           IF(KACGUT(J,K).EQ.0) QFACT(J,1,K) = QFACT(J,1,K) *  
     1                                        2.205 / 32.808  
           IF(KACGUT(J,K).EQ.1) QFACT(J,1,K) = QFACT(J,1,K) *  
     1                                        2.205 / 2.4710  
           IF(KACGUT(J,K).EQ.2) QFACT(J,1,K) = QFACT(J,1,K) * 2.205  
C  
           IF(KALC(J,K).EQ.1) THEN  
                IF(KACGUT(J,K).EQ.0) QFACT(J,3,K) = QFACT(J,3,K) *  
     1                                        2.205 / 32.808  
C#### WCH (W. CHRUSCIEL), 9/28/93.  DIVIDE BY 2.471, NOT 32.808  
                IF(KACGUT(J,K).EQ.1) QFACT(J,3,K) = QFACT(J,3,K) *  
     1                                        2.205 / 2.4710  
                IF(KACGUT(J,K).EQ.2) QFACT(J,3,K) = QFACT(J,3,K) * 2.205  
                ENDIF  
 2690      CONTINUE  
 2700      CONTINUE  
           ENDIF  
C#######################################################################  
      DO 3070 I = 1,NQS  
      DO 3070 J = 1,NQS  
      IF(F1(I,J).NE.0.0) GO TO 3075  
3070  CONTINUE  
      GO TO 3099  
3075  CONTINUE  
C=======================================================================  
C     Write the fractional constituent data.  
C=======================================================================  
      IF(IPRN(7).EQ.0) THEN  
      WRITE(N6,3076)  
      WRITE(N6,3077)  
      WRITE(N6,3078) (PNAME(JJ),JJ=1,NQS)  
      WRITE(N6,3094) (IDASH,ISTAR,KK=1,NQS)  
C  
      DO 3080 I = 1,NQS  
      DO 3085 JTEST = 1,NQS  
      IF(F1(I,JTEST).NE.0.0) GO TO 3086  
3085  CONTINUE  
      GO TO 3080  
3086  WRITE(N6,3090) (ISTAR,KK=1,NQS)  
      WRITE(N6,3091) (ISTAR,KK=1,NQS)  
      WRITE(N6,3092) (ISTAR,KK=1,NQS)  
      WRITE(N6,3093) PNAME(I),(F1(I,JJ),JJ=1,NQS)  
      WRITE(N6,3094) (IDASH,ISTAR,KK=1,NQS)  
3080  CONTINUE  
      ENDIF  
C=======================================================================  
C     Read groundwater quality data if present on data group J5.  
C=======================================================================  
3099  CONTINUE  
      IF(NOGWSC.GT.0) THEN  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>> READ DATA LINE J5 <<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
                READ(N5,*,ERR=888) CC  
                BACKSPACE N5  
                IF(CC.EQ.'J5')THEN  
                              READ(N5,*,ERR=888) CC,(CGWQ(K),K=1,NQS)  
                              WRITE(N6,3010) (PNAME(K),  
     1                                        CGWQ(K),PUNIT(K),K=1,NQS)  
                              ENDIF  
                ENDIF  
C=======================================================================  
C     Read infiltration/inflow quality data if present on data group J6.  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>> READ DATA LINE J6 <<<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
                IF(CC.EQ.'J6')THEN  
                              READ(N5,*,ERR=888) CC,(CONCII(K),K=1,NQS)  
                              WRITE(N6,3015) (PNAME(K),  
     1                                      CONCII(K),PUNIT(K),K=1,NQS)  
                              ENDIF  
C=======================================================================  
Cwch, 2/10/01. New input of BMP removal fraction for channel/pipes.  
C>>>>>>>>>>>>>>>>>>>>>> READ DATA LINES J7 <<<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IJK = 0  
	DO J = 1,NQS  
	   GREMV(J) = 0.0  
	   ENDDO  
 3100 READ(N5,*,ERR=888) CC  
	BACKSPACE N5  
	   IF(CC.EQ.'J7') THEN  
	     IJK = IJK + 1  
C     Error message for too many J7 lines, but continue.  
		 IF(IJK.GT.NOG) WRITE(N6,6023) IJK,NOG  
	     IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,NGNAME,(GREMV(J),J=1,NQS)  
	     IF(JCE.EQ.1) READ(N5,*,ERR=888) CC,KGNAME,(GREMV(J),J=1,NQS)  
C     Find matching channel/pipe, to get subscript.  
	     DO 3150 N = 1,NOG  
	     NNN = N  
C     Error message for no match for channel/pipe name.  But continue.  
	     IF(JCE.EQ.0.AND.NGNAME.EQ.NAMEG(N)) GOTO 3155  
	     IF(JCE.EQ.1.AND.KGNAME.EQ.KAMEG(N)) GOTO 3155  
 3150      CONTINUE  
           IF(JCE.EQ.0) WRITE(N6,6021) NGNAME  
	     IF(JCE.EQ.1) WRITE(N6,6022) KGNAME  
	     GOTO 3100  
 3155      DO J = 1,NQS  
              GREMOVE(J,NNN) = GREMV(J)  
	        ENDDO  
           IF(IJK.EQ.1) WRITE(N6,6025) (PNAME(J),J=1,NQS)  
	     IF(IJK.EQ.1) WRITE(N6,6026) (IDASH,J=1,2*NQS)  
	     IF(JCE.EQ.0) WRITE(N6,6027) NGNAME,(GREMV(J),J=1,NQS)  
	     IF(JCE.EQ.1) WRITE(N6,6028) KGNAME,(GREMV(J),J=1,NQS)  
	     GOTO 3100  
	     ENDIF  
C=======================================================================  
C     NWPGE is a line counter for the printout  
C             of erosion and subcatchment data.  
C=======================================================================  
      NWPGE = 0  
      IF(IROS.GT.0) THEN  
C=======================================================================  
C     Erosion input  
C=======================================================================  
C     Set the default values and default ratios for erosion.  
C=======================================================================  
      DO 4000 I = 1,5  
      DEROS(I)  = 0.0  
4000  REROS(I)  = 1.0  
C=======================================================================  
C     Print the erosion title data group depending on metric.  
C=======================================================================  
      IF(METRIC.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,4050)  
      IF(METRIC.EQ.2.AND.IPRN(7).EQ.0) WRITE(N6,4051)  
      NWPGE       = 13  
      DO 5000  II = 1,1000  
      NWPGE       = NWPGE + 1  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>>>>> READ DATA GROUP K1 <<<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
      IF(CC.EQ.'K1') THEN  
                     IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,  
     1                                    N,(EROS(K),K=1,5)  
                     IF(JCE.EQ.1) READ(N5,*,ERR=888) CC,  
     1                                    KKN,(EROS(K),K=1,5)  
                     ELSE  
                     GO TO 5005  
                     ENDIF  
C=======================================================================  
C     Set the default values for erosion.  
C=======================================================================  
      IF(N.NE.-2) GO TO 4065  
      DO 4064 J = 1,5  
      IF(EROS(J).GT.0.0) DEROS(J) = EROS(J)  
4064  CONTINUE  
      GO TO 5000  
C=======================================================================  
C     Set the new ratios for erosion  
C=======================================================================  
4065  IF(N.NE.-1) GO TO 4067  
      DO 4066 J = 1,5  
      IF(EROS(J).GT.0.0) REROS(J) = EROS(J)  
4066  CONTINUE  
      GO TO 5000  
4067  DO 4080 J = 1,NOW  
      IF(JCE.EQ.0.AND.N.NE.NAMEW(J)) GO TO 4080  
      IF(JCE.EQ.1.AND.KKN.NE.KAMEW(J)) GO TO 4080  
      K = J  
      GO TO 4090  
4080  CONTINUE  
C=======================================================================  
C     No match was found call ERROR subroutine.  
C=======================================================================  
      CALL ERROR(11)  
C=======================================================================  
C     Multiply by the ratios and assign default values.  
C=======================================================================  
4090  DO 4085 I = 1,5  
      IF(EROS(I).LE.0.0) EROS(I) = DEROS(I)  
4085  EROS(I)   = EROS(I) * REROS(I)  
C=======================================================================  
      ERODAR  = EROS(1)  
      ERLEN   = EROS(2)  
      SOILF   = EROS(3)  
      CROPMF  = EROS(4)  
      CONTPF  = EROS(5)  
      ERLEN   = ERLEN  * CMET(1,METRIC)  
      ERODAR  = ERODAR * CMET(2,METRIC)  
C=======================================================================  
C     The new values of ERLEN and ERODAR are used internally in  
C     the runoff block.  The input values are saved in EROS(1)  
C     and EROS(2) and will be printed on the output sheet.  
C=======================================================================  
C     Compute the slope length gradient ratio.  
C=======================================================================  
      SLGR = SQRT(ERLEN) * (0.0076 + 0.53 * WSLOPE(K) +  
     1                             7.6 * WSLOPE(K)**2 )  
C=======================================================================  
C     COMPUTE THE PARTIAL USLE ( MINUS THE RAINFALL FACTOR)  
C     UNITS ARE IN MILLIGRAMS  
C     THE NUMBER 9.072E08 = 2000.0 * 453.6E03  
C     THE UNITS ARE LBS/TON * MG/LBS.  
C=======================================================================  
      CNSTNT(K) = SLGR * SOILF * CROPMF * CONTPF * ERODAR * 9.072E08  
C=======================================================================  
      IF(IPRN(7).EQ.0) THEN  
      IF(METRIC.EQ.1.AND.NWPGE.EQ.55) WRITE(N6,4050)  
      IF(METRIC.EQ.2.AND.NWPGE.EQ.55) WRITE(N6,4051)  
      IF(NWPGE.EQ.55) NWPGE = 13  
      WRITE(N6,4070) N,EROS(1),EROS(2),SOILF,CROPMF,CONTPF,  
     1           SLGR,CNSTNT(K)  
      ENDIF  
5000  CONTINUE  
5005  IF(IPRN(7).EQ.0) WRITE(N6,4075)  
C=======================================================================  
C     Since IROS = 1 , add a new quality constituent.  
C=======================================================================  
      NQSS = NQS  
      NQS  = NQS + 1  
      ENDIF  
C=======================================================================  
C     Read the subcatchment quality data.  
C=======================================================================  
C     Set the default values and default ratios.  
C=======================================================================  
      DO 5020 I = 1,MQUAL+2  
      DSUBQL(I) = 0.0  
5020  RSUBQL(I) = 1.0  
      DO 5030 I = 1,MQUAL  
5030  RNQS(I)   = 0.0  
      M         = 0  
      SMCTCH    = 0.0  
      GUTSM     = 0.0  
C#### WCH, 11/15/93  
      IEND      = NQSS + 2  
C=======================================================================  
Cred (WCH), 5/8/01 Increase loop to 200000 to allow for max no. subcats.  
      DO 6010 JJ = 1,200000  
      M          = M + 1  
      IF(M.GT.NOW) GO TO 6020  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>>>>>> Read data group L1 <<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(JCE.EQ.0) READ(N5,*,ERR=888) CC,N,KL,(SUBQL(K),K=1,IEND)  
      IF(JCE.EQ.1) READ(N5,*,ERR=888) CC,KKN,KL,(SUBQL(K),K=1,IEND)  
C=======================================================================  
C     Alter ratios  
C=======================================================================  
      IF(N.NE.-1) GO TO 5070  
      DO 5065 I = 1,IEND  
5065  IF(SUBQL(I).NE.0.0) RSUBQL(I) = SUBQL(I)  
      M = M - 1  
      GO TO 6010  
C=======================================================================  
C     Alter the default values  
C=======================================================================  
5070  IF(N.NE.-2) GO TO 5080  
      DO 5075 I = 1,IEND  
5075  DSUBQL(I) = SUBQL(I)  
      M = M - 1  
      GO TO 6010  
5080  DO 6000 K = 1,NOW  
      IF(JCE.EQ.0.AND.N.NE.NAMEW(K))   GO TO 6000  
      IF(JCE.EQ.1.AND.KKN.NE.KAMEW(K)) GO TO 6000  
      KK = K  
      GO TO 6005  
6000  CONTINUE  
      IF(JCE.EQ.0) WRITE(N6,6006)   N  
      IF(JCE.EQ.1) WRITE(N6,6016) KKN  
6005  DO 6007 I   = 1,MQUAL+2  
      IF(SUBQL(I).LE.0.0) SUBQL(I) = DSUBQL(I)  
6007  SUBQL(I)      = SUBQL(I) * RSUBQL(I)  
C#### WCH, 4/19/93.  DON'T ALLOW ZERO FOR KL.  
C#### WCH, 10/19/95.  ADD WARNING MESSAGE.  
C####      IF(KL.LE.0.OR.KL.GT.NLU)  KL = 1  
Cwch 3/29/02. KL should be first in two prints below. .  
      IF(KL.LE.0.OR.KL.GT.JLAND) THEN  
           IF(JCE.EQ.0) WRITE(N6,6003) KL,N,JLAND  
           IF(JCE.EQ.1) WRITE(N6,6004) KL,KKN,JLAND  
           KL = 1  
           ENDIF  
      KLAND(KK)     = KL  
      BASINS(KK)    = SUBQL(1)  
      GQLEN(KK)     = SUBQL(2)  
C=======================================================================  
C>>>>>>>>>>>>>>>>>>>>>>>>>> Read data group L2 <<<<<<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(IMUL.EQ.0) PLAND(KL,KK) = 1.0  
      IF(IMUL.GT.0) READ(N5,*,ERR=888) CC,(PLAND(I,KK),I=1,N1)  
      TOLAND     = 0.0  
      DO 6008  I = 1,JLAND  
      IF(IMUL.EQ.0.AND.I.NE.KL) PLAND(I,KK) = 0.0  
      TOLAND     = TOLAND + PLAND(I,KK)  
6008  CONTINUE  
C##### WCH, 4/12/93.  RELAX CONSTRAINT ON SUM = 1.00000000000000000000.  
      IF(ABS(TOLAND-1.0).GT.0.001) THEN  
                        WRITE(N6,6300) KK  
                        CALL ERROR(154)  
                        ENDIF  
C=======================================================================  
Cwch, 1/4/01. This has to be an ERROR. In subs QINT and QSHED set  
C     land use subscript to KLAND if N1 = 1. To input intial loads,  
C     need to do the same here.  
C     Change land use subscript accordingly.  
C=======================================================================  
      DO 6009  LL   = 1,N1  
      IF(N1.EQ.1) J = KLAND(KK)  
      IF(N1.GT.1) J = LL  
C#### WCH, 11/15/93  
      DO 6009  I    = 1,NQSS  
C### WCH, 4/12/93.  REMOVE MULTIPLICATION BY PLAND.  DONE IN SUB QINT.  
6009  PSHED(J,I,KK) = SUBQL(I+2)  
6010  CONTINUE  
6020  CONTINUE  
      IF(IMUL.EQ.0.AND.JLAND.GT.1) THEN  
                                   DO 7100  K   = 1,NQS  
                                   DO 7100  J   = 1,JLAND  
                                   KALC(J,K)    = KALC(1,K)  
                                   KWASH(J,K)   = KWASH(1,K)  
                                   KACGUT(J,K)  = KACGUT(1,K)  
                                   LINKUP(J,K)  = LINKUP(1,K)  
C#### WCH, 3/30/95.  I THINK MISTAKE HERE FOR KALC = 0.  
C  PROGRAM USES ONLY QFACT(J,1,K), NEVER A MIDDLE SUBSCRIPT > 1.  
C  THUS, FOR KALC = 0, NEED TO SET QFACT(J,1,K) = QFACT(1,J,K).??  
C  
                                   QFACT(J,1,K) = QFACT(1,1,K)  
                                   QFACT(J,2,K) = QFACT(1,2,K)  
                                   QFACT(J,3,K) = QFACT(1,3,K)  
                                   QFACT(J,4,K) = QFACT(1,4,K)  
                                   QFACT(J,5,K) = QFACT(1,5,K)  
                                   WASHPO(J,K)  = WASHPO(1,K)  
                                   RCOEF(J,K)   = RCOEF(1,K)  
                                   CBFACT(J,K)  = CBFACT(1,K)  
                                   CONCRN(J,K)  = CONCRN(1,K)  
                                   REFF(J,K)    = REFF(1,K)  
7100                               CONTINUE  
                                   ENDIF  
C=======================================================================  
C     Do not write a new page heading if there is less than 55 lines  
C                                 printed on the erosion output page.  
C=======================================================================  
      DO 6200 N = 1,NOW  
      NWPGE     = NWPGE + 1  
      IF(N.GT.1)       GO TO 6240  
      IF(NWPGE.EQ.55)  GO TO 6100  
      IF(IPRN(7).EQ.0) WRITE(N6,6029)  
      GO TO 6040  
C=======================================================================  
C     Write a new page heading.  
C=======================================================================  
6100  IF(IPRN(7).EQ.0) WRITE(N6,6101)  
6040  IF(IPRN(7).EQ.0) WRITE(N6,6102) (ISPACE,LL=1,NQSS)  
      IF(IPRN(7).EQ.0) WRITE(N6,6103) (ISPACE,LL=1,NQSS)  
C### WCH, 4/12/93.  MODIFY PRINT-OUT TO GIVE UNITS.  
      IF(METRIC.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,6104) (ISPACE,LL=1,NQSS)  
      IF(METRIC.EQ.2.AND.IPRN(7).EQ.0) WRITE(N6,6114) (ISPACE,LL=1,NQSS)  
C=======================================================================  
C     Write the descriptor line for GUTTER length depending  
C                                    on the value of METRIC.  
C=======================================================================  
      IF(IPRN(7).EQ.0) THEN  
             IF(METRIC.EQ.1) WRITE(N6,6105) (PNAME(LL),LL=1,NQSS)  
             IF(METRIC.EQ.2) WRITE(N6,6106) (PNAME(LL),LL=1,NQSS)  
             WRITE(N6,6109) (ISPACE,JJ=1,NQSS)  
             ENDIF  
      NWPGE = 10  
6240  KOUT  = KLAND(N)  
Cwch, 1/4/01.  Here, must use KOUT as subscript for PSHED.  
      IF(JCE.EQ.0.AND.IPRN(7).EQ.0) WRITE(N6,6250)  
     1       N,NAMEW(N),LNAME(KOUT),KLAND(N),GQLEN(N),BASINS(N),  
     2                                  (PSHED(KOUT,K,N),K=1,NQSS)  
      IF(JCE.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,6251)  
     1       N,KAMEW(N),LNAME(KOUT),KLAND(N),GQLEN(N),BASINS(N),  
     2                                  (PSHED(KOUT,K,N),K=1,NQSS)  
C=======================================================================  
C     Sum the GUTTER lengths and the number of catchbasins for printout.  
C=======================================================================  
      SMCTCH    = SMCTCH   + BASINS(N)  
      GUTSM     = GUTSM    + GQLEN(N)  
      GQLEN(N)  = GQLEN(N) * CMET(10,METRIC)  
Cwch, 1/4/01.  Here again must convert land use subscript.  
      DO 6190 JJ = 1,N1  
	IF(N1.EQ.1) J = KLAND(N)  
	IF(N1.GT.1) J = JJ  
      DO 6190 K  = 1,NQSS  
C##### WCH, 4/12/93.  CONVERT TO TOTAL LOAD.  
      IF(METRIC.EQ.1)  
     1 RNQS(K) = RNQS(K)+PSHED(J,K,N)*WAREA(N)/43560.*PLAND(J,N)  
      IF(METRIC.EQ.2)  
     1 RNQS(K) = RNQS(K)+PSHED(J,K,N)*WAREA(N)/(43560.*2.471)*PLAND(J,N)  
6190  CONTINUE  
6200  CONTINUE  
C=======================================================================  
C     Write the gutter length and catchbasin sums.  
C=======================================================================  
C### WCH, 4/12/93. ALTER PRINT-OUT FOR METRIC.  
      IF(METRIC.EQ.1.AND.IPRN(7).EQ.0) WRITE(N6,6270)  
     1 GUTSM,SMCTCH,(RNQS(I),I=1,NQSS)  
      IF(METRIC.EQ.2.AND.IPRN(7).EQ.0) WRITE(N6,6271)  
     1 GUTSM,SMCTCH,(RNQS(I),I=1,NQSS)  
C#######################################################################  
C  WCH, 4/13/93.  PRINT OUT LAND USE FRACTIONS FROM GROUP L2  
C=======================================================================  
C     Do not write a new page heading if there are fewer than 45 lines  
C                         printed on the last subcatchment output page.  
C=======================================================================  
      IF(IPRN(7).EQ.0.AND.IMUL.GT.0) THEN  
           IF(NWPGE.GT.45) NWPGE = 55  
           DO 6400 N = 1,NOW  
           NWPGE     = NWPGE + 1  
           IF(N.GT.1.AND.NWPGE.LE.55)  GO TO 6340  
C=======================================================================  
C     Write a new page heading.  
C=======================================================================  
           IF(NWPGE.LT.45) WRITE(N6,6500)  
           IF(NWPGE.GE.45) WRITE(N6,6501)  
           WRITE(N6,6502)  
           WRITE(N6,6503) (LL,LL=1,N1)  
           WRITE(N6,6504) (LNAME(LL),LL=1,N1)  
           NWPGE = 10  
6340       KOUT  = KLAND(N)  
           IF(JCE.EQ.0) WRITE(N6,6505) N,NAMEW(N),(PLAND(LL,N),LL=1,N1)  
           IF(JCE.EQ.1) WRITE(N6,6506) N,KAMEW(N),(PLAND(LL,N),LL=1,N1)  
6400       CONTINUE  
C     END LOOP FOR L2 FRACTIONS PRINT  
           ENDIF  
C=======================================================================  
C     INITIALIZE WATERSHED POLLUTION LOADS.....  
C=======================================================================  
      CALL QINT  
      RETURN  
  888 CALL IERROR  
C=======================================================================  
 1180 FORMAT(/,1H1,/,  
     1' ###################################################',/,  
     2' #              Quality Simulation                 #',/,  
     3' ###################################################',/,  
     4' #      General Quality Control Data Groups        #',/,  
     5' ###################################################',//,  
     62X,'Description',28X,'Variable',7X,'Value',/,2X,  
     7'-----------',28X,'--------',7X,'-----',//,  
     82X,'Number of quality constituents.....    NQS.......',I10,  
     9//,2X,'Number of land uses................  JLAND.......',  
     9I10,//,2X,'Standard catchbasin volume.........  CBVOL.......',  
     1F10.2,' cubic feet',/)  
 1190 FORMAT(/,1H1,/,  
     1' ###################################################',/,  
     2' #              Quality Simulation                 #',/,  
     3' ###################################################',/,  
     4' #      General Quality Control Data Groups        #',/,  
     5' ###################################################',//,  
     62X,'Description',28X,'Variable',7X,'Value',/,2X,  
     7'-----------',28X,'--------',7X,'-----',//,  
     82X,'Number of quality constituents.....    NQS.......',I10,  
     9//,2X,'Number of land uses................  JLAND.......',  
     9I10,//,2X,'Standard catchbasin volume.........  CBVOL.......',  
     1F10.2,' cubic meters',/)  
 1590 FORMAT(2X,'Erosion is not simulated.........    IROS........',  
     1       I10,/)  
 1600 FORMAT(2X,'Erosion is simulated using the ',/,  
     1       2X,'Universal soil loss equation.......  IROS........',  
     2       I10,/)  
 1610 FORMAT(2X,'Erosion added to constituent....... IROSAD.......',  
     1  I10,/)  
 1615 FORMAT(2X,'HIGHEST AVERAGE 30 MINUTE RAINFALL',/,2X,  
     1           'INTENSITY DURING STORM OR YEAR..... RAINIT.......',  
     2 F10.3,' IN/HR',/)  
 1616 FORMAT(2X,'HIGHEST AVERAGE 30 MINUTE RAINFALL',/,2X,  
     1           'INTENSITY DURING STORM OR YEAR..... RAINIT.......',  
     2 F10.3,' MM/HR',/)  
 1620 FORMAT(2X,'DRY DAYS PRIOR TO START OF STORM... DRYDAY.......',  
     1  F10.2,' DAYS',/)  
 1623 FORMAT(/,' ====> ERROR  DRYBSN HAS A',  
     1      'VALUE OF ',F10.3,' AND HAS BEEN CHANGED TO 1.0',/)  
 1625 FORMAT(2X,'DRY DAYS REQUIRED TO RECHARGE',/,2X,  
     1           'CATCHBASIN CONCENTRATION TO  ',/,2X,  
     2           'INITIAL VALUES..................... DRYBSN.......',  
     3 F10.2,' DAYS',/)  
 1630 FORMAT(2X,'DUST AND DIRT',/,  
     1 2X,'STREET SWEEPING EFFICIENCY......... REFFDD.......',  
     2 F10.3,/)  
 1635 FORMAT(2X,'DAY OF YEAR ON WHICH STREET ',/,2X,  
     1           'SWEEPING BEGINS.................... KLNBGN.......',  
     2 I10,//,2X,'DAY OF YEAR ON WHICH STREET',/,2X,  
     3           'SWEEPING ENDS...................... KLNEND.......',  
     4 I10,/)  
 1639 FORMAT(/,  
     1' ###########################################',/,  
     2' #     Land use data on data group J2      #',/,  
     3' ###########################################',/)  
 1640 FORMAT(1X,'                                                 ',  
     1'            LIMITING                      CLEANING  AVAIL.',  
     2'    DAYS SINCE',/,  
     3'                                                              ',  
     4'BUILDUP    BUILDUP  BUILDUP   INTERVAL  FACTOR       LAST',/,  
     5'LAND USE   BUILDUP EQUATION TYPE   FUNCTIONAL DEPENDENCE OF',  
     6'   QUANTITY   POWER    COEFF.    IN DAYS   FRACTION   SWEEPING',  
     7/,'(LNAME)            (METHOD)        BUILDUP PARAMETER(JACGUT)',  
     8'  (DDLIM)    (DDPOW)  (DDFACT)  (CLFREQ)  (AVSWP)     (DSLCL)',/,  
     9'--------   ---------------------   -------------------------',  
     9'  --------   -------  --------  --------  -------    ---------')  
 1641 FORMAT(1X,A8,1X,A20,5X,A16,8X,1PE11.3,5(0PF10.3))  
 1660 FORMAT(//,1H1,/  
     1' ##############################################',/,  
     2' #     Constituent data on data group J3      #',/,  
     3' ##############################################',/)  
 2001 FORMAT(/,26X,99(6X,A8,6X))  
 2002 FORMAT(26X,99(5X,A1,'--------',6X))  
 2003 FORMAT(1X,'Constituent units........',99(6X,A8,6X))  
 2004 FORMAT(1X,'Type of units............',99(8X,I4,8X))  
 2006 FORMAT(1X,'KALC.....................',99(8X,I4,8X))  
 2007 FORMAT(1X,'KWASH....................',99(8X,I4,8X))  
 2008 FORMAT(1X,'KACGUT...................',99(8X,I4,8X))  
 2009 FORMAT(1X,'LINKUP...................',99(8X,I4,8X))  
C#### WCH 4/13/93.  WCH MONKEYED WITH THESE FORMATS.  
Cwch, 3/29/02. Change 4X,F12.3 to 1X,F15.3  
 2205 FORMAT(1X,'Type of buildup calc.....',99(2X,A16,2X))  
 2206 FORMAT(1X,'Type of washoff calc.....',99A20)  
 2207 FORMAT(1X,'Dependence of buildup....',99(2X,A16,2X))  
 2208 FORMAT(1X,'Linkage to snowmelt......',99(2X,A16,2X))  
 2209 FORMAT(1X,'Buildup param 1 (QFACT1).',99(1X,F15.3,4X))  
 2500 FORMAT(1X,'Buildup param 2 (QFACT2).',99(1X,F15.3,4X))  
 2501 FORMAT(1X,'Buildup param 3 (QFACT3).',99(1X,F15.3,4X))  
 2502 FORMAT(1X,'Buildup param 4 (QFACT4).',99(1X,F15.3,4X))  
 2503 FORMAT(1X,'Buildup param 5 (QFACT5).',99(1X,F15.3,4X))  
 2504 FORMAT(1X,'Washoff power (WASHPO)...',99(1X,F15.3,4X))  
 2505 FORMAT(1X,'Washoff coef. (RCOEF)....',99(1X,F15.3,4X))  
 2506 FORMAT(1X,'Init catchb conc (CBFACT)',99(1X,F15.3,4X))  
 2507 FORMAT(1X,'Precip. conc. (CONCRN)...',99(1X,F15.3,4X))  
 2508 FORMAT(1X,'Street sweep effic (REFF)',99(1X,F15.3,4X))  
 2509 FORMAT(1X,'Land use number..........',99(4X,I12,4X))  
Cwch, 12/20/00  
 2510 FORMAT(1X,'Remove fraction (REMOVE).',99(1X,F15.3,4X))  
 2511 FORMAT(1X,'1st order QDECAY, 1/day..',99(1X,F15.3,4X))  
 3010 FORMAT(/,  
     1       ' *************************************************',/,  
     2       ' * Constant Groundwater Quality Concentration(s) *',/,  
     3       ' *************************************************',//,  
     4       (2X,A10,' has a concentration of..',F10.4,' ',A10,/))  
 3015 FORMAT(/,  
     1       ' *************************************************',/,  
     2       ' * Constant Infil/Inflw Quality Concentration(s) *',/,  
     3       ' *************************************************',//,  
     4       (2X,A10,' has a concentration of..',F10.4,' ',A10,/))  
 3076 FORMAT(/,1H1,/,  
     1' *******************************************',/,  
     2' * Fractions for contributions from other  *',/,  
     3' *     constituents on data group J4       *',/,  
     4' *******************************************',//)  
 3077 FORMAT(15X,' CONSTITUENT FROM WHICH THE FRACTION IS COMPUTED',  
     1  /,15X,' -----------------------------------------------')  
Cwch, 1/18/01.  These should work, but don't.  Try another route.  
C 3078 FORMAT(/,15X,'*',(A8,1X,'*'),/)  
C 3090 FORMAT(1X,'Fraction will *',(9X,A1))  
C 3091 FORMAT(1X,' be added to  *',(9X,A1))  
C 3092 FORMAT(1X,'  Constituent *',(9X,A1))  
C 3093 FORMAT(4X,A8,3X,'*',(1X,F7.3,1X,'*'))  
C 3094 FORMAT(15X,'*',(A4,'-----',A1))  
 3078 FORMAT(/,15X,'*',99(A8,1X,'*'))  
 3090 FORMAT(1X,'Fraction will *',99(9X,A1))  
 3091 FORMAT(1X,' be added to  *',99(9X,A1))  
 3092 FORMAT(1X,'  Constituent *',99(9X,A1))  
 3093 FORMAT(4X,A8,3X,'*',99(1X,F7.3,1X,'*'))  
 3094 FORMAT(15X,'*',99(A4,'-----',A1))  
C  
 4050 FORMAT(/,1H1,T20,'*******************************',/,  
     1           T20,'*      EROSION INPUT DATA     *',/,  
     2           T20,'*        DATA GROUP K1        *',/,  
     3           T20,'*******************************',//,  
     4           T11,'SUBCAT',T20,'EROSION',T30,'  FLOW',T45,'  SOIL',  
     5           T60,'CROPPING',T75,'CONTROL',T90,' SLOPE',T105,  
     6               'PARTIAL',/,  
     7           T10, 'NUMBER',T20,'AREA-ACRES',T30,' LENGTH-FT',T45,  
     8               ' FACTOR',T60,' FACTOR',T75,' FACTOR',T90,  
     9               'LENGTH',T105,' USLE *',/,T90,'GRAD-RATIO',/,  
     9            T10,2('--------',2X),6('----------',5X))  
 4051 FORMAT(/,1H1,T20,'*******************************',/,  
     1           T20,'*      EROSION INPUT DATA     *',/,  
     2           T20,'*        DATA GROUP K1        *',/,  
     3           T20,'*******************************',//,  
     4           T11,'SUBCAT',T20,'EROSION',T30,'  FLOW',T45,'  SOIL',  
     5           T60,'CROPPING',T75,'CONTROL',T90,' SLOPE',T105,  
     6               'PARTIAL',/,  
     7           T10, 'NUMBER',T20,' AREA-HA  ',T30,' LENGTH-M',T45,  
     8               ' FACTOR',T60,' FACTOR',T75,' FACTOR',T90,  
     9               'LENGTH',T105,' USLE *',/,T90,'GRAD-RATIO',/,  
     9            T10,2('--------',2X),6('----------',5X))  
 4070 FORMAT(9X,I6,3X,2F10.1,5X,4(F10.3,5X),1PE10.2)  
 4075 FORMAT(/,' ===> PARTIAL USLE = ERODAR * SOILF * CROPMF * CONTPF *  
     1SLGR * (9.072E8 MG/TON)')  
C#### WCH, 10/19/95.  THREE NEW FORMAT STATEMENTS.  
 6001 FORMAT(' ==> ERROR  YOU INDICATE QUALITY SIMULATION (KWALTY = 1)  
     2BUT JUMP RIGHT TO',/,' M1 LINES. ADD QUALITY DATA OR SET KWALTY =  
     30 ON LINE B1.  RUN STOPPED.')  
 6003 FORMAT(' ==> WARNING  LAND USE NUMBER = ',I2,' ON L1 SUBCATCHMEN  
     1T NO. ',I10,/,' KL VALUE MUST BE IN RANGE 1 -',I2,' AND HAS BEEN S  
     2ET = 1.')  
 6004 FORMAT(' ==> WARNING  LAND USE NUMBER = ',I2,' ON L1 SUBCATCHMEN  
     1T NO. ',A10,/,' KL VALUE MUST BE IN RANGE 1 -',I2,' AND HAS BEEN S  
     2ET = 1.')  
 6006 FORMAT(' ===> ERROR   NO MATCH WAS FOUND FOR',  
     1       ' SUBCATCHMENT ',I10,' ON DATA GROUP L1',/,  
     2           '                      WITH ANY SUBCATCHMENT ',  
     3       'NUMBERS ON DATA GROUP H1.')  
 6016 FORMAT(' ===> ERROR   NO MATCH WAS FOUND FOR',  
     1       ' SUBCATCHMENT ',A10,' ON DATA GROUP L1',/,  
     2           '                      WITH ANY SUBCATCHMENT ',  
     3       'NUMBERS ON DATA GROUP H1.')  
C#### WCH, 4/13/93  
 6017 FORMAT(' $$$$$ WARNING  FOR LAND USE',I2,' AND POLLUTANT',I3,  
     1 ' WASHPO =',F8.2,/,' VALUES GREATER THAN APPROX. 25 LIKELY TO CAU  
     2SE NUMERICAL PROBLEMS.',/,' E.G., EXTREMELY LARGE OR SMALL WASHOFF  
     3 VALUES.')  
C#### WCH, 9/29/93.  
 6018 FORMAT (' $$$$ WARNING JLAND VALUE ON LINE J1 =',I2,' AND IS LESS  
     1 THAN NUMBER OF J2 LINES.',/,' JLAND INCREASED TO',I3,' AND CONTIN  
     2UE READING THE J2 LINES IN HOPES OF INPUTTING ALL LAND USE DATA.')  
Cwch, 2/10/01.  
 6021 FORMAT(' **ERROR** NO MATCH FOR NAME OF CHANNEL/PIPE ',I10,  
     1 ' ON J7 LINE. VALUES FOR GREMOVE ON THIS LINE NOT USED.')  
 6022 FORMAT(' **ERROR** NO MATCH FOR NAME OF CHANNEL/PIPE ',A10,  
     1 ' ON J7 LINE. VALUES FOR GREMOVE ON THIS LINE NOT USED.')  
 6023 FORMAT(' $$WARNING$$ MORE J7 LINES (',I4,') THAN NUMBER OF CHANNEL  
     1/PIPES (',I4,')',/,  
     2' BUT CONTINUE READING J7 LINES.')  
 6025 FORMAT(//,  
     1 ' ************************************************',/,  
	2 ' * REMOVAL FRACTIONS FOR SELECTED CHANNEL/PIPES *',/,  
	3 ' * FROM J7 LINES                                *',/,  
	4 ' ************************************************',//,  
	5 '   CHANNEL/   CONSTITUENT',/,  
	6 '      PIPE ',99(A10))  
 6026 FORMAT(' ----------',99(2X,2A4))  
 6027 FORMAT(1X,I10,99F10.3)  
 6028 FORMAT(1X,A10,99F10.3)  
C  
 6029 FORMAT(//,  
     1' *****************************************************',/,  
     2' *     Subcatchment surface quality on data group L1 *',/,  
     3' *****************************************************',/)  
 6101 FORMAT(/,1H1,/,  
     1' *****************************************************',/,  
     2' *     Subcatchment surface quality on data group L1 *',/,  
     3' *****************************************************',/)  
C#### WCH, 4/12/93.  ALTER FORMATS SLIGHTLY FOR METRIC LOAD UNITS  
C                    AND WIDER SUBCAT. NO. FIELD.  
cim 4/5/99 change 10( to 99(  
 6102 FORMAT(//,31X,'    Total   Number',99(A1,'  Input '),/)  
 6103 FORMAT(26X,'Land',1X,'   Gutter     of  ',99(A1,' Loading'))  
 6104 FORMAT(15X,'   Land     Use    Length   Catch-',  
     1       99(A1,' load/ac'))  
 6114 FORMAT(15X,'   Land     Use    Length   Catch-',  
     1       99(A1,' load/ha'))  
 6105 FORMAT(13X,'No.  Usage    No.   10**2ft   Basins  ',  
     1       99(1X,A8))  
 6106 FORMAT(13X,'No.  Usage    No.      Km     Basins  ',  
     1       99(1X,A8))  
6109  FORMAT(9X,'------',' --------','  ----','   --------',  
     1          ' --------',99(A1,' -------'))  
 6250 FORMAT(1X,I4,1X,I10,1X,A8,1X,I2,4X,2F9.2,99(1X,1PE8.1))  
 6251 FORMAT(1X,I4,1X,A10,1X,A8,1X,I2,4X,2F9.2,99(1X,1PE8.1))  
 6270 FORMAT(4X,'Totals (Loads in lb or other)',F8.2,F9.2,99(1X,1PE8.1))  
 6271 FORMAT(4X,'Totals (Loads in kg or other)',F8.2,F9.2,99(1X,1PE8.1))  
 6300 FORMAT(' ===> Problem with subcatchment # ',I6,' L2 line.')  
 6500 FORMAT(//,  
     1' ********************************************************',/,  
     2' *   Subcatchment land use fractions on data group L2   *',/,  
     3' ********************************************************',/)  
 6501 FORMAT(/,1H1,/,  
     1' ********************************************************',/,  
     2' *   Subcatchment land use fractions on data group L2   *',/,  
     3' ********************************************************',/)  
 6502 FORMAT(14X,'FRACTION FOR LAND USE NUMBER:')  
CIM FIX THREEE STATMENT FOR NUMEROUS LAND USES  
 6503 FORMAT(5X,'CATCHMENT  ',I6,99I10)  
 6504 FORMAT(1X,'NO.      NAME ',99(2X,A8))  
 6505 FORMAT(I4,1X,I10,99F10.3)  
 6506 FORMAT(I4,1X,A10,99F10.3)  
 8000 FORMAT(1H1)  
C=======================================================================  
      END  
ECHO is off.
REM File: QUALSOLN.FOR  
ECHO is off.
	SUBROUTINE QUALSOLN(IP,QAVG,CQAVG,DVDT,VOL,DECAYY,ERODE,  
     1 DEPOS,REMOVE,XLDECAY)  
C=======================================================================  
C	Routine to evaluate analytical solution to Transport pollutant  
C       routing using complete mixing solutions.    
C     Called from Sub. QUAL.  Replaces code at end of QUAL.  
C     Created 7/6/01 by Wayne Huber in order to provide linked DO-BOD-  
C       NOD simulation.   
C     Follow procedure similar to that used in Sub. SHEDQUAL.  
C     Correct for non-calc when there is zero flow and thus, zero  
C       DENOM.  WCH, 8/6/03.  
C=======================================================================  
C	CAUTION  
C     THERE MAY BE SOME IDENTICAL NAMES USED IN ARGUMENT LIST AS IN   
C     TRANSPORT COMMON.  BE VERY CAREFUL IF LATER DECIDE TO INCLUDE    
C     VARIOUS LABELED COMMONS.  
C     Caution. Most Transport Common blocks not accessed.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
	INCLUDE 'TRANWQ.INC'  
	INCLUDE 'HUGO.INC'  
C=======================================================================  
C  
C     IP      = Constituent number.  
C     M       = Element number (should be channel/pipe or element  
C               with storage). (HUGO.INC)  
C     QAVG    = Average outflow from element, cfs.  
C               "Average"  means average of beginning and end of time  
C               step.  
C     CQAVG   = Average incoming load to element, cfs * mg/L.  
C     DVDT    = dV/dt = change in volume per time step, cfs.  
C	VOL     = Average volume of water in element, ft3.  
C     DECAYY  = First-order decay coefficient, 1/sec.  
C     DT      = Time step, sec. (HUGO.INC)  
C     ERODE   = Load from erosion, cfs*mg/L.  
C     DEPOS	= Deposition, cfs*mg/L.  
C	REMOVE  = BMP removal fraction, affecting all loads.  
C   CPOL2 values are in Common in HUGO.INC  
C     CPOL2(M,1,IP)  = Downstream concentration at beginning of   
C               time step, mg/L.  
C     CPOL2(M,2,IP)  = Downstream concentration at end of time   
C               step, mg/L.  
C  
C     XLREMOV = mg/L*ft3 removed by removal fraction.  
C     XLDECAY = mg/L*ft3 removed by first-order decay.  
C     XLSETL  = mg/L*ft3 removed by settling.  
C=======================================================================  
C     The following equation uses average quantities over the  
C     time step to avoid stability problems.  
C  
C     The equation integrated is:  
C  
C     V*dC/dt = (Qin*Cin + Load)*(1 - Remove) - Q*C - C*dV/dt - Vs*As   
C         - K*C*V + [possible linkages among CBOD, NOD, NO3-N & DO]  
C  
C     (See User's Manual, Appendix IX.)  
C  
C     C       = outflow concentration, mg/L  
C     Vs      = settling velocity, ft/s  
C     As      = surface area, ft2  
C     Q       = QAVG = outflow rate, cfs  
C     Qin*Cin = CQAVG = incoming load, cfs*mg/L  
C     Load    = other loads, cfs*mg/L  
C     K       = DECAYY, 1/s  
C  
C     Note that evaporation does not remove mass.  Outflow by evaporation  
C     is accounted for in (1/V)dV/dt term.  Hence, evaporation can increase  
C     concentrations, especially when outflow (and volume or depth) are  
C     very small.   
C     No evaporation in Transport Block, July 2001.    
C  
C     Use average values for the time step in order to integrate   
C     equation with constant coefficients.    
C  
C     C = Cnew [1 - EXP(-ARG)] + Cold EXP(-ARG) + [Possible additional  
C         terms reflecting linked CBOD, NOD, NO3-N, DO]  
C  
C     where   
C     Cnew  = TOP/DENOM  
C     ARG   = DENOM*DT,  
C     TOP   = [Qin*Cin + Load]*(1-REMOVE)/V  
C     DENOM = [Q/V + (1/V)dV/dt + Vs/D + K]  
C     D     = Average depth, ft  
C     Cold  = C at last time step.  
C     Cnew, Cold and C have units of mg/ft3  
C=======================================================================  
C     Compute current values of channel parameters for routing.  
C     For linked DO simulation, need surface area, average depth,  
C     and velocity.  
C=======================================================================  
C     DENOM can be negative when there is evaporation.    
C     But no evaporation in Transport, as of July 2001.  Hence, should  
C     not have negative DENOM.   
C=======================================================================  
C     This subroutine is only called when VOL > 0.0.  Hence, there are   
C     no checks for zero divide with VOL.   
C=======================================================================  
      DENOM = 0.0  
	TOP   = 0.0  
	DENOM = (QAVG + DVDT)/VOL  
C=======================================================================  
C     Determine several parameters used by constituents during  
C     evaluation for IP = 1.  
C=======================================================================  
      IF(IP.EQ.1) CALL QUALPARM(ASURF,ASSETL,DBAR,DBARSETL,VELL,CS,WAVG)  
      IF(NWQ.EQ.1.AND.IP.LE.4) THEN  
         SELECT CASE (IP)  
	      CASE (1)   CBOD  
C=======================================================================  
C     Here, simulate ultimate, carbonaceous BOD = CBOD.  
C     Use same solution form as for other constituents -- no "upstream"  
C     linkages.  
C=======================================================================  
            DECAYY  = DEKD(M)*THETA(1)**(TWATER(M)-20.0)  
	      DECAYYD = DECAYY  
            DENOM   = DENOM + DECAYY  
	      IF(DBARSETL.GT.0.0)   
     1	       DENOM = DENOM + (1.0-FDIS(1))*VSETL(1)/DBARSETL  
	      IF(DENOM.LT.0.0) DENOM = 0.0  
	      DENBOD = DENOM  
	      TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL  
            TOPBOD = TOP  
            CASE (2)   NBOD  
C=======================================================================  
C     Here, simulate nitrogenous oxygen demand = NOD.  
C     This may be simulated as TKN or NH3-N, but will be called NOD  
C     in output.   
C     Use same solution form as for other constituents -- no "upstream"   
C     linkages.  
C=======================================================================  
            DECAYY  = DEKN(M)*THETA(2)**(TWATER(M)-20.0)  
	      DECAYYN = DECAYY  
            DENOM   = DENOM + DECAYY  
	      IF(DBARSETL.GT.0.0) DENOM = DENOM +   
     1          (1.0-FDIS(2))*VSETL(2)/DBARSETL  
	      IF(DENOM.LT.0.0) DENOM = 0.0  
	      DENNOD = DENOM  
	      TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL  
            TOPNOD = TOP  
            CASE (3)   NO3-N  
C=======================================================================  
C     Here, simulate NO3-N.  
C     This is linked to decay of NOD, so must evaluate fully linked  
C     integral solution.  
C=======================================================================  
            DENOM  = DENOM + DECAYY  
	      IF(DBARSETL.GT.0.0) DENOM = DENOM +   
     1          (1.0-FDIS(3))*VSETL(3)/DBARSETL  
	      IF(DENOM.LT.0.0) DENOM = 0.0  
	      TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL  
	      CASE (4)   DO  
C=======================================================================  
C     Here, simulate dissolve oxygen deficit DEFICIT = Csat - DO.  
C     This is linked to decay of BOD and NOD, so must evaluate fully  
C     linked integral solution.  
C     Calculate the reaeration coefficient = decay coef. for DEFICIT.  
C     Units of TOP are mg/L * ft3/s.  Units of SOD are mg/ft2-sec.  
C     For same units for settling load, divide by average depth  
C     (ft) and divide by 28.3 L/ft3.   
C=======================================================================  
           CALL REAERATE(DECAY2,DBAR,VELL,WIND(M),TAIR(M),TWATER(M),REA,  
     1THETA(3),KWIND,KOVAR,GNUW,GNUA,RHOW,RHOA,DMOLEC,XLAMBDA,ZEE,CAPPA,  
     2 GAMMAZ,UTSTAR,PRESURE,UCSTAR,CAPPA3,CDRAG,IYZ,DELG1,ZZERO,USTAR,  
     3 CAYEL,DECAY2W,SALINITY,G1,ZAA,N6,DECAY2F)  
	      DECAYY = DECAY2  
	      DENOM  = DENOM + DECAY2  
	      SEDMD  = 0.0  
	      IF(DBARSETL.GT.0.0) SEDMD = SOD(M)/DBARSETL/28.3  
C=======================================================================  
C     Do not include ERODE and DEPOS for DEFICIT, for now.  
C     Do not include REMOVE for DEFICIT.  
C     Assume upstream and incoming deficit load is QAVG*CS - CQAVG  
C     where CQAVG is "load" of incoming DO.  
C=======================================================================  
            DEFLOAD = QAVG*CS - CQAVG  
	      IF(DEFLOAD.LT.0.0) DEFLOAD = 0.0  
	      TOP = DEFLOAD/VOL + SEDMD  
	      END SELECT  
C=======================================================================  
	   ELSE  
C=======================================================================  
C     Here for "ordinary" constituent.  
C=======================================================================  
         DENOM = DENOM + DECAYY  
	   IF(DBARSETL.GT.0.0) DENOM = DENOM +   
     1          (1.0-FDIS(IP))*VSETL(IP)/DBARSETL  
	   IF(DENOM.LT.0.0) DENOM = 0.0  
	   TOP = (CQAVG+ERODE-DEPOS)*(1.0-REMOVE)/VOL  
         ENDIF  
C=======================================================================  
C     EXXP => 0 ==> Big ARG, big Qin/V, concentration => Cin.  
C     EXXP >  0 ==> Smaller ARG, smaller Qin/V, and  
C      concentration between Cin and Co.    
C     EXXP => 1 ==> ARG => 0, Qin/V => 0, concentration => Co.  
C     EXXP > 1.0 for negative DENOM (increase concentration because  
C      of evaporation).  But no evap in Transport yet.  
C=======================================================================  
                      EXXP = 0.0  
				    ARG  = DENOM*DT  
	IF(ARG.EQ.0.0)  EXPP = 1.0  
      IF(ARG.LT.10.0.AND.ARG.GT.0.0) EXXP = EXP(-ARG)  
C=======================================================================  
C     For all cases except DO, first part of solution is the same.  
C=======================================================================  
      C2NEXT = 0.0  
	CZERO  = CPOL2(M,1,IP)  
	IF(NWQ.EQ.1.AND.IP.EQ.4) CZERO = CS - CPOL2(M,1,4)  
	IF(CZERO.LT.0.0) CZERO  = 0.0  
	IF(DENOM.NE.0.0) C2NEXT = TOP/DENOM*(1.0-EXXP) + CZERO*EXXP  
Cwch, 8/6/03  
      IF(DENOM.EQ.0.0) C2NEXT = CZERO  
C=======================================================================  
      IF(NWQ.EQ.1.AND.IP.LE.4) THEN  
	   SELECT CASE (IP)  
	     CASE (1)   CBOD  
	     EXPBOD = EXXP  
	     CPOL2(M,2,1) = C2NEXT  
	     CASE (2)   NBOD  
	     EXPNOD = EXXP  
	     CPOL2(M,2,2) = C2NEXT  
	     CASE (3)   NO3-N  
C=======================================================================  
C     Add linkage to NOD decay to NO3-N.  
C=======================================================================  
           PART2 = 0.0  
	     PART3 = 0.0  
	     IF(DENOM.NE.0.0.AND.DENNOD.NE.0.0) THEN  
		    PART2 = DECAYYN*TOPNOD/DENOM/DENNOD*(1.0 - EXXP)  
	        IF(ABS(DENOM-DENNOD).GT.0.0001) THEN  
	           PART3 = DECAYYN/(DENOM-DENNOD)*  
     1     	   (CPOL2(M,1,2)-TOPNOD/DENNOD)*(EXPNOD-EXXP)  
	           ELSE  
C=======================================================================  
C     Use solution for lim->(DENOM->DENNOD)  
C=======================================================================  
                 PART3 = DECAYYN*(CPOL2(M,1,2)-TOPNOD/DENNOD)*(-DT*EXXP)  
	           ENDIF  
              ENDIF  
	     CPOL2(M,2,3) = C2NEXT + PART2 + PART3  
           CASE (4)   DO	  
C=======================================================================  
C     Add linkage to NOD and BOD decay to DEFICIT.  First, BOD.  
C=======================================================================  
           PART4 = 0.0  
	     PART5 = 0.0  
	     IF(DENOM.NE.0.0.AND.DENBOD.NE.0.0) THEN  
		    PART4 = DECAYYD*TOPBOD/DENOM/DENBOD*(1.0 - EXXP)  
	        IF(ABS(DENOM-DENBOD).GT.0.0001) THEN  
	           PART5 = DECAYYD/(DENOM-DENBOD)*  
     1              (CPOL2(M,1,1)-TOPBOD/DENBOD)*(EXPBOD-EXXP)  
	           ELSE  
C=======================================================================  
C     Use solution for lim->(DENOM->DENBOD)  
C=======================================================================  
                 PART5 = DECAYYD*(CPOL2(M,1,1)-TOPBOD/DENBOD)*(-DT*EXXP)  
	           ENDIF  
              ENDIF  
C=======================================================================  
C     Similarly for NOD, but need to multiply by   
C     stoichiometric constant, TKN to NO3-N, 64/14 = 4.57.  
C=======================================================================  
           PART6 = 0.0  
	     PART7 = 0.0  
	     IF(DENOM.NE.0.0.AND.DENNOD.NE.0.0) THEN  
		    PART6 = DECAYYN*TOPNOD/DENOM/DENNOD*(1.0 - EXXP)  
	        IF(ABS(DENOM-DENNOD).GT.0.0001) THEN  
	           PART7 = DECAYYN/(DENOM-DENNOD)*  
     1              (CPOL2(M,1,2)-TOPNOD/DENNOD)*(EXPNOD-EXXP)  
	           ELSE  
C=======================================================================  
C     Use solution for lim->(DENOM->DENNOD)  
C=======================================================================  
                 PART7 = DECAYYN*(CPOL2(M,1,2)-TOPNOD/DENNOD)*(-DT*EXXP)  
	           ENDIF  
              ENDIF  
	     CPOL2(M,2,4) = CS - (C2NEXT + PART4 + PART5   
     1                    + 4.57*(PART6 + PART7))  
           IF(CPOL2(M,2,4).LT.0.0) CPOL2(M,2,4) = 0.0  
           END SELECT  
C=======================================================================  
	   ELSE  
C=======================================================================  
C     For "ordinary" pollutants, just use C2NEXT previously computed.   
C=======================================================================  
	   CPOL2(M,2,IP) = C2NEXT  
	   ENDIF  
C=======================================================================  
C     For continuity, try to keep track of losses (mg/L * ft3/s)*sec =  
C     mg/L * ft3.  Processes include:  
C       -removal fraction (XLREMOV)  
C       -settling (XLSETL)  
C       -decay (XLDECAY) -- sum in Sub. QUAL  
C       -NOD decay to NO3-N (XLNO3SRC)  
C       -reaeration (XLREAER)  
C       -sediment oxygen demand (XLSEDOD)  
C       -For DO: deficit source from CBOD (XLBOD2DO)  
C                deficit source from NOD  (XLNOD2DO)  
C=======================================================================  
      XLREMOV(IP) = XLREMOV(IP) + REMOVE*(CQAVG + ERODE - DEPOS)*DT	  
	CAVG        = (CPOL2(M,1,IP)+CPOL2(M,2,IP))/2.0  
	XLSETL(IP)  = XLSETL(IP) + ASSETL*(1-FDIS(IP))*VSETL(IP)*CAVG*DT	  
      IF(NWQ.EQ.1.AND.(IP.EQ.3.OR.IP.EQ.4)) THEN  
	   SELECT CASE (IP)  
	     CASE (3)   NO3-N  
C=======================================================================  
C     For NO3-N, keep track of mass added by NOD decay.  
C=======================================================================  
           XLNO3SRC = XLNO3SRC   
     1       + DECAYYN*VOL*DT*(CPOL2(M,1,2)+CPOL2(M,2,2))/2.0  
           XLDECAY  = DECAYY*VOL*CAVG*DT  
	     CASE (4)   DO  
C=======================================================================  
C     For DO continuity check, calculate mass of DO from reaeration by  
C     knowing deficits.  Use current Cs for old and current time step.   
C     Also need deficit source from BOD, NOD, and sediment OD.   
C=======================================================================  
	                        DEFICIT = CS-CAVG  
	     IF(DEFICIT.LT.0.0) DEFICIT = 0.0  
	     XLREAER  = XLREAER + DECAY2*VOL*DEFICIT*DT  
	     XLSEDOD  = XLSEDOD + VOL*SEDMD*DT  
	     XLBOD2DO = XLBOD2DO  
     1       + DECAYYD*VOL*DT*(CPOL2(M,1,1)+CPOL2(M,2,1))/2.0  
	     XLNOD2DO = XLNOD2DO  
     1       + DECAYYN*VOL*DT*(CPOL2(M,1,2)+CPOL2(M,2,2))/2.0*4.57  
           END SELECT  
	     ELSE  
           XLDECAY = DECAYY*VOL*CAVG*DT  
	     ENDIF  
C=======================================================================  
      RETURN  
	END  
ECHO is off.
REM File: RAIN.FOR  
ECHO is off.
      SUBROUTINE RAIN  
C=======================================================================  
C     Created June 1988 by Bob Dickinson (R.E.D.)  
C     Last updated December, 1990 by R.E.D.  
C     WCH, March 1993.  Add warning message for multiple stations.  
C     WCH, August 1993. Add option to process new EarthInfo ASCII files  
C       and to place 15-min. data on interface file at 15-min intervals,  
C       not in the form of hourly totals.  
C     WCH, 9/7/93.  Add option to bypass all statistical calculations  
C       if IDECID = 0.  
C     WCH, 11/12/93. Fix THISO-HISTO problem for IFORM = 3 and add  
C       option for user-defined input for hours to range from 1-24 as  
C       well as 0-23.  
C     WCH, 4/22/94. Set units for depth for IFORM <= 1.  
C     WCH, 4/25/94. Add to logic for recovery of 15-min. data.  
C     WCH, 4/26/94. Provide input for optional treatment of accumulated  
C       rainfall (NCDC code = A).  
C     WCH, 4/26/94. Correct minor error for print of inches missing  
C       data.  
C     WCH, 4/26/94. Print indication of special rainfall codes in event  
C       summary.  
C     WCH, 5/25/94. Reset MFLAG parameter at end of each day during  
C       event definition calcs.  Also fix KUNIT definition.  
C     WCH, 10/15/94. Fix check for old HIST = new THISTO.  Prevented  
C       use of multiple gages except for IFORM >= 9.  
C     WCH, 2/27/95.  Typo in Format 1026.  
C     WCH, 8/1/95.  Allow alphanumeric station IDs for AES precipitation  
C       files (IFORM = 5 or 13).  Change involves converting integer  
C       station IDs to character after input for other data.  This  
C       change affects the Runoff and Statistics Blocks that read  
C       the rainfall interface file.  Also,  
C       read AES ID from AES data as A7 instead of I8 (Sub. GTRAIN).  
C     WCH, 7/23/96.  Change heading for interevent time hours.  Open  
C       NSCRAT1 as unformatted file if DOS name entered on @-line,  
C       thus avoiding query of user for IFILE=1.  Add header for this  
C       ASCII file.  
C     WCH, 7/25/96.  Allow over-writing of existing rainfall interface  
C       file.  
C     WCH (Bruce LaZerte), 10/2/96.  Correct formats 2023, 2024.  
C     WCH, 12/3/96.  Initialize some variables that change during run  
C       in statements, not DATA statements.  
C	WCH, 11/22/99.  Allow 4-digit years in Canadian AES format.   
C       (IFORM = 14) and 15-min.data (IFORM = 15).  
C     WCH, 11/23/99.  Add some routine totals for each year.  
C     WCH, 3/27/00.  Format change for 4-digit year in ASCII stats file.  
C     WCH, 3/27/00.  Delete line near line 816, in by mistake.  
C     WCH, 2/9/01.  Initialize KSUM, TSUM, and SUM.  Suggested by   
C       Nerkez Gavranovic, Sydney, Australia  
C     WCH, 8/27/03. Error message about NUVAL.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'PRECIP.INC'  
C=======================================================================  
      INTEGER JK5(2),JSUM(2),IPRN(5,5),Y1(2),M1(2),D1(2),KSUM(2)  
      INTEGER KEY(LSTORM,3),JK1(3),JK2(3),DURAT,MIT,DURLS,JK4(2),COND  
CWCH, 11/23/99   
      INTEGER MORAIN(12),MDRAIN(12),MHRAIN(12)  
C#### WCH, 8/1/95.  
C####      INTEGER DRY,WET,PRCON,STORM,MSTRM,DSTRM,YSTRM,HSTRM,JSTA(10)  
      INTEGER DRY,WET,PRCON,STORM,MSTRM,DSTRM,YSTRM,HSTRM  
C  
CIM INCREASE HYETOGRAPHS   ~~~~~~~~~~~~~~~~~~~  
      REAL INTEN,STAT(5,8),TSUM(2),XOUT(500),WANE(MAXRG),WAX(MAXRG)  
cim      REAL INTEN,STAT(5,8),TSUM(2),XOUT(500),WANE(10),WAX(10)  
cim  ~~~~~~~~~~~~~~~~~~  
cim  rainfall totals  
      REAL SUMRAIN(MAXRG)  
      CHARACTER  TITL(6)*10,NABRK(4)*6,VALUE(4)*6,VALMM(4)*6  
      CHARACTER*128 NEWFIL  
C#### WCH, 4/26/94.  
      CHARACTER* 1 BLANK  
C#### WCH, 8/1/95.  CHANGE STATION NAMES TO CHARACTER INTERNALLY.  
CIM INCREASE HYETOGRAPHS  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
      CHARACTER*8 JSTA(MAXRG)  
cim      CHARACTER*8 JSTA(10)  
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
C=======================================================================  
      DATA BLANK/' '/  
      DATA JK1/1,3,0/,JK2/1,1,0/,JK4/1,0/,JK5/2,0/,DRY/2/  
      DATA WET/1/  
      DATA VALUE/' Hours',' in/hr','Inches',' Hours'/  
      DATA VALMM/' Hours',' mm/hr','Millim',' Hours'/  
      DATA NABRK/'Month ','Year  ','Storm ','Avg yr'/  
      DATA TITL/'Duration  ','Intensity ','Volume    ',  
     1          'Delta     ','Years     ','Months    '/  
C####      DATA JSUM/0,0/,XINT/0/,MHDATA/0/,MSDATA/0/,DURLS/0/  
C####      DATA COND/2/,NDRY/0/,NDRHR/0/,VOLUM/0/,DURAT/0/,STORM/0/  
C####      DATA NOYRS/0/,LOC11/0/  
C=======================================================================  
C#### WCH, 12/3/96.  INITIALIZE MOST VARIABLES HERE, NOT IN DATA STMTS.  
C=======================================================================  
      JK4(1)  = 1  
      JK4(2)  = 0  
      JSUM(1) = 0  
      JSUM(2) = 0  
Cwch, 2/9/01.  Add KSUM, TSUM and SUM  
      KSUM(1) = 0  
	KSUM(2) = 0  
	TSUM(1) = 0.0  
	TSUM(2) = 0.0  
	SUM(1)  = 0.0  
	SUM(2)  = 0.0  
      XINT    = 0.  
      MHDATA  = 0  
      MSDATA  = 0  
      DURLS   = 0  
      COND    = 2  
      NDRY    = 0  
      NDRHR   = 0  
      VOLUM   = 0.  
      DURAT   = 0  
      STORM   = 0  
      NOYRS   = 0  
      LOC11   = 0  
CWCH, 11/23/99  
	MGDAY   = 0  
	MGHR    = 0  
C#### WCH, 12/3/96.  ADD INITIALIZATION OF IGO.  
      IGO     = 0  
C  
      MIT     = 1  
      KUNIT   = 0  
      METRIC  = 0  
C#### WCH, 8/1/95.  
      LENREC  = 0  
C#### WCH, 4/26/94.  INITIALIZE NEW VARIABLE ACODE.  
      DO 5 I = 1,366  
      DO 5 J = 1,4  
    5 ACODE(I,J) = BLANK  
      INCNT  = INCNT + 1  
      IOUTCT = IOUTCT + 1  
      IO     = JIN(INCNT)  
      JO     = JOUT(IOUTCT)  
      ITEMP  = NSCRAT(2)  
C#### WCH, 8/93.  
      HIST   = 0.0  
CCC      THISTO = 60.0  
C=======================================================================  
C     Open Rainfall file(s).  
C=======================================================================  
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR.  
     +      FFNAME(INCNT).EQ.'JIN.UF'))  
     +      OPEN(JIN(INCNT),FORM='FORMATTED',STATUS='SCRATCH')  
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND.  
     +      FFNAME(INCNT).NE.'JIN.UF')  
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='FORMATTED',  
     +      STATUS='UNKNOWN')  
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR.  
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF'))  
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND.  
     +      FFNAME(25+IOUTCT).NE.'JIN.UF')  
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
C#### WCH, 7/23/96.  ALLOW USER TO ENTER NSCRAT1 FILE NAME WITH @-LINE.  
      IF(JKP(51).EQ.1.AND.NSCRAT(1).GT.0.AND.FFNAME(51).NE.' ')  
     +OPEN(NSCRAT(1),FILE=FFNAME(51),FORM='FORMATTED',STATUS='UNKNOWN')  
C  
      IF(JKP(52).NE.2.AND.NSCRAT(2).GT.0.AND.FFNAME(52).NE.'SCRT2.UF') O  
     +PEN(NSCRAT(2),FILE=FFNAME(52),FORM='UNFORMATTED',STATUS='UNKNOWN')  
      IF(JKP(52).NE.2.AND.NSCRAT(2).GT.0.AND.FFNAME(52).EQ.'SCRT2.UF')  
     +             OPEN(NSCRAT(2),FORM='UNFORMATTED',STATUS='SCRATCH')  
      REWIND IO  
C=======================================================================  
C#### WCH, 8/1/95.  CHECK TO BE SURE INPUT FILE CONTAINS SOME DATA.  
C     STRANGE ERRORS INVOLVING SYSTEM HANG-UPS MAY RESULT OTHERWISE.  
C  
C     CAUTION TO PROGRAMMERS.  OPTION "FLEN=" MAY BE SPECIFIC TO LAHEY  
C     FORTRAN.  
C=======================================================================  
c     INQUIRE (UNIT=IO,FLEN=LENREC)  
c     IF(LENREC.LE.0) THEN  
c          WRITE (N6,965) IO  
c          WRITE (*,965) IO  
c          STOP  
c          ENDIF  
C=======================================================================  
      WRITE(N6,1000)  
      WRITE(*,1000)  
C=======================================================================  
C >>>>>>>>>>>>>> READ DATA GROUP A1 <<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,TITLE(1)  
      READ(N5,*,ERR=888) CC,TITLE(2)  
      WRITE(N6,68)          TITLE(1),TITLE(2)  
C#######################################################################  
C#### WCH, 4/26/94.  
C     INSERT OPTIONAL DATA GROUP B0 FOR NEW PARAMETER KODEA.  
C     KODEA   = 0, DON'T INCLUDE NCDC CUMULATIVE VALUES IN RAINFALL  
C                  TIME SERIES.  HISTORICAL SWMM METHOD (DEFAULT).  
C             = 1, AVERAGE CUMULATIVE VALUES (NCDC CODE = "A") OVER  
C                  PRECEDING TIME PERIOD.  
C             = 2, TREAT CUMULATIVE VALUE AS INSTANTANEOUS VALUE AT  
C                  INDICATED TIME.  
C     OPTIONS 1,2 ONLY FOR IFORM = 0,1,4,6, >=9.  
C     KODEPRT = 0, DON'T PRINT INDICATION OF SPECIAL CODES FOR ALL  
C                  DATES, ONLY FOR DATES OF EVENTS (DEFAULT).  
C             = 1, PRINT INDICATOR IN EVENT SUMMARY FOR ANY DATE ON  
C                  WHICH SPECIAL CODES ARE PRESENT.  
C#### WCH, 7/25/96.  ALLOW OVERWRITING OF EXISTING INTERFACE FILE.  
C     KOVER   = 0, ADD NEW RAINGAGE DATA TO EXISTING INTERFACE FILE.  
C              =1, OVERWRITE EXISTING RAINFALL INTERFACE FILE, CREATING  
C                  FILE CONTAINING ONLY THE DATA FOR CURRENT GAGE.  
C=======================================================================  
      KOVER  = 0  
      KODEA  = 0  
      KODEPR = 0  
C=======================================================================  
C >>>>>>>>>>>>> READ OPTIONAL DATA GROUP B0 <<<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      BACKSPACE N5  
C#### WCH, 7/25/96.  ADD KOVER  
      IF(CC.EQ.'B0') READ(N5,*,ERR=888) CC,KODEA,KODEPR,KOVER  
C=======================================================================  
C >>>>>>>>>>>>>> READ DATA GROUP B1 <<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
C#### WCH, 8/1/95.  
C     READ ALPHANUMERIC ISTA IF IFORM = 5 OR .GE.13.  
C     READ INTEGER IISTA OTHERWISE, AND CONVERT TO CHARACTER ISTA.  
C     AFFECTS APPROXIMATELY NEXT 20 LINES.  
C=======================================================================  
Cwch, 7/28/04  
      IFORM1 = 0  
      READ(N5,*,ERR=888) CC,IFORM  
      IF(CC.NE.'B1') THEN  
           CC = 'B1'  
           GO TO 888  
           ELSE  
           BACKSPACE N5  
           ENDIF  
CWCH, 11/22/99. MAKE .LT.13  
      IF(IFORM.NE.5.AND.IFORM.LT.13) READ(N5,*,ERR=888) CC,IFORM,  
     1     IISTA,IDECID,JYBEG,JYEND,IYEAR,ISUM  
Cwch, 7/28/04. Add option for unformatted read for IFORM=1  
      IF(IFORM.EQ.-1) THEN  
	     IFORM1 = 1  
	     IFORM  = 1  
	     ENDIF  
CWCH, 11/22/99. MAKE .GE.13  
      IF(IFORM.EQ.5.OR.IFORM.GE.13)  READ(N5,*,ERR=888) CC,IFORM,  
     1     ISTA,IDECID,JYBEG,JYEND,IYEAR,ISUM  
      IF(IDECID.GT.0) THEN  
                      BACKSPACE N5  
CWCH, 11/22/99. MAKE .LT.13  
                      IF(IFORM.NE.5.AND.IFORM.LT.13)  
     +                   READ(N5,*,ERR=888) CC,IFORM,IISTA,IDECID,JYBEG,  
     +                      JYEND,IYEAR,ISUM,MIT,NPTS,IFILE,A,NOSTAT  
Cwch, 7/28/04. Add option for unformatted read for IFORM=1  
                      IF(IFORM.EQ.-1) THEN  
	                     IFORM1 = 1  
	                     IFORM  = 1  
	                     ENDIF  
CWCH, 11/22/99. MAKE .GE.13  
                      IF(IFORM.EQ.5.OR.IFORM.GE.13)  
     +                   READ(N5,*,ERR=888) CC,IFORM,ISTA,IDECID,JYBEG,  
     +                      JYEND,IYEAR,ISUM,MIT,NPTS,IFILE,A,NOSTAT  
                      ENDIF  
      IF(IDECID.EQ.2) THEN  
                      JO   = 0  
                      NSTA = 1  
                      ENDIF  
      IYBEG(1) = JYBEG/10000  
      IF((JYBEG.NE.0).AND.(IYBEG(1).LT.100)) THEN  
		JYBEG = JYBEG - IYBEG(1)*10000  
		IYBEG(1) = IYBEG(1)+1900  
		JYBEG = JYBEG + IYBEG(1)*10000  
		ENDIF  
      IYBEG(2) = (JYBEG - IYBEG(1)*10000)/100  
      IYEND(1) = JYEND/10000  
      IF((JYEND.NE.0).AND.(IYEND(1).LT.100)) THEN  
		JYEND = JYEND - IYEND(1)*10000  
		IYEND(1) = IYEND(1)+1900  
		JYEND = JYEND + IYEND(1)*10000  
		ENDIF  
      IYEND(2) = (JYEND - IYEND(1)*10000)/100  
      IYEND(3) = JYEND - IYEND(1)*10000 - IYEND(2)*100  
      IYBEG(3) = JYBEG - IYBEG(1)*10000 - IYBEG(2)*100  
      IF(IYBEG(2).EQ.0) IYBEG(2) =  1  
      IF(IYBEG(3).EQ.0) IYBEG(3) =  1  
      IF(IYEND(2).EQ.0) IYEND(2) = 12  
      IF(IYEND(3).EQ.0) IYEND(3) = 31  
C=======================================================================  
C#### WCH, 8/1/95.  CONVERT INTEGER IISTA TO CHARACTER ISTA.  
C     AMAZING (TO WCH) CONVERSION METHOD IS WRITE TO "INTERNAL FILES".  
C     SEE LAHEY LANGUAGE REFERENCE, SECTION 9.2.1  
CWCH, 11/22/99. MAKE .LT.13  
C=======================================================================  
      IF(IFORM.NE.5.AND.IFORM.LT.13) WRITE(ISTA,'(I8)') IISTA  
C=======================================================================  
C#### WCH, 8/1/95.  REMEMBER, FROM HERE ON, ISTA AND JSTA() ARE  
C     CHARACTER VARIABLES.  
C=======================================================================  
      IF(IDECID.GT.0) WRITE(N6,1021) ISTA,IYBEG,IYEND,MIT,NPTS,IFORM,  
     +                ISUM,IYEAR,IFILE,IDECID,A,NOSTAT  
      IF(IDECID.EQ.0) WRITE(N6,1022) ISTA,IYBEG,IYEND,IFORM,  
     +                                    ISUM,IYEAR,IDECID  
C#### WCH, 4/26/94.  
      WRITE(N6,1025) KODEA  
      WRITE(N6,1026) KODEPR  
C#### WCH, 7/25/96.  
      WRITE(N6,1028) KOVER  
C#### WCH, 8/1/95 AND 11/22/99. ADD NOTE FOR IFORM.GE.13.  
      IF(IFORM.GE.13) WRITE(N6,1027)  
C=======================================================================  
C     READ THE NUMBER OF STATIONS ON JO FILE  
C          IF THE FILE IS EMPTY STATEMENT 123 WILL BE CALLED  
C=======================================================================  
      IF(IDECID.LE.1) THEN  
                      IF(JO.EQ.0) CALL ERROR(111)  
                      MSTA   = 0  
                      READ(JO,END=123,ERR=123) NSTA,MRAIN,  
     +                                         (JSTA(I),I=1,NSTA)  
C#######################################################################  
C#### WCH, 7/25/96.  ALLOW USER TO OVERWRITE EXISTING FILE WITH NEW  
C     GAGE DATA.  
C#######################################################################  
                      IF(KOVER.EQ.1) THEN  
                           WRITE (N6,2121) JO,NSTA  
                           GOTO 123  
                           ENDIF  
                      MSTA   = NSTA  
CIM INCREASE HYETOGRAPHS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
                      IF(NSTA.EQ.MAXRG) CALL ERROR(113)  
                      DO J = 1, MAXRG  
                      SUMRAIN(J) = 0.0  
                      ENDDO  
cim                      IF(NSTA.EQ.10) CALL ERROR(113)  
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
                                      NSTA =  NSTA + 1  
                      WRITE(N6,2115)  NSTA  
C#######################################################################  
C  WCH, 3/3/93  WRITE CAUTION MESSAGE WHEN NSTA > 1  
C#######################################################################  
                      IF(NSTA.GT.1) WRITE(N6,2116) JO, JO  
                      IF(NSTA.GT.1) WRITE(*,2116)  JO, JO  
                      JSTA(NSTA)  =   ISTA  
                      MRAIN       =   1000000  
                      WRITE(N6,2120) (I,JSTA(I),I=1,NSTA)  
C=======================================================================  
C                     Read and save JO on NSCRAT(2) scratch file.  
C=======================================================================  
                      IF(ITEMP.EQ.0) CALL ERROR(114)  
                      REWIND ITEMP  
                      DO 2110 I = 1,1000000  
                      READ(JO,END=2112) JULDAY,RHOUR,  
     +                                  THISTO,(WANE(J),J=1,MSTA)  
C#### WCH, 8/93. CHECK FOR COMPATIBILITY OF TIME INTERVALS.  
C#### WCH, 10/25/94.  DO THIS ONLY FOR IFORM >= 9.  CHECK OCCURS  
C     LATER FOR IFORM = 3 AND IN SUB. GTRAIN FOR OTHER IFORM VALUES.  
C####                      IF(I.EQ.1) THEN  
C  
C#### WCH, 8/1/95. SKIP THIS CHECK FOR IFORM=13 OR 14.  
CWCH, 11/22/99. ADD NEW IFORM=14 AND 15.    
                      IF(IFORM.EQ.13.OR.IFORM.EQ.14) GO TO 2108  
C  
                      IF(I.EQ.1.AND.IFORM.GE.9) THEN  
                    IF(IFORM.EQ.9.OR.IFORM.EQ.11.OR.IFORM.EQ.15) THEN  
                            IF(ABS(THISTO-900.).LT.1.1) GO TO 2108  
                            HIST = 900.0  
                            GO TO 2106  
                            ENDIF  
                         IF(IFORM.EQ.10.OR.IFORM.EQ.12) THEN  
                            IF(ABS(THISTO-3600.).GT.1.1) GO TO 2108  
                            HIST = 3600.0  
                            ENDIF  
 2106                    WRITE(N6,9110) HIST,THISTO  
                         WRITE(*,9110)  HIST,THISTO  
                         STOP  
                         ENDIF  
 2108                 WRITE(ITEMP)      JULDAY,RHOUR,  
     +                                  THISTO,(WANE(J),J=1,MSTA)  
 2110                 CONTINUE  
 2112                 CONTINUE  
                      REWIND JO  
                      REWIND ITEMP  
                      MRAIN = 1000000  
                      WRITE(JO) NSTA,MRAIN,(JSTA(I),I=1,NSTA)  
C#### WCH, 8/93.  
                      HIST = THISTO  
                      GO TO 124  
C=======================================================================  
C      Here, if single rain gage.  
C=======================================================================  
  123                                NSTA = 1  
                      WRITE(N6,2115) NSTA  
                      WRITE(N6,2120) NSTA,ISTA  
                      JSTA(1) = ISTA  
                      REWIND JO  
                      MRAIN = 1000000  
                      WRITE (JO) NSTA,MRAIN,(JSTA(I),I=1,NSTA)  
  124                 CONTINUE  
                      ENDIF  
C=======================================================================  
C     Check file existence of NSCRAT(1).  
C=======================================================================  
      IF(IFILE.EQ.1) THEN  
                     NOUT  = NSCRAT(1)  
                     CALL CKFILE(NOUT)  
                     ENDIF  
C=======================================================================  
C >>>>>>>>>>>>>> READ DATA GROUP B2 <<<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(IFORM.EQ.3) THEN  
                     READ(N5,*,ERR=888) CC,THISTO,METRIC,KUNIT,FIRMAT,  
     +                         CONV,F1,F2,F3,F4,F5,F6,F7  
C#### WCH, 11/12/93  
                     IF(CONV.LT.0.0) THEN  
                          IHH = 1  
                          CONV = -CONV  
                          ELSE  
                          IHH = 0  
                          ENDIF  
                     WRITE(N6,1030) FIRMAT,METRIC,KUNIT,CONV,  
     +                              THISTO,F1,F2,F3,F4,F5,F6,F7  
C#### WCH, 11/12/93  
                     IF(IHH.EQ.0) WRITE (N6,1035)  
                     IF(IHH.EQ.1) WRITE (N6,1036)  
                     THISTO = THISTO*60.0  
C#### WCH, 8/93  
                     IF(HIST.GT.0.0.AND.ABS(HIST-THISTO).GT.0.1) THEN  
                        WRITE(N6,9110) THISTO,HIST  
                        WRITE(*,9110)  THISTO,HIST  
                        STOP  
                        ENDIF  
C#### WCH, 11/12/93  
                     HIST = THISTO  
C=======================================================================  
C >>>>>>>>>>>>>> READ DATA GROUP B3 <<<<<<<<<<<<<<<<<<<<  
C=======================================================================  
                     READ(N5,*,ERR=888) CC  
                     BACKSPACE N5  
                     NUVAL = 1  
                     IF(CC.EQ.'B3') READ(N5,*,ERR=888) CC,NUVAL  
Cwch, 8/27/03.  
Cwch, 728/04. Move to within IF.   
	               IF(NUVAL.LE.0) THEN  
	                     WRITE (N6,9130) NUVAL  
	                     WRITE  (*,9130) NUVAL  
	                     ENDIF  
                     ENDIF  
C=======================================================================  
C#### WCH, 8/1/95.  ADD IFORM=13.  
CWCH, 11/22/99. ADD IFORM=14 AND 15.  CHANGE TO .GE.13  
      IF(IFORM.EQ.5.OR.IFORM.GE.13) METRIC = 1  
                                    METRIC = METRIC + 1  
C#### WCH, 8/93.  
CCC      THISTO = THISTO * 60.0  
      NEND = 24  
      IF(CONV.EQ.0.0)   CONV = 1.0  
      XCONV  = CONV  
C#### WCH, 4/22/94.  SET UNITS FOR DEPTH FOR IFORM <= 1.  
C#### WCH, 5/25/94.  ALSO FOR IFORM = 4 OR 6.  
      IF(IFORM.LE.1.OR.IFORM.EQ.4.OR.IFORM.EQ.6) KUNIT = 1  
C#######################################################################  
C     WCH, 8/93.  Add option for recent (1993) EarthInfo ASCII hourly  
C       and 15-min precipitation files.  
C     Values of IFORM:  
C                Unprocessed  Processed  
C     15-min.        9            11  
C     Hourly        10            12  
C#######################################################################  
C#### WCH, 8/1/95.  ADD CHECK FOR IFORM = 13.  
      IF(IFORM.GE.9.AND.IFORM.LT.13) THEN  
         IF(IFORM.EQ.9.OR.IFORM.EQ.10) THEN  
            M3 = NSCRAT(3)  
            IF(M3.EQ.0) CALL ERROR(104)  
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).NE.'SCRT3.UF')  
     +      OPEN(M3,FILE=FFNAME(53),FORM='FORMATTED',STATUS='UNKNOWN')  
            IF(JKP(53).NE.2.AND.M3.GT.0.AND.FFNAME(53).EQ.'SCRT3.UF')  
     +      OPEN(M3,FORM='FORMATTED',STATUS='SCRATCH')  
            ENDIF  
         IF(IFORM.EQ.9.OR.IFORM.EQ.11) THEN  
            M4 = NSCRAT(4)  
            IF(M4.EQ.0) CALL ERROR(155)  
            OPEN(M4,FORM='UNFORMATTED',STATUS='SCRATCH')  
            NEND = 96  
            ENDIF  
         CALL G9RAIN(0,IGO,ILOST,M3,M4)  
         KUNIT = 1  
         ENDIF  
C=======================================================================  
      IF(IFORM.EQ.3) CALL G3RAIN(0,IGO,ILOST)  
      IF(IFORM.LT.9.AND.IFORM.NE.3) CALL GTRAIN(0,IGO,ILOST,M4)  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. ADD IFORM=14 AND 15.  CHANGE TO .GE.13.  
      IF(IFORM.GE.13) CALL GTRAIN(0,IGO,ILOST,M4)  
C#######################################################################  
C     WCH, 8/93.  FOR 15-MIN. DATA, NEED TO USE NSCRAT(4) FOR TEMPORARY  
C       STORAGE OF ONE YEAR'S DATA.  
C=======================================================================  
C#### WCH, 8/1/95  
CWCH, 11/22/99. ADD IFORM = 14 AND 15.  CHANGE TO .GE.13  
      IF((IFORM.LT.9.OR.IFORM.GE.13).AND.ABS(HIST-900.0).LT.0.1) THEN  
            M4 = NSCRAT(4)  
            IF(M4.EQ.0) CALL ERROR(155)  
            OPEN(M4,FORM='UNFORMATTED',STATUS='SCRATCH')  
            NEND = 96  
            ENDIF  
      THISTO = HIST  
      IF(NEND.EQ.96) WRITE(N6,2027)  
C=======================================================================  
C     END OF YEAR OR END OF FILE-COMPUTE SYNOPTIC DATA  
C     FIND NUMBER OF DAYS IN THIS YEAR  
C     SAVE LAST STORM NUMBER AND PRESENT FILE NUMBER  
C=======================================================================  
C      write to 6 to get carriage control  
    7 WRITE(6,911) NEWYR  
      CONV  = XCONV  
      IF(IFORM.NE.3.AND.IFORM.LT.9) CALL GTRAIN(1,IGO,ILOST,M4)  
      IF(IFORM.EQ.3) CALL G3RAIN(1,IGO,ILOST)  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. CHANGE TO .GE.13  
      IF(IFORM.GE.13) CALL GTRAIN(1,IGO,ILOST,M4)  
      IF(IFORM.GE.9.AND.IFORM.LT.13) CALL G9RAIN(1,IGO,ILOST,M3,M4)  
C  
      IF(ILOST.EQ.0) GO TO 7  
C#### WCH, 8/93  
      IF(NEND.EQ.96) REWIND M4  
      NDAYR = KDATE(0,1,NEWYR+1)-KDATE(0,1,NEWYR)  
      MFLAG = 0  
      NOLDS = STORM  
      NDRSA = NDRY  
      NOYRS = NOYRS + 1  
                                     CONV = 0.01  
      IF(IFORM.EQ.3.AND.METRIC.EQ.1) CONV = 0.001  
      IF(IFORM.EQ.3.AND.METRIC.EQ.2) CONV = 0.01  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. TWO NEW AES OPTIONS.  MAKE .GE.13  
      IF(IFORM.EQ.5.OR.IFORM.GE.13)  CONV = 0.1  
C=======================================================================  
C     Write interface file for NWS precipitation data.  
C     Must use this IF-loop for 15-min. data, except for user-defined.  
C=======================================================================  
C#### WCH, 8/1/95.  ADD CHECK FOR IFORM=13.  
CWCH, 11/22/99. INCLUDE AES 15-MIN DATA HERE, IFORM=15.  
      IF(IFORM.LT.3.OR.IFORM.EQ.4.OR.(IFORM.GE.6.AND.IFORM.LT.13)  
     1.OR.IFORM.EQ.15) THEN  
           IREAD   = 0  
           DO 70 J = 1,NDAYR  
           JULDAY  = NEWYR*1000 + J  
C#######################################################################  
C     WCH, 8/93.  SEVERAL CHANGES FOR 15-MIN RAINFALL  
C#######################################################################  
           M4READ  = 0  
           DO 71 K = 1,NEND  
           KK = K  
           IF(NEND.EQ.96) KK = (K-1)/4 + 1  
           IF(HOUR(J,KK).LE.0) GO TO 71  
           IF(NEND.EQ.24) THEN  
              REIN  = FLOAT(HOUR(J,KK))*CONV  
              RHOUR = FLOAT(KK-1)*3600.0  
              WANE(NSTA) = REIN  
              ELSE  
C=======================================================================  
C     Here, for 15-min. data, compute hour and time and read yearly  
C       data from file M4.  
C=======================================================================  
              RHOUR = FLOAT(K-1)*THISTO  
              REIN       = 0.0  
              WANE(NSTA) = 0.0  
              IF(M4READ.EQ.0) THEN  
 3900              READ(M4,END=3940,ERR=950,IOSTAT=IOS)  
     1                         JLDAY,SHOUR,THIST,REIN  
C#### WCH, 4/25/94.  SPEED UP 15-MIN RAINFALL RECOVERY?  
                   IF(JLDAY.EQ.JULDAY.AND.ABS(RHOUR-SHOUR).LT.0.1)  
     1                                               GO TO 3910  
                   IF(JLDAY.LT.JULDAY) GO TO 3900  
                   IF(JLDAY.EQ.JULDAY.AND.(RHOUR-SHOUR).GT.0.1)  
     1                                               GO TO 3900  
                   IF(JLDAY.GT.JULDAY.OR.(JLDAY.EQ.JULDAY.AND.  
     1                    (SHOUR-RHOUR).GT.0.1)) THEN  
                      REIN = 0.0  
                      BACKSPACE M4  
                      ENDIF  
C#### WCH, 4/25/94.  ADD STATMENT 3910.  
 3910              WANE(NSTA) = REIN  
                   ELSE  
                   GO TO 3950  
                   ENDIF  
              ENDIF  
           GO TO 3950  
C=======================================================================  
C     If reach end of file on M4, set M4READ=1, don't read any more and  
C       end this year's rain data at end of day.  
C=======================================================================  
 3940      M4READ = 1  
C=======================================================================  
 3950      IF(JO.GT.0)    THEN  
              IF(MSTA.GT.0)  THEN  
 4000            IF(IREAD.EQ.0) READ(ITEMP,END=4010) JDAY,QHOUR,  
     +                                    THIS,(WAX(I),I=1,MSTA)  
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.EQ.RHOUR) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = REIN  
                    WRITE(JO)  JULDAY,RHOUR,THISTO,(WAX(I),I=1,NSTA)  
                    GO TO 71  
                    ENDIF  
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.LT.RHOUR) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = 0.0  
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA)  
                    GO TO 4000  
                    ENDIF  
                 IF(JDAY.GE.JULDAY) THEN  
                    IREAD     = 1  
                    DO 4020 I = 1,MSTA  
 4020               WANE(I)   = 0.0  
                    WRITE(JO) JULDAY,RHOUR,THISTO,(WANE(I),I=1,NSTA)  
                    GO TO 71  
                    ENDIF  
                 IF(JDAY.LE.JULDAY) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = 0.0  
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA)  
                    GO TO 4000  
                    ENDIF  
 4010            JDAY  = 9999999  
                 QHOUR = 0.0  
                 IREAD = 1  
                 GO TO 4000  
C=======================================================================  
C     Here, just one precip. station (MSTA = 0).  
C=======================================================================  
                 ELSE  
                 WRITE(JO) JULDAY,RHOUR,THISTO,REIN  
                 ENDIF  
C=======================================================================  
C     ENDIF for JO > 0  
C=======================================================================  
              ENDIF  
   71      CONTINUE  
           IF(M4READ.EQ.1) GO TO 701  
   70      CONTINUE  
  701      CONTINUE  
           ENDIF  
C=======================================================================  
C     User defined rainfall.  
C=======================================================================  
      IF(IFORM.EQ.3) THEN  
           IREAD   = 0  
c     write(*,*) NSTORM  
c     read(*,*) junk  
           DO 80 J = 1,NSTORM  
           JULDAY  = NEWYR*1000 + RDAY(J)  
           REIN    = FLOAT(RRAIN(J))*CONV  
           IF(KUNIT.EQ.1)  REIN = REIN*3600.0/THISTO  
           RHOUR                = RTIME(J)*3600.0  
           WANE(NSTA)           = REIN  
           sumrain(nsta) = sumrain(nsta) + rein*THISTO/3600.0  
           IF (RDAY(J).LT.999990) THEN  
           LDAY1 = JULDAY  
           HLAST1 = RHOUR  
           ENDIF  
C=======================================================================  
C    NOTE, PRECIP. ON INTERFACE FILE IS VALUE OF REIN.  
C    PRECIP. USED FOR STATISTICS IS VALUE OF HOUR().  
C=======================================================================  
           IF(JO.GT.0)    THEN  
              IF(MSTA.GT.0)  THEN  
 5000            IF(IREAD.EQ.0) THEN  
                     READ(ITEMP,END=5010) JDAY,QHOUR,  
     +                                     THIS,(WAX(I),I=1,MSTA)  
                     LDAY2 = JDAY  
                     HLAST2 = QHOUR  
                 ENDIF  
c          write(*,*) j,nstorm  
c          write(*,*) jday,qhour,this,thisto,'-'  
c          write(*,*) julday,rhour  
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.EQ.RHOUR) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = REIN  
                    WRITE(JO)  JULDAY,RHOUR,THISTO,(WAX(I),I=1,NSTA)  
                     do i = 1, msta  
                     sumrain(i) = sumrain(i) + wax(i)*THISTO/3600.0  
                     enddo  
                    GO TO 80  
                    ENDIF  
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.LT.RHOUR) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = 0.0  
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA)  
                    GO TO 5000  
                    ENDIF  
                 IF(JDAY.GE.JULDAY) THEN  
                    IREAD     = 1  
                    DO 5020 I = 1,MSTA  
 5020               WANE(I)   = 0.0  
                    IF (RDAY(J).LT.999990)  
     +              WRITE(JO) JULDAY,RHOUR,THISTO,(WANE(I),I=1,NSTA)  
                    GO TO 80  
                    ENDIF  
                 IF(JDAY.LT.JULDAY) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = 0.0  
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA)  
                    GO TO 5000  
                    ENDIF  
 5010            JDAY  = 9999999  
                 QHOUR = 0.0  
                 IREAD = 1  
                 GO TO 5000  
                 ELSE  
                    IF (RDAY(J).LT.999990)  
     1            WRITE(JO) JULDAY,RHOUR,THISTO,REIN  
                 ENDIF  
              ENDIF  
   80      CONTINUE  
           ENDIF  
C write last day and total rain for IFORM=3 only  
	IF(IFORM.EQ.3) THEN  
           WRITE(N6,8000) LDAY1,HLAST1/60.0/60.0  
           IF (MSTA.GT.0) WRITE(N6,8010) LDAY2,HLAST2/60.0/60.0  
           WRITE(N6,8020)  
           DO I =1, NSTA  
           WRITE(N6,8030) I,SUMRAIN(I)  
           SUMRAIN(I) = 0.0  
           ENDDO  
	ENDIF  
C=======================================================================  
C     AES Canadian rainfall.  
C=======================================================================  
C#### WCH, 8/1/95  
CWCH, 11/22/99. ADD AES 4-DIGIT YEAR, HOURLY OPTION, IFORM=14.  
      IF(IFORM.EQ.5.OR.IFORM.EQ.13.OR.IFORM.EQ.14) THEN  
           IREAD   = 0  
           DO 85 J = 1,NDAYR  
           JULDAY  = NEWYR*1000 + J  
           DO 86 K = 1,24  
           IF(HOUR(J,K).LE.0) GO TO 86  
           REIN  = FLOAT(HOUR(J,K))*CONV  
           KK    = K - 1  
           RHOUR = FLOAT(KK)*3600.0  
           WANE(NSTA)           = REIN  
C=======================================================================  
           IF(JO.GT.0)    THEN  
              IF(MSTA.GT.0)  THEN  
 6000            IF(IREAD.EQ.0) READ(ITEMP,END=6010) JDAY,QHOUR,  
     +                                  THIS,(WAX(I),I=1,MSTA)  
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.EQ.RHOUR) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = REIN  
                    WRITE(JO)  JULDAY,RHOUR,THISTO,(WAX(I),I=1,NSTA)  
                    GO TO 86  
                    ENDIF  
                 IF(JDAY.EQ.JULDAY.AND.QHOUR.LT.RHOUR) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = 0.0  
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA)  
                    GO TO 6000  
                    ENDIF  
                 IF(JDAY.GE.JULDAY) THEN  
                    IREAD     = 1  
                    DO 6020 I = 1,MSTA  
 6020               WANE(I)   = 0.0  
                    WRITE(JO) JULDAY,RHOUR,THISTO,(WANE(I),I=1,NSTA)  
                    GO TO 86  
                    ENDIF  
                 IF(JDAY.LT.JULDAY) THEN  
                    IREAD     = 0  
                    WAX(NSTA) = 0.0  
                    WRITE(JO) JDAY,QHOUR,THIS,(WAX(I),I=1,NSTA)  
                    GO TO 6000  
                    ENDIF  
 6010            JDAY  = 9999999  
                 QHOUR = 0.0  
                 IREAD = 1  
                 GO TO 6000  
                 ELSE  
                 WRITE(JO) JULDAY,RHOUR,THISTO,REIN  
                 ENDIF  
              ENDIF  
86         CONTINUE  
85         CONTINUE  
           ENDIF  
C=======================================================================  
C=======================================================================  
C     Write yearly summary.  
C=======================================================================  
C=======================================================================  
      IF(IYEAR.EQ.1) THEN  
                     IF(IFORM.EQ.3) THEN  
                                    WRITE(N6,975) TITLE(1),TITLE(2)  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. MAKE .GE.13  
                                    ELSE IF(IFORM.EQ.5.OR.IFORM.GE.13)  
     +                                  THEN  
                                        WRITE(N6,971) TITLE(1),TITLE(2)  
                                    ELSE  
                                    WRITE(N6,970) TITLE(1),TITLE(2)  
                                    ENDIF  
                     KW = 0  
                     II = 0  
CWCH, 11/23/99. Add monthly and annual totals and hours with precip.   
				   DO 811 L = 1,12  
				   MORAIN(L) = 0  
	               MDRAIN(L) = 0  
  811                MHRAIN(L) = 0  
C	Find value of current year.  
				   DO 813 L = 1,366  
				   IF(HOUR(L,27).GT.0) THEN  
						IYR = HOUR(L,27)  
	                    GOTO 814  
					    ENDIF  
  813				   CONTINUE  
  814                DO 81  J = 1,NDAYR  
	               JULDAY = 1000*IYR + J  
	               CALL DATED  
				   NNNDAY = 0  
                     DO 82  K = 1,24  
                     IF(HOUR(J,K).LE.0) GO TO 82  
				   MORAIN(MONTH) = MORAIN(MONTH) + HOUR(J,K)  
	               MHRAIN(MONTH) = MHRAIN(MONTH) + 1  
				   IF(NNNDAY.EQ.0) THEN  
						MDRAIN(MONTH) = MDRAIN(MONTH) + 1  
						NNNDAY = 1  
						ENDIF  
                     KW = KW + 1  
                     II = II + 1  
                     IPRN(KW,1) = HOUR(J,25)  
                     IPRN(KW,2) = HOUR(J,26)  
                     IPRN(KW,3) = HOUR(J,27)  
                     IPRN(KW,4) = K - 1  
                     IPRN(KW,5) = HOUR(J,K)  
                     IF(MOD(II,220).EQ.0) THEN  
                        IF(IFORM.EQ.3) WRITE(N6,975) TITLE(1),TITLE(2)  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. MAKE .GE.13  
                        IF(IFORM.EQ.5.OR.IFORM.GE.13) WRITE(N6,971)  
     +                                            TITLE(1),TITLE(2)  
CWCH, 11/22/99. MAKE .LT.13  
                        IF(IFORM.NE.3.AND.IFORM.NE.5.AND.IFORM.LT.13)  
     +                              WRITE(N6,970) TITLE(1),TITLE(2)  
                        ENDIF  
                     IF(MOD(KW,4).EQ.0) THEN  
                            WRITE(N6,980) ((IPRN(KK,JJ),JJ=1,5),KK=1,4)  
                            KW = 0  
                            ENDIF  
82                   CONTINUE  
81                   CONTINUE  
                     IF(KW.GT.0) WRITE(N6,980)  
     +                          ((IPRN(KK,JJ),JJ=1,5),KK=1,KW)  
Cwch  delete.  Here by mistake.        ANNTOT = NHRAIN*CONV  
	               WRITE(N6,985) IYR  
				   IF(METRIC.EQ.1) WRITE(N6,986)   
	               IF(METRIC.EQ.2) WRITE(N6,987)   
				   ANTOT = 0  
	               MMDAY = 0  
	               MMHR  = 0  
				   DO 816 L = 1,12  
				   MMDAY = MMDAY + MDRAIN(L)  
				   MMHR  = MMHR  + MHRAIN(L)  
				   IF(MORAIN(L).GT.0) THEN  
					   TOTRAIN = FLOAT(MORAIN(L))*CONV  
	                   ANTOT   = ANTOT + TOTRAIN  
					   WRITE(N6,988) L,TOTRAIN,MDRAIN(L),MHRAIN(L)  
	                   ENDIF  
  816				   CONTINUE  
                     WRITE(N6,989) ANTOT,MMDAY,MMHR  
	               MGDAY = MGDAY + MMDAY  
	               MGHR  = MGHR  + MMHR  
                     ENDIF  
C#######################################################################  
C     WCH, 9/7/93.  
C     Skip synoptic analysis if IDECID = 0.  
C=======================================================================  
      IF(IDECID.EQ.0) THEN  
           NEWYR = NEWYR + 1  
           GO TO 115  
           ENDIF  
C=======================================================================  
C     End of year printouts.  
C=======================================================================  
      IF(ISUM.EQ.1.AND.METRIC.EQ.1) WRITE(N6,2030) TITLE(1),TITLE(2)  
      IF(ISUM.EQ.1.AND.METRIC.EQ.2) WRITE(N6,2035) TITLE(1),TITLE(2)  
C=======================================================================  
C     PRESENT CONDITION IS DETERMINED IF ANY PRECIPITATION IS  
C     RECORDED FOR THIS HOUR  
C     PREVIOUS CONDITION AND PRESENT CONDITION DETERMINE CURRENT STATUS  
C     PRCON  AND  COND  CAN BE EITHER 1 OR 2.  THUS  NEXT  
C     WHICH DEFINES THE CURRENT STATUS CAN BE EITHER 1,2,3, OR 4  
C     AS INDICATED IN THE FOLLOWING TABLE  
C  
C                          PREVIOUS CONDITION  
C                             WET       DRY  
C                          (COND=1)  (COND=2)  
C     PRESENT       WET  
C     CONDITION  (PRCON=1)     1         3  
C  
C                   DRY        2         4  
C                (PRCON=2)  
C  
C     IN CODE, DRY = 2, WET = 1 (INTEGER VARIABLES).  
C=======================================================================  
C     NOTE, ALL STATISTICAL AND SUMMARY CALCULATIONS ARE DONE USING  
C       HOURLY DATA.  WHEN RAW DATA ARE AT 15-MIN. INTERVALS, HOURLY  
C       VALUES REPRESENT THE SUM FOR THE HOUR.  
C=======================================================================  
      II       = 0  
      TIMDAY   = 0.0  
      DO 100 J = 1,NDAYR  
      JULDAY   = NEWYR*1000 + J  
      CALL DATED  
C#### WCH, 4/26/94.  JXP = INDICATOR VARIABLE FOR PRINT-OUTS.  
      JXP = 0  
      DO 90  K = 1,24  
      IF(MFLAG.GE.1)     GO TO 46  
      IF(HOUR(J,K).GE.0) GO TO 48  
      IF(IFORM.EQ.2) THEN  
                     IF(HOUR(J,K).EQ.-1) MHDATA = MHDATA + 1  
                     IF(HOUR(J,K).EQ.-2) MSDATA = MSDATA + 1  
                     GO TO 90  
                     ENDIF  
C#### WCH, 8/1/95.  
CWCH, 11/22/99. ALLOW IFORM=14 AND 15. CHANGE TO .GE.13  
      IF(IFORM.EQ.5.OR.IFORM.GE.13) THEN  
                     IF(HOUR(J,K).EQ.-1) MHDATA = MHDATA + 1  
                     IF(HOUR(J,K).EQ.-2) MSDATA = MSDATA + 1  
                     GO TO 90  
                     ENDIF  
C#### WCH, 4/25/94.  CAN HAVE -1 AND -2 FLAGS FOR IFORM = 1 ALSO.  
C     CHANGE IF-STMT TO ALLOW CHECK FOR THESE CASES ALSO.  
C####  46  IF(IFORM.EQ.0.OR.IFORM.EQ.4.OR.IFORM.GE.6) THEN  
  46  IF(IFORM.LE.1.OR.IFORM.EQ.4.OR.IFORM.GE.6) THEN  
                     IF(MFLAG.EQ.0) THEN  
                         IF(HOUR(J,K).EQ.-1) THEN  
                                             MHDATA = MHDATA + 1  
                                             ELSE  
                                             MSDATA = MSDATA + 1  
                                             ENDIF  
                         ENDIF  
                     IF(MSDATA.GT.0) MSDATA = MSDATA + 1  
                     IF(MHDATA.GT.0) MHDATA = MHDATA + 1  
                     MFLAG = MFLAG +1  
                     IF(HOUR(J,K).LE.-1.AND.MFLAG.GT.1) MFLAG = 0  
                     GO TO 90  
                     ENDIF  
  48                       PRCON = 2  
      IF(HOUR(J,K) .GT. 0) PRCON = 1  
      NEXT = (COND-1)*2+PRCON  
C=======================================================================  
C     Continue storm (NEXT=1)  
C=======================================================================  
      IF(NEXT.EQ.1) THEN  
                    DURAT = DURAT + 1 + NDRHR  
                    NDRHR = 0  
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.0) VOLUM =  
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV*THISTO/3600.0  
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.1) VOLUM =  
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV  
                    IF(HOUR(J,K).GT.XINT) XINT = HOUR(J,K)  
                    ENDIF  
C=======================================================================  
C     DRY PERIOD (NEXT=2)-CHECK IF NOL OF CONSECUTIVE DRY HOURS  
C     IS SUFFICIENT TO BE CONSIDERED AS END OF STORM  
C=======================================================================  
      IF(NEXT.EQ.2) THEN  
                    NDRHR = NDRHR + 1  
                    IF(NDRHR.LT.MIT) GO TO 90  
                    STORM = STORM+1  
                    IF(STORM.EQ.1) DURLS = DURAT  
                    DELTA = 0.5*(DURAT+DURLS)+FLOAT(NDRY)  
C=======================================================================  
C                   CHECK IF DELTA IS TO BE IGNORED  
C=======================================================================  
                    IF(STORM.EQ.1)                 GO TO 61  
                    IF(MHDATA.GT.0.OR.MSDATA.GT.0) GO TO 61  
                    GO TO 62  
   61               DELTA = 0.0  
                    DH0   = 1.0E10  
   62               CONTINUE  
                    INTEN = VOLUM/FLOAT(DURAT)  
                    LOC11 = LOC11 + 1  
                    IF(LOC11.GT.LSTORM) THEN  
                                        WRITE(N6,9101) LSTORM  
                                        GO TO 101  
                                        ENDIF  
                    KEY(LOC11,1) = MSTRM  
                    KEY(LOC11,2) = YSTRM  
                    KEY(LOC11,3) = LOC11  
                    X1(LOC11,1)  = DURAT  
                    X1(LOC11,2)  = INTEN  
                    X1(LOC11,3)  = FLOAT(JDAY)  
                    X2(LOC11,1)  = VOLUM  
                    X2(LOC11,2)  = DELTA  
                    X2(LOC11,3)  = FLOAT(JDAY)  
                    XDUR         = DURAT  
                    DH0          = DH0+DELTA-0.5*DURAT  
                    ZINT         = XINT*CONV  
C=======================================================================  
C                   Create an ASCII interface file with storm data.  
C=======================================================================  
                    IF(IFILE.EQ.1) THEN  
C#### WCH, 7/23/96.  ADD HEADER TO ASCII FILE.  
                        IF(STORM.EQ.1) THEN  
                             IF(METRIC.EQ.1) WRITE(NOUT,2023) MIT  
                             IF(METRIC.EQ.2) WRITE(NOUT,2024) MIT  
                             ENDIF  
                        DH1 = DH0  
                        IF(DH0.GE.1E06) DH1 = 0.0  
                        WRITE(NOUT,2025) ISTA,STORM,MSTRM,DSTRM,YSTRM,  
     *                  HSTRM,XDUR,VOLUM,INTEN,ZINT,DH1,MHDATA,MSDATA  
                        ENDIF  
C=======================================================================  
C#### WCH, 4/26/94.  HERE, INCLUDE PRINT OF SPECIAL CODE INDICATOR  
                    IXY = JDATE(DSTRM,MSTRM,YSTRM)  
                    IF(ISUM.EQ.1)  THEN  
                       JXP = 1  
                       IF(DH0.LT.1E06) THEN  
                          WRITE(N6,2020) STORM,MSTRM,DSTRM,YSTRM,HSTRM,  
     * XDUR,VOLUM,INTEN,ZINT,DH0,MHDATA,MSDATA,(ACODE(IXY,JXY),JXY=1,4)  
                          ELSE  
                          WRITE(N6,2021) STORM,MSTRM,DSTRM,YSTRM,HSTRM,  
     * XDUR,VOLUM,INTEN,ZINT,MHDATA,MSDATA,(ACODE(IXY,JXY),JXY=1,4)  
                          ENDIF  
                       II = II + 1  
                       IF(MOD(II,50).EQ.0) THEN  
                        IF(METRIC.EQ.1) WRITE(N6,2030) TITLE(1),TITLE(2)  
                        IF(METRIC.EQ.2) WRITE(N6,2035) TITLE(1),TITLE(2)  
                        ENDIF  
                       ENDIF  
C=======================================================================  
                    JSUM(1) = JSUM(1) + MHDATA  
                    JSUM(2) = JSUM(2) + MSDATA  
                    SUM(2)  = SUM(2)  + VOLUM  
                    XINT    = 0.0  
                    MHDATA  = 0  
                    MSDATA  = 0  
                    DH0     = -0.5*DURAT  
                    NDRY    = NDRHR  
                    NDRHR   = 0  
                    COND    = DRY  
                    DURLS   = DURAT  
                    ENDIF  
C=======================================================================  
C     Beginning of storm  (NEXT=3)  
C=======================================================================  
      IF(NEXT.EQ.3) THEN  
                    MSTRM = HOUR(J,25)  
                    DSTRM = HOUR(J,26)  
                    YSTRM = HOUR(J,27)  
                    JDAY  = JULDAY  
                    HSTRM = K - 1  
                    DURAT = 1  
                    VOLUM = 0.0  
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.0) VOLUM =  
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV*THISTO/3600.0  
                    IF(HOUR(J,K).GT.0.AND.KUNIT.EQ.1) VOLUM =  
     +                 VOLUM + FLOAT(HOUR(J,K))*CONV  
                    IF(HOUR(J,K).GT.XINT) XINT = HOUR(J,K)  
                    NDRHR = 0  
                    COND  = WET  
                    ENDIF  
C=======================================================================  
C     Continuation of dry weather (NEXT=4).  
C=======================================================================  
      IF(NEXT.EQ.4) NDRY = NDRY+1  
   90 CONTINUE  
C#######################################################################  
C#### WCH, 4/26/94.  PRINT SPECIAL CODES INDICATOR IF DESIRED.  
C=======================================================================  
      IF(NEXT.NE.2.AND.KODEPR.EQ.1.AND.JXP.EQ.0) THEN  
          IF(ACODE(J,1).NE.BLANK)  
     1       WRITE(N6,2022) MONTH,NDAY,NEWYR,(ACODE(J,JXY),JXY=1,4)  
          JXP = 0  
          ENDIF  
C#### WCH, 5/25/94.  RESET MFLAG AT END OF EACH DAY TO AVOID CARRY-OVER.  
      MFLAG = 0  
  100 CONTINUE  
C=======================================================================  
C     Update for next year.  
C     Revert to saved storm and record number if less than 2 storms.  
C=======================================================================  
      NEWYR = NEWYR+1  
      IF(STORM-NOLDS.LT.2) THEN  
                           NDRY  = NDRSA  
                           STORM = NOLDS  
                           ENDIF  
      RE = FLOAT(JSUM(1))/(FLOAT(NDAYR)*24.0)*SUM(2)  
C#### WCH, 4/26/94.  DIVIDE SUM(1) BY 100 TO GET INCHES.  
      IF(ISUM.EQ.1.AND.METRIC.EQ.1) WRITE(N6,990) SUM(2),JSUM(1),  
     1   JSUM(2),RE,SUM(1)/100.  
      IF(ISUM.EQ.1.AND.METRIC.EQ.2) WRITE(N6,990) SUM(2),JSUM(1),  
     1   JSUM(2),RE,SUM(1)  
      DO 110  K = 1,2  
      TSUM(K)   = SUM(K)  + TSUM(K)  
      KSUM(K)   = JSUM(K) + KSUM(K)  
      JSUM(K)   = 0  
  110 SUM(K)    = 0  
C=======================================================================  
C     Continue reading/or/start writing.  
C=======================================================================  
C#### WCH, 9/7/93  
  115 IF(IYEND(1).GT.0.0.AND.NEWYR.GT.IYEND(1)) GO TO 49  
      IF(IGO.EQ.0) GO TO 7  
C=======================================================================  
C     If IFORM = 4 or IFORM = 6 a new file may be opened.  
C=======================================================================  
   49 CONTINUE  
      IF(IFORM.EQ.4.OR.IFORM.EQ.6) THEN  
                    READ(N5,*,ERR=888) CC  
                    IF(CC.EQ.'@') THEN  
                                  BACKSPACE N5  
                                  READ(N5,*,ERR=888) CC,IO,NEWFIL  
                                  IGO = 0  
                                  CLOSE(IO)  
                                  OPEN(IO,FILE=NEWFIL,FORM='FORMATTED',  
     +                                                STATUS='UNKNOWN')  
                                  REWIND IO  
C#### WCH, 8/93  
                                  CALL GTRAIN(0,IGO,ILOST,M4)  
                                  IF(IGO.EQ.0) GO TO 7  
                                  ELSE  
C#### WCH, 8/93  
                                  WRITE (N6,9120)  
                                  WRITE (*,9120)  
                                  BACKSPACE N5  
                                  ENDIF  
                     ENDIF  
C#######################################################################  
C     WCH, 9/7/03.  
C     End of Rain Block if IDECID = 0.  
C=======================================================================  
      IF(IDECID.EQ.0) GO TO 600  
C=======================================================================  
C     Write rainfall summary.  
CWCH, 11/23/99. Add total wet days and hours.  
C=======================================================================  
      WRITE(N6,2065)  
      IF(METRIC.EQ.1) WRITE(N6,995) ISTA,MGDAY,MGHR,KSUM(1),  
     1     KSUM(2),TSUM(2),NOYRS  
      IF(METRIC.EQ.2) WRITE(N6,996) ISTA,MGDAY,MGHR,KSUM(1),  
     1     KSUM(2),TSUM(2),NOYRS  
C=======================================================================  
C     End of storm event calculations.  Start printing statistics.  
C=======================================================================  
  101 CONTINUE  
      IF(NOSTAT.GT.0) THEN  
      DO 400 ICOL = 4,1,-1  
      IF(ICOL.LE.2) WRITE(N6,2065)  
      IF (ICOL .EQ. 1) CALL SHELL(KEY,LOC11,LSTORM,3,JK1,JK2)  
      IF(NOSTAT.GT.0) WRITE(N6,2070) NABRK(ICOL)  
      IF(ICOL.LE.2) KEYV = KEY(1,ICOL)  
      IF(ICOL.EQ.1) KEYX = KEY(1,2)  
      IF(ICOL.EQ.2) KEYX = KEY(1,1)  
      IC       = 0  
      DO 300 J = 1,LOC11  
      IF(J.EQ.1)     GO TO 260  
      IF(J.EQ.LOC11) GO TO 240  
C=======================================================================  
C     THERE IS NO KEY CHANGE IN PASSES 3 AND 4.  
C     CHECK FOR CHANGE IN KEY  
C=======================================================================  
      IF (ICOL .GT. 2) GO TO 280  
      IF (KEY(J,ICOL) .EQ. KEYV) GO TO 280  
  240 IC = IC+1  
      IF(ICOL.EQ.1.AND.NOYRS.EQ.1) STAT(5,1) = STAT(5,1) + 1.0  
      DO 250 I = 1,5  
      IF(ICOL.EQ.4) STAT(I,1) = FLOAT(NOYRS)  
      IF(STAT(I,1).LE.0.0) STAT(I,1) = 1.0  
                    STAT(I,5) = STAT(I,2)/STAT(I,1)  
      IF(STAT(I,1).GT.1.0) THEN  
                  STAT(I,6) = SQRT(ABS((STAT(I,6)-  
     *            STAT(I,2)**2/STAT(I,1))/(STAT(I,1)-1.0)))  
                  STAT(I,6) = STAT(I,6)/STAT(I,5)  
                  ELSE  
                  STAT(I,6) = 1.0E20  
                  ENDIF  
  250 CONTINUE  
      IF(ICOL.LE.2) WRITE(N6,2130) KEYV  
      IF(ICOL.NE.3) JJ = 5  
      IF(ICOL.EQ.3) JJ = 4  
      IF(ICOL.EQ.1) JJ = 4  
      DO 255 I = 1,JJ  
      II       = I  
      IF(ICOL.EQ.2.AND.II.EQ.JJ) II = 6  
      IF(STAT(I,6).LT.1.0E05) THEN  
                   WRITE(N6,2080) TITL(II),(STAT(I,M),M=1,6)  
                   ELSE  
                   WRITE(N6,2081) TITL(II),(STAT(I,M),M=1,5)  
                   ENDIF  
  255 CONTINUE  
      IF(ICOL.LE.2) KEYV = KEY(J,ICOL)  
      IF(J.EQ.LOC11) GO TO 300  
  260 DO 270 I  = 1,5  
      STAT(I,1) = 0.0  
      STAT(I,2) = 0.0  
      STAT(I,3) =  1.0E20  
      STAT(I,4) = -1.0E20  
  270 STAT(I,6) = 0.0  
      DATAX     = 0.0  
C=======================================================================  
C     THE THIRD COLUMN OF ARRAY KEY STORES THE ORIGINAL  
C     SEQUENCE NUMBER OF THE STORM INFORMATION BEFORE  
C     THE SWITCH AROUND IN SHELL SORT.  
C=======================================================================  
C     STAT(I,1) = NUMBER  
C     STAT(I,2) = TOTAL  
C     STAT(I,3) = MINIMUM  
C     STAT(I,4) = MAXIMUM  
C     STAT(I,5) = AVERAGE  
C     STAT(I,6) = VARIANCE  
C=======================================================================  
  280 DO 290 I = 1,5  
      JJ       = KEY(J,3)  
      IF(I.LE.2) DATA = X1(JJ,I)  
      IF(I.EQ.3) DATA = X2(JJ,1)  
      IF(I.EQ.4) DATA = X2(JJ,2)  
      IF(I.EQ.5) DATA = X2(JJ,1)  
      IF(DATA.EQ.0.0) GO TO 290  
      STAT(I,2) = STAT(I,2) + DATA  
      STAT(I,6) = STAT(I,6) + DATA*DATA  
      IF(I.NE.5) THEN  
                 STAT(I,1) = STAT(I,1)+1.0  
                 IF(DATA.LT.STAT(I,3)) STAT(I,3) = DATA  
                 IF(DATA.GT.STAT(I,4)) STAT(I,4) = DATA  
                 GO TO 290  
                 ENDIF  
      IF(ICOL.EQ.1.AND.KEY(J,2).EQ.KEYX) GO TO 290  
      IF(ICOL.EQ.2.AND.KEY(J,1).EQ.KEYX) GO TO 290  
      STAT(I,1) = STAT(I,1) + 1.0  
C=======================================================================  
C     Break in year occured or break in month occured.  
C=======================================================================  
      IF(ICOL.EQ.1) KEYX = KEY(J,2)  
      IF(ICOL.EQ.2) KEYX = KEY(J,1)  
      IF(STAT(5,2)-DATAX.LE.0.0) GO TO 290  
      IF(STAT(5,2)-DATAX.LT.STAT(5,3)) STAT(5,3) = STAT(5,2)-DATAX  
      IF(STAT(5,2)-DATAX.GT.STAT(5,4)) STAT(5,4) = STAT(5,2)-DATAX  
      STAT(5,6) = STAT(5,6) + ( STAT(5,2)-DATAX)**2  
      DATAX     = STAT(5,2)  
  290 CONTINUE  
  300 CONTINUE  
  400 CONTINUE  
      ENDIF  
C=======================================================================  
C     Compute and print recurrance interval.  
C     JK - Shell sort key.  
C=======================================================================  
      IF(NOSTAT.GT.0) THEN  
                      DO 500 IVAR = 1,4  
                      IF(IVAR.EQ.1) THEN  
                                    MYTEST = NOSTAT/1000  
                                    NOSTAT = NOSTAT - MYTEST*1000  
                                    IF(MYTEST.EQ.0) GO TO 500  
                                    ENDIF  
                      IF(IVAR.EQ.2) THEN  
                                    MYTEST = NOSTAT/100  
                                    NOSTAT = NOSTAT - MYTEST*100  
                                    IF(MYTEST.EQ.0) GO TO 500  
                                    ENDIF  
                      IF(IVAR.EQ.3) THEN  
                                    MYTEST = NOSTAT/10  
                                    NOSTAT = NOSTAT - MYTEST*10  
                                    IF(MYTEST.EQ.0) GO TO 500  
                                    ENDIF  
                      IF(IVAR.EQ.4.AND.NOSTAT.EQ.0) GO TO 500  
                      IF(IVAR.LE.2) JK4(1) = IVAR  
                      IF(IVAR.GT.2) JK4(1) = IVAR - 2  
                      IF(IVAR.LE.2)CALL SHELR(X1,LOC11,LSTORM,3,  
     +                                        JK4,JK5)  
                      IF(IVAR.GT.2)CALL SHELR(X2,LOC11,LSTORM,3,  
     +                                       JK4,JK5)  
                      IF(NPTS.EQ.0)     NPTS = LOC11  
                      IF(NPTS.GT.LOC11) NPTS = LOC11  
                      IF(NPTS.GT.500)   NPTS = 500  
                      DO 440 I= 1,NPTS  
  440                 XOUT(I) = (FLOAT(NOYRS)+1.0-2.0*A)/(FLOAT(I)-A)  
                      IF(METRIC.EQ.1) WRITE(N6,2170) TITL(IVAR),  
     +                                   VALUE(IVAR),VALUE(IVAR)  
                      IF(METRIC.EQ.2) WRITE(N6,2170) TITL(IVAR),  
     +                                   VALMM(IVAR),VALMM(IVAR)  
                      MPTS     = NPTS/2  
                      TIMDAY   = 0.0  
                      DO 450 I = 1,MPTS  
                      I2       = I + MPTS  
                      IF(IVAR.LE.2) JULDAY   = IFIX(X1(I,3))  
                      IF(IVAR.GT.2) JULDAY   = IFIX(X2(I,3))  
                      CALL DATED  
                      M1(1)    = MONTH  
                      D1(1)    = NDAY  
                      Y1(1)    = NYEAR  
                      IF(IVAR.LE.2) JULDAY   = IFIX(X1(I2,3))  
                      IF(IVAR.GT.2) JULDAY   = IFIX(X2(I2,3))  
                      CALL DATED  
                      M1(2)    = MONTH  
                      D1(2)    = NDAY  
                      Y1(2)    = NYEAR  
                      IV       = IVAR - 2  
                      IF(IVAR.GT.2) WRITE(N6,2150) I,X2(I,IV),XOUT(I),  
     +                             M1(1),D1(1),Y1(1),I2,X2(I2,IV),  
     +                             XOUT(I2),M1(2),D1(2),Y1(2)  
  450                 IF(IVAR.LE.2) WRITE(N6,2150) I,X1(I,IVAR),XOUT(I),  
     +                             M1(1),D1(1),Y1(1),I2,X1(I2,IVAR),  
     +                             XOUT(I2),M1(2),D1(2),Y1(2)  
  500                 CONTINUE  
                      ENDIF  
C#### WCH, 9/7/93.  
  600 WRITE(*,1010)  
      WRITE(N6,1010)  
      CLOSE (JIN(INCNT))  
      RETURN  
C=======================================================================  
  888 CALL IERROR  
C#######################################################################  
C     WCH, 10/11/93.  ADDITIONAL ERROR MESSAGE FOR READING SCRATCH  
C       FILE M4 WITH 15-MIN. DATA.  
C=======================================================================  
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY.  
  950 WRITE(N6,9500) M4,JULDAY,JLDAY,SHOUR,THIST,REIN,MOD(IOS,256)  
      WRITE(*,9501) M4,MOD(IOS,256)  
      STOP  
C=======================================================================  
   68 FORMAT(/,10X,A80,/,10X,A80)  
  911 FORMAT('+ Reading rainfall from year : ',I4)  
C#### WCH, 8/1/95.  FILE ERROR MESSAGE.  
  965 FORMAT(' ==> ERROR  JIN DATA INPUT FILE ON UNIT',I3,' IS EMPTY.'  
     1,/,' BE SURE YOU HAVE UNIT PROPERLY DEFINED ON @-LINE.',/,  
     2   ' RUN STOPPED AT BEGINNING OF RAIN BLOCK.')  
  970 FORMAT(//,10X,  
     +' ******************************************',/,10X,  
     +' * Rainfall from Nat. Weather Serv. file  *',/,10X,  
     +' * in units of hundredths of an inch      *',/,10X,  
     +' ******************************************',//,  
     * 10X,A80,/,10X,A80,//,1X,4(2X,'Mo/Dy/Year Hr/ Rn'),/,  
     *                 1X,4(2X,'---------- ------'))  
CWCH, 11/22/99. Minor alteration to title.   
  971 FORMAT(//,10X,  
     +' ********************************************',/,10X,  
     +' * Rainfall from Canadian Met. Centre file, *',/,10X,  
     +' * in units of tenths of a millimeter       *',/,10X,  
     +' ********************************************',//,  
     * 10X,A80,/,10X,A80,//,1X,4(2X,'Mo/Dy/Year Hr/ Rn'),/,  
     *                 1X,4(2X,'---------- ------'))  
  975 FORMAT(//,10X,  
     +' ########################################################',/,10X,  
     +' # Rainfall from user time series in units of           #',/,10X,  
     +' # thousandths of an inch or hundredths of a millimeter #',/,10X,  
     +' # (as defined by the user with parameter METRIC)       #',/,10X,  
     +' ########################################################',//,  
     *10X,A80,/,10X,A80,//,1X,4(2X,'Mo/Dy/Year Hr/ Rn'),/,  
     *                1X,4(2X,'---------- ------'))  
  980 FORMAT(' ',4(1X,2(I2,'/'),I4,I3,'/',I4))  
CWCH, 11/23/99. Two new formats for annual rain prints.  
  985 FORMAT(/,' **********************************************',/,  
     1         ' * Annual Precipitation Summary for Year',I5,' *',/,  
	2         ' **********************************************',//,  
     3         '   Month  Total    Total Wet  Total Wet',/,  
     4         '          Precip.  Days       Hours')  
  986 FORMAT(  '         (inches)')  
  987 FORMAT(  '          (mm)')  
  988 FORMAT(I7,F8.2,I7,I11)  
  989 FORMAT(  ' --------------------------------------',/,  
     1         ' Annual:',F7.2,I7,I11)  
CWCH, 11/22/99.  Add to 990 Format.   
  990 FORMAT(' Total*',18X,F8.2,20X,I6,I8,/,  
     *' Estimated missing rainfall              ',12X,F6.2,F8.2,/,  
     *' *Note, annual total is incorrect for years with events that',  
     *' span the Dec-Jan boundary.')  
C#### WCH, 8/1/95.  995 AND 996: CHANGE ISTA FORMAT TO A8 FROM I8.  
  995 FORMAT(/,  
     *'      ########################################',/,  
     *'      #   Grand Total Precipitation Summary  #',/,  
     *'      ########################################',//,  
     *'      Precip. summary for station     ',A8,/,  
     *'      Total days with precip.         ',I8,'  days',/,  
     *'      Total hours with precip.        ',I8,'  hours',/,  
     *'      Total missing hours             ',2X,I6,'  hours',/,  
     *'      Total hours of meter malfunction',2X,I6,'  hours',/,  
     *'      Total precipitation             ',F8.2,'  inches',/,  
     *'      Total number of years           ',2X,I6,'  years',/)  
  996 FORMAT(/,  
     *'      ****************************************',/,  
     *'      *   Grand Total Precipitation Summary  *',/,  
     *'      ****************************************',//,  
     *'      Precip. summary for station     ',A8,/,  
     *'      Total days with precip.         ',I8,'  days',/,  
     *'      Total hours with precip.        ',I8,'  hours',/,  
     *'      Total missing hours             ',2X,I6,'  hours',/,  
     *'      Total hours of meter malfunction',2X,I6,'  hours',/,  
     *'      Total precipitation            ',F9.2,'  millimeters',/,  
     *'      Total number of years           ',2X,I6,'  years',/)  
 1000 FORMAT(/,' ***************************************************',/,  
     1        ' * Entry made to the Rain Block                    *',/,  
     2        ' * Created by the University of Florida - 1988     *',/,  
     3        ' * Updated by Oregon State University, March 2000  *',/,  
     4        ' ***************************************************',//)  
 1010 FORMAT(/,' ===> Rain Block ended normally.')  
C#### WCH, 8/1/95.  CHANGE ISTA TO CHARACTER.  
 1021 FORMAT(1X,//,  
     1'      ########################################',/,  
     1'      #  Precipitation Block Input Commands  #',/,  
     1'      ########################################',//,  
     1 5X,'Station, ISTA.........................',A10,//,  
     2 5X,'Beginning date, IYBEG (Yr/Mo/Dy)......',  
     2     2X,I4,'/',I2,'/',I2,//,  
     3 5X,'Ending date, IYEND (Yr/Mo/Dy).........',  
     3     2X,I4,'/',I2,'/',I2,//,  
     4 5X,'Minimum interevent time, MIT..........',I6,//,  
     6 5X,'Number of ranked storms, NPTS.........',I6,//,  
     6 5X,'NWS format, IFORM (See text)..........',I6,//,  
     6 5X,'Print storm summary, ISUM (O-No 1-Yes)',I6,//,  
     6 5X,'Print all rainfall, IYEAR (O-No 1-Yes)',I6,//,  
     6 5X,'Save storm event data on NSCRAT(1)....',I6,/,  
     7 5X,'(IFILE =0 -Do not save, =1 -Save data)',//,  
     8 5X,'IDECID 0 - Create interface file',/,  
     9 5X,'       1 - Create file and analyze',/,  
     1 5X,'       2 - Synoptic analysis..........',I6,//,  
     1 5X,'Plotting position parameter, A........',F6.2,//,  
     1 5X,'Storm event statistics, NOSTAT........',I6,//)  
 1022 FORMAT(1X,//,  
     1'      ########################################',/,  
     1'      #  Precipitation Block Input Commands  #',/,  
     1'      ########################################',//,  
     1 5X,'Station, ISTA.........................',A10,/,  
     2 5X,'Beginning date, IYBEG (Yr/Mo/Dy)......',  
     2     2X,I4,'/',I2,'/',I2,//,  
     3 5X,'Ending date, IYEND (Yr/Mo/Dy).........',  
     3     2X,I4,'/',I2,'/',I2,//,  
     6 5X,'NWS format, IFORM (see text)..........',I6,/,  
     6 5X,'Print storm summary, ISUM (O-NO 1-YES)',I6,/,  
     6 5X,'Print all rainfall, IYEAR (O-NO 1-YES)',I6,/,  
     8 5X,'IDECID 0 - Create interface file',/,  
     9 5X,'       1 - Create file and analyze',/,  
     1 5X,'       2 - Synoptic analysis..........',I6)  
C#### WCH, 4/26/94.  
 1025 FORMAT(/,  
     1 5X,'KODEA (from optional group B0)........',I6,/,  
     2 5X,' = 0, Do not include NCDC cumulative values.',/,  
     3 5X,' = 1, Average NCDC cumulative values.',/,  
     4 5X,' = 2, Use NCDC cumulative value as inst. rain.')  
C#### WCH, 2/27/95.  Typo: accumulated, not accumuated  
 1026 FORMAT(/,  
     1 5X,'KODEPR (from optional group B0).......',I6,/,  
     2 5X,' Print NCDC special codes in event summary:',/,  
     3 5X,' = 0, only on days with events.',/,  
     4 5X,' = 1, on all days with codes present.',/,  
     5 5X,' Codes: A = accumulated value, I = incomplete value,',/,  
     6 5X,'        M = missing value,     O = other code present')  
C#### WCH, 8/1/95.  ADDITIONAL INFO FOR IFORM.GE.13.  
 1027 FORMAT(  
     1 5X,' For current Canadian AES data, I = unadjusted')  
C#### WCH, 7/25/96.  
 1028 FORMAT(/,  
     1 5X,'KOVER (from optional group B0)........',I6,/,  
     2 5X,' = 0, Do not over-write existing rainfall interface file.',/,  
     3 5X,' = 1, Over-write existing file with single new gage data.')  
 1030 FORMAT(1X,//,5X,  
     +' #############################',/,5X,  
     +' # User defined input format #',/,5X,  
     +' #############################',//,  
     + 5X,' User format (FIRMAT)..................',A60,/,  
     + 5X,' I/O units (METRIC) 0 = U.S. customary.',/,  
     + 5X,'                    1 = Metric units...',I6,/,  
     + 5X,' Units of rainfall (KUNIT).............',I6,/,  
     + 5X,' 0 -> Intensity; 1 --> Volume..........',/,  
     + 5X,' Conversion factor (CONV)..............',F6.2,/,  
     + 5X,' Rainfall interval in minutes (THISTO).',F6.2,/,  
     + 5X,' Field position for STATION NUMBER, F1.',I6,/,  
     + 5X,' Field position for YEAR,    F2........',I6,/,  
     + 5X,' Field position for MONTH,   F3........',I6,/,  
     + 5X,' Field position for DAY,     F4........',I6,/,  
     + 5X,' Field position for HOUR,    F5........',I6,/,  
     + 5X,' Field position for MINUTE,  F6........',I6,/,  
     + 5X,' Field position for RAINFALL,F7........',I6)  
C#### WCH, 11/12/93  
 1035 FORMAT (5X,' Hour values to be in range 0 - 23 (CONV > 0)',/)  
 1036 FORMAT (5X,' Hour values to be in range 1 - 24 (CONV < 0)',/)  
C#### WCH, 4/26/94.  FORMATS 2020,2021,2022,2025  
 2020 FORMAT(I5,1X,2(I2,'/'),I4,I3,F7.0,3(1X,F6.2),1X,F6.0,I5,I8,  
     1 5X,4A1)  
 2021 FORMAT(I5,1X,2(I2,'/'),I4,I3,F7.0,3(1X,F6.2),1X,  
     +      ' Undef',I5,I8,5X,4A1)  
 2022 FORMAT(4X,2(I2,'/'),I4,58X,4A1)  
C#### WCH, 7/23/96.  ADD HEADER FOR ASCII FILE WITH EVENT DATA.  
C#### WCH (B. LAZERTE), 10/2/96.  CHANGE FORMAT FOR MIT TO I7, NOT F7.2.  
 2023 FORMAT(' Min. Interevent Time =',I7,' hrs.',/,  
     1 T34,'  Dura-        Avg    Max    Inter- Hours   Hours',/,  
     1'          Event    Date    Start   tion  Volume Inten  Inten  eve  
     2nt  Missing Meter Special',/,  
     3'  Station   No. Mo Da  Yr   Hour   hours inches in/hr  in/hr  hou  
     4rs  Data    Stuck   Codes')  
 2024 FORMAT(' Min. Interevent Time =',I7,' hrs.',/,  
     1 T34,'  Dura-        Avg    Max    Inter- Hours   Hours',/,  
     1'          Event    Date    Start   tion  Volume Inten  Inten  eve  
     2nt  Missing Meter Special',/,  
     3'  Station   No. Mo Da  Yr   Hour   hours   mm   mm/hr  mm/hr  hou  
     4rs  Data    Stuck   Codes')  
C#### WCH, 8/1/95.  CHANGE 2025 FIRST FIELD TO A8 FROM I6.  
C#### WCH, 3/27/00. CHANGE YEAR TO 4-DIGIT FIELD, & FIX HEADERS ABOVE.    
 2025 FORMAT(1X,A8,1X,I5,1X,2(I2,1X),I4,I5,F7.0,3(1X,F6.2),  
     *       1X,F6.0,I7,I8,5X,4A1)  
C#### WCH, 8/93  
 2027 FORMAT(//,' $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$',/,  
     1          ' Note, 15-min. data are being processed, but hourly',/,  
     2          ' print-out, summaries, and statistics are based on ',/,  
     3          ' hourly totals only.  Data placed on interface file',/,  
     4          ' are at correct 15-min. intervals.                 ',/,  
     5          ' $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$')  
C#### WCH, 7/23/96.  CHANGE HEADING FOR INTEREVENT TIME.  
 2030 FORMAT(1H1,/,  
     +' ##########################################################',/,  
     *' #  S  T  O  R  M    E  V  E  N  T    S  U  M  M  A  R  Y #',/,  
     +' ##########################################################',//,  
     +1X,A80,/,1X,A80,//,  
     223X,'Dur-          Ave    Max  Inter- Hours   Hours'/,  
     41X, 'Storm        Start   ',  
     3    'ation Volume Inten  Inten  event  Missing Meter Special'/,  
     51X,' No    Date   Hour   hours inches in/hr  in/hr  hours  Data  
     5 Stuck   Codes',/,1X,' --    ----   ----   ----- ------ -----  ---  
     6--  -----  ----    ----- -------')  
 2035 FORMAT(1H1,/,  
     +' ##########################################################',/,  
     *' #  S  T  O  R  M    E  V  E  N  T    S  U  M  M  A  R  Y #',/,  
     +' ##########################################################',//,  
     +1X,A80,/,1X,A80,//,  
     223X,'Dur-          Ave    Max  Inter- Hours   Hours'/,  
     41X, 'Storm        Start   ',  
     3    'ation Volume Inten  Inten  event  Missing Meter Special'/,  
     51X,' No    Date   Hour   hours millim mm/hr  mm/hr  hours  Data  
     5 Stuck   Codes',/,1X,' --    ----   ----   ----- ------ -----  ---  
     6--  -----  ----    ----- -------')  
 2065 FORMAT(1H1)  
 2070 FORMAT (1X,//,5X,'Rainfall Statistics by ',A6,'(for period of',  
     .' record)'/,  
     .18X,'Number',5X,'Total',3X,'Minimum',3X,'Maximum',3X,'Average',  
     .3X,'Coef-Var',/,  
     .18X,'------',5X,'-----',3X,'-------',3X,'-------',3X,'-------',  
     .3X,'--------')  
 2080 FORMAT(8X,A10,F6.0,1X,F9.2,4(1X,F9.3))  
 2081 FORMAT(8X,A10,F6.0,1X,F9.2,3(1X,F9.3),' Undefined')  
 2115 FORMAT(//,  
     +' ********************************************************',/,  
     +' *  Precipitation output created using the Rain block   *',/,  
     +' *  Number of precipitation stations...',I9,'        *',/,  
     +' ********************************************************',/)  
 2116 FORMAT(/,' $$$ CAUTION Multiple precip. stations based on non-emp  
     *ty file on unit ',I3,/,' If this is not correct, delete file on un  
     *it ',I3,' before Rain Block run.',/,' Otherwise may lead to incorr  
     *ect Rain Block interface file.'/)  
C#### WCH, 8/1/95.  CHANGE STATION IDs TO CHARACTER.  
 2120 FORMAT(' Location Station Number',/,  
     +       ' -------- --------------',/,  
     +       10(I9,'. ',A13,/))  
C#### WCH, 7/25/96.  MESSAGE ABOUT OVER-WRITING JOUT.  
 2121 FORMAT(/,' $$$ CAUTION About to over-write non-empty rainfall int  
     1erface file',/,  
     2' on unit',I3,' possibly containing data from',I3,' gage(s).',/,  
     3' This is in accordance with parameter KOVER = 1.')  
 2130 FORMAT(1X,I6)  
 2150 FORMAT(' ',2(I5,2F8.3,3X,2(I2,'/'),I4,5X))  
 2170 FORMAT(//,1H1,10X,'Return Period(years) for ',A10,///,1X,  
     .2('     ',8X,2X,'Return                  '),/,1X,  
     .2(' Rank',2X,A6,2X,'Period   Mo/Dy/Yr       '),/,1X,  
     .2(' ----',2X,'------',2X,'------   --------       '))  
 2220 FORMAT(6X,21I5,I9,T2,I5)  
 2240 FORMAT(1X,I4,12(1X,I3))  
 9101 FORMAT(/,' ===> Error  ',I9,/)  
cim   cim 11/97 write last days in file  
 8000 FORMAT(/,' Last day and hour for this gage          = '  
     a,I10,F10.3)  
 8010 FORMAT(  ' Last day and hour in input transfer file = '  
     a,I10,F10.3)  
 8020 FORMAT('    Total Rainfall For Each Gage : ')  
 8030 FORMAT(/,5X,I10,F10.3)  
C#### WCH, 8/93.  
 9110 FORMAT(/,' ===> ERROR. Time interval for new data,',F7.1,/,  
     1 ' sec. does not',/,'     agree with time interval,',F7.1,  
     2 ' sec. of data on unit JOUT with which',/,  
     3 '     new data are to be combined.  Run stopped.')  
 9120 FORMAT(/,' WARNING. Additional data are expected for IFORM = 4 or  
     16 but no @-line is',/,' found in input stream to identify data for  
     2 future years.',/,' Rain Block will stop processing data.')  
Cwch, 8/27/03  
 9130 FORMAT (/,' WARNING NUVAL (LINE B3)= ',I3,', BUT MUST BE > 0.',/,  
     1 ' PROGRAM WILL LIKELY STOP WITH ERROR.',/,  
     2 ' DO NOT SET NUVAL ACCIDENTALLY ON LINE B3.  OMIT B3 INSTEAD.')  
C#### WCH, 10/11/93.  
C#### WCH, 8/4/95.  9500 AND 9501, CHANGE RMFORT TO LAHEY.  
 9500 FORMAT(/,' ERROR READING SCRATCH FILE ON UNIT',I3,' CONTAINING',/,  
     1' YEARLY 15-MIN. PRECIP. TIME SERIES.',/,' SHOULD BE AT APPROX. JU  
     2LIAN DAY',I6,'. PARAMETERS FROM SCRATCH FILE ARE:',/,  
     3' JULIAN DAY =',I6,/,' TIME OF DAY =',F7.1,' SECONDS',/,  
     4' THISTO =',F7.1,' SECONDS',/,' PRECIP =',F7.3,' IN/HR',/,  
     5' LAHEY ERROR NO. =',I5,/,' RUN STOPPED FROM RAIN BLOCK.')  
 9501 FORMAT(' ERROR READING SCRATCH FILE ON UNIT',I3,' CONTAINING',/,  
     1' YEARLY 15-MIN. PRECIP. TIME SERIES.',/,' SEE OUTPUT FILE FOR DET  
     2AILED MESSAGE.',/,  
     3' LAHEY ERROR NO. =',I5,/,' RUN STOPPED FROM RAIN BLOCK.')  
C=======================================================================  
      END  
ECHO is off.
REM File: RDIIREAD.FOR  
ECHO is off.
      SUBROUTINE RDIIREAD(JFLAG,N)  
C     RUNOFF BLOCK  
C     CALLED BY RHYDRO1, CATCH  
C=======================================================================  
C     ROUTINE TO READ INFILTRATION/INFLOW DATA.  
C     WRITTEN BY CHUCK MOORE, CDM, 8/93  
C     EDITED FOR STYLE BY WCH, 8/93  
C     CHANGE 4 OCCURENCES OF IFLAG TO JFLAG AND ADD METRIC VARIABLE  
C       BY INCLUDING DETAIL.INC, RED, 11/29/93.  
C     CHANGE METRIC CALC.  9/8/00 CIM.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'RDII.INC'  
C#### RED, 11/29/93.  
      INCLUDE 'DETAIL.INC'  
C=======================================================================  
C  THIS IS FIRST CALL TO READ GLOBAL DATA F3 LINE  
C=======================================================================  
      IF(JFLAG.EQ.0) THEN  
           TSTEP  = 0.0  
           TSTEP2 = 0.0  
C=======================================================================  
C>>>>>>>>>>>>>>> READ F3 LINE <<<<<<<<<<<<<<<  
C=======================================================================  
           READ(N5,*,ERR=888) CC  
           BACKSPACE(N5)  
           IF(CC.EQ.'F3') THEN  
                READ(N5,*,ERR=888) CC,IIRDII,TSTEP,TSTEP2  
                IRATIOS = NINT(TSTEP/TSTEP2+0.001)  
                IF(AMOD(TSTEP,TSTEP2).NE.0.0) THEN  
                      IF(IRATIOS.LT.1) IRATIOS = 1  
                      TSTEP2 = TSTEP/FLOAT(IRATIOS)  
                      WRITE(N6,6000) TSTEP2  
                      ENDIF  
                ENDIF  
           RETURN  
           ENDIF  
C=======================================================================  
C  THIS IS SECOND CALL TO READ GLOBAL DATA  
C ======================================================================  
      IF(JFLAG.EQ.1) THEN  
           DO 50 J=1,NTK  
           NRDHYET(J) = 0  
CIM 12 VALUES AND INTIALIZE ALL VALUES  
           DO 50 JJ = 1,12  
           DO 50 I = 1,3  
           RDIIT(J,I,JJ)=0.0  
           RDIIK(J,I,JJ)=0.0  
           DSTORE(J,I,JJ) = 0.0  
           STORAGE(J,I,JJ) = 0.0  
           DREC(J,I,JJ) = 0.0  
  50       CONTINUE  
           NRDII = 0  
C=======================================================================  
C>>>>>>>>>>>>>>> READ F4 LINE <<<<<<<<<<<<<<<  
C=======================================================================  
  100      READ(N5,*,ERR=888) CC  
           BACKSPACE(N5)  
           IF(CC.EQ.'F4') THEN  
                IF(TSTEP.EQ.0.0.OR.TSTEP2.EQ.0.0) THEN  
                     WRITE(N6,*) ' ERROR: F4 CARD FOUND BUT TSTEP',  
     +                 ' SPECIFIED ON F3 CARD EQUALS 0.0'  
                     ENDIF  
                NRDII = NRDII + 1  
                IF(NRDII.GT.NTK) THEN  
                     WRITE(N6,*) ' ERROR - ATTEMPT TO READ MORE THAN ',  
     +                  NTK,' F4 DATA LINES'  
                     STOP  
                     ENDIF  
                READ(N5,*,ERR=888) CC,NRDHYET(NRDII),  
     1            (RDIIT(NRDII,I,1),RDIIK(NRDII,I,1),  
     2            DSTORE(NRDII,I,1),STORAGE(NRDII,I,1),  
     3            DREC(NRDII,I,1),I=1,3)  
                NNTK = NRDII  
cim monthly input of values  
                IF (NRDHYET(NRDII).LT.0) THEN  
                     NRDHYET(NRDII)=-NRDHYET(NRDII)  
                     DO 101 JJ=2,12  
 101                 READ(N5,*,ERR=888) CC,  
     1                 (RDIIT(NRDII,I,JJ),RDIIK(NRDII,I,JJ),  
     2                 DSTORE(NRDII,I,JJ),STORAGE(NRDII,I,JJ),  
     3                 DREC(NRDII,I,JJ),I=1,3)  
                     ELSE  
                     DO 102 I=1,3  
                     do 102 jj=2,12  
                     RDIIT(NRDII,I,JJ) = RDIIT(NRDII,I,1)  
                     RDIIK(NRDII,I,JJ) = RDIIK(NRDII,I,1)  
                     DSTORE(NRDII,I,JJ) = DSTORE(NRDII,I,1)  
                     STORAGE(NRDII,I,JJ) = STORAGE(NRDII,I,1)  
                     DREC(NRDII,I,JJ) = DREC(NRDII,I,1)  
  102                CONTINUE  
                     ENDIF  
CIM MONTHLY  
                GO TO 100  
                ENDIF  
           RETURN  
           ENDIF  
C=======================================================================  
C  THIS IS THE THIRD CALL TO READ SUBBASIN DATA  
C=======================================================================  
      IF(JFLAG.EQ.2) THEN  
C=======================================================================  
C>>>>>>>>>>>>>>> READ H5 LINE <<<<<<<<<<<<<<<  
C=======================================================================  
           READ(N5,*,ERR=888) CC  
           BACKSPACE N5  
           IF(CC.EQ.'H5') THEN  
                READ(N5,*,ERR=888) CC,SEWAREA(N),  
     +                            (RDIIR(N,I,1),I=1,3),ICURVE(N)  
C=======================================================================  
C  CONVERT FROM METRIC, HA TO AC.  
CIM### 9/8/00  DON'T DO IT HERE.  See conversion of Qpeak in RDIIRES  
C=======================================================================  
C                IF(METRIC.EQ.2) SEWAREA(N) = SEWAREA(N)*2.471  
CIM  
                IF(SEWAREA(N).EQ.0.0) THEN  
                     ICURVE(N) = 0  
                     DO 200 I = 1,3  
  200                RDIIR(N,I,1) = 0.0  
                     ENDIF  
                IF (SEWAREA(N).LT.0.0) THEN  
                     SEWAREA(N) = -SEWAREA(N)  
                     DO 201 JJ=2,12  
  201                READ(N5,*,ERR=888) CC,(RDIIR(N,I,JJ),I=1,3)  
                     ELSE  
                     DO 202 JJ=2,12  
                     DO 202 I=1,3  
  202                RDIIR(N,I,JJ) = RDIIR(N,I,1)  
                     ENDIF  
                ENDIF  
           ENDIF  
C=======================================================================  
      RETURN  
C=======================================================================  
  888 CALL IERROR  
C=======================================================================  
 6000 FORMAT(' WARNING - INPUT TSTEP2 NOT EQUAL TO INTEGER FRACTION ',  
     1'OF RAINFALL TIME STEP AND WAS ADJUSTED TO THE NEAREST INTEGER',  
     2' FRACTION'/'  NEW TSTEP2 = ',F10.5)  
      END  
ECHO is off.
REM File: RDIIRES.FOR  
ECHO is off.
      SUBROUTINE RDIIRES  
C     RUNOFF BLOCK  
C     CALLED BY HYDRO  
C ======================================================================  
C     COMPUTES RDII RESPONSE CURVES FROM RAINFALL  
C     WRITES TO SCRATCH FILE(8) - NEW FOR RUNOFF  
C  
C     WRITTEN BY CHUCK MOORE, CDM, 8/93.  
C     EDITED FOR STYLE BY WCH, 8/93  
C     WCH, 1/4/94.  CORRECTIONS TO RAINFALL TOTAL AND PLACEMENT OF  
C       UHs ON FILE FOR CASE WHEN RAIN ENDS BEFORE SIMULATION ENDS.  
C     WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY.  
C     CIM 9/8/00 Change for metric version.  In this version rainfall  
C       remains in mm and area is hectares.  Conversions are made to  
C       compute flows in cfs.  
C       Also changed JSTA to character*8 to match other programs.  
C       Change time step comparison to not be absolutely equal.  
C       Increase array size.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'SUBCAT.INC'  
      INCLUDE 'RDII.INC'  
      PARAMETER(MAXARRAY=1000)  
      DIMENSION RMAX(NTK,3,12),QPEAK(NTK,3,12),TTKMAX(NTK,3,12),  
     1 ISHIFT(NTK,3,12)  
      DIMENSION ARRAY(NTK,3,MAXARRAY)  
CIM INCREASE HYETOGRAPHS  ~~~~~~~~~  
CIM CHANGE JSTA TO CHARACTER*8 TO MATCH CHANGES IN RAINBLOCK AND ELSEWHERE  8/10/00  
C      DIMENSION REIN(MAXRG),JSTA(MAXRG),BAIN(MAXRG)  
      DIMENSION REIN(MAXRG),BAIN(MAXRG)  
      CHARACTER*8 JSTA(MAXRG)  
cim      DIMENSION REIN(10),JSTA(10),BAIN(10)  
cim ~~~~~~~~~~  
      DIMENSION EXCESS(NTK,3),SUMEX(NTK,3)  
      DOUBLE PRECISION SUMEX  
      LOGICAL  INZERO  
      CHARACTER*10 PRT(4,2)  
      DATA PRT /'cfs/ac-in ','in','in/day','ac',  
     1          'cms/ha-mm ','mm','mm/day','ha'/  
C=======================================================================  
C  FIND MAXIMUM R VALUES  
C=======================================================================  
      INZERO = .TRUE.  
      IULDAY  = JULDAY  
      STIMDAY = TIMDAY  
      TIME    = TZERO  
      NNZERO  = 0  
      SUMOFRS = 0.0  
      CNEXCESS = 0.0  
      ICOUNT=0  
C#### WCH, 1/4/94.  NEW VARIABLE IFEND.  
      IFEND   = 0  
      DO 10 JJ = 1,12  
      DO 10 J = 1,NTK  
      DO 10 I = 1,3  
      SUMEX(J,I)   = 0.0  
      STORAGE(J,I,JJ) = AMIN1(DSTORE(J,I,JJ),STORAGE(J,I,JJ))  
      STORAGE(J,I,JJ) = AMAX1(0.0,STORAGE(J,I,JJ))  
      DREC(J,I,JJ)    = DREC(J,I,JJ) / (24.0*60.0*60.0)  
      TTKMAX(J,I,JJ)  = 0.0  
      RMAX(J,I,JJ)    = 0.0  
      DO 10 K = 1,2  
   10 IZERO(J,I,K) = .FALSE.  
      RRMAX        = 0.0  
      RDIIAREA     = 0.0  
      DO 21 J=1,NOW  
      IC = ICURVE(J)  
      IF(IC.GT.0) THEN  
           RDIIAREA = RDIIAREA + SEWAREA(J)  
           DO 20 I=1,3  
           DO 20 JJ=1,12  
           RRMAX = AMAX1(RDIIR(J,I,JJ),RRMAX)  
   20      RMAX(IC,I,JJ) = AMAX1(RDIIR(J,I,JJ),RMAX(IC,I,JJ))  
           ENDIF  
   21 CONTINUE  
C=======================================================================  
C  RRMAX IS INDICATOR FOR WHETHER I/I CALCULATIONS ARE PERFORMED.  
C=======================================================================  
      IF(RRMAX.EQ.0.0) RETURN  
C=======================================================================  
      WRITE(*,*)  
      WRITE(*,*)  ' Computing RDII response curve from rainfall data.'  
      WRITE(*,*)  
C=======================================================================  
C  CHECK FOR EXISTANCE OF SCRATCH FILE 8  
C=======================================================================  
      NRDII = NSCRAT(8)  
      IF(NRDII.EQ.0) THEN  
           WRITE(N6,*) ' SCRATCH UNIT NUMBER 8 (NSCRAT(8))',  
     1 ' MUST BE NON-ZERO TO PERFORM RDII CALCULATIONS'  
           WRITE(*,*) ' SCRATCH UNIT NUMBER 8 (NSCRAT(8))',  
     1 ' MUST BE NON-ZERO TO PERFORM RDII CALCULATIONS'  
           STOP  
           ENDIF  
C=======================================================================  
      TKMAX = 0.0  
      TMIN  = 999.0  
      DO 25 J=1,NNTK  
      DO 25 I=1,3  
      DO 25 JJ=1,12  
      IF(RDIIT(J,I,JJ).GT.0.0) TMIN = AMIN1(RDIIT(J,I,JJ),TMIN)  
      TTKMAX(J,I,JJ) = AMAX1(RDIIT(J,I,JJ)*(1.0+RDIIK(J,I,JJ)),  
     2 TTKMAX(J,I,JJ))  
   25 TKMAX = AMAX1(RDIIT(J,I,JJ)*(1.0+RDIIK(J,I,JJ)),TKMAX)  
C  
      TSTEPS  = TSTEP*60.0*60.0  
      TSTEP2S = TSTEP2*60.0*60.0  
      WRITE(N6,6010) TSTEP,TSTEP2  
C=======================================================================  
C  CHECK MAXARRAY  
C=======================================================================  
      NARRAY = INT(TKMAX/TSTEP2)+IRATIOS+1  
      DO 32 J=1,NNTK  
      DO 32 I=1,3  
      DO 32 JJ=1,12  
      ISHIFT(J,I,JJ) = INT(TTKMAX(J,I,JJ)/TSTEP2)+IRATIOS+1  
   32 CONTINUE  
      IF(NARRAY.GT.MAXARRAY) THEN  
           WRITE(N6,6000) NARRAY  
           STOP  
           ENDIF  
      DO 35 K = 1,NNTK  
      DO 35 I = 1,3  
      DO 35 M = 1,MAXARRAY  
   35 ARRAY(K,I,M) = 0.0  
C=======================================================================  
C  COMPUTE QPEAK/(AIR)  THIS IS UNIT QPEAK TO BE MULTIPLIED LATER BY  
C    AREA, RAINFALL, AND R FACTOR TO COMPUTE PEAK FLOW  
C=======================================================================  
      DO 40 J = 1,NNTK  
      DO 40 I = 1,3  
      DO 40 JJ= 1,12  
C=======================================================================  
C  RAIN (INCHES)  AREA (ACRES)  T (HOURS)  Q (CFS)  
C  AREA OF TRIANGULAR UH IS 1 AC-IN. = 1/12 AC-FT.  
C=======================================================================  
      IF(RDIIT(J,I,JJ).GT.0.0) THEN  
           QPEAK(J,I,JJ) = (2.0*43560.0/12.0)/  
     +       (RDIIT(J,I,JJ)*(1.0+RDIIK(J,I,JJ))*60.0*60.0)  
           ELSE  
           IF(RMAX(J,I,JJ).NE.0.0) THEN  
                WRITE(N6,*) ' T CANNOT EQUAL ZERO WHEN R IS NON-ZERO'  
                WRITE(N6,*) ' RESPONSE CURVE = ',J,' TRIANGLE = ',I  
                WRITE(N6,*) ' MONTH = ',JJ  
                STOP  
                ENDIF  
           ENDIF  
   40 CONTINUE  
C=======================================================================  
C  PRINT DATA FROM F4 LINES.  
C=======================================================================  
      WRITE(N6,6016) PRT(1,METRIC),PRT(2,METRIC),PRT(2,METRIC),  
     1               PRT(3,METRIC)  
      WRITE(N6,6017) PRT(1,METRIC),PRT(2,METRIC),PRT(2,METRIC),  
     1               PRT(3,METRIC)  
      DO 50 J = 1,NNTK  
      DO 50 JJ= 1,12  
      DO 50 I = 1,3  
C=======================================================================  
C  CFS/AC-IN / 362.9956 = CMS/HA-MM  
C=======================================================================  
cim### 9/8/00  
      IF(METRIC.EQ.2) THEN  
      QPP = QPEAK(J,I,JJ)/362.9956  
      else  
      QPP = QPEAK(J,I,JJ)  
      endif  
      IF(I.EQ.1) WRITE(N6,6019) J,NRDHYET(J),JJ,I,RDIIT(J,I,JJ),  
     1 RDIIK(J,I,JJ),TTKMAX(J,I,JJ),QPP,DSTORE(J,I,JJ),STORAGE(J,I,JJ),  
     2 DREC(J,I,JJ)*60.0*60.0*24.0  
      IF(I.GT.1) WRITE(N6,6020) I,RDIIT(J,I,JJ),RDIIK(J,I,JJ),  
     1 TTKMAX(J,I,JJ),QPP,DSTORE(J,I,JJ),STORAGE(J,I,JJ),  
     2 DREC(J,I,JJ)*60.0*60.0*24.0  
C=======================================================================  
C  CONVERT DEPTH PARAMETERS FROM METRIC (MM) TO U.S. (IN.)  
C=======================================================================  
      IF(METRIC.EQ.2) THEN  
CIM### 9/8/00  
CIM these remain in metric  
c           DSTORE(J,I,JJ)  = DSTORE(J,I,JJ)/25.4  
c           STORAGE(J,I,JJ) = STORAGE(J,I,JJ)/25.4  
c           DREC(J,I,JJ)    = DREC(J,I,JJ)/25.4  
C  conversion from cfs/acre-in to cfs/ha-mm for subsequent calculations  
           QPEAK(J,I,JJ) = QPEAK(J,I,JJ)*2.471/25.4  
           ENDIF  
   50 CONTINUE  
C=======================================================================  
C  PRINT SUBCATCHMENT DATA FROM H5 LINES.  
C=======================================================================  
      WRITE(N6,7000) PRT(4,METRIC)  
      DO 60 J = 1,NOW  
      IC = ICURVE(J)  
      IF(IC.GT.0) THEN  
cim### 9/8/00 leave as hectares  
           SEWW = SEWAREA(J)  
c           IF(METRIC.EQ.2) SEWW = SEWW/2.471  
           IF(JCE.EQ.0) WRITE(N6,7010) J,NAMEW(J),IC,SEWW,  
     1                             (JJ,(RDIIR(J,I,JJ),I=1,3),JJ=1,12)  
           IF(JCE.EQ.1) WRITE(N6,7011) J,KAMEW(J),IC,SEWW,  
     1                             (JJ,(RDIIR(J,I,JJ),I=1,3),JJ=1,12)  
           ENDIF  
   60 CONTINUE  
      SEWW = RDIIAREA  
cim### 9/8/00 leave as hectares  
c      IF(METRIC.EQ.2) SEWW = SEWW/2.471  
      WRITE(N6,7015) SEWW,PRT(4,METRIC)  
C=======================================================================  
C  IF IIRDII = 1, USE PREVIOUSLY CALCULATED RESPONSE CURVE.  
C  SKIP UNIT HYDROGRAPH CALCULATIONS.  
C=======================================================================  
      IF(IIRDII.EQ.1) THEN  
           WRITE(N6,7050) NRDII,FFNAME(58)  
           GO TO 210  
           ENDIF  
C=======================================================================  
C  READ RAINFALL TAPE  
C=======================================================================  
      NREIN = NSCRAT(1)  
      REWIND NREIN  
      READ(NREIN,END=777,IOSTAT=IOSS,ERR=777) NSTA,MRAIN,  
     1              (JSTA(I),I=1,NSTA)  
      WRITE(N6,2115)  NSTA  
      WRITE(N6,2120) (I,JSTA(I),I=1,NSTA)  
      READ(NREIN,END=210,IOSTAT=IOSS,ERR=777) JDAY,TMDAY,THISTO,  
     1                                    (BAIN(J),J=1,NSTA)  
      JYEAR = JDAY/1000  
      IF (JYEAR.LT.100) THEN  
      JDAY = JDAY-JYEAR*1000  
      JYEAR = JYEAR + 1900  
      JDAY = JDAY + JYEAR*1000  
      ENDIF  
cim ### 9/8/00  change to have a tolerance of .5 minutes  
c      IF(THISTO.NE.TSTEPS) THEN  
      IF(ABS(THISTO-TSTEPS).GT.30.0) THEN  
           WRITE(N6,*) ' ERROR - RAINFALL TIME STEP IN RAINFALL FILE ',  
     1       'DOES NOT EQUAL RAINFALL TIME STEP SET ON F3 CARD'  
           WRITE(N6,*)  'THISTO = ',THISTO,' Seconds'  
           WRITE(N6,*)  'TSTEPS = ',TSTEPS,' Seconds'  
           STOP  
           ENDIF  
      JOLDAY  = JDAY  
      TOMDAY  = TMDAY  
      JODAY   = JDAY  
      TODAY   = TMDAY  
      TOHISTO = THISTO  
      DO  98 J = 1,NSTA  
   98 REIN(J)  = BAIN(J)  
C#### WCH, 1/3/94.  DON'T BACKSPACE OR GET EXTRA RAIN AFTER FIRST  
C                   TIME STEP.  
C####      BACKSPACE(NREIN)  
      JULDAY = JDAY  
      TIMDAY = TMDAY  
      CALL DATED  
      WRITE(N6,272) MONTH,NDAY,NYEAR,JULDAY,TIMDAY,TIMDAY/3600.0  
CIM  MONTHLY VALUES  
cim here initialize storage(j,i,1) to initial value for starting month  
cim of rainfall record  
      DO 99 J = 1,NTK  
      DO 99 I = 1,3  
   99 STORAGE(J,I,1) = STORAGE(J,I,MONTH)  
      REWIND NRDII  
C=======================================================================  
C  BEGIN LOOPING OVER RAINFALL USING TIME STEP EQUAL TO RAINFALL STEP  
C=======================================================================  
      CNRAIN = 0.0  
  100 CONTINUE  
      IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN  
           JOLDAY  = JDAY  
           TOMDAY  = TMDAY  
           TOHISTO = THISTO  
           DO 101 J = 1,NSTA  
  101      REIN(J)  = BAIN(J)  
C#### WCH, 1/4/94.  NEW END= LOCATION (151, NOT 210).  
           READ(NREIN,END=151,IOSTAT=IOSS,ERR=777) JDAY,TMDAY,THISTO,  
     +                                    (BAIN(J),J=1,NSTA)  
      JYEAR = JDAY/1000  
      IF (JYEAR.LT.100) THEN  
      JDAY = JDAY-JYEAR*1000  
      JYEAR = JYEAR + 1900  
      JDAY = JDAY + JYEAR*1000  
      ENDIF  
cim### 9/8/00  change to have a tolerance of .5 minutes  
      IF(ABS(THISTO-TSTEPS).GT.30.0) THEN  
           WRITE(N6,*) ' ERROR - RAINFALL TIME STEP IN RAINFALL FILE ',  
     1       'DOES NOT EQUAL RAINFALL TIME STEP SET ON F3 CARD'  
           WRITE(N6,*)  'THISTO = ',THISTO,' Seconds'  
           WRITE(N6,*)  'TSTEPS = ',TSTEPS,' Seconds'  
           STOP  
           ENDIF  
c  write to 6 to get carriage control  
           WRITE(6,104) JDAY  
           ELSE  
           CALL NTIME(JOLDAY,TOMDAY,DELTA)  
           IF(ABS(DELTA).GT.(1.0-1.0/FLOAT(IRATIOS))*TOHISTO) THEN  
                DO 105 J = 1,NSTA  
  105           REIN(J) = 0.0  
                ENDIF  
           ENDIF  
C=======================================================================  
C COMPUTE RAINFALL EXCESS AMOUNTS AND ADJUST INITIAL ABSTRACTION STORAGE  
C=======================================================================  
      DO 550 J = 1,NNTK  
      IF(NRDHYET(J).GT.0) THEN  
           IF(REIN(NRDHYET(J)).GT.0.0) THEN  
                RAINFALL = REIN(NRDHYET(J))*TSTEP  
                CNRAIN   = CNRAIN + RAINFALL  
                DO 540 I = 1,3  
                EXCESS(J,I) = RAINFALL-STORAGE(J,I,1)  
                EXCESS(J,I) = AMAX1(EXCESS(J,I),0.0)  
                STORAGE(J,I,1) = STORAGE(J,I,1)-(RAINFALL-EXCESS(J,I))  
                SUMEX(J,I) = SUMEX(J,I) + EXCESS(J,I)  
  540           CONTINUE  
                ELSE  
C=======================================================================  
C  STORAGE RECOVERS IF NOT RAINING  
C=======================================================================  
                DO 545 I = 1,3  
                EXCESS(J,I) = 0.0  
                STORAGE(J,I,1) = STORAGE(J,I,1)+DREC(J,I,MONTH)*TSTEPS  
                STORAGE(J,I,1) = AMIN1(STORAGE(J,I,1),DSTORE(J,I,MONTH))  
  545           CONTINUE  
                ENDIF  
           ENDIF  
  550 CONTINUE  
      ICOUNT=ICOUNT+1  
      DO 360 JJ = 1,NOW  
      JT = ICURVE(JJ)  
      IF(JT.GT.0) THEN  
      DO 350 I=1,3  
      SUMOFRS = SUMOFRS+SEWAREA(JJ)*RDIIR(JJ,I,month)  
      CNEXCESS = CNEXCESS + EXCESS(JT,I)*SEWAREA(JJ)*RDIIR(JJ,I,MONTH)  
  350 CONTINUE  
      ENDIF  
  360 CONTINUE  
C=======================================================================  
C  LOOP OF TSTEP2  
C  LOOP OVER UNIT HYDROGRAPHS TO COMPUTE ARRAY VALUES  
C=======================================================================  
      DO 150 J=1,NNTK  
C=======================================================================  
C  LOOP OVER TRIANGLES  
C=======================================================================  
      DO 140 I = 1,3  
      IF(EXCESS(J,I).GT.0.0) THEN  
           IF(RMAX(J,I,MONTH).GT.0.0) THEN  
C======================================================================  
C  LOOP OVER TIMESTEPS TO FILL ARRAY  
C=======================================================================  
                TRDII = 0.0  
                DO 139 IT = 2,ISHIFT(J,I,MONTH)  
                TRDII = TRDII + TSTEP2  
                IF(TRDII.LE.RDIIT(J,I,MONTH)) THEN  
                     FLOW = QPEAK(J,I,MONTH)*TRDII/RDIIT(J,I,MONTH)  
     +               *EXCESS(J,I)  
                     ELSE  
                     RRATIO = 1.0 - (TRDII-RDIIT(J,I,MONTH))/  
     +                              (RDIIT(J,I,MONTH)*RDIIK(J,I,MONTH))  
                     RRATIO = AMAX1(RRATIO,0.0)  
                     FLOW = QPEAK(J,I,MONTH)*RRATIO*EXCESS(J,I)  
                     ENDIF  
                ARRAY(J,I,IT) = ARRAY(J,I,IT)+FLOW  
                IF(FLOW.LE.0.0) GO TO 140  
  139           CONTINUE  
                ENDIF  
           ENDIF  
  140 CONTINUE  
  150 CONTINUE  
C#######################################################################  
C#### WCH, 1/4/93.  
C  PROVIDE NEW CODE FOR SITUATION IN WHICH END OF RAINFALL IS REACHED  
C  WELL BEFORE END OF SIMULATION.  
C=======================================================================  
      GO TO 153  
  151 IFEND = 1  
      IF(TIME.GE.(LONG+TZERO)) GO TO 210  
  153 DO 200 JJJ = 1,IRATIOS  
C=======================================================================  
C  WRITE THIS FLOW TO FILE  (MOSTLY, WRITE JUST NON-ZERO VALUES).  
C  USE ARRAY IZERO TO INDICATE PRESENCE OF NON-ZERO I/I EXCESS VALUE.  
C  IZERO = .TRUE. ==> NON-ZERO EXCESS VALUE TO WRITE.  
C  IZERO = .FALSE. => DON'T WRITE ZERO VALUE OF ARRAY().  
C=======================================================================  
      IF(NNZERO.GT.0) THEN  
           IF(INZERO)  
     +        WRITE(NRDII) JODAY,TODAY,((IZERO(J,I,2),I=1,3),J=1,NTK)  
           INZERO = .FALSE.  
           WRITE(NRDII) JULDAY,TIMDAY,((IZERO(J,I,1),I=1,3),J=1,NTK)  
           ELSE  
C=======================================================================  
C  WRITE FIRST ZERO VALUE  
C=======================================================================  
           IF(.NOT.INZERO) THEN  
             WRITE(NRDII) JULDAY,TIMDAY,((IZERO(J,I,1),I=1,3),J=1,NTK)  
             INZERO = .TRUE.  
             ENDIF  
           ENDIF  
C=======================================================================  
C  SHIFT ARRAYS  
C=======================================================================  
C#### WCH, 1/4/93.  MOVE TIME CHANGES TO AFTER 160 LOOP FOR CONVENIENCE  
C                   ONLY.  
C  
      NNZERO = 0  
      DO 160 J = 1,NNTK  
      DO 160 I = 1,3  
C=======================================================================  
C  ONLY STORE NON-ZERO I/I EXCESS VALUES (IZERO = .TRUE.).  
C=======================================================================  
      IF(IZERO(J,I,1)) WRITE(NRDII) ARRAY(J,I,1)  
      DO 155 IT = 1,ISHIFT(J,I,MONTH)-1  
  155 ARRAY(J,I,IT) = ARRAY(J,I,IT+1)  
      IZERO(J,I,2)  = IZERO(J,I,1)  
      IZERO(J,I,1)  = (ARRAY(J,I,1).NE.0.0)  
      IF(IZERO(J,I,1)) NNZERO = NNZERO+1  
  160 ARRAY(J,I,ISHIFT(J,I,MONTH)) = 0.0  
C#### WCH, 1/4/94.  TIME CHANGES MOVED TO HERE.  
      JODAY = JULDAY  
      TODAY = TIMDAY  
      CALL STIME(TSTEP2S)  
      TIME   = TIME+TSTEP2S  
  200 CONTINUE  
C#######################################################################  
C#### WCH, 1/4/94  
C  CHECK TO BE SURE ARRAY() IS "FLUSHED" OF ALL NON-ZERO VALUES  AND  
C  A LAST ZERO STORED ON FILE BEFORE QUITTING.  
C=======================================================================  
      IF(IFEND.EQ.1.AND.NNZERO.GT.0) GO TO 151  
      IF(IFEND.EQ.1.AND.NNZERO.LE.0) THEN  
           IFEND = 2  
           GO TO 153  
           ENDIF  
      IF(IFEND.EQ.2) GO TO 210  
C=======================================================================  
C  READ NEXT RAINFALL  
C=======================================================================  
      IF(TIME.LT.(LONG+TZERO)) GO TO 100  
  210 CONTINUE  
C=======================================================================  
C  APPROXIMATE AVERAGE RAIN BY DIVIDING TOTAL BY NUMBER OF UH SETS.  
C=======================================================================  
      CNRAIN = CNRAIN/DBLE(NNTK)  
      JULDAY = IULDAY  
      TIMDAY = STIMDAY  
      CALL DATED  
      REWIND NRDII  
C=======================================================================  
C  READ FIRST TWO VALUES SETTING UP INPUT FILE FOR RDIISHED  
C=======================================================================  
      CALL READNEXT  
      CALL READNEXT  
      DO 300 I = 1,3  
 300  CNTRDII(I) = 0.0  
      SUMOFRS=SUMOFRS/ICOUNT  
      CNEXCESS = CNEXCESS/SUMOFRS  
      RETURN  
C=======================================================================  
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY.  
 777  WRITE(N6,9777) MOD(IOSS,256)  
      STOP  
C=======================================================================  
  104 FORMAT(1H+,' Reading rainfall Julian day',I8)  
  272 FORMAT(/,  
     1' ************************************************',/,  
     2' *      INITIAL RAINFALL RECORD                 *',/,  
     3' ************************************************',//,  
     4' Date (Mo/Day/Year)   = ',T50,I2,'/',I2,'/',I4,/,  
     6' Julian Date  =',T45,5X,I8,/,  
     7' Time of day  =',T45,F13.0,' seconds.',/,  
     8' Time of day  =',T45,F13.2,'   hours.',/)  
 2115 FORMAT(//,  
     +' ***************************************************',/,  
     +' *  Precipitation Interface File Summary           *',/,  
     +' *  Number of precipitation station....',I9,'   *',/,  
     +' ***************************************************',/)  
 2120 FORMAT(' Location Station Number',/,  
     +       ' -------- --------------',/,  
cim### 9/8/00 change rain id to character*8  
c     +       10(I9,'. ',I13,/))  
     +       10(I9,'. ',5X,A8,/))  
 6000 FORMAT(' ERROR - ARRAY DIMENSIONS IN RDIIRES NOT SUFFICIENT TO',  
     1' SIMULATE COMPLETE HYDROGRAPH.',/,' EITHER DECREASE TP(1+K) OR ',  
     2'CHANGE PARAMETER STATEMENT IN RDIIRES.',/,  
     3' DIMENSION REQUIRED FOR THIS SIMULATION = ',I5)  
 6010 FORMAT('1 RAINFALL DEPENDENT INFILTRATION/INFLOW (RDII) CALCULATIO  
     1NS',/,' DATA FROM F3 AND F4 LINES FOR COMPUTATION OF UNIT HYDROGRA  
     2PH RESPONSE:',//  
     3 '  TSTEP  = RAINFALL INCREMENT (MUST = HYETOGRAPH TIME INTERVAL,'  
     4,/,12X,'THISTO)   =',F10.3,' HOURS',/,  
     5 '  TSTEP2 = TIME STEP FOR UH RESPONSE (MUST BE INTEGER FRACTION'  
     6,/,12X,'OF TSTEP) =',F10.3,' HOURS')  
 6015 FORMAT(//,' LINE F4 DATA INPUTS FOR TRIANGULAR UNIT HYDROGRAPH NUM  
     1BER ',I2)  
 6016 FORMAT(/,  
     1'  Qpeak   = Peak RDII flow produced by 1 unit of rainfall excess  
     2',/,13X,'over 1 area unit, ',A10,'.',/,  
     3'  DSTORE  = Maximum depression storage to be satified before I/I  
     4begins, ',A2,'.',/,  
     5'  STORAGE = Initial depression storage, ',A2,'.',/,  
     6'  DREC    = DSTORE recovery rate when not raining, ',A6,'.',/,  
     7'  TP      = Time to peak, hr.',/,  
     8'  K       = Ratio, recession time to TP.',/,  
     9'  TB      = Time base = TP*(1+K), hr.')  
 6017 FORMAT(/,  
     1'   UH   HYET MONTH TRIANG. TP     K      TB    Qpeak  DSTORE',  
     2'  STORAGE   DREC',/,  
C                                              cfs/ac-in  in       in    in/day  
     3' SET NO. NO.         NO.   hr            hr  ',A10,1X,A2,7X,A2,  
     4 4X,A6,/,  
     5' ------ ---- ----- ----- ------ ------ ------ -------- -------',  
     6' ------- -------')  
C          1     1      2   3.00   2.00   9.00  33.86877  0.275   0.376   0.084  
 6019 FORMAT(/,3I5,I7,3F7.2,F10.5,F7.3,2F8.3)  
 6020 FORMAT(I22,3F7.2,F10.5,F7.3,2F8.3)  
C  
 7000 FORMAT(//,' SUBCATCHMENT PARAMETERS FROM H5 DATA LINES',//,  
     1' SUBCATCHMENT  USE  SEWERED MONTH RATIOS FOR TRIANGLE NOS.',/,  
     2' SEQ.     ID    UH    AREA             1       2       3',/,  
     3'  NO.     NO.   NO.    ',A2,/,  
     4'----- ------- ----- -------- ----- ------- ------- -------')  
C         4     977     3   4568.93   0.3333  0.3333  0.3333  
 7010 FORMAT(I4,1X,I10,1X,I6,F10.2,I5,F9.4,2F8.4,  
     1       11(/,32X,I5,F9.4,2F8.4))  
 7011 FORMAT(I4,1X,A10,1X,I6,F10.2,I5,F9.4,2F8.4,  
     1       11(/,32X,I5,F9.4,2F8.4))  
 7015 FORMAT(19X,'---------',/,' TOT. SEWERED AREA =',F8.2,1X,A2)  
 7050 FORMAT(/,' PARAMETER IIRDII = 1.  SKIP UH RESPONSE CURVE CALCULATI  
     1ONS.',/,' USE RESPONSE HYDROGRAPH STORED ON UNIT',I3,', DOS FILE '  
     2,A10,/,' DATES ON FILE MUST OVERLAP DATES REQUIRED FOR THIS SIMULA  
     3TION')  
 9777 FORMAT(/,' ===> Error   Reading precipitation time history',  
     1' on the NSCRAT(1) file.',/,' IOSTAT =',I5,' Run stopped from Subr  
     2outine RDIIRES')  
      END  
ECHO is off.
REM File: RDIISHED.FOR  
ECHO is off.
      SUBROUTINE RDIISHED  
C     RUNOFF BLOCK  
C     CALLED BY HYDRO NEAR LINE 353  
C=======================================================================  
C    RDIISHED CREATED AUGUST 1993 BY C. MOORE, CDM  
C    PERFORMS RDII CALCULATIONS FOR BASINS WITH E5 CARDS  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'SUBCAT.INC'  
      INCLUDE 'GRWTR.INC'  
      INCLUDE 'RDII.INC'  
C=======================================================================  
   10 CALL NTIME(JRDDAY(2),RDTIM(2),DEL2)  
CCC      write(6,*) 1,JRDDAY(2),RDTIM(2),DEL2,JULDAY,TIMDAY  
      IF(DEL2.LE.0.0) THEN  
           CALL READNEXT  
           GO TO 10  
           ENDIF  
      CALL NTIME(JRDDAY(1),RDTIM(1),DEL1)  
CCC      write(6,*) 2,JRDDAY(1),RDTIM(1),DEL1,JULDAY,TIMDAY  
      RRATIO = AMAX1(-DEL1/(DEL2-DEL1),0.0)  
      DO 100 J = 1,NOW  
      IF(ICURVE(J).EQ.0.OR.SEWAREA(J).EQ.0.0) GO TO 100  
      JJ    = ICURVE(J)  
      FFLOW = 0.0  
      DO 50 I = 1,3  
      FFFLOW = RDFLOW(JJ,I,1)+RRATIO*(RDFLOW(JJ,I,2)-RDFLOW(JJ,I,1))  
C=======================================================================  
C     RDFLOW = IN/HR  
C     RDFLOW*SEWAREA = AC-IN/HR = CFS  
C=======================================================================  
      FFFLOW = FFFLOW*SEWAREA(J)*RDIIR(J,I,MONTH)  
      FFLOW  = FFLOW+FFFLOW  
      CNTRDII(I) = CNTRDII(I) + FFFLOW*DMEAN  
   50 CONTINUE  
C=======================================================================  
C     MUST SAVE I/I FLOW SEPARATELY IF WANT TO ISOLATE QUALITY  
C       CONTRIBUTIONS.  
C=======================================================================  
      FLOWII(J) = FFLOW  
  100 CONTINUE  
      END  
  
ECHO is off.
REM File: RHYDRO1.FOR  
ECHO is off.
      SUBROUTINE RHYDRO1  
C	RUNOFF BLOCK  
C	CALLED BY SUBROUTINE RUNOFF NEAR LINE 217  
C=======================================================================  
C     General Input Subroutine of the Runoff Block.  
C     RHYDRO1 updated August 1992.  
C     Updated 12/92 by WCH to include limit for groundwater  
C       non-convergence messages (entered optionally on B2 line).  
C     Call I/I routine, C. Moore, CDM, 8/93.  
C     Metric correction, WCH (RED), 9/23/93.  UNDONE, RED, 12/31/93.  
C     Option for zero evaporation during rainy time steps, WCH (CDM,  
C       Chuck Moore), 10/5/93.  Also slight change to print-out for  
C       IVAP parameter.  
C     Metric correction, WCH (RED), 11/12/93, for print of QFULL.  
C     Correction to print alphanumeric tributary subareas in linkage  
C       table, WCH, 11/30/93.  
C     Fix to use correct Format statement for evaporation in in. or mm  
C       per day, WCH, 4/19/94.  
C     Add check to be sure when reading F1 evap. data, WCH, 12/5/94.  
C     Check for maximum number of connections to channel/pipe/inlets,  
C       WCH, 12/11/96.  
C     Modify to handle subcat to subcat routing.  WCH, 12/20/00.  
C     Add additional printout options.  WCH, 12/20/00.  
C     Minor spacing changes to initial echo output.  WCH, 1/18/01.  
C     Add error message for too-high initial depth.  WCH, 2/7/01  
C     Add error message for same NAMEG and NGTO.  WCH, 2/12/01.  
C     Reinstate correction for 8-digit date entry on B3 line, made  
C      4/11/00 but lost.  WCH, 5/1/02  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'SUBCAT.INC'  
      INCLUDE 'QUALTY.INC'  
      INCLUDE 'GRWTR.INC'  
      INCLUDE 'NEW88.INC'  
      INCLUDE 'NEW89.INC'  
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
CIM   MAXINF  C.Moore B. Cunningham CDM  
      INCLUDE 'MAXINF.INC'  
Cwch, 12/20/00  
	INCLUDE 'OVERLAND.INC'  
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
Cwch, 4/11/00  
      REAL LLONG*8  
C=======================================================================  
      CHARACTER JUNIT(5)*10,GTYPE(4)*9,CTYPE(3)*12  
CIM Modification to table to print 10 characters and digits of id's 4/99  
      CHARACTER GOUT(20)*90,FOR1(2)*90,FOR2(2)*90,FOR3(2)*90,FOR4(2)*90  
C#### WCH, 12/92  
      DIMENSION G(8),GD(8),GR(8)  
      DATA JUNIT/' Seconds',' Minutes',' Hours',' Days',' Yr/Mo/Dy'/  
      DATA GTYPE/'Trapezoid',' Circular',  
     1           '  Dummy  ','Parabolic'/  
      DATA CTYPE/' Weir ','V-Notch Weir',' Orifice '/  
      GOUT(1) = '('' Input   NAMEG: '''//  
     1'3X,'' Drains                         '','  
      GOUT(2) = '(''Sequen  Channel'''//  
     1'3X,''   to     Channel  Width  Length '','  
      GOUT(3) = '(''Number    ID # '''//  
     1'3X,''  NGTO:    Type     (ft)   (ft)  '','  
      GOUT(4) = '(''------  ------------------'''//  
     1','' -------- ------ ------- '','  
      GOUT(5) = '''  Invert  L Side   R Side  Intial     Max  Mann-   Fu  
     +ll'')'  
      GOUT(6) = '''   Slope   Slope    Slope   Depth   Depth   ings   Fl  
     +ow'')'  
      GOUT(7) = '''  (ft/ft) (ft/ft)  (ft/ft)   (ft)    (ft)    "N"  (cf  
     +s)'')'  
      GOUT(8) = '''  ------- -------- ------- ------- ------- -----  ---  
     +--'')'  
      GOUT(9) = '(''Number    ID # '''//  
     1'3X,''  NGTO:    Type     (m)    (m)   '','  
      GOUT(10)= '''  (m/m)   (m/m)    (m/m)     (m)     (m)    "N"   (cm  
     +s)'')'  
      GOUT(11)= '('' Input   NAMEG:  Drains   Type of     Crest '','  
      GOUT(12)= '(''Sequen  Channel   to      Control      Elev.'','  
      GOUT(13)= '(''Number    ID #   NGTO:   Structure     (ft) '','  
      GOUT(14)= '(''------  --------------- -----------  ------ '','  
      GOUT(15)= '''    Discharge   Spillway Width, Notch '')'  
      GOUT(16)= '''  Coefficient  Angle, or Orifice area  '')'  
      GOUT(17)= ''' (ft**1/2)/s)  (ft or ft**2 or degrees)'')'  
      GOUT(18)= ''' ------------  ------------------------'')'  
      GOUT(19)= '(''Number    ID #   NGTO:   Structure     (m) '','  
      GOUT(20)= '''  (m**1/2)/s)   (m or m**2 or degrees)'')'  
      SOURCE  = 'Runoff Block'  
C=======================================================================  
C     General information.  
C=======================================================================  
C>>>>>>>>>> READ DATA GROUP A1 <<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,TITLE(1)  
      READ(N5,*,ERR=888) CC,TITLE(2)  
      WRITE(N6,14)          TITLE(1),TITLE(2)  
      TITLE(3) = TITLE(1)  
      TITLE(4) = TITLE(2)  
C=======================================================================  
C>>>>>>>> READ DATA GROUP B1 <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,METRIC,ISNOW,NRGAG,INFILM,KWALTY,  
     1                   IVAP,NHR,NMN,NDAY,MONTH,NYEAR,IVCHAN  
      IF (NYEAR.LT.100) NYEAR = NYEAR+1900  
      WRITE(N6,31) ISNOW,NRGAG  
      IF(INFILM.EQ.0) WRITE(N6,32) INFILM  
      IF(INFILM.EQ.1) WRITE(N6,33) INFILM  
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
      IF(INFILM.EQ.2) WRITE(N6,321) INFILM  
      IF(INFILM.EQ.3) WRITE(N6,331) INFILM  
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
      IF(KWALTY.EQ.1) WRITE(N6,34) KWALTY  
      IF(KWALTY.EQ.0) WRITE(N6,35) KWALTY  
C#### WCH (CDM, C. MOORE), 10/5/93.  ADD OPTION FOR NO EVAP DURING RAIN.  
      IF(IVAP.LT.0) THEN  
c  if iivap > 0 then no evaporation during rainfall.  
c           < 0 then evaporation is allowed during rainfall.  
c  if abs(iivap) = 1 then evaporation is allowed from channels.  
c                = 2 then evaporation is not allowed from channels.  
           IIVAP = 1  
           IF (IVCHAN.EQ.1) IIVAP = 2  
           IVAP  = -IVAP  
           ELSE  
           IIVAP = -1  
           IF (IVCHAN.EQ.1) IIVAP = -2  
           ENDIF  
      IF(IIVAP.GT.0) WRITE(N6,41)  
      IF(IVCHAN.EQ.1) WRITE(N6,45)  
C  
      IF(IVAP.EQ.0) WRITE(N6,36)   IVAP  
C#### WCH, 10/5/93.  MODIFY IVAP WRITE.  
      IF(IVAP.GE.1.AND.IVAP.LE.3) WRITE(N6,37)   IVAP  
      IF(IVAP.EQ.4) WRITE(N6,42) IVAP  
      WRITE(N6,38) NHR,NMN  
      TZERO = FLOAT(NHR) + FLOAT(NMN)/60.0  
      WRITE (N6,39) TZERO  
      TZERO  = TZERO * 3600.0  
      TIMDAY = TZERO  
      METRIC = METRIC + 1  
      IF(METRIC.EQ.1) WRITE(N6,48) METRIC-1  
      IF(METRIC.EQ.2) WRITE(N6,49) METRIC-1  
C=======================================================================  
C>>>>>>>> READ DATA GROUP B2 <<<<<<<<  
C=======================================================================  
      IPRNGW  = 0  
	NOHEAD  = 0  
	LANDUPR = 0  
Cwch, 12/20/00. Add NOHEAD and LANDUPR  
      READ(N5,*,ERR=888)CC,IPRN(1),IPRN(2),IPRN(3),IPRNGW,NOHEAD,LANDUPR  
      WRITE(N6,40)          IPRN(1),IPRN(2),IPRN(3)  
	WRITE(N6,9072) NOHEAD  
	WRITE(N6,9074) LANDUPR  
      IF(IPRNGW.EQ.0) IPRNGW = 10000  
      WRITE(N6,9070) IPRNGW  
C  
      IPRN(4) = 1  
      IPRN(5) = 1  
      IPRN(6) = 1  
      IPRN(7) = 1  
      IF(IPRN(1).EQ.0) THEN  
                       IPRN(4) = 0  
                       IPRN(5) = 0  
                       IPRN(6) = 0  
                       IPRN(7) = 0  
                       ENDIF  
      IF(IPRN(1).GT.1) THEN  
         I1 = IPRN(1)/1000  
         J2 = IPRN(1) - I1*1000  
         I2 = J2/100  
         J3 = J2 - I2*100  
         I3 = J3/10  
         I4 = J3 - I3*10  
         IF(I1.EQ.2.OR.I2.EQ.2.OR.I3.EQ.2.OR.I4.EQ.2) IPRN(4) = 0  
         IF(I1.EQ.3.OR.I2.EQ.3.OR.I3.EQ.3.OR.I4.EQ.3) IPRN(5) = 0  
         IF(I1.EQ.4.OR.I2.EQ.4.OR.I3.EQ.4.OR.I4.EQ.4) IPRN(6) = 0  
         IF(I1.EQ.5.OR.I2.EQ.5.OR.I3.EQ.5.OR.I4.EQ.5) IPRN(7) = 0  
         ENDIF  
C=======================================================================  
C>>>>>>>> READ DATA GROUP B3 <<<<<<<<  
Cwch, 4/11/00. Read LONG here as double precision (LLONG), but keep  
C     LONG for use in computations.  Need double to get last digit of  
C     8-digit dates when LUNIT = 4.   
C=======================================================================  
      READ(N5,*,ERR=888) CC,WET,WETDRY,DRY,LUNIT,LLONG  
C=======================================================================  
C>>>>>>>> READ DATA GROUP B4 (IF PRESENT) <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC  
      IF(CC.EQ.'B4') THEN  
                   BACKSPACE N5  
                   READ(N5,*,ERR=888) CC,PCTZER,REGEN  
                   ELSE  
                   BACKSPACE N5  
                   ENDIF  
	IF (NDAY+MONTH+NYEAR.EQ.0) THEN  
          NDAY   =     2  
          MONTH  =     8  
          NYEAR  =  1941  
	ENDIF  
c      IF(NDAY.LE.0)   NDAY   =  2  
c      IF(MONTH.LE.0)  MONTH  =  8  
c      IF(NYEAR.LE.0)  NYEAR  = 1941  
      JULDAY = NYEAR*1000 + JDATE(NDAY,MONTH,NYEAR)  
      IDATEZ = JULDAY  
      CALL DATED  
      NBD(1) = NYEAR  
      NBD(2) = MONTH  
      NBD(3) = NDAY  
      NBD(4) = JHR  
      NBD(5) = MINUTE  
      NBD(6) = JSEC  
      IF(NRGAG.EQ.0)    NRGAG  =    1  
      IF(REGEN.LE.0.0)  REGEN  = 0.01  
      IF(PCTZER.EQ.0.0) PCTZER = 25.0  
C=======================================================================  
      WRITE (N6,162)  MONTH,NDAY,NYEAR  
      WRITE (N6,160)  WET,DRY,WETDRY  
Cwch, 4/11/00  
      WRITE (N6,165)  LLONG,JUNIT(LUNIT+1)  
      WRITE (N6,174)  PCTZER  
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
      IF(INFILM.EQ.0.OR.INFILM.EQ.2) WRITE(N6,180) REGEN  
cim      IF(INFILM.EQ.0) WRITE(N6,180) REGEN  
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
Cwch, 4/11/00.  Use LLONG on RHS for these calcs.   
C=======================================================================  
      IF(LUNIT.EQ.1)  LONG = LLONG*60.0  
      IF(LUNIT.EQ.2)  LONG = LLONG*3600.0  
      IF(LUNIT.EQ.3)  LONG = LLONG*86400.0  
      IF(LUNIT.EQ.4)  THEN  
C                      JEND  = IFIX(LONG)  
                      JEND  = IDINT(LLONG)  
                      MYEAR = JEND/10000  
                      MDAY  = JEND - MYEAR*10000  
                      IF (MYEAR.LT.100) MYEAR = MYEAR + 1900  
                      MMNTH = MDAY/100  
                      MDAY  = MDAY - MMNTH*100  
                      JEND  = 1000*MYEAR + JDATE(MDAY,MMNTH,MYEAR)  
                      TMD   = 86400.0  
                      CALL NTIME(JEND,TMD,TDIFF)  
                      LONG  = TDIFF  
                      ENDIF  
C=======================================================================  
C     Read Snow Input Data Groups.  
C=======================================================================  
      IF(ISNOW.GT.0) THEN  
                     WRITE(*,9050)  
                     CALL SNOWIN(0)  
                     ENDIF  
C=======================================================================  
C     Rainfall Intensity Histogram.  
C=======================================================================  
      WRITE(*,9060)  
      CALL MKRAIN  
C=======================================================================  
C>>>>>>>> Read Data Group F1 If IVAP >= 1 <<<<<<<<  
C=======================================================================  
      IF(IVAP.EQ.0) THEN  
                    CDEF     = 0.1  
                    IF(METRIC.EQ.2) CDEF = 3.0  
                    DO 535 I = 1,12  
  535               VAP(I)   = CDEF  
                    IF(METRIC.EQ.1) WRITE(N6,550) (VAP(I),I=1,12)  
                    IF(METRIC.EQ.2) WRITE(N6,555) (VAP(I),I=1,12)  
                    ENDIF  
      IF(IVAP.EQ.1) THEN  
                    READ(N5,*,ERR=888) CC,(VAP(I),I=1,12)  
C#### WCH, 12/5/94.  CHECK FOR PRESENCE OF F1 LINE.  
                    IF(CC.NE.'F1') THEN  
                         CC = 'F1'  
                         GO TO 888  
                         ENDIF  
C#### WCH, 4/19/94.  USE CORRECT FORMAT STATEMENTS FOR IN OR MM/DAY.  
                    IF(METRIC.EQ.1) WRITE(N6,550) (VAP(I),I=1,12)  
                    IF(METRIC.EQ.2) WRITE(N6,555) (VAP(I),I=1,12)  
                    ENDIF  
      IF(IVAP.EQ.2) THEN  
                    READ(N5,*,ERR=888) CC,(VAP(I),I=1,12)  
C#### WCH, 12/5/94.  CHECK FOR PRESENCE OF F1 LINE.  
                    IF(CC.NE.'F1') THEN  
                         CC = 'F1'  
                         GO TO 888  
                         ENDIF  
                    IF(METRIC.EQ.1) WRITE(N6,551) (VAP(I),I=1,12)  
                    IF(METRIC.EQ.2) WRITE(N6,556) (VAP(I),I=1,12)  
                    DO 540 I = 1,12  
  540               VAP(I)   = VAP(I)/PDAYS(I)  
                    ENDIF  
      IF(IVAP.EQ.3) THEN  
                    READ(N5,*,ERR=888) CC,NVAP(1),NVAP(2)  
                    IF (NVAP(1).LE.100) NVAP(1) = NVAP(1) + 1900  
C#### WCH, 12/5/94.  CHECK FOR PRESENCE OF F1 LINE.  
                    IF(CC.NE.'F1') THEN  
                         CC = 'F1'  
                         GO TO 888  
                         ENDIF  
                    IF(NVAP(2).GT.600) CALL ERROR(150)  
                    IF(NVAP(1).LE.00)  CALL ERROR(151)  
C                   IF(NVAP(1).GT.100) CALL ERROR(152)  
                    DO 5300 I  = 1,NVAP(2),12  
                    KK         = I - 1  
                    READ(N5,*,ERR=888) CC,(VAP(K+KK),K=1,12)  
5300                CONTINUE  
                    IF(METRIC.EQ.1) WRITE(N6,5505)  
                    IF(METRIC.EQ.2) WRITE(N6,5506)  
                    ISTYR      = NVAP(1) - 1  
                    DO 5400 I  = 1,NVAP(2),12  
                    ISTYR      = ISTYR   + 1  
                    KK         = I       - 1  
                    WRITE(N6,5510) ISTYR,(VAP(K+KK),K=1,12)  
5400                CONTINUE  
                    DO 5600 I  = 1,NVAP(2),12  
                    DO 5500 K  = 1,12  
                    KK         = K - 1  
5500                VAP(I+KK)  = VAP(I+KK)/PDAYS(K)/CMET(7,METRIC)  
5600                CONTINUE  
                    ENDIF  
C=======================================================================  
C     Convert from in/day or mm/day to ft/sec.  
C=======================================================================  
      IF(IVAP.LE.2) THEN  
                    DO 560 I = 1,12  
560                 VAP(I)   = VAP(I)/CMET(7,METRIC)  
                    ENDIF  
      FOR1(1) = GOUT(1)  
      FOR1(2) = GOUT(5)  
      FOR2(1) = GOUT(2)  
      FOR2(2) = GOUT(6)  
      FOR4(1) = GOUT(4)  
      FOR4(2) = GOUT(8)  
      IF(METRIC.EQ.1) THEN  
                      FOR3(1) = GOUT(3)  
                      FOR3(2) = GOUT(7)  
                      ELSE  
                      FOR3(1) = GOUT(9)  
                      FOR3(2) = GOUT(10)  
                      ENDIF  
C#######################################################################  
C####   C. Moore, 8/93.  Add option to read I/I data.  
C#######################################################################  
C>>>>>>>> Read F3 and F4 lines <<<<<<<<  
C=======================================================================  
C     Look for new F3 line with first call to RDIIREAD  
C=======================================================================  
      CALL RDIIREAD(0,0)  
C=======================================================================  
C     Look for new F4 lines with second call to RDIIREAD  
C=======================================================================  
      CALL RDIIREAD(1,0)  
C=======================================================================  
C     Channel and Pipe Data.  
C=======================================================================  
      DO 562 I = 1,8  
      GD(I)    = 0.0  
  562 GR(I)    = 1.0  
      NOGG     = 0  
      N        = 0  
      WRITE(*,9040)  
Change from 900 to NG  
      DO 660 I = 1,NG  
      N        = N + 1  
C=======================================================================  
C>>>>>>>> Read Data Groups G1 and G2 <<<<<<<<  
C=======================================================================  
      READ (N5,*,ERR=888) CC  
      IF(CC.NE.'G1'.AND.CC.NE.'G2') THEN  
                     BACKSPACE N5  
                     IF(I.EQ.1) WRITE(N6,600)  
                     GO TO 670  
                     ENDIF  
      IF(CC.EQ.'G1') THEN  
                     BACKSPACE N5  
                     IF(JCE.EQ.0) READ(N5,*,ERR=888)  
     +                                 CC,NAMEG(N),NGTO(N),NP,G  
                     IF(JCE.EQ.1) READ(N5,*,ERR=888)  
     +                                 CC,KAMEG(N),KGTO(N),NP,G  
                     IF(NP.GT.4) THEN  
                                 READ(N5,*,ERR=888) CC,WTYPE(N),  
     +                                WELEV(N),WDIS(N),SPILL(N)  
                                 IF(CC.NE.'G2') THEN  
                                    IF(JCE.EQ.0) WRITE(N6,8900) NAMEG(N)  
                                    IF(JCE.EQ.1) WRITE(N6,8901) KAMEG(N)  
                                    CALL ERROR(200)  
                                    ENDIF  
                                 IF(NP.LE.6) NP = NP - 4  
                                 IF(NP.EQ.7) NP =  4  
                                 ENDIF  
                     ENDIF  
      IF(JCE.EQ.0)        THEN  
		IF(NAMEG(N).EQ.-1)  THEN  
                          DO 610 J = 1,8  
  610                     IF(G(J).NE.0.0) GR(J)=G(J)  
                          N = N - 1  
                          GO TO 660  
                          ENDIF  
		IF(NAMEG(N).EQ.-2)  THEN  
                          DO 640 J = 1,8  
  640                     IF(G(J).NE.0.0) GD(J)=G(J)  
                          N = N - 1  
                          GO TO 660  
                          ENDIF  
Cwch, 2/12/01.  Check for same NAMEG and NGTO  
          IF(NAMEG(N).EQ.NGTO(N)) THEN  
	                    WRITE(*,8925) NAMEG(N)  
	                    WRITE(N6,8926) NAMEG(N)  
	                    STOP ' Run stopped from Runoff Block data inpu  
     1t routine, RHYDRO1'  
	                    ENDIF  
          ENDIF  
	IF(JCE.EQ.1)        THEN  
		IF(KAMEG(N).EQ.'-1')THEN  
                          DO 810 J = 1,8  
  810                     IF(G(J).NE.0.0) GR(J)=G(J)  
                          N = N - 1  
                          GO TO 660  
                          ENDIF  
		IF(KAMEG(N).EQ.'-2')THEN  
                          DO 840 J = 1,8  
  840                     IF(G(J).NE.0.0) GD(J)=G(J)  
                          N = N - 1  
                          GO TO 660  
                          ENDIF  
Cwch, 2/12/01.  Check for same KAMEG and KGTO  
          IF(KAMEG(N).EQ.KGTO(N)) THEN  
	                    WRITE(*,8930) KAMEG(N)  
	                    WRITE(N6,8931) KAMEG(N)  
	                    STOP ' Run stopped from Runoff Block data inpu  
     1t routine, RHYDRO1'  
	                    ENDIF  
          ENDIF  
      IF(NP.NE.3) THEN  
                   DO 605 IG = 1,8  
                   IF(G(IG).EQ.0.0) G(IG) = GD(IG)  
  605              G(IG)                  = GR(IG) * G(IG)  
                   ENDIF  
C=======================================================================  
C     Calculate Qfull for Channel or Pipe.  
C=======================================================================  
      IF(NP.NE.3) THEN  
      IF(G(6).LE.0.0) G(6) = 0.014  
      IF(NP.EQ.1) THEN  
             AX = 0.5*(G(4)+G(5))*G(7)**2.0+G(1)*G(7)  
             PW = SQRT(G(4)**2.0+1.0)*G(7)+SQRT(G(5)**2.0+1.0)*G(7)+G(1)  
             ENDIF  
      IF(NP.EQ.2)  THEN  
                   SIN2D0  = 0.5*SIN(2.0*2.62)  
                   AX      = G(1)**2*(2.62-SIN2D0)/4.0  
                   PW      = G(1)*2.62  
                   ENDIF  
      IF(NP.EQ.4)     THEN  
      IF(G(7).GT.0.0) THEN  
                      WIDTH = G(1)  
                      AX    = 0.66666667*WIDTH*G(7)  
                      X     = WIDTH/2.0  
                      AA    = WIDTH**4.0/(64.0*G(7)**2.0)  
                      PW    = 8.0*G(7)/WIDTH**2.0*(X*SQRT(AA+X**2.0) +  
     +                                     AA*LOG(X+SQRT(AA+X**2.0)) -  
     +                                     AA*LOG(SQRT(AA)))  
                     ELSE  
                     AX    = 0.0  
                     PW    = 0.001  
                     ENDIF  
                     ENDIF  
      IF(AX.LT.0.001) AX   = 0.0  
      IF(PW.LE.0.001) PW   = 0.001  
      RAD                  = AX/PW  
      GCON(N)              = 1.486/G(6)*SQRT(G(3))  
                     QFULL = 0.0  
      IF(RAD.GT.0.0) QFULL = GCON(N)*AX*RAD**0.666666667  
      ELSE  
      QFULL                = 0.0  
      ENDIF  
C#### WCH (RED), 11/12/93.  
      IF(METRIC.EQ.2) QFULL = QFULL/1.486  
C=======================================================================  
C     Print Channel/Pipe data.  
C=======================================================================  
      IF(IPRN(4).EQ.0)   THEN  
      IF(N.EQ.1.OR.MOD(N,50).EQ.0) THEN  
                                   WRITE(N6,620)  
                                   WRITE(N6,FOR1)  
                                   WRITE(N6,FOR2)  
                                   WRITE(N6,FOR3)  
                                   WRITE(N6,FOR4)  
                                   ENDIF  
      IF(JCE.EQ.0) WRITE(N6,630) N,NAMEG(N),NGTO(N),GTYPE(NP),  
     +             G(1),G(2),G(3),G(4),G(5),G(8),G(7),G(6),QFULL  
      IF(JCE.EQ.1) WRITE(N6,631) N,KAMEG(N),KGTO(N),GTYPE(NP),  
     +             G(1),G(2),G(3),G(4),G(5),G(8),G(7),G(6),QFULL  
      ENDIF  
C=======================================================================  
Cwch, 2/7/01  Check that initial depth not greater than channel max.  
C=======================================================================  
      IF(NP.NE.2.OR.NP.NE.3.OR.NP.NE.6) THEN  
	     IF(G(8).GT.G(1)) THEN  
	        IF(JCE.EQ.0) WRITE(N6,9925) NAMEG(N),G(8),G(1)  
	        IF(JCE.EQ.1) WRITE(N6,9926) KAMEG(N),G(8),G(1)  
	        G(8) = G(1)  
	       ELSEIF(NP.NE.3.AND.G(8).GT.G(7)) THEN  
	        IF(JCE.EQ.0) WRITE(N6,9930) NAMEG(N),G(8),G(7)  
	        IF(JCE.EQ.1) WRITE(N6,9931) KAMEG(N),G(8),G(7)  
	        G(7) = G(1)  
	       ENDIF  
	     ENDIF  
C=======================================================================  
C     Transfer data and convert units.  
C=======================================================================  
      NPG(N)    = NP  
      GWIDTH(N) = G(1)*CMET(1,METRIC)  
      GLEN(N)   = G(2)*CMET(1,METRIC)  
      GS1(N)    = G(4)  
      GS2(N)    = G(5)  
      DFULL(N)  = G(7)*CMET(1,METRIC)  
      IF(G(8).LE.0.0.AND.NP.EQ.4) G(8) = 0.0001  
      GDEPTH(N) = G(8)*CMET(1,METRIC)  
C=======================================================================  
C     For circular pipes, Dfull is in radians.  
C     2.62=Half angle of wetted perimeter at maximum flow.  
C=======================================================================  
      IF(NP.EQ.2) THEN  
                  DFULL(N)  = 2.62  
                  IF(GDEPTH(N).GE.GWIDTH(N)/2.0) THEN  
                               TH9 = GDEPTH(N) -  GWIDTH(N)/2.0  
                               GDEPTH(N) =  3.1415927  
     +                                    - ACOS(TH9/(GWIDTH(N)/2.0))  
                               ENDIF  
                  IF(GDEPTH(N).LT.GWIDTH(N)/2.0) THEN  
                               TH9 =  GWIDTH(N)/2.0 - GDEPTH(N)  
                               GDEPTH(N) =  ACOS(TH9/(GWIDTH(N)/2.0))  
                               ENDIF  
                  ENDIF  
      NOGG = 1  
  660 CONTINUE  
  670 NOG = N-1  
C=======================================================================  
C     Write control structure data.  
C=======================================================================  
      IF(IPRN(4).EQ.0) THEN  
      FOR1(1) = GOUT(11)  
      FOR1(2) = GOUT(15)  
      FOR2(1) = GOUT(12)  
      FOR2(2) = GOUT(16)  
      FOR4(1) = GOUT(14)  
      FOR4(2) = GOUT(18)  
      IF(METRIC.EQ.1) THEN  
                      FOR3(1) = GOUT(13)  
                      FOR3(2) = GOUT(17)  
                      ELSE  
                      FOR3(1) = GOUT(19)  
                      FOR3(2) = GOUT(20)  
                      ENDIF  
      I        = 0  
      DO 680 N = 1,NOG  
      IF(WTYPE(N).EQ.-1) GO TO 680  
      I = I + 1  
      IF(I.EQ.1.OR.MOD(I,50).EQ.0) THEN  
                                   WRITE(N6,625)  
                                   WRITE(N6,FOR1)  
                                   WRITE(N6,FOR2)  
                                   WRITE(N6,FOR3)  
                                   WRITE(N6,FOR4)  
                                   ENDIF  
      N1 = WTYPE(N) + 1  
C#### WCH (RED), 9/93.  METRIC CORRECTION FOR WELEV.  
C#### RED (WCH), 12/31/93.  UNDO CORRECTION.  UNNECESSARY BECAUSE  
C####                       CONVERTED WELEV AFTER WRITE STATEMENTS.  
      IF(JCE.EQ.0) WRITE(N6,635) N,NAMEG(N),NGTO(N),  
     +             CTYPE(N1),WELEV(N),WDIS(N),SPILL(N)  
      IF(JCE.EQ.1) WRITE(N6,636) N,KAMEG(N),KGTO(N),  
     +             CTYPE(N1),WELEV(N),WDIS(N),SPILL(N)  
C#######################################################################  
C MOVE NEXT THREE STATEMENTS TO HERE TO CONVERT PARAMETERS AFTER  
C  PRINT-OUT. WCH, 8/28/92  
C#######################################################################  
      WELEV(N) = WELEV(N)*CMET(1,METRIC)  
      IF(WTYPE(N).EQ.2) SPILL(N) = SPILL(N)*CMET(1,METRIC)**2.0  
C#######################################################################  
C CORRECT ANGLE (SPILL) TO INPUT UNITS OF DEGREES.  WCH, 8/28/92  
C#######################################################################  
      IF(WTYPE(N).EQ.1) SPILL(N) =TAN(SPILL(N)/2.0*3.14159/180)  
 680  CONTINUE  
      ENDIF  
C=======================================================================  
C     Set up channel connectivity tables.  
C=======================================================================  
      INLETS = 0  
      IF(NOG.GT.0) THEN  
                   DO 720 N     = 1,NOG  
                   NN           = NOG + INLETS  
                   DO 690 NGOTO = 1,NN  
                   IF(JCE.EQ.0.AND.NGTO(N).EQ.NAMEG(NGOTO)) GO TO 700  
                   IF(JCE.EQ.1.AND.KGTO(N).EQ.KAMEG(NGOTO)) GO TO 700  
  690              CONTINUE  
C=======================================================================  
C                  Create dummy channels as needed  
C=======================================================================  
                   INLETS = INLETS + 1  
                   NGOTO  = NOG    + INLETS  
                   IF(NGOTO.GT.NG) CALL ERROR(13)  
                   IF(JCE.EQ.0) NAMEG(NGOTO) = NGTO(N)  
                   IF(JCE.EQ.1) KAMEG(NGOTO) = KGTO(N)  
                   NPG(NGOTO)    = 3  
                   NGTOI(INLETS) = NGOTO  
  700              CONTINUE  
                   DO 710 J = 1,NCP  
CIM### 9/8/00 trap for more than NCP gutters entering another gutter  
                   IF ((J.EQ.NCP).AND.(NGTOG(J,NGOTO).NE.0)) then  
                       write(*,*) 'warning more than',ncp,  
     1                 ' gutters entering a junction'  
                       if (JCE.EQ.0) then  
                           write(*,701) NAMEG(NGOTO)  
                           else  
                           write(8,702) KAMEG(NGOTO)  
                           endif  
  701 FORMAT(' RECEIVING GUTTER ',i10)  
  702 FORMAT(' RECEIVING GUTTER ',A10)  
                       STOP 'TOO MANNY GUTTERS ENTERING ANOTHER GUTTER'  
                       ENDIF  
CIM  
                   IF(NGTOG(J,NGOTO).GT.0) GO TO 710  
                   NGTOG(J,NGOTO) = N  
                   GO TO 720  
  710              CONTINUE  
C#### WCH, 12/11/96.  ADD ERROR MESSAGE HERE IF EXCEED NCP CONNECTIONS.  
                   IF(JCE.EQ.0) WRITE(N6,8910) NCP,NAMEG(NGOTO),NAMEG(N)  
                   IF(JCE.EQ.1) WRITE(N6,8911) NCP,KAMEG(NGOTO),KAMEG(N)  
                   WRITE (N6,8912) NCP  
                   WRITE (*,8912) NCP  
                   STOP 'See error message in output file.'  
  720              CONTINUE  
                   ENDIF  
C=======================================================================  
C     Read subcatchment information from Subroutine CATCH.  
C=======================================================================  
      WRITE(*,9010)  
      CALL CATCH(TRIBA)  
C=======================================================================  
C     Set up connectivity tables.  
C  
Cwch, 12/20/00.  Do not add inlet if subcat flow goes to another subcat.  
C     If IFLOWP(N).ge.3, outflow is to another subcatchment.   
C=======================================================================  
      DO 940 N     = 1,NOW  
	IF(IFLOWP(N).GE.3) GO TO 940  
      NN           = NOG + INLETS  
      DO 910 NGOTO = 1,NN  
      IF(JCE.EQ.0.AND.NGTO(N).EQ.NAMEG(NGOTO)) GO TO 920  
      IF(JCE.EQ.1.AND.KGTO(N).EQ.KAMEG(NGOTO)) GO TO 920  
  910 CONTINUE  
C=======================================================================  
C     Identify additional inlets.  
C=======================================================================  
      INLETS        = INLETS+1  
      NGOTO         = NOG + INLETS  
CIM### 9/8/00 ADDED CHECK FOR NGOTO HERE ALSO  
                   IF(NGOTO.GT.NG) CALL ERROR(13)  
      IF(JCE.EQ.0) NAMEG(NGOTO)  = NGTO(N)  
      IF(JCE.EQ.1) KAMEG(NGOTO)  = KGTO(N)  
      NPG(NGOTO)    = 3  
      NGTOI(INLETS) = NGOTO  
      IF(NGOTO.GT.NG) CALL ERROR(13)  
  920 CONTINUE  
C=======================================================================  
C     Channel connection.  
C=======================================================================  
      DO 930 J = 1,NCP  
      IF(NWTOG(J,NGOTO).GT.0) GO TO 930  
      NWTOG(J,NGOTO) = N  
      GO TO 940  
  930 CONTINUE  
C#### WCH, 12/11/96.  ADD ERROR MESSAGE HERE IF EXCEED NCP CONNECTIONS.  
      IF(JCE.EQ.0) WRITE(N6,8920) NCP,NAMEG(NGOTO),NAMEW(N)  
      IF(JCE.EQ.1) WRITE(N6,8921) NCP,KAMEG(NGOTO),KAMEW(N)  
      WRITE (N6,8912) NCP  
      WRITE (*,8912) NCP  
      STOP ' See error message in output file.'  
  940 CONTINUE  
C=======================================================================  
Cwch, 12/20/00. Here perform similar connectivity effort for   
C     subcatchment to subcatchment flow.   
C=======================================================================  
	ICERR = 0  
      DO 946 N     = 1,NOW  
	IF(IFLOWP(N).LE.2) GO TO 946  
		DO NNN = 1,NOW  
		NWTOTO = NNN  
          IF(JCE.EQ.0.AND.NGTO(N).EQ.NAMEW(NNN)) GO TO 944  
          IF(JCE.EQ.1.AND.KGTO(N).EQ.KAMEW(NNN)) GO TO 944  
          ENDDO  
C=======================================================================  
C  Here, error, no matching name for NGTO.  
C=======================================================================  
	IF(JCE.EQ.0) WRITE(N6,9900) NGTO(N),NAMEW(N)  
	IF(JCE.EQ.1) WRITE(N6,9901) KGTO(N),KAMEW(N)  
	WRITE (*,9905)  
	ICERR = 1  
	GO TO 946  
C=======================================================================  
C  Establish connectivity with Subcat.   
C=======================================================================  
  944	DO 945 J = 1,NCP  
	IF(NWTOW(J,NWTOTO).GT.0) GO TO 945  
      NWTOW(J,NWTOTO) = N  
      GO TO 946  
  945 CONTINUE  
C=======================================================================  
C  Error, exceed NCP dimension.  
C=======================================================================  
      IF(JCE.EQ.0) WRITE(N6,9920) NCP,NAMEW(NWTOTO)  
      IF(JCE.EQ.1) WRITE(N6,9921) NCP,KAMEW(NWTOTO)  
      WRITE (N6,8912) NCP  
      WRITE (*,8912) NCP  
      ICERR = 1  
  946 CONTINUE  
	IF(ICERR.EQ.1) THEN  
		STOP ' Error in subcat to subcat connectivity.  See output fil  
     +e.'  
	    ENDIF  
C=======================================================================  
C     Print connectivity summary.  
C=======================================================================  
      WRITE(N6,950)  
      IF(NOG.GT.0) THEN  
                   WRITE(N6,960)  
                   DO 1100 J = 1,NOG  
                   IF(MOD(J,25).EQ.0) THEN  
                                      WRITE(N6,950)  
                                      WRITE(N6,960)  
                                      ENDIF  
                   DO 990 N = 1,NCP  
                   IF(NGTOG(N,J)) 980,1000,980  
  980              INUM    = NGTOG(N,J)  
                   IF(JCE.EQ.0) NGTO(N) = NAMEG(INUM)  
                   IF(JCE.EQ.1) KGTO(N) = KAMEG(INUM)  
  990              CONTINUE  
 1000              N = N-1  
                   IF(JCE.EQ.0.AND.N.LE.0) WRITE(N6,1030) NAMEG(J)  
                   IF(JCE.EQ.1.AND.N.LE.0) WRITE(N6,1031) KAMEG(J)  
                   IF(JCE.EQ.0.AND.N.GT.0) WRITE(N6,1170)  
     +                                     NAMEG(J),(NGTO(K),K=1,N)  
                   IF(JCE.EQ.1.AND.N.GT.0) WRITE(N6,1171)  
     +                                     KAMEG(J),(KGTO(K),K=1,N)  
                   DO 1060 N = 1,NCP  
                   IF(NWTOG(N,J)) 1050,1070,1050  
 1050              INUM    = NWTOG(N,J)  
                   IF(JCE.EQ.0) NGTO(N) = NAMEW(INUM)  
                   IF(JCE.EQ.1) KGTO(N) = KAMEW(INUM)  
 1060              CONTINUE  
 1070              N = N-1  
                   IF(N.EQ.0) WRITE(N6,1090)  
                   IF(JCE.EQ.0.AND.N.GT.0) WRITE(N6,1095)(NGTO(K),K=1,N)  
                   IF(JCE.EQ.1.AND.N.GT.0) WRITE(N6,1096)(KGTO(K),K=1,N)  
 1100              CONTINUE  
                   ENDIF  
      WRITE(N6,1120)  
C-----------------------------------------------------------------------  
      DO 1180 I = 1,INLETS  
      N         = NGTOI(I)  
      JG        = 0  
      JW        = 10  
      DO 1160 J = 1,NCP  
      IF(NGTOG(J,N).NE.0) THEN  
                          JG       = JG+1  
                          INUM     = NGTOG(J,N)  
                          IF(JCE.EQ.0) NGTO(JG) = NAMEG(INUM)  
                          IF(JCE.EQ.1) KGTO(JG) = KAMEG(INUM)  
                          ENDIF  
      IF(NWTOG(J,N).NE.0) THEN  
                          JW       = JW+1  
                          INUM     = NWTOG(J,N)  
                          IF(JCE.EQ.0) NGTO(JW) = NAMEW(INUM)  
                          IF(JCE.EQ.1) KGTO(JW) = KAMEW(INUM)  
                          ENDIF  
 1160 CONTINUE  
      IF(JCE.EQ.0.AND.JG.EQ.0) WRITE(N6,1030) NAMEG(N)  
      IF(JCE.EQ.1.AND.JG.EQ.0) WRITE(N6,1031) KAMEG(N)  
      IF(JCE.EQ.0.AND.JG.GT.0) WRITE(N6,1170) NAMEG(N),(NGTO(J),J=1,JG)  
      IF(JCE.EQ.1.AND.JG.GT.0) WRITE(N6,1171) KAMEG(N),(KGTO(J),J=1,JG)  
      IF(JW.EQ.10) WRITE(N6,1090)  
      IF(JCE.EQ.0.AND.JW.GT.10) WRITE(N6,1095) (NGTO(J),J=11,JW)  
C#### WCH, 11/30/93.  CHANGE NGTO TO KGTO HERE.  
      IF(JCE.EQ.1.AND.JW.GT.10) WRITE(N6,1096) (KGTO(J),J=11,JW)  
 1180 CONTINUE  
C=======================================================================  
C     Read information to control inlets saved and printed.  
C=======================================================================  
      NSAVE     = INLETS  
      DO 1190 J = 1,INLETS  
      N         = NGTOI(J)  
      IF(JCE.EQ.0) ISAVE(J) = NAMEG(N)  
 1190 IF(JCE.EQ.1) KSAVE(J) = KAMEG(N)  
      IF(JCE.EQ.0) WRITE(N6,1200) INLETS,(ISAVE(K),K=1,INLETS)  
      IF(JCE.EQ.1) WRITE(N6,1201) INLETS,(KSAVE(K),K=1,INLETS)  
C=======================================================================  
C     Set up header for subsurface information to be graphed.  
C=======================================================================  
C     IF(NSVGW.GT.0) THEN  
C                    LKOUN  = 0  
C                    DO 1206 JF = 1,NOGWSC  
C                    IF(NSCSFG(JF).EQ.0) GO TO 1206  
C                    LKOUN         = LKOUN+1  
C                    NSSVFG(LKOUN) = NSCSFG(JF)  
C1206                CONTINUE  
C                    ENDIF  
C=======================================================================  
C     Snow melt data for each catchment.  
C=======================================================================  
      IF(ISNOW.GT.0) THEN  
                     WRITE(*,9030)  
                     CALL SNOWIN(1)  
                     ENDIF  
      RETURN  
  888 CALL IERROR  
C=======================================================================  
   14 FORMAT(//,20X,A80,//,20X,A80,/)  
   31 FORMAT(//,1X,'Snowmelt parameter - ISNOW.......................',  
     2 T57,I5,// ,1X,'Number of rain gages - NRGAG.....................'  
     4 ,T57,I5)  
   32 FORMAT(/,' Horton infiltration equation used - INFILM.......',  
     1 T57,I5)  
   33 FORMAT (/,1X,'Green-Ampt infiltration equation used - INFILM...',  
     1 T57,I5)  
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
  321 FORMAT(/,' Horton infiltration equation used - INFILM.......',  
     1 T57,I5,/,  
     2' Maximum infiltration volume is limited to RMAXINF input on ',  
     3' subcatchment lines.  Infiltration volume regenerates during ',  
     4' non rainfall periods.')  
  331 FORMAT (/,1X,'Green-Ampt infiltration equation used - INFILM...',  
     1 T57,I5,/,  
     2' Maximum infiltration volume is limited to RMAXINF input on ',  
     3' subcatchment lines.  Does not regenerate. ')  
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
   34 FORMAT(/,1X,'Quality is simulated - KWALTY....................',  
     1 T57,I5)  
   35 FORMAT (/,1X,'Quality is not simulated - KWALTY................',  
     1 T57,I5)  
   36 FORMAT(/,1X,'Default evaporation rate used - IVAP.............',  
     1  T57,I5)  
   37 FORMAT(/,1X,'Read evaporation data on line(s) F1 (F2) - IVAP..',  
     1  T57,I5)  
   38 FORMAT(/,1X,'Hour of day at start of storm - NHR..............',  
     1 T57,I5,//,1X,'Minute of hour at start of storm - NMN...........',  
     2 T57,I5)  
   39 FORMAT(/,' Time TZERO at start of storm (hours).............',  
     1 F11.3)  
   40 FORMAT(/,' Runoff input print control...',T57,I5,  
     1      //,' Runoff graph plot control....',T57,I5,  
     2      //,' Runoff output print control..',T57,I5)  
C#### WCH, 10/5/93.  
   41 FORMAT(/,1X,'IVAP is negative.  Evaporation will be set to zero'  
     1 ,/,'     during time steps with rainfall.')  
   45 FORMAT(/,1x,'IVCHAN equals 1.  Evaporation is not allowed from '  
     1,' channels or conduits.')  
C#### WCH, 10/5/93.  
   42 FORMAT(/,1X,'Input evaporation data on NSCRAT(3) from the',/,  
     1           ' Temp Block - IVAP................................',  
     2  T57,I5)  
   48 FORMAT(/,' Use U.S. Customary units for most I/O - METRIC...',  
     1 T57,I5)  
   49 FORMAT(/,' Use Metric units for I/O - METRIC................',  
     1 T57,I5,/,'  ===> Ft-sec units used in all internal computations')  
  162 FORMAT (/,' Month, day, year of start of storm is: ',  
     1 12X,2(I2,'/'),I4)  
  160 FORMAT(/,1X,  
     +  'Wet time step length (seconds).......',T52,F10.0,//,1X,  
     +  'Dry time step length (seconds).......',T52,F10.0,//,1X,  
     +  'Wet/Dry time step length (seconds)...',T52,F10.0)  
  165 FORMAT(/,1X,'Simulation length is......',T52,F10.1,A10)  
  174 FORMAT(/,' Percent of impervious area with zero detention',  
     .       ' depth',3X,F5.1)  
CIM### 9/8/00 modify format to include space  
  180 FORMAT(/,1X,'Horton infiltration model being used',/,' Rate for ',  
     1'regeneration of infiltration = REGEN * DECAY'  
     1,/,' DECAY is read in for each subcatchment',/,  
     2   ' REGEN = ............................................'  
     3   ,T52,F10.5,/,1H1)  
  550 FORMAT(/,  
     +'   #############################',/,  
     +'   #        Data Group F1      #',/,  
     +'   # Evaporation Rate (in/day) #',/,  
     +'   #############################',//,  
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV  
     +.  DEC.',/,  
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---  
     +-  ----',/,12F6.2)  
  551 FORMAT(/,  
     +'   ##############################',/,  
     +'   #        Data Group F1       #',/,  
     +'   # Evaporation Rate (in/month)#',/,  
     +'   ##############################',//,  
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV  
     +.  DEC.',/,  
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---  
     +-  ----',/,12F6.2)  
  555 FORMAT(/,  
     +'   #############################',/,  
     +'   #        Data Group F1      #',/,  
     +'   # Evaporation Rate (mm/day) #',/,  
     +'   #############################',//,  
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV  
     +.  DEC.',/,  
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---  
     +-  ----',/,12F6.2)  
  556 FORMAT(/,  
     +'   ###############################',/,  
     +'   #        Data Group F1        #',/,  
     +'   # Evaporation Rate (mm/month) #',/,  
     +'   ###############################',//,  
     1'  JAN.  FEB.  MAR.  APR.  MAY   JUN.  JUL.  AUG.  SEP.  OCT.  NOV  
     +.  DEC.',/,  
     +'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---  
     +-  ----',/,12F6.2)  
  600 FORMAT(//,  
     +' ************************************************',/,  
     +' *          No Channel or Pipe Network          *',/,  
     +' ************************************************',//)  
  620 FORMAT(/,1H1,/  
     +' *********************************************************',/,  
     +' *         C H A N N E L  A N D  P I P E  D A T A        *',/,  
     +' *********************************************************',/)  
  625 FORMAT(/,1H1,/  
     +' **********************************************************',/,  
     +' *       C O N T R O L  S T R U C T U R E   D A T A       *',/,  
     +' **********************************************************',/)  
  630 FORMAT(1X,I3,1X,I10,1X,I10,1X,A9,F6.1,F8.1,F10.4,  
     1                             F9.4,F8.4,2F8.1,F8.4,1PE9.2)  
  631 FORMAT(1X,I3,1X,A10,1X,A10,1X,A9,F6.1,F8.1,F10.4,  
     1                             F9.4,F8.4,2F8.1,F8.4,1PE9.2)  
  635 FORMAT(1X,I3,1X,I10,1X,I10,1X,A12,F7.1,F12.3,5X,F12.4)  
  636 FORMAT(1X,I3,1X,A10,1X,A10,1X,A12,F7.1,F12.3,5X,F12.4)  
Cwch, 12/20/00  
  950 FORMAT(/,1H1,/  
     1' *********************************************************',/,  
     2' *    Arrangement of Subcatchments and Channel/Pipes     *',/,  
     3' *********************************************************',/,  
     4' * See second subcatchment output table for connectivity *',/,  
     5' * of subcatchment to subcatchment flows.                *',/,  
     6' *********************************************************')  
  960 FORMAT(//,4X,'Channel',/,4X,'or Pipe')  
 1030 FORMAT(1X,I10,5X,'No Tributary Channel/Pipes')  
 1031 FORMAT(1X,A10,5X,'No Tributary Channel/Pipes')  
 1090 FORMAT(    16X,'No Tributary Subareas.....')  
 1095 FORMAT(    16X,'Tributary Subareas........',5(1X,I10))  
 1096 FORMAT(    16X,'Tributary Subareas........',5(1X,A10))  
 1120 FORMAT(//,2X,'   INLET')  
 1170 FORMAT(1X,I10,5X,'Tributary Channel/Pipes...',5(1X,I10))  
 1171 FORMAT(1X,A10,5X,'Tributary Channel/Pipes...',5(1X,A10))  
 1200 FORMAT(//,  
     1' ***********************************************************',/,  
     2' * Hydrographs will be stored for the following',I4,' INLETS *',  
     3/,' ***********************************************************',  
     4 /,(5X,6I10))  
 1201 FORMAT(//,  
     1' ***********************************************************',/,  
     2' * Hydrographs will be stored for the following',I4,' INLETS *',  
     3/,' ***********************************************************',  
     4 /,(1X,6A10))  
 5505 FORMAT(/,  
     1'   ###############################',/,  
     2'   #        Data Group F2        #',/,  
     3'   # Evaporation Rate (in/month) #',/,  
     4'   ###############################',//,  
     5'  Year  Jan.  Feb.  Mar.  Apr.  May   June  July  Aug.  Sep.  Oct  
     6.  Nov. Dec.',/,  
     7'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---  
     8   ---- ----')  
 5506 FORMAT(/,  
     +'   ###############################',/,  
     +'   #        Data Group F2        #',/,  
     +'   # Evaporation Rate (mm/month) #',/,  
     +'   ###############################',//,  
     1'  Year  Jan.  Feb.  Mar.  Apr.  May   June  July  Aug.  Sep.  Oct  
     2.  Nov. Dec.',/,  
     1'  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ---  
     2-  ---- ----')  
 5510 FORMAT(I6,12F6.2)  
 8900 FORMAT(/,' ===> Error   There was no G2 data line for Channel/Pi  
     +pe number ',I10,/)  
 8901 FORMAT(/,' ===> Error   There was no G2 data line for Channel/Pi  
     +pe name ',A10,/)  
C#### WCH, 12/11/96.  
 8910 FORMAT(/,' ERROR MAXIMUM OF',I3,' CHANNEL/PIPE CONNECTIONS TO ANO  
     1THER',/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',I10,/,  
     2' BY CHANNEL/PIPE',I10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C  
     3ONNECTIONS.')  
 8911 FORMAT(/,' ERROR MAXIMUM OF',I3,' CHANNEL/PIPE CONNECTIONS TO ANO  
     1THER',/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',A10,/,  
     2' BY CHANNEL/PIPE',A10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C  
     3ONNECTIONS.')  
 8912 FORMAT(' Run stopped due to exceeding maximum no. connections, NCP  
     1 =',I3)  
 8920 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO A'  
     1,/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',I10,/,  
     2' BY SUBCATCHMENT',I10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C  
     3ONNECTIONS.')  
 8921 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO A'  
     1,/,' CHANNEL/PIPE/INLET EXCEEDED FOR CH/PIPE/INLET',A10,/,  
     2' BY SUBCATCHMENT',A10,'. SUGGEST USING DUMMY PIPE TO ALLOW MORE C  
     3ONNECTIONS.')  
Cwch, 2/12/01.  
 8925 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name (  
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',I10)  
 8926 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name (  
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',I10,/,  
	2' Run stopped from Runoff Block input routine RHYDRO1.')  
 8930 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name (  
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',A10)  
 8931 FORMAT(/' ERROR on G1 line Cannot have channel/pipe number/name (  
     1NAMEG) same as flow destination (NGTO), for channel/pipe: ',A10,/,  
	2' Run stopped from Runoff Block input routine RHYDRO1.')  
C  
 9010 FORMAT(/,' Reading subcatchment information.')  
 9030 FORMAT(/,' Reading subcatchment snowmelt information.')  
 9040 FORMAT(/,' Reading channel/pipe information.')  
 9050 FORMAT(/,' Reading snowmelt information.')  
 9060 FORMAT(/,' Reading rainfall information.')  
C##### WCH, 12/92  
 9070 FORMAT(/,' Limit number of groundwater convergence messages to ',  
     +I5,' (if simulated)')  
Cwch, 12/20/00.   
 9072 FORMAT(/,1X,'Print headers every 50 lines - NOHEAD (0=yes, 1=no)',  
     1 T57,I5)  
 9074 FORMAT(/,1X,'Print land use load percentages -LANDUPR (0=no, 1=yes  
     1)',T57,I5)  
Cwch, 12/20/00  
 9900 FORMAT(' ERROR CANNOT FIND CORRESPONDING SUBCATCHMENT ',I10,' (NG  
     1TO) FOR',/,  
	2' SURFACE FLOW FROM SUBCATCHMENT ',I10,'. RUN WILL STOP.')  
 9901 FORMAT(' ERROR CANNOT FIND CORRESPONDING SUBCATCHMENT ',A10,' (NG  
     1TO) FOR',/,  
	2' SURFACE FLOW FROM SUBCATCHMENT ',A10,'. RUN WILL STOP.')  
 9905 FORMAT (' Error Run will stop due to connectivity error.')  
 9920 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO ANO  
     1THER',/,  
     2' SUBCATCHMENT EXCEEED FOR SUBCATCHMENT',I10,/,  
     4' MUST REDUCE THE NUMBER OF SURFACE CONNECTIONS TO THIS SUBCAT.')  
 9921 FORMAT(/,' ERROR MAXIMUM OF',I3,' SUBCATCHMENT CONNECTIONS TO ANO  
     1THER',/,  
     2' SUBCATCHMENT EXCEEED FOR SUBCATCHMENT',A10,/,  
     4' MUST REDUCE THE NUMBER OF SURFACE CONNECTIONS TO THIS SUBCAT.')  
Cwch, 2/7/01  
 9925 FORMAT(' WARNING FOR PIPE ',I10,' INITIAL DEPTH ',F7.2,' > DIAMET  
     1ER ',F7.2,'. SET = DIAMETER AND CONTINUE.')  
 9926 FORMAT(' WARNING FOR PIPE ',A10,' INITIAL DEPTH ',F7.2,' > DIAMET  
     1ER ',F7.2,'. SET = DIAMETER AND CONTINUE.')  
 9930 FORMAT(' WARNING FOR CHANNEL ',I10,' INITIAL DEPTH ',F7.2,' > MAX  
     1 ',F7.2,'. SET = MAX AND CONTINUE.')  
 9931 FORMAT(' WARNING FOR CHANNEL ',A10,' INITIAL DEPTH ',F7.2,' > MAX  
     1 ',F7.2,'. SET = MAX AND CONTINUE.')  
C=======================================================================  
      END  
ECHO is off.
REM File: ROUTE.FOR  
ECHO is off.
      SUBROUTINE ROUTE(DELQ,WSLOPE)  
C     TRANSPORT BLOCK  
C     CALLED BY DWLOAD NEAR LINE 170  
C               INITAL NEAR LINE 195  
C               TRANS NEAR LINE 511  
C=======================================================================  
C     ROUTING SUBPROGRAM FOR FLOW THROUGH SEWER ELEMENTS.  
C     IN THE PROGRAM, ALPHA REPRESENTS NORMALIZED AREA, A/AFULL.  
C                     PSI AND PS REPRESENT NORMALIZED FLOW, Q/QFULL.  
C=======================================================================  
C     UPDATED SEPTEMBER 1981 BY W.C.H. AND S.J.N.  
C     UPDATED SEPTEMBER 1988 BY R.E.D.  
C     UPDATED SEPTEMBER 1989 BY R.E.D.  
C     UPDATED AUGUST 1993 BY CHARLES I. MOORE, CDM, ANNANDALE, VA FOR  
C       INSTALLATION OF TYPE 26 TABULAR FLOW DIVIDER.  INSTALLED BY  
C       WCH.  
C     CHECK ON VALUE OF DH, 9/23/93.  WCH (RED).  
C     USE STORE() INSTEAD OF STORL() FOR BACKWATER ELEMENT, WCH, 10/6/93.  
C     ADD PROBABLY UNNECESSARY CHECK ON RANGE FOR L, WCH, 10/6/93.  
C     SET DEFALUT VALUE FOR QO2(M) BEFORE IF STMT, RED, 12/31/93.  
C     Changes to have additional level of detail in TRANSPORT irregular  
C       section calculations.  CIM 9/8/00  
C     Use QCURVE(4), not (3), for flow. No change to QCURV2. WCH, 7/6/01.  
C     Use parameter QMINRTE for minimum flow for flow routing. Also  
C       go through same extra effort for power function channels, types  
C       14 and 15 as for natural channels, type 16 since all can have  
C       IDETAIL = 1. WCH 3/14/02.   
C     Move a couple of error prints to better location. WCH (LR),   
C       6/11/02.  
C     Correction to QCURVE2 index. WCH (CIM), 7/20/04.  
C=======================================================================  
C     MEANING OF A AND Q ARRAY DIMENSIONS, E.G., A(M,1,2):  
C     A OR Q(CHANNEL,1-UPSTREAM 2-DOWNSTREAM,  
C                    1-START OF TIME STEP 2-END OF TIME STEP)  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'TABLES.INC'  
      INCLUDE 'NAMES.INC'  
      INCLUDE 'HUGO.INC'  
      INCLUDE 'NEW81.INC'  
      INCLUDE 'TST.INC'  
      INCLUDE 'FLODAT.INC'  
      INCLUDE 'FSPLIT.INC'  
CIM### 9/8/00 add NEWTR  
      INCLUDE 'NEWTR.INC'  
      DIMENSION QI(NET),QO(NET),WELL1(NET),WELL2(NET),PUMP(NET),  
     +          QO1(NET),QO2(NET)  
      CHARACTER BMJ*10  
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2)),(PUMP(1),DIST(1))  
      EQUIVALENCE (QO1(1),QMAX(1)),(QO2(1),QFULL(1))  
      EQUIVALENCE (WELL1(1),SLOPE(1)),(WELL2(1),ROUGH(1))  
      DATA WT/0.60/,WD/0.60/  
      DATA NUMERR/0/  
Cwch 3/14/02. Set flows and areas to zero for Q < 0.00001 cfs.   
      DATA QMINRTE/1E-5/  
C=======================================================================  
C     USE GENERALIZED WEIGHTS OF TIME AND SPACE DERIVATIVES OF  
C     CONTINUITY EQUATION.  
C     WT = WEIGHT ON TIME DERIVATIVE.  
C     WD = WEIGHT ON SPATIAL DERIVATIVE.  
C          THESE CONSTANTS APPEAR IN DEFINITIONS OF C1(M) AND C2.  
C     NOTE, WT  = WD = 0.50 CORRESPOND TO ORIGINAL VERSION OF TRANSPORT MODEL.  
C           WT  = WD = 0.55 APPEAR TO GIVE BEST ATTENUATION OF HYDROGRAPHS.  
C     M         = ELEMENT NUMBER  
C     KLASS(NTPE) = 1 FOR CONDUIT WITH FUNCTIONAL Q-A RELATIONSHIP.  
C     KLASS(NTPE) = 2 FOR CONDUIT WITH TABULAR Q-A RELATIONSHIP.  
C     KLASS(NTPE) = 3 FOR ELEMENT OTHER THAN CONDUIT.  
C                   COMPUTE TOTAL HEAD SLOPE AND ASSOCIATED PARAMETERS.  
C     KFULL = 1 IF CONDUIT IS FULL AT UPSTREAM END.  
C     KFULL = 2 IF CONDUIT IS NOT FULL AT UPSTREAM END.  
C=======================================================================  
      NTPE   = NTYPE(M)  
      K      = KLASS(NTPE)  
C=======================================================================  
C     PRINT OF ERRORS STOPS WHEN NUMBER OF ERRORS EXCEED 50  
C=======================================================================  
      IF(NUMERR.EQ.50.AND.NPRINT.GT.0) THEN  
                                        NUMERR = NUMERR + 1  
                                        WRITE(N6,930)  
                                        ENDIF  
C=======================================================================  
C     NO ITERATIONS REQUIRED FOR CONDUITS WITH SURCHARGED FLOW.  
C     NO ITERATIONS REQUIRED FOR CONDUITS WITH SUPER-CRITICAL FLOW.  
C=======================================================================  
      IF(K.LE.2)     THEN  
           IF(KFULL.EQ.1) THEN  
                  C1(M)   = AFULL(M)/QFULL(M)*DXDT(M)*WT/WD  
                  QMAX(M) = P4(M)*QFULL(M)  
                  WSLOPE  = SLOPE(M)  
                  DELQ    = 0.0  
                  ELSE  
                  IF(SCF(M).NE.GNO) THEN  
                            ITER    = 0  
                            WSLOPE  = SLOPE(M)  
                            DELQ    = 0.0  
                            ELSE  
C=======================================================================  
C                           NON-SUPERCRITICAL FLOW  
C=======================================================================  
                            IF(ITER.LE.NITER) THEN  
                               QOLD = QFULL(M)  
                               A1   = A(M,1,1)/AFULL(M)  
                               A2   = A(M,2,1)/AFULL(M)  
                               DV   = (VEL(Q(M,1,1),A(M,1,1))**2 -  
     +                                 VEL(Q(M,2,1),A(M,2,1))**2)  
     +                                /DIST(M)/64.4  
                               WSLOPE = SLOPE(M) + P2(M)*(DEPTH(A1) -  
     +                                  DEPTH(A2)) + DV  
                               ELSE  
                               A1 = A(M,1,2)/AFULL(M)  
                               A2 = A(M,2,2)/AFULL(M)  
                               DV = (VEL(Q(M,1,2),A(M,1,2))**2 -  
     +                               VEL(Q(M,2,2),A(M,2,2))**2)  
     +                              /DIST(M)/64.4  
                               WSLOPE = SLOPE(M) + P2(M)*(DEPTH(A1) -  
     +                                  DEPTH(A2)) + DV  
                               ENDIF  
C=======================================================================  
                            IF(WSLOPE.LE.SLOPE(M)) WSLOPE = SLOPE(M)  
                                                OMEGA = 0.50  
                            IF(ITER.GT.NITER+3) OMEGA = 0.33  
                            QFULL(M) = P1(M)*SQRT(WSLOPE)  
                            QFULL(M) = (1.0-OMEGA)*QOLD+OMEGA*QFULL(M)  
                            DELQ     = ABS(QFULL(M)-QOLD)  
                            QOLD     = QFULL(M)  
                            IF(DELQ.LT.EPSIL*QFULL(M)) ITER = 0  
                            IF(ITER-NITER.GE.NITER-1)  ITER = 0  
                            C1(M)   = AFULL(M)/QFULL(M)*DXDT(M)*WT/WD  
                            QMAX(M) = P4(M)*QFULL(M)  
                            ENDIF  
C=======================================================================  
                  ENDIF  
           ENDIF  
C=======================================================================  
C     ROUTINE FOR CONDUIT WITH FUNCTIONAL Q-A RELATIONSHIP.  
C     FIND NEW UPSTREAM AREA.  
C=======================================================================  
      IF(K.EQ.1) THEN  
Cwch 3/14/02.  Use QMINRTE for minimum flow for routing, not 1E-20.   
      IF(QI(M).EQ.0.0.AND.Q(M,2,1).LE.QMINRTE) THEN  
                                               A(M,2,2) = 0.0  
                                               Q(M,2,2) = 0.0  
                                               RETURN  
                                               ENDIF  
      IF(KFULL.EQ.1) THEN  
                     A(M,1,2) = AFULL(M)  
                     ELSE  
                     C2    = -Q(M,1,2)/QFULL(M)  
                     ALPHA = A(M,1,1)/AFULL(M)  
                     CALL NEWTON(ALPHA,PS,0.0,C2,KFLAG)  
                     IF(KFLAG.EQ.2) THEN  
                              NUMERR = NUMERR + 1  
                              IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN  
                                 IF(JCE.EQ.0) WRITE(N6,910)  
     +                                        TIME,N,NOE(M),A(M,1,1)  
                                 IF(JCE.EQ.1) WRITE(N6,911)  
     +                                        TIME,N,KOE(M),A(M,1,1)  
                                 ENDIF  
                              ALPHA = A(M,1,1)/AFULL(M)  
                              ENDIF  
                     A(M,1,2) = ALPHA*AFULL(M)  
                     ENDIF  
C=======================================================================  
C     ASSIGN VALUES TO CONSTANTS AND SOLVE FOR DOWNSTREAM Q AND A.  
C=======================================================================  
      C2    = (1.0-WD)*Q(M,2,1)-(1.0-WD)*Q(M,1,1)-WD*Q(M,1,2)  
      C2    = C2 + DXDT(M)*((1.0-WT)*A(M,1,2) -  
     +                      (1.0-WT)*A(M,1,1)-WT*A(M,2,1))  
      C2    = C2/QFULL(M)/WD  
      ALPHA = A(M,2,1)/AFULL(M)  
C=======================================================================  
C     DOWNSTREAM Q AND A MAY NOW BE CALCULATED.  
C=======================================================================  
      CALL NEWTON(ALPHA,PS,C1(M),C2,KFLAG)  
      IF(KFLAG.EQ.1) THEN  
                     A(M,2,2) = ALPHA*AFULL(M)  
                     Q(M,2,2) = PS*QFULL(M)  
                     RETURN  
                     ENDIF  
C=======================================================================  
C     DETERMINE REASON FOR NON-CONVERGENCE.  
C     THEN USE DEFAULT OPTIONS TO DETERMINE Q AND A.  
C  
C     SEE IF LINE-C1*ALPHA-C2 INTERSECTS Q-A CURVE.  
C     CONTINUITY EQUATION TRIES TO FORCE Q.GT.QMAX.  
C     LET DOWNSTREAM FLOW BE QFULL UNLESS UPSTREAM Q IS GT QFULL.  
C=======================================================================  
      NUMERR = NUMERR + 1  
      IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN  
         WRITE(N6,900)  
         IF(JCE.EQ.0) WRITE(N6,901) TIME,NOE(M),QFULL(M),AFULL(M),  
     +                DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1),  
     +                A(M,1,2),A(M,2,1),ALPHA,PS,C2,N  
         IF(JCE.EQ.1) WRITE(N6,1901) TIME,KOE(M),QFULL(M),AFULL(M),  
     +                DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1),  
     +                A(M,1,2),A(M,2,1),ALPHA,PS,C2,N  
         ENDIF  
      IF((-C1(M)*ALFMAX(NTPE)-C2).GT.P4(M)) THEN  
Cwch, 6/11/02. (LR)  Error print should be here, not after ELSE below.  
C     Also, don't need another addition to error count?  
         IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,903)  
C                                  NUMERR = NUMERR + 1  
         IF(Q(M,1,2).GT.QFULL(M)) THEN  
                                  Q(M,2,2) = Q(M,1,2)  
                                  A(M,2,2) = A(M,1,2)  
                                  ELSE  
                                  Q(M,2,2) = QFULL(M)  
                                  A(M,2,2) = AFULL(M)  
                                  ENDIF  
         RETURN  
         ELSE  
C=======================================================================  
C     CONTINUITY EQUATION TRIES TO FORCE Q. LT. ZERO.  
C     LET DOWNSTREAM FLOW BE ZERO.  
C=======================================================================  
         IF(C2.GT.0.0) THEN  
                       NUMERR = NUMERR + 1  
                       IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,904)  
                       Q(M,2,2) = 0.0  
                       A(M,2,2) = 0.0  
                       RETURN  
                       ENDIF  
C=======================================================================  
C     REASON FOR NON-CONVERGENCE UNDETERMINED.  
C     LET NEW Q AND A EQUAL VALUES AT PREVIOUS TIME STEP.  
C=======================================================================  
         IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,902)  
                   NUMERR   = NUMERR + 1  
                   A(M,2,2) = A(M,2,1)  
                   Q(M,2,2) = Q(M,2,1)  
                   RETURN  
                   ENDIF  
      ENDIF  
C=======================================================================  
C     END OF IF-REALM FOR CONDUITS WITH FUNCTIONAL Q-A RELATIONSHIP.  
C  
C     ROUTINE FOR CONDUITS WITH TABULAR Q-A RELATIONSHIP.  
C=======================================================================  
      IF(K.EQ.2)   THEN  
Cwch 3/14/02.  Use QMINRTE for minimum flow for routing, not 1E-20.   
                   IF(QI(M).EQ.0.0.AND.Q(M,2,1).LE.QMINRTE) THEN  
                                               A(M,2,2) = 0.0  
                                               Q(M,2,2) = 0.0  
                                               RETURN  
                                               ENDIF  
Cwch, 3/14/02. Also need this for power function channels.   
           IF(NTPE.LE.16.AND.NTPE.GE.14) THEN  
                   KK     = NQC(M)  
                   DALPHA = 0.04  
                   MMM    = 26  
CIM### 9/8/00 CIMDETAIL detail cal for irregular sections  
                   IF(IDETAIL.EQ.1) THEN  
                        DALPH2 = 0.0016  
CIM MM = 26 + 26 -2 DUPLICATES (1 AND 26)  
                        MMM    = 50  
                        ENDIF  
                   ELSE    types other than 16  
                   DALPHA = ANORM(NTPE,2) - ANORM(NTPE,1)  
                   MMM    = MM(NTPE)  
                   ENDIF  
C=======================================================================  
C     CALCULATE UPSTREAM AREA.  
C=======================================================================  
           IF(KFULL.EQ.1) THEN  
                     A(M,1,2) = AFULL(M)  
                     ELSE  
                     PS = Q(M,1,2)/QFULL(M)  
                     CALL FINDA(PS,A(M,1,2))  
                     ENDIF  
C=======================================================================  
C     CALCULATE DOWNSTREAM Q AND A.  
C=======================================================================  
                                    ISIGN =  1  
           IF(A(M,1,2).LE.A(M,1,1)) ISIGN = -1  
           ICHK = 1  
           I    = IOLD(M)  
           C2   = (1.0-WD)*Q(M,2,1)-(1.0-WD)*Q(M,1,1)-WD*Q(M,1,2)  
           C2   = C2 + DXDT(M)*((1.0-WT)*A(M,1,2) -  
     +                     (1.0-WT)*A(M,1,1) - WT*A(M,2,1))  
           C2   = C2/QFULL(M)/WD  
C=======================================================================  
C     CALCULATE SLOPE OF LINE SEGMENT I OF Q-A CURVE.  
Cwch, 3/14/02.  Also do IDETAIL stuff for power function channels.   
C=======================================================================  
C     For parabolic, power function, and natural channels, NTPE=16.  
C     From Sub GETCUR:  
C     QCURVE(1)  = hydraulic radius  
C     QCURVE(2)  = area  
C     QCURVE(3)  = top width  
C     QCURVE(4)  = flow  
C     For detail at low water:  
C     QCURVE2(1) = hydraulic radius  
C     QCURVE2(2) = area  
C     QCURVE2(3) = flow  
C=======================================================================  
  120      IF(NTPE.LE.16.AND.NTPE.GE.14) THEN  
                   KK    = NQC(M)  
CIM### 9/8/00 DETAIL  First is normal case for type 16  
                 IF(IDETAIL.EQ.0) THEN  
                   SLUPE = (QCURVE(KK,4,I+1) - QCURVE(KK,4,I))/DALPHA  
                 ELSE  IDETAIL = 1  
CIM REFINED ESTIMATE FOR LOW FLOW  
                   IF (I.GE.26) THEN  
                    ICIM = I-24  
                    SLUPE = (QCURVE(KK,4,ICIM+1) - QCURVE(KK,4,ICIM))  
     1                      /DALPHA  
                   ELSE  
                    SLUPE = (QCURV2(KK,3,I+1) - QCURV2(KK,3,I))/DALPH2  
                   ENDIF  
                 ENDIF IDETAIL  
CIM### 9/8/00 DETAIL  
                   ELSE      this is types other than 16  
                   SLUPE = (QNORM(NTPE,I+1) - QNORM(NTPE,I))/DALPHA  
                   ENDIF  
           IF(SLUPE+C1(M).EQ.0.0) GO TO 130  
C=======================================================================  
C     COMPUTE ALPHA CORRESPONDING TO INTERSECTION OF LINE SEGMENT  
C     I OF Q-A CURVE WITH LINE -C1*ALPHA-C2.  
C     CHECK TO SEE IF ALPHA IS IN PROPER RANGE.  
Cwch, 3/14/02.  Also do extra stuff for power function channels.   
C=======================================================================  
           IF(NTPE.LE.16.AND.NTPE.GE.14) THEN  
                KK    = NQC(M)  
CIM### 9/8/00 DETAIL FIRST IS NORMAL CASE FOR IDETAIL = 0  
                IF (IDETAIL.EQ.0) THEN  
                  ALPHA = (-QCURVE(KK,4,I)-C2+SLUPE*FLOAT(I-1)*0.04) /  
     +                                     (SLUPE + C1(M))  
                  ELSE  
cim  refined low flow estimates 4/96  
                  IF (I.GE.26) THEN  
                    ICIM = I-24  
              ALPHA = (-QCURVE(KK,4,ICIM)-C2+SLUPE*FLOAT(ICIM-1)*0.04) /  
     +                                     (SLUPE + C1(M))  
                    ELSE  
CIM Here, should use 3, not 4.  
C                ALPHA = (-QCURV2(KK,4,I)-C2+SLUPE*FLOAT(I-1)*0.0016) /  
Cwch 7/20/04  
                ALPHA = (-QCURV2(KK,3,I)-C2+SLUPE*FLOAT(I-1)*0.0016) /  
     +                                     (SLUPE + C1(M))  
                    ENDIF  
                  ENDIF  
                ELSE    Types other than 16  
                ALPHA = (-QNORM(NTPE,I)-C2+SLUPE*ANORM(NTPE,I))/  
     1                                                    (SLUPE+C1(M))  
                ENDIF  
           IF(ALPHA.GT.1.0.OR.ALPHA.LT.0.0) GO TO 125  
           L  =  IFIX(ALPHA/DALPHA) + 1  
           IF(NTPE.LE.16.AND.NTPE.GE.14) THEN  
                IF(L.GT.25) L = 25  
                KK    = NQC(M)  
CIM### 9/8/00 DETAIL  
                IF(L.GE.2.OR.IDETAIL.EQ.0) THEN  
                  PS    = QCURVE(KK,4,L) + (ALPHA - FLOAT(L-1)*0.04 )/  
     1                   DALPHA * (QCURVE(KK,4,L+1) - QCURVE(KK,4,L))  
                  ELSE   DETAILED FOR LOWER PORTION OF CURVE  
                  L2 = IFIX(ALPHA/DALPH2) + 1  
              PS    = QCURV2(KK,3,L2) + (ALPHA - FLOAT(L2-1)*0.0016 )/  
     1                DALPH2 * (QCURV2(KK,3,L2+1) - QCURV2(KK,3,L2))  
                  ENDIF  
                ELSE   types other than 16  
C#### WCH, 10/6/93.  CHECK RANGE ON L.  IF AT MAX, USE QFULL.  
                IF(L.LT.MMM) THEN  
                    PS    = QNORM(NTPE,L) + (ALPHA-ANORM(NTPE,L))/DALPHA  
     1                          * (QNORM(NTPE,L+1) - QNORM(NTPE,L))  
                    ELSE  
                    PS    = QNORM(NTPE,MMM)  
                    ENDIF  
                ENDIF  
           IF(ABS(PS+C1(M)*ALPHA+C2).LE.EPSIL) GO TO 150  
C=======================================================================  
C     TRY NEXT LINE SEGMENT.  
C=======================================================================  
  125      I = I+ISIGN  
  126      IF(I.GT.0.AND.I.LT.MMM) GO TO 120  
C=======================================================================  
C     CONDITION FOR ICHK = 2  
C=======================================================================  
           IF(ICHK.EQ.2) THEN  
                NUMERR = NUMERR + 1  
                IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN  
                     WRITE(N6,900)  
                     IF(JCE.EQ.0) WRITE(N6,901)TIME,NOE(M),QFULL(M),  
     1                 AFULL(M),DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),  
     2                 A(M,1,1),A(M,1,2),A(M,2,1),ALPHA,PS,C2,N  
                     IF(JCE.EQ.1) WRITE(N6,1901)TIME,KOE(M),QFULL(M),  
     1                 AFULL(M),DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),  
     2                 A(M,1,1),A(M,1,2),A(M,2,1),ALPHA,PS,C2,N  
                     ENDIF  
                IF((-C1(M)*ALFMAX(NTPE)-C2).GT.P4(M)) THEN  
Cwch, 6/11/02. (LR)  Error print should be here, not after ELSE below.  
                     IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,903)  
                     IF(Q(M,1,2).GT.QFULL(M)) THEN  
                          Q(M,2,2) = Q(M,1,2)  
                          A(M,2,2) = A(M,1,2)  
                          ELSE  
                          Q(M,2,2) = QFULL(M)  
                          A(M,2,2) = AFULL(M)  
                          NUMERR = NUMERR + 1  
                          ENDIF  
                     RETURN  
                     ELSE  
                     IF(C2.GT.0.0) THEN  
                          IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,904)  
                          Q(M,2,2) = 0.0  
                          A(M,2,2) = 0.0  
                          NUMERR = NUMERR + 1  
                          RETURN  
                          ENDIF  
                     IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,902)  
                     A(M,2,2) = A(M,2,1)  
                     Q(M,2,2) = Q(M,2,1)  
                     NUMERR = NUMERR + 1  
                     RETURN  
                     ENDIF  
                ENDIF  
C=======================================================================  
C     END OF ICHK = 2 CONDITIONAL STATEMENTS  
C=======================================================================  
C     IF I HAS REACHED ZERO OR MMM START AT IOLD AND GO OTHER WAY  
C=======================================================================  
           ISIGN = -ISIGN  
           I     = IOLD(M)+ISIGN  
           ICHK  = 2  
           GO TO 126  
C=======================================================================  
C     LINE-C1*ALPHA-C2 AND LINE SEGMENT ARE PARALLEL.  
C     CHECK TO SEE IF THEY ARE CO-LINEAR.  
C=======================================================================  
  130      IF(NTPE.LE.16.AND.NTPE.GE.14) THEN  
                KK = NQC(M)  
CIM### 9/8/00 DETAIL Normal calculations were IDETAIL = 0  
              IF(IDETAIL.EQ.0) THEN  
                IF(ABS(C2+QCURVE(KK,4,I)-SLUPE*FLOAT(I-1)*.04).GT.EPSIL)  
     1                                                         GO TO 125  
                ALPHA = QCURVE(KK,2,I) + DALPHA/2.0  
                L     = IFIX(ALPHA/DALPHA) + 1  
                PS    = QCURVE(KK,4,L) + (ALPHA - FLOAT(I-1)*0.04)/  
     1                DALPHA * (QCURVE(KK,4,L+1) - QCURVE(KK,4,L) )  
             ELSE    This is detailed caculations section  
                IF (I.GE.26) THEN  
                ICIM = I-24  
          IF(ABS(C2+QCURVE(KK,4,ICIM)-SLUPE*FLOAT(ICIM-1)*.04).GT.EPSIL)  
     1                                                         GO TO 125  
                ALPHA = QCURVE(KK,2,ICIM) + DALPHA/2.0  
                L     = IFIX(ALPHA/DALPHA) + 1  
                ELSE  
                ICIM = I  
          IF(ABS(C2+QCURV2(KK,3,I)-SLUPE*FLOAT(I-1)*.0016).GT.EPSIL)  
     1                                                         GO TO 125  
                ALPHA = QCURV2(KK,2,I) + DALPH2/2.0  
                L2    = IFIX(ALPHA/DALPH2) + 1  
                ENDIF  
                IF (L.GE.2) THEN  
                PS = QCURVE(KK,4,L) + (ALPHA - FLOAT(ICIM-1)*0.04)/  
     1               DALPHA * (QCURVE(KK,4,L+1) - QCURVE(KK,4,L))  
                ELSE  
                PS = QCURV2(KK,3,L2) + (ALPHA - FLOAT(ICIM-1)*0.0016)/  
     1                DALPH2 * (QCURV2(KK,3,L2+1) - QCURV2(KK,3,L2) )  
                ENDIF  
                ENDIF   End of detailed calculations  
                ELSE  types other than 16  
              IF(ABS(C2 + QNORM(NTPE,I) - SLUPE*ANORM(NTPE,I)).GT.EPSIL)  
     1                                                         GO TO 125  
                ALPHA = ANORM(NTPE,I)    + DALPHA/2.0  
                L     = IFIX(ALPHA/DALPHA) + 1  
                PS    = QNORM(NTPE,L)    + (ALPHA-ANORM(NTPE,L))/DALPHA  
     +                       * (QNORM(NTPE,L+1) - QNORM(NTPE,L))  
                ENDIF  
 150       IOLD(M) = I  
C=======================================================================  
C     IF VERY LOW FLOW, OBTAIN REFINED CALCULATION FOR CIRCULAR PIPE  
C=======================================================================  
           IF(ALPHA.LT.0.04.AND.NTPE.EQ.1) THEN  
               CALL NEWTON(ALPHA,PS,C1(M),C2,KFLAG)  
               IF(KFLAG.EQ.1) THEN  
                              A(M,2,2) = ALPHA*AFULL(M)  
                              Q(M,2,2) = PS*QFULL(M)  
                              RETURN  
                              ENDIF  
               IF(NPRINT.GE.1.AND.NUMERR.LT.50) THEN  
                    WRITE(N6,900)  
               IF(JCE.EQ.0) WRITE(N6,901)TIME,NOE(M),QFULL(M),AFULL(M),  
     +                      DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1),  
     +                      A(M,1,2),A(M,2,1),ALPHA,PS,C2,N  
               IF(JCE.EQ.1) WRITE(N6,1901)TIME,KOE(M),QFULL(M),AFULL(M),  
     +                      DXDT(M),Q(M,1,1),Q(M,1,2),Q(M,2,1),A(M,1,1),  
     +                      A(M,1,2),A(M,2,1),ALPHA,PS,C2,N  
                    NUMERR = NUMERR + 1  
                    ENDIF  
               IF((-C1(M)*ALFMAX(NTPE)-C2).GT.P4(M)) THEN  
                    IF(Q(M,1,2).GT.QFULL(M)) THEN  
                                        Q(M,2,2) = Q(M,1,2)  
                                        A(M,2,2) = A(M,1,2)  
                                        ELSE  
                                        IF(NPRINT.GE.1.AND.NUMERR.  
     +                                            LT.50) WRITE(N6,903)  
                                        Q(M,2,2) = QFULL(M)  
                                        A(M,2,2) = AFULL(M)  
                                        NUMERR = NUMERR + 1  
                                        ENDIF  
                    RETURN  
                    ELSE  
                    IF(C2.GT.0.0) THEN  
                             IF(NPRINT.GE.1.AND.  
     +                                 NUMERR.LT.50) WRITE(N6,904)  
                             Q(M,2,2) = 0.0  
                             A(M,2,2) = 0.0  
                             NUMERR   = NUMERR + 1  
                             RETURN  
                             ENDIF  
                    IF(NPRINT.GE.1.AND.NUMERR.LT.50) WRITE(N6,902)  
                    A(M,2,2) = A(M,2,1)  
                    Q(M,2,2) = Q(M,2,1)  
                    NUMERR = NUMERR + 1  
                    RETURN  
                    ENDIF  
               ENDIF  
           A(M,2,2) = ALPHA * AFULL(M)  
           Q(M,2,2) =    PS * QFULL(M)  
           RETURN  
           ENDIF  
C===================================================================  
C	END OF IF-REALM FOR CHANNELS WITH FUNCTIONAL Q-A RELATIONSHIP.  
C===================================================================  
C  
C=========> ELEMENT IS NOT A CONDUIT.  
C  
C====================================================================  
      NGOTO = NTPE - 18  
C====================================================================  
C     ERROR ===> CONDUITS SHOULD BE KLASS 1 OR 2  (NTPE < 19)  
C====================================================================  
      IF(NGOTO.LT.1) THEN  
                     QO(M)  = QI(M)  
                     NUMERR = NUMERR + 1  
                     IF(NPRINT.GT.0.AND.NUMERR.LT.50) WRITE(N6,905) M  
                     RETURN  
                     ENDIF  
C====================================================================  
C     MANHOLE ===> SIMPLY TRANSLATE FLOW WITH NO TIME DELAY (NTPE = 19)  
C====================================================================  
      IF(NGOTO.EQ.1) THEN  
                     QO(M) = QI(M)  
                     RETURN  
                     ENDIF  
C====================================================================  
C     LIFT STATION ===> PUMPS ASSUMED TO BE PUMPING AT CONSTANT RATE  
C     FORCE MAIN ASSUMED TO REMAIN FULL AT ALL TIMES RESULTING IN NO  
C     VOLUME IN WET WELL INITIALLY IS HALF THE CAPACITY(GEOM1).  
C     TIME DELAY.  (NTPE = 20)  
C====================================================================  
      IF(NGOTO.EQ.2) THEN  
                     WELL2(M) = WELL2(M) + QI(M)*DT  
                     IF(WELL2(M).GE.GEOM1(M)) THEN  
                             IF(WELL2(M).GE.PUMP(M)*DT) THEN  
                                         QO(M)    = PUMP(M)  
                                         WELL2(M) = WELL2(M)-PUMP(M)*DT  
                                         GEOM2(M) = 1.0  
                                         RETURN  
                                         ELSE  
                                         QO(M)    = WELL2(M)/DT  
                                         WELL2(M) = 0.0  
                                         GEOM2(M) = 0.0  
                                         RETURN  
                                         ENDIF  
                     ENDIF  
                     IF(GEOM2(M).LE.0.0) THEN  
                             QO(M)    = 0.0  
                             GEOM2(M) = 0.0  
                             RETURN  
                             ELSE  
                             IF(WELL2(M).GE.PUMP(M)*DT) THEN  
                                         QO(M)    = PUMP(M)  
                                         WELL2(M) = WELL2(M)-PUMP(M)*DT  
                                         GEOM2(M) = 1.0  
                                         RETURN  
                                         ELSE  
                                         QO(M)    = WELL2(M)/DT  
                                         WELL2(M) = 0.0  
                                         GEOM2(M) = 0.0  
                                         RETURN  
                                         ENDIF  
                             ENDIF  
                     ENDIF  
C====================================================================  
C     ROUTINE FOR TYPE 21 AND TYPE 24 FLOW DIVIDERS.  
C     TYPE 21 MAY BE USED FOR A SIMPLE OVERFLOW STRUCTURE.  
C     TYPE 24 MAY BE USED WITH A CUNNETTE SECTION DOWNSTREAM.  
C====================================================================  
      IF(NGOTO.EQ.3.OR.NGOTO.EQ.6) THEN  
                     QO(M) = QI(M)  
                     IF(GEOM1(M).GT.0.0)   THEN  
                          IF(QI(M).LE.GEOM1(M)) THEN  
                                            QO1(M) = QI(M)  
                                            QO2(M) = 0.0  
                                            ELSE  
                                            QO1(M) = GEOM1(M)  
                                            QO2(M) = QI(M)-GEOM1(M)  
                                            ENDIF  
                          ELSE  
C====================================================================  
C     MODIFICATION MADE 9/26/89 TO ALLOW GEOM1(M) TO INDICATE  
C     A PIPE THAT WILL ONLY ALLOW QFULL(M) TO PASS TO GEOM3(M).  
C====================================================================  
                          L      = GEOM3(M)  
                          BMJ    = KGEOM(M)  
                          NEXRAM = NIN(L,BMJ)  
                          IF(QI(M).LE.QFULL(NEXRAM)) THEN  
                                            QO1(M) = QI(M)  
                                            QO2(M) = 0.0  
                                            ELSE  
                                            QO1(M) = QFULL(NEXRAM)  
                                            QO2(M) = QI(M)-QFULL(NEXRAM)  
                                            ENDIF  
                          ENDIF  
                     RETURN  
                     ENDIF  
C====================================================================  
C     STORAGE ELEMENT. ADAPTED FROM STORAGE/TREATMENT BLOCK.  
C====================================================================  
      IF(NGOTO.EQ.4) THEN  
                     KSTOR = KSTORE(M)  
                     QINST = QI(M)  
                     CALL TSTORG  
                     QO1(M) = QOUST1  
                     QO2(M) = QOUST2  
                     QO(M)  = QOUST1 + QOUST2  
                     RETURN  
                     ENDIF  
C====================================================================  
C     ROUTINE FOR TYPE 23 FLOW DIVIDER.  
C     USE WITH SIDE WEIR OR OTHER WEIR TYPE DIVERSION.  
C     DIST  = MAX FLOW WITHOUT FLOW OVER WEIR.  
C     SLOPE = MAXIMUM FLOW THROUGH WHOLE STRUCTURE.  
C     ROUGH = WEIR CONSTANT TIMES WEIR LENGTH.  
C     GEOM1 = WEIR HEIGHT.  
C     GEOM2 = DEPTH IN STRUCTURE AT TIME OF MAXIMUM FLOW.  
C     GEOM3 = DOWNSTREAM EXT. ELE. NUM. INTO WHICH GOES UNDIVERTED FLOW.  
C             FLOW OVER WEIR IS THE DIVERTED FLOW.  
C====================================================================  
      IF(NGOTO.EQ.5) THEN  
                     QO(M) = QI(M)  
                     IF(QI(M).GT.SLOPE(M).AND.JCE.EQ.0) WRITE(N6,920)  
     +                                     TIME,NOE(M),QI(M)  
                     IF(QI(M).GT.SLOPE(M).AND.JCE.EQ.1) WRITE(N6,921)  
     +                                     TIME,KOE(M),QI(M)  
                     IF (QI(M).LE.DIST(M)) THEN  
                                           QO2(M) = 0.0  
                                           QO1(M) = QI(M)  
                                           RETURN  
                                           ENDIF  
                     DH     = (QI(M)-DIST(M))/(SLOPE(M)-DIST(M)) *  
     +                                        (GEOM2(M)-GEOM1(M))  
C#### WCH (RED), 9/93.  CHECK FOR LARGE ENOUGH VALUE OF DH.  
C#### RED (WCH), 12/31/93.  SET DEFAULT VALUE FOR QO2(M)  (= 0.0).  
                                       QO2(M) = 0.0  
                     IF(DH.GT.1.0E-10) QO2(M) = ROUGH(M)*DH*SQRT(DH)  
                     QO1(M) = QI(M) - QO2(M)  
                     QO1(M) = AMAX1(QO1(M),DIST(M))  
                     QO2(M) = QI(M) - QO1(M)  
                     RETURN  
                     ENDIF  
C====================================================================  
C     ROUTINE FOR BACKWATER ELEMENT.  
C     ELEMENT ACTS AS FLOW DIVIDER.  
C     GEOM3 = ELEMENT NUMBER OF DOWNSTREAM STORAGE UNIT.  
C  
C     IF BACKWATER EXTENDS ALL THE WAY UP TO ELEMENT,  
C     THEN WHOLE FLOW IS DIVERTED TO STORAGE ELEMENT.  
C     ASSUME LENGTH OF BACKWATER IS PROPORTIONAL TO SQRT OF STORAGE  
C     VOLUME.  
C====================================================================  
      IF(NGOTO.EQ.7) THEN  
               QO(M)  = QI(M)  
               L      = GEOM3(M)  
               BMJ    = KGEOM(M)  
               L      = NIN(L,BMJ)  
               KSTOR  = KSTORE(L)  
               MINT   = MINTS(KSTOR)  
C#### WCH, 10/6/93.  CHANGE STORL() TO STORE().  
               QO1(M) = QI(M)*SQRT(STORE(KSTOR)/TSTORE(KSTOR,MINT))  
               IF(QO1(M).GT.QI(M)) QO1(M) = QI(M)  
               QO2(M) = QI(M) - QO1(M)  
               RETURN  
               ENDIF  
C#######################################################################  
C      WCH, 8/93.  
C      ROUTINE FOR TABULAR DIVERSION  NTYPE = 26  
C      WRITTEN BY CHUCK MOORE, CDM, 8/93  
C=======================================================================  
      IF(NGOTO.EQ.8) THEN  
         QO(M) = QI(M)  
         KIN   = KINOUT(M)  
         DO 400 IM=1,NSPLIT(KIN)  
         INEXT = IM  
         IF (SPLITIN(KIN,IM).GE.QI(M)) GO TO 405  
  400    CONTINUE  
C=======================================================================  
C  PRINT WARNING IF INFLOW EXCEEDS MAXIMUM TABULAR VALUE.  
C=======================================================================  
         WRITE(N6,940) TIME,N  
         IF(JCE.EQ.0) WRITE(N6,1030) NOE(M)  
         IF(JCE.EQ.1) WRITE(N6,1031) KOE(M)  
         WRITE(N6,1035) QI(M),SPLITIN(KIN,NSPLIT(KIN))  
         UNDIV = SPLITOUT(KIN,NSPLIT(KIN))  
         GO TO 410  
  405    IF(INEXT.EQ.1) THEN  
            UNDIV = SPLITOUT(KIN,INEXT)  
            ELSE  
            RRATIO = (QI(M)-SPLITIN(KIN,INEXT-1))/  
     1             (SPLITIN(KIN,INEXT)-SPLITIN(KIN,INEXT-1))  
            UNDIV = SPLITOUT(KIN,INEXT-1) +  
     1      RRATIO*(SPLITOUT(KIN,INEXT)-SPLITOUT(KIN,INEXT-1))  
            ENDIF  
  410    DIVERT = QI(M) - UNDIV  
         QO1(M) = UNDIV  
         QO2(M) = DIVERT  
         RETURN  
      ENDIF  
C#######################################################################  
C      WCH, 4/99  
C      ROUTINE FOR QUALITY FLOW SPLITTER NTYPE = 27  
C====================================================================  
C       SIMPLY TRANSLATE FLOW WITH NO TIME DELAY  
C       SAME AS MANHOLE(NTPE = 19)  
C====================================================================  
      IF(NGOTO.EQ.9) THEN  
                     QO(M) = QI(M)  
                     RETURN  
                     ENDIF  
C====================================================================  
  900 FORMAT(/,' ===> ITERATION FOR DOWNSTREAM FLOW HAS NOT CONVERGED.',  
     +/,'      Q(CHANNEL,1-UPSTREAM 2-DOWNSTREAM,1-START 2-END)',/,3X  
     1,'TIME  ELEMENT  QFULL  AFULL  DXDT  Q(M,1,1) Q(M,1,2) Q(M,2,1) A(  
     2M,1,1) A(M,1,2) A(M,2,1)  ALPHA     PS     C2 TIME STEP')  
  901 FORMAT(1PE8.2,I10,0PF9.1,F7.2,F7.1,3F9.2,3F9.3,3F7.3,I10)  
 1901 FORMAT(1PE8.2,A10,0PF9.1,F7.2,F7.1,3F9.2,3F9.3,3F7.3,I10)  
  902 FORMAT(/,' ===> REASON FOR NON-CONVERGENCE UNDETERMINED. USE Q,A V  
     +ALUES AT PREVIOUS TIME STEP.')  
  903 FORMAT(/,' ===> CONTINUITY EQN TRIES TO FORCE Q.GT.QMAX. USE QFULL  
     + UNLESS UPSTREAM Q.GT.QFULL - THEN USE UPSTREAM VALUE.')  
  904 FORMAT(/,' ===> CONTINUITY EQN TRIES TO FORCE Q < 0.0   USE',  
     +         ' ZERO FLOW.')  
  905 FORMAT(/,' ===> ERROR  CONDUITS SHOULD BE CLASS 1 OR 2. M= ',I5)  
  910 FORMAT(/,' ===> WARNING   NEWTON UNABLE TO FIND AREA GIVEN FLOW.  
     + TIME = ',F7.1,', TIME STEP=',I3,/,  
     +'       EXT. ELE. NUM.=',I8,', USE OLD UPSTREAM AREA = ',F6.2)  
  911 FORMAT(/,' ===> WARNING   NEWTON UNABLE TO FIND AREA GIVEN FLOW.  
     + TIME = ',F7.1,', TIME STEP=',I3,/,  
     +'       EXT. ELE. NUM.= ',A10,', USE OLD UPSTREAM AREA = ',F6.2)  
  920 FORMAT(/,' ===> WARNING . TIME = ',E14.7,' ELEMENT',I9,  
     +  '      MAX FLOW TO TYPE 23 DIVIDER EXCEEDED. INFLOW = ',E14.7)  
  921 FORMAT(/,' ===> WARNING . TIME = ',E14.7,' ELEMENT ',A10,  
     +  '      MAX FLOW TO TYPE 23 DIVIDER EXCEEDED. INFLOW = ',E14.7)  
  930 FORMAT(/,' ====> ALLOWABLE ERRORS IN ROUTE EXCEEDED.',/,  
     +         ' ====> PRINTOUT OF ERRORS ENDED.')  
C#### WCH (CDM), 8/93.  
  940 FORMAT(' WARNING - INFLOW TO TYPE 26 FLOW DIVIDER EXCEEDS MAXIMUM  
     1INFLOW SPECIFIED IN TABLE.',/,' TIME =',F7.1,' SEC., TIME STEP ='  
     2 ,I5)  
 1030 FORMAT(' TABULAR FLOW SPLIT ELEMENT # ',I10)  
 1031 FORMAT(' TABULAR FLOW SPLIT ELEMENT # ',A10)  
 1035 FORMAT('+',40X,', INFLOW = ',F10.3,' CFS, MAXIMUM IN TABLE = ',  
     1 F10.3,' CFS.')  
C=======================================================================  
      END  
ECHO is off.
REM File: SNOW.FOR  
ECHO is off.
      SUBROUTINE SNOW(TA,SMIMED,J,K,II,RIN,RINE,ASC,WINDY,KOMPUT)  
C     RUNOFF BLOCK  
C     CALLED BY WSHED NEAR LINE 254, 266, 278, 290  
C=======================================================================  
C     This subroutine adds/deletes water from snow pack, performs  
C       redistribution of snow, calls AREAL and MELT, and routes   
C       liquid water through snow pack.  
C     Updated 4/7/94 by WCH to indicate if snow is present in   
C       catchment.  Put new variable KWIKSN in SUBCAT.INC.    
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'TIMER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'DETAIL.INC'  
      INCLUDE 'SUBCAT.INC'  
C=======================================================================  
C     Add new snow to snow pack.  
C=======================================================================  
      IF(RIN.LT.0.0) WSNOW(II,J) = WSNOW(II,J)-RIN*DELT  
      IF(WSNOW(II,J).LE.0.0) RETURN  
C#######################################################################  
C#### WCH, 4/7/94.  Here, indicate presence of snow in order to set  
C       WET time step in Sub. HYDRO.  
C=======================================================================  
      KWIKSN = 1  
C  
      IF(K.EQ.2.OR.K.EQ.4) GO TO 110  
C=======================================================================  
C     Can redistribute snow (e.g., plow) off subareas 1 and 3 for   
C     continuous simulation (ISNOW=2).  This is only done once since  
C     only call Sub. SNOW once for subareas 1 and 3.  
C=======================================================================  
      IF(ISNOW.EQ.2) GO TO 105  
C=======================================================================  
C     If ISNOW = 1 and there is no new snow (RIN >= 0), RETURN.  
C     Else, there is snow on "normally bare" area.  It is all immediately  
C     melted at statement 115.   
C=======================================================================  
      IF(RIN.GE.0.0) RETURN  
      IF(RIN.LT.0.0) GO TO 115  
C=======================================================================  
C     IMPERVIOUS AREA WITH DEPRESSION STORAGE (K=1).  
C     PERFORM SNOW CALCS ONLY FOR ISNOW=2 (CONTINUOUS MELT).  
C     NORMALLY WITH NO SNOW BUT MAY HAVE UP TO WEPLOW FT WATER EQUIV.  
C  
C     CHECK FOR REDISTRIBUTION OF SNOW (PLOWING).  
C     Arrive here only for subarea 1 or 3 and for continuous simulation.  
C=======================================================================  
  105 IF(WSNOW(3,J).LT.WEPLOW(J)) GO TO 110  
      EXC = WSNOW(3,J)-WEPLOW(J)  
C=======================================================================  
C     MOVE EXCESS SNOW TO:  
C        OTHER IMPERVIOUS IN SUBCATCHMENT,  
C        (FRACTIONS HAVE BEEN MULTIPLIED BY (WAR(1,J)+WAR(3,J))/WAR(KX,JX)  
C        EARLIER.)  
C=======================================================================  
      WSNOW(1,J) = WSNOW(1,J)+SFRAC(1,J)*EXC  
C=======================================================================  
C     PERVIOUS IN SUBCATCHMENT,  
C=======================================================================  
      WSNOW(2,J) = WSNOW(2,J)+SFRAC(2,J)*EXC  
C=======================================================================  
C     PERVIOUS IN LAST SUBCATCHMENT,  
C=======================================================================  
      WSNOW(2,NOW) = WSNOW(2,NOW)+SFRAC(3,J)*EXC  
C=======================================================================  
C     OUT OF SYSTEM, (KEEP TALLY ON THIS QUANTITY),  
C=======================================================================  
      CNT(9) = CNT(9) + SFRAC(4,J)*EXC  
C=======================================================================  
C        CONVERT TO IMMEDIATE MELT.  
C=======================================================================  
      SMIMED     = SFRAC(5,J)*EXC/DELT  
      WSNOW(3,J) = WEPLOW(J)  
C=======================================================================  
C     SNOW MELT CALCULATIONS FOR ALL AREAS.  
C=======================================================================  
  110 SMELT = 0.0  
      RI    = RINE  
C=======================================================================  
C     Upon entering this subroutine, RINE = rain, if raining, or  
C     zero if snowing.   
C     CEASE SNOW CALCS WHEN AMT LT 0.001 IN. (0.00008 FT).  
C=======================================================================  
      IF(WSNOW(II,J).GT.0.00008) GO TO 120  
  115 SMIMED      = SMIMED + (WSNOW(II,J) + FW(II,J))/DELT  
      WSNOW(II,J) = 0.0  
      FW(II,J)    = 0.0  
      IF(ISNOW.EQ.2) COLDC(II,J) = 0.0  
      ASC = 0.0  
      RETURN  
C=======================================================================  
C     DETERMINE FRACTION OF AREA THAT IS SNOW COVERED = ASC.  
C=======================================================================  
  120                           ASC = 1.0  
      IF(ISNOW.EQ.1.AND.K.EQ.2) ASC = SNCP(J)  
      IF(ASC.LE.0.0) RETURN  
C  
      IF(ISNOW.NE.2) GO TO 130  
      IF(K.EQ.2) CALL AREAL(WSNOW(II,J),SI(II,J),NEWSNO(II,J),ASC,  
     1                  AWE(II,J),SBA(II,J),SBWS(II,J),RIN,ADCP,DELT)  
C  
      IF(K.EQ.4) CALL AREAL(WSNOW(II,J),SI(II,J),NEWSNO(II,J),ASC,  
     1                  AWE(II,J),SBA(II,J),SBWS(II,J),RIN,ADCI,DELT)  
C  
C     DETERMINE MELT RATE (FT/SEC) = SMELT.  
C     MELT RETURNS SMELT, IF MELT OCCURS, OR ELSE ADDS TO COLD CONTENT.  
C  
                     DHM = DH(II,J)  
  130 IF(ISNOW.EQ.1) DHM = DHMAX(II,J)  
      IF(WSNOW(II,J).GT.0.0) CALL MELT(DHM,TBASE(II,J),RIN,TA,DELT,  
     1SMELT,COLDC(II,J),ATI(II,J),WINDY,ASC,WSNOW(II,J),KOMPUT)  
C=======================================================================  
      IF(SMELT.LE.0.0) RETURN  
C=======================================================================  
C     ROUTE MELT THROUGH SNOW PACK.  
C     Return snowmelt to Sub. WSHED through RI, in COMMON "Detail.inc"  
C=======================================================================  
                            RI = SMELT*DELT*ASC  
      IF(RI.GT.WSNOW(II,J)) RI = WSNOW(II,J)  
      WSNOW(II,J) = WSNOW(II,J) - RI  
      FW(II,J)    = FW(II,J) + RI + RINE*DELT  
      RI          = FW(II,J) - FWFRAC(II)*WSNOW(II,J)  
      IF(RI.LT.0.0) RI = 0.0  
      FW(II,J)         = FW(II,J) - RI  
      RI               = RI / DELT  
      RETURN  
      END  
  
ECHO is off.
REM File: STATS.FOR  
ECHO is off.
      SUBROUTINE STATS  
C=======================================================================  
C                 STATISTICAL ANALYSIS BLOCK WRITTEN BY  
C  
C                           DONALD J. POLMANN  
C                   ENVIRONMENTAL ENGINEERING SCIENCES  
C                         UNIVERSITY OF FLORIDA  
C                         GAINESVILLE,  FLORIDA  
C       JULY 1981         (UPDATED JANUARY 1983)  
C       OCTOBER 1985      (REVISED BY BOB DICKINSON)  
C       OCTOBER 1988      (REVISED BY BOB DICKINSON)  
C       MAY     1989      (REVISED BY BOB DICKINSON)  
C       SEPTEMBER 1990    (REVISED BY LAURA TERRELL, CDM)  
C       December 1990     (REVISED BY BOB DICKINSON)  
C       December 1992     (Zero divide check, WCH)  
C       July 1993         WCH. Labels for return period in years,  
C                           and miscellaneous format corrections.  
C                         Use average and max flow values of cfs  
C                           and cms, not cf/hr or m^3/hr.  
C                         Make sure tables are sorted before plotting.  
C                         Warn about small return periods.  
C       November 1993     Correction for metric conversions and make  
C                         summations consistent with other blocks  
C                         regarding time step averaging, WCH.  
C       2/27/95, WCH.     Mysterious correction to read arrays  
C                         IEVNTB, TEVNTB again off NOUT because they  
C                         are somehow corrupted earlier, prior to  
C                         sorting, resulting in wrong date assigned  
C                         to ranked data.  
C       8/1/95, WCH.      To correspond to Rain Block change, change  
C                         rainfall station ID, LOCRN, to character.  
C       8/7/95, WCH.      Add check for requested ending date before  
C                         first date on interface file.  
C       7/22/96, WCH.     Correct computation of rainfall interevent  
C                         times (was THISTO too great).  
C       7/23/96, WCH.     Correct computation of flow etc. duration  
C                         and interevent times.  Correct print-out of  
C                         interevent time for flows etc. (was off by  
C                         one line).  Add fix to catch first flow etc.  
C                         event when it starts before time MIT.  
C                         Add event number to event print out.  Add  
C                         message explaining duration and interevent  
C                         calculation for hydrographs.  Print all  
C                         concentrations with G-format.  Improve  
C                         print-out of KTSEQS.  Print correct  
C                         definition of JCUBE.  
C       7/29/96, WCH.     Additional initialization.  Otherwise,  
C                         parameter METRIC was incremented on successive  
C                         STATS runs, if slash delimeter (nul input)  
C                         was used on B1 input line  
C       8/7/96, WCH.      Correction for event separation.  
C      10/2/96, WCH.      Remove extra BACKSPACE in error routine.  
C       6/3/97, CIM.      Add check for zero TRIBA for JCUBE=0 option.  
C       9/8/00, CIM.      Modify to check against KTIME instead of KREAD.  
C     11/24/03, WCH.      Fix computation for avg. flow for depth/time.  
C=======================================================================  
C     THE STATS BLOCK WILL PERFORM STATISTICAL ANALYSES ON EVENTS OF  
C     STORMWATER FLOW AT ONE CHOSEN LOCATION.  THE OPTIONS AVAILABLE  
C     INCLUDE A TABLE OF MAGNITUDE,   RETURN PERIOD AND FREQUENCY, A  
C     GRAPH OF MAGNITUDE VS. RETURN PERIOD, A GRAPH OF MAGNITUDE VS.  
C     FREQUENCY, AND THE FIRST THREE MOMENTS OF THE EVENT DATA.  ANY  
C     OR ALL OF THESE OPTIONS CAN BE CHOSEN FOR ANY OR ALL OF FIVE  
C     RAINFALL PARAMETERS (VOLUME, AVERAGE INTENSITY, PEAK INTENSITY,  
C     EVENT DURATION, AND INTEREVENT DURATION).  ANY  
C     OR  ALL OF THESE OPTIONS CAN BE CHOSEN FOR ANY OR  ALL OF FIVE  
C     FLOW PARAMETERS (TOTAL FLOW,  AVERAGE FLOW,  PEAK FLOW,  EVENT  
C     DURATION,  INTEREVENT DURATION)  AND FIVE POLLUTANT PARAMETERS  
C     (TOTAL LOAD,  AVERAGE LOAD,  PEAK LOAD,  FLOW WEIGHTED AVERAGE  
C     CONCENTRATION,PEAK CONCENTRATION). THE FLOW/POLLUTANT DATA ARE  
C     SEPARATED INTO EVENTS ON THE BASIS OF FLOW RATE WHETHER OR NOT  
C     ANY STATISTICAL  OPTIONS ARE SELECTED FOR FLOW.   FROM ZERO TO  
C     TEN POLLUTANTS MAY BE ANALYZED.  
C=======================================================================  
C     THE  STATS BLOCK  MAY BE CALLED AFTER ANY BLOCK THAT GENERATES  
C     AN INTERFACE FILE OF FLOW AND POLLUTANT DATA.  BESIDES INSTAN-  
C     TANEOUS VALUES FOR FLOW RATE,  THE FILE MAY CONTAIN  UP TO TEN  
C     POLLUTANTS.  THE NUMBER OF LOCATIONS IN THE FILE IS LIMITED TO  
C     200.  THE NUMBER OF TIME STEPS IS NOT DIRECTLY CONSTRAINED BUT  
C     THE NUMBER OF EVENTS THAT CAN BE SORTED AND ANALYZED IS LIMIT-  
C     ED TO 4000. THE NUMBER OF EVENTS IN A GIVEN TIME SERIES IS DE-  
C     PENDENT ON THE USER-DEFINED MINIMUM INTEREVENT TIME. THIS LIM-  
C     IT OF 4000  EVENTS CAN BE EXTENDED (OR DECREASED)  BY THE USER  
C     BY ALTERING THE PARAMETER STATEMENT FOR LIMIT (E.G.,  
C     LIMIT=4000) IN STCOM.INC, CONTAINING THE STATS BLOCK  
C     COMMON GROUPS.  
C=======================================================================  
C     THE  STATS BLOCK  INCLUDES THE SUBROUTINES 'STATS',  'SBTABL',  
C     'MOMENT',   'SORT',  'POINTS',  AND 'STBLOCK'.  OTHER SWMM SUB-  
C     ROUTINES CALLED INCLUDE 'CURVE'.  
C=======================================================================  
C  
C     ATTENTION VAX PROGRAMMERS:  YOU MAY ENCOUNTER AN OUTPUT OVERFLOWS  
C     RECORD ERROR BECAUSE OF THE LENGTH OF THE FORMAT STATEMENT  
C     (I.E., 3550).  A SOLUTION TO THIS MAY BE TO MODIFY THE FDL FILE  
C     ASSOCIATED WITH YOUR OUTPUT FILE TO INCREASE RECORD LENGTH.  
C  
C========================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'LAB.INC'  
      INCLUDE 'STCOM.INC'  
C=======================================================================  
CIM CHANGE DIMENSIONS FROM 10 TO MQUAL  
      DIMENSION FLOWP(5),POLLP(MQUAL,5),Q(NIE),POLL(MQUAL,NIE),  
     1          PCONV(MQUAL),IFPAR(5),IPPAR(MQUAL,5),ISFLOW(10,6),  
     1          ISPOLL(MQUAL,5,5)  
C#### WCH, 7/21/93. INCREASE DIMENSION OF RPHOR TO 3.  
CIM INCREASE HYDROGRAPHS  ~~~~~~~~~~~~~~~~~~~~~~~  
      DIMENSION RPHOR(3),PHOR(2),VRTITL(15),SICONV(9,2),JSTA(MAXRG)  
CIM  CHANGE TO WRITE ALL PARAMETERS  
      DIMENSION PEMC(MQUAL),PLOAD(MQUAL),PLSUM(MQUAL)  
cim      DIMENSION RPHOR(3),PHOR(2),VRTITL(15),SICONV(9,2),JSTA(10)  
cim ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
      REAL MIT  
C#### WCH, 7/21/93. MAKE NEWLAB BE 8 BYTES TO AGREE WITH ENGLAB.  
      CHARACTER RPTITL*30,PTITL*30,BLANK*10,PHOR*30,  
     1          BMJ*10,KOCRQ*10,RPHOR*30,VRTITL*10,NEWLAB(4)*8,  
     2          COND*3,OLD*3,QUAN(3)*8,OTHER(4)*8,PAA(MQUAL)*8  
C#### WCH, 8/1/95. CHANGE PRECIP. STATION ID TO CHARACTER AND 3 MORE.  
      CHARACTER*8 JSTA, BLANK1*1,TRYLOC*8,TRYSTA*8  
C=======================================================================  
      DATA SICONV/9*1.0,3*25.4,3*0.4536,3*28.32/  
      DATA RPTITL/'Magnitude vs. Return period'/  
      DATA PTITL /'Magnitude  vs.  Frequency  '/  
C#### WCH, 7/21/93.  ADD LABEL FOR YEARS.  
      DATA RPHOR/' Base 10 Log of Return period',' (Log months)  ',  
     +                                           ' (Log years)   '/  
      DATA PHOR/'  Percent of occurrences less',  
     +          'than/equal to given magnitude'/  
      DATA VRTITL/' Total  Q ',' Avg   Q  ',  
     +            '  Peak  Q ',' Duration ',  
     +            'Interevent','Total load',  
     +            ' Avg load ','Peak load ',  
     +            ' Avg conc.','Peak conc.',  
     +            ' Total V  ','Avg  int. ',  
     +            ' Peak int.',  
     +            ' Duration ','Interevent'/  
      DATA QUAN/'Quantity','Quan/hr ','Quan/hr '/  
      DATA OTHER/'ft3*unit','cfs*unit','lit*unit','l/s*unit'/  
C#### WCH, 8/1/95.  ADD SINGLE BLANK.  
      DATA BLANK/'          '/,BMJ/'          '/,BLANK1/' '/  
C#### WCH, 7/21/93.  UNITS OF CFS AND CMS AND 8 BYTES.  
      DATA NEWLAB/'feet^3  ',' cfs    ','meter^3 ','m^3/sec '/  
C=======================================================================  
C     Label the graphs in Subroutine Curve.  
C=======================================================================  
      VERT1  = BLANK  
      VERT2  = BLANK  
      VERT3  = BLANK  
      INCNT  = INCNT  + 1  
      IOUTCT = IOUTCT + 1  
      LAST   = JIN(INCNT)  
      NOUT   = JOUT(IOUTCT)  
      IF(LAST.LE.0) CALL ERROR(130)  
      IF(NOUT.LE.0) CALL ERROR(131)  
      WRITE(*,34)  
      WRITE(N6,34)  
C=======================================================================  
C     Open all input/output files for the Statistics Block.  
C=======================================================================  
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR.  
     +      FFNAME(INCNT).EQ.'JIN.UF'))  
     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND.  
     +      FFNAME(INCNT).NE.'JIN.UF')  
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR.  
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF'))  
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND.  
     +      FFNAME(25+IOUTCT).NE.'JIN.UF')  
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
C=======================================================================  
      REWIND (NOUT)  
      REWIND (LAST)  
C=======================================================================  
C     Initialize several variables and arrays.  
C=======================================================================  
      COND       = 'DRY'  
      OLD        = 'DRY'  
C#### WCH, 8/1/95.  INITIALIZE LOCRN.  
      LOCRN      = '        '  
C#### WCH, 7/29/96.  INITIALIZE ADDITIONAL VARIABLES.  
      METRIC     = 0  
      ISTART     = 0  
      TSTART     = 0.  
      IEND       = 0  
      TEND       = 0.  
      INLOG      = 0  
      JCUBE      = 0  
      MIT        = 0  
      BASE       = 0.  
      EBASE      = 0.  
      LOCRQ      = 0  
      KOCRQ      = '        '  
      LLOCRN     = 0  
      NPR        = 0  
      NPOINT     = 0  
      LRET       = 0  
      A          = 0.  
C  
      NNEND      = 0  
      NEXIT      = 0  
      IPEVNT     = 0  
      IDATEZ     = 0  
      DRYTS      = 0.0  
      TZERO      = 0.0  
      HSEC       = 3600.0  
      DO 5 I     = 1,5  
      IFPAR(I)   = 0  
    5 FLOWP(I)   = 0.0  
      DO 6 I     = 1,5  
      DO 6 J     = 1,MQUAL  
      POLLP(J,I) = 0.0  
    6 IPPAR(J,I) = 0  
C=======================================================================  
C >>>>Read Data Group A1 <<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,ISTART,TSTART,IEND,TEND,INLOG,JCUBE,JNEG  
      JYEAR = ISTART/10000  
      IF ((ISTART.GT.0).AND.(JYEAR.LT.100)) THEN  
      ISTART = ISTART - JYEAR*10000  
      JYEAR = JYEAR + 1900  
      ISTART = ISTART + JYEAR*10000  
      ENDIF  
      JYEAR = IEND/10000  
      IF ((IEND.GT.0).AND.(JYEAR.LT.100)) THEN  
      IEND = IEND - JYEAR*10000  
      JYEAR = JYEAR + 1900  
      IEND = IEND + JYEAR*10000  
      ENDIF  
C=======================================================================  
C>>>>>>>>>> Read Data Group B1 <<<<<<<<<<<<<<<<<  
C=======================================================================  
C#### WCH, 8/1/95.  
C     LOCRN CHANGED TO CHARACTER.  INSTALL AN ERROR CHECK IN CASE  
C     USER MISTAKENLY PUTS IT IN AS INTEGER.  IF SO, CONVERT TO CHARCT.  
C     MAY NOT NEED THIS FOR LAHEY  LAHEY APPARENTLY READS CHARACTER  
C     VARIABLES CORRECTLY EVEN IF NOT INCLUDED IN QUOTES  
C=======================================================================  
      IF(JCE.EQ.0) THEN  
                   READ(N5,*,ERR=885) CC,MIT,BASE,EBASE,LOCRQ,  
     +                                LOCRN,NPR,NPOINT,METRIC,LRET,A  
                   GO TO 15  
  885              BACKSPACE N5  
C#### WCH (B. LAZERTE), 10/2/96.  REMOVE EXTRA BACKSPACE.  
C####                   BACKSPACE N5  
                   READ(N5,*,ERR=888) CC,MIT,BASE,EBASE,LOCRQ,  
     +                                LLOCRN,NPR,NPOINT,METRIC,LRET,A  
                   IF(LLOCRN.EQ.0) LOCRN = ' '  
                   IF(LLOCRN.GT.0) WRITE(LOCRN,'(I8)') LLOCRN  
                   WRITE(N6,9040) LLOCRN  
                   ELSE  
                   READ(N5,*,ERR=886) CC,MIT,BASE,EBASE,KOCRQ,  
     +                                LOCRN,NPR,NPOINT,METRIC,LRET,A  
                   IF(KOCRQ.NE.' ') LOCRQ = 1  
                   GO TO 15  
  886              BACKSPACE N5  
                   BACKSPACE N5  
                   READ(N5,*,ERR=888) CC,MIT,BASE,EBASE,KOCRQ,  
     +                                LLOCRN,NPR,NPOINT,METRIC,LRET,A  
                   IF(LLOCRN.EQ.0) LOCRN = ' '  
                   IF(LLOCRN.GT.0) WRITE(LOCRN,'(I8)') LLOCRN  
                   WRITE(N6,9040) LLOCRN  
                   IF(KOCRQ.NE.' ') LOCRQ = 1  
                   ENDIF  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(LOCRN.GT.0) INLOG = 0  
   15 IF(LOCRN.EQ.'0') LOCRN = ' '  
      IF(LOCRN.NE.' ') INLOG = 0  
cim process all  
      IF (KOCRQ.EQ.'-1') LOCRQ = -1  
      LLOCRQ = LOCRQ  
      IF (LOCRQ.LT.0) THEN  
      LOCRQ = 1  
      WRITE(N6,8005)  
      ENDIF  
cim all  
      WRITE(N6,92) MIT,NPOINT,METRIC,LRET,A,INLOG,JCUBE,JNEG  
      METRIC = METRIC + 1  
      IF(LOCRQ.GT.0.AND.JCUBE.GT.0) THEN  
                                    ENGLAB(1) = NEWLAB(1)  
                                    ENGLAB(2) = NEWLAB(2)  
                                    ENGLAB(3) = NEWLAB(2)  
                                    SILAB(1)  = NEWLAB(3)  
                                    SILAB(2)  = NEWLAB(4)  
                                    SILAB(3)  = NEWLAB(4)  
                                    ENDIF  
C=======================================================================  
C>>>>>>> Read Data Group B2 <<<<<<<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,KSEQ,KTERM,KTSEQS  
      WRITE(N6,93)          KSEQ,KTERM,KTSEQS  
C=======================================================================  
C >>>>>>>  Read Data Group B3 <<<<<<<<<<<<<<<  
C=======================================================================  
      IF(NPR.GT.0) READ(N5,*,ERR=888) CC,(IPOLRQ(K),K=1,NPR)  
C=======================================================================  
C >>>>>>>>>>> Read Data Group C1 <<<<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(LOCRQ.GT.0) THEN  
                     CALL INFACE(1,LAST)  
cim check for zero triba  
                     IF(TRIBA.LE.0.0.AND.JCUBE.EQ.0) THEN  
                     WRITE(N6,*) 'ERROR - TRIBA EQUALS ZERO,',  
     +                           ' CANNOT USE JCUBE = 0'  
                     WRITE(N6,*) '        SET JCUBE = 1'  
                     STOP ' ZERO TRIBA'  
                     ENDIF  
                     READ(N5,*,ERR=888) CC,(ISFLOW(1,J),J=1,5)  
                     DO 200 J = 1,5  
                     I1 = ISFLOW(1,J)/1000  
                     J2 = ISFLOW(1,J) - I1*1000  
                     I2 = J2/100  
                     J3 = J2 - I2*100  
                     I3 = J3/10  
                     I4 = J3 - I3*10  
                     ISFLOW(2,J) = I1  
                     ISFLOW(3,J) = I2  
                     ISFLOW(4,J) = I3  
                     ISFLOW(5,J) = I4  
                     IF(I1.EQ.1.OR.I2.EQ.1.OR.I3.EQ.1.OR.I4.EQ.1)  
     +                                              IFPAR(J) = 1  
  200                CONTINUE  
                     ENDIF  
C=======================================================================  
C >>>> Read Data Group D1 <<<<<<<<<<<<<<<<<  
C=======================================================================  
      IF(NPR.GT.0) THEN  
                   DO 250 J = 1,NPR  
                   READ(N5,*,ERR=888) CC,(ISPOLL(J,1,K),K=1,5)  
                   DO 275 K = 1,5  
                   I1 = ISPOLL(J,1,K)/1000  
                   J2 = ISPOLL(J,1,K) - I1*1000  
                   I2 = J2/100  
                   J3 = J2 - I2*100  
                   I3 = J3/10  
                   I4 = J3 - I3*10  
                   ISPOLL(J,2,K)  = I1  
                   ISPOLL(J,3,K)  = I2  
                   ISPOLL(J,4,K)  = I3  
                   ISPOLL(J,5,K)  = I4  
                   IF(I1.EQ.1.OR.I2.EQ.1.OR.I3.EQ.1.OR.I4.EQ.1)  
     +                                          IPPAR(J,K) = 1  
  275              CONTINUE  
  250              CONTINUE  
                   ENDIF  
C=======================================================================  
C >>>>>>>>>>> Read Data Group E1 <<<<<<<<<<<<<<<<<<<  
C=======================================================================  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(LOCRN.GT.0) THEN  
      IF(LOCRN.NE.' ') THEN  
                     REWIND (LAST)  
                     READ(LAST,ERR=9070) NSTA,MRAIN,(JSTA(I),I=1,NSTA)  
                     WRITE(N6,2115)  NSTA  
                     WRITE(N6,2120) (I,JSTA(I),I=1,NSTA)  
C=======================================================================  
C#### WCH, 8/1/95.  INORDINATE HASSEL TO COMPARE CHARACTER VARIABLES  
C     BECAUSE DON'T KNOW WHERE NON-BLANK CHARACTERS ARE IN FIELD.  
C     TRYLOC WILL BE RIGHT-ADJUSTED VALUE OF LOCRN, THAT IS, PUSH  
C     NON-BLANK CHARACTERS OF LOCRN TO RIGHT OF 8-CHARACTER FIELD.  
C     FUNCTION NBLANK() GIVES POSITION OF LAST NON-BLANK CHARACTER.  
C     CAUTION  FUNCTION NBLANK() MAY BE LAHEY-SPECIFIC.  
C     // OPERATOR IN LINE 230 IS CONCATENATION OPERATOR FOR CHARACTER  
C     VARIABLES.  BLANKS WILL BE "ADDED" ON LEFT, WITH EXTRA CHARACTERS  
C     (BEYOND 8-CHARACTER FIELD WIDTH) LOST TO RIGHT.  THESE LOST  
C     CHARACTERS ARE SUPPOSED TO BE BLANKS  
C=======================================================================  
c  nblank is lahey  
c                     NCLEN = 8 - NBLANK(LOCRN)  
c  len_trim is digital visual fortran  
                     NCLEN = 8 - LEN_TRIM(LOCRN)  
                     TRYLOC = LOCRN  
                     IF(NCLEN.GT.0) THEN  
                          DO 230 I = 1,NCLEN  
  230                     TRYLOC = BLANK1//TRYLOC  
                          ENDIF  
                     DO 290 I = 1,NSTA  
                     TRYSTA = JSTA(I)  
c nblank is lahey  
c                     NCLEN = 8 - NBLANK(JSTA(I))  
c  len_trim is digital visual fortran  
                     NCLEN = 8 - LEN_TRIM(JSTA(I))  
                     IF(NCLEN.GT.0) THEN  
                          DO 240 K = 1,NCLEN  
  240                     TRYSTA = BLANK1//TRYSTA  
                          ENDIF  
                     IF(TRYLOC.EQ.TRYSTA) THEN  
                                          MSTA = I  
                                          GO TO 295  
                                          ENDIF  
  290                CONTINUE  
C#### WCH, 8/7/95.  ENHANCE ERROR MESSAGE.  
                     WRITE(N6,9030) LOCRN,JSTA(NSTA)  
C#### WCH, 10/19/95.  ASSIGN VALUE OF MSTA  
                     MSTA = NSTA  
  295                CONTINUE  
                     READ(N5,*,ERR=888) CC,(ISFLOW(6,J),J=1,5)  
                     DO 300 J = 1,5  
                     I1 = ISFLOW(6,J)/1000  
                     J2 = ISFLOW(6,J) - I1*1000  
                     I2 = J2/100  
                     J3 = J2 - I2*100  
                     I3 = J3/10  
                     I4 = J3 - I3*10  
                     ISFLOW(7,J)  = I1  
                     ISFLOW(8,J)  = I2  
                     ISFLOW(9,J)  = I3  
                     ISFLOW(10,J) = I4  
                     IF(I1.EQ.1.OR.I2.EQ.1.OR.I3.EQ.1.OR.I4.EQ.1)  
     +                                              IFPAR(J) = 1  
  300                CONTINUE  
                     NPR = 0  
                     ENDIF  
C=======================================================================  
C     Set up pollutant conversions.  
C=======================================================================  
      IF(NPR.GT.0) THEN  
                   DO 350 K = 1,MQUAL  
                   PAA(K)   = BLANK  
                   IF(K.GT.NPR) GO TO 350  
                   JJ       = IPOLRQ(K)  
                   IF(METRIC.EQ.1) THEN  
C=======================================================================  
C        16018.93 is equal to 0.0353157 ft/l * 453592.4 mg/lb  
C        3.53157E-2 = ft3/l = 1/28.31605  
C=======================================================================  
                           PCONV(JJ) = 16018.93  
                           PAA(K)    = ENGLAB(6)  
                           IF(NDIM(JJ).EQ.1) PCONV(JJ) = 3.53157E-2  
                           IF(NDIM(JJ).EQ.1) PAA(K)    = QUAN(1)  
                           IF(NDIM(JJ).GE.2) PAA(K)    = OTHER(2)  
                           ELSE  
                           PCONV(JJ) = 1000.0  
                           PAA(K)    = SILAB(6)  
                           IF(NDIM(JJ).EQ.1) PAA(K)    = QUAN(1)  
                           IF(NDIM(JJ).EQ.1) PCONV(JJ) = 0.001  
                           IF(NDIM(JJ).GE.2) PAA(K)    = OTHER(4)  
                           ENDIF  
                   IF(NDIM(JJ).GE.2) PCONV(JJ) = 1.0  
  350              CONTINUE  
                   ENDIF  
C=======================================================================  
C     Summarize input data.  
C=======================================================================  
      WRITE(N6,100) ISTART,TSTART,IEND,TEND  
      TSTART = TSTART * 3600.0  
      TEND   = TEND   * 3600.0  
      IF(ISTART.GT.0) THEN  
                      NYEAR  = ISTART/10000  
                      NDAY   = ISTART - NYEAR*10000  
                      MONTH  = NDAY/100  
                      NDAY   = NDAY - MONTH*100  
                      IF(NDAY.EQ.0)   NDAY = 1  
                      IF(NDAY.GT.31)  NDAY = 1  
                      IF(MONTH.EQ.0)  MONTH = 1  
                      IF(MONTH.GT.12) MONTH = 1  
                      ISTART = 1000*NYEAR + JDATE(NDAY,MONTH,NYEAR)  
                      ENDIF  
      IF(IEND.GT.0) THEN  
                    NYEAR  = IEND/10000  
                    NDAY   = IEND - NYEAR*10000  
                    MONTH  = NDAY/100  
                    NDAY   = NDAY - MONTH*100  
                    IF(NDAY.EQ.0)   NDAY = 12  
                    IF(NDAY.GT.31)  NDAY = 12  
                    IF(MONTH.EQ.0)  MONTH = 12  
                    IF(MONTH.GT.12) MONTH = 12  
                    IEND   = 1000*NYEAR + JDATE(NDAY,MONTH,NYEAR)  
                    ENDIF  
      IF(LOCRQ.GT.0) THEN  
                     JULDAY = IDATEZ  
                     TIMDAY = TZERO  
                     ENDIF  
      WRITE(N6,101) ISTART,TSTART,IEND,TEND  
C=======================================================================  
      IF((ISTART.EQ.0.AND.TSTART.EQ.0.0).OR.(IEND.EQ.0.AND.TEND.  
     +        EQ.0.0)) WRITE(N6,102)  
      WRITE(N6,105) MIT  
      IF(JCE.EQ.0) WRITE(N6,110)  LOCRQ  
      IF(JCE.EQ.1) WRITE(N6,1110) KOCRQ  
      WRITE(N6,111) LOCRN  
      MIT         = MIT*3600.0  
      IF(METRIC.EQ.1) THEN  
                      WRITE(N6,113)  
                      WRITE(N6,112) NPR,BASE,EBASE  
                      ELSE  
                      WRITE(N6,115)  
                      WRITE(N6,1112) NPR,BASE,EBASE  
                      ENDIF  
C=======================================================================  
C     Print pollutants requested, by number, to indicate  
C     correct/incorrect choices by user.  
C=======================================================================  
      IF(NPR.GT.0) WRITE(N6,114) (IPOLRQ(I),I=1,NPR)  
C=======================================================================  
C     Print matrices indicating Stat options for flow and pollutants.  
C=======================================================================  
      IF(LOCRQ.GT.0) WRITE(N6,118) ((ISFLOW(I,J),J=1,5),I=2,5)  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(LOCRN.GT.0) WRITE(N6,119) ((ISFLOW(I,J),J=1,5),I=7,10)  
      IF(LOCRN.NE.' ') WRITE(N6,119) ((ISFLOW(I,J),J=1,5),I=7,10)  
      IF(NPR.GT.0) THEN  
                   DO 130 J = 1,NPR  
                   KK       = IPOLRQ(J)  
                   WRITE(N6,120) PNAME(KK),((ISPOLL(J,I,K),K=1,5),I=2,5)  
130                CONTINUE  
                   ENDIF  
C=======================================================================  
C     Find the position on the interface file of the requested number.  
C=======================================================================  
      KK = MSTA  
CIM  CHANGE TO LOOP THROUGH ALL LOCATIONS IF LOCRQ IS LESS THAN ZERO 6/97  
CIM  OR KOCRQ is '-1'  
CIM  
      ILOCRQ = 0  
8100  ILOCRQ = ILOCRQ + 1  
      IF (LLOCRQ.LT.0) THEN  
      IF (ILOCRQ.GT.1) THEN  
C=======================================================================  
C     Initialize several variables and arrays.  
C=======================================================================  
      COND       = 'DRY'  
      OLD        = 'DRY'  
      NNEND      = 0  
      NEXIT      = 0  
      IPEVNT     = 0  
      IDATEZ     = 0  
      DRYTS      = 0.0  
      TZERO      = 0.0  
      DO 8105 I     = 1,5  
 8105 FLOWP(I)   = 0.0  
      DO 8106 I     = 1,5  
      DO 8106 J     = 1,MQUAL  
      POLLP(J,I) = 0.0  
 8106 CONTINUE  
      REWIND (LAST)  
      REWIND (NOUT)  
      CALL INFACE(1,LAST)  
      ENDIF  
      IF (JCE.EQ.0) THEN  
         LOCRQ = NLOC(ILOCRQ)  
         WRITE(N6,2110) LOCRQ  
      ELSE  
         KOCRQ = KAN(ILOCRQ)  
         WRITE(N6,2111) KOCRQ  
      ENDIF  
      ENDIF  
CIM  <:)  
      IF(LOCRQ.GT.0) THEN  
                     DO 140 J = 1,LOCATS  
                     IF(JCE.EQ.0.AND.LOCRQ.EQ.NLOC(J)) GO TO 145  
                     IF(JCE.EQ.1.AND.KOCRQ.EQ.KAN(J))  GO TO 145  
140                  CONTINUE  
                     IF(JCE.EQ.0) WRITE(N6,142) LOCRQ  
                     IF(JCE.EQ.1) WRITE(N6,143) KOCRQ  
                     RETURN  
145                  KK = J  
                     ENDIF  
C=======================================================================  
C     Initialize read counter to zero.  
C     Initialize event counter to zero.  
C     Used to find first date/time on file.  
C     If zero value for starting date/time is chosen.  
C     Initialize time counter to one.  Used to set T1  
C     (Beginning of elapsed time for the period of analysis)  
C=======================================================================  
      NEVNTS = 0  
      KREAD  = 0  
      KTIME  = 1  
      TIME   = TZERO  
C#### WCH, 11/30/93.  
      ITEST  = 0  
      DLAST  = 0.0  
C=======================================================================  
C     Read flow (THEN) or rainfall (ELSE) interface files.  
C=======================================================================  
      WRITE(N6,375)  
      WRITE(*,911)  
      WRITE(*,913)  
cim   need to write to 6 not * to get carriage control on writes to console  
      WRITE(6,914) NEVNTS + 1  
  400 IF(LOCRQ.GT.0) THEN  
                     IF(NQUAL.EQ.0) READ(LAST,END=2005)  
     +                  JULDAY,TIMDAY,DELTA,(Q(K),K=1,LOCATS)  
                     IF(NQUAL.GT.0) READ(LAST,END=2005) JULDAY,TIMDAY,  
     +                  DELTA,(Q(K),(POLL(J,K),J=1,NQUAL),K=1,LOCATS)  
c      Write(n6,*) JULDAY,TIMDAY,DELTA,(Q(K),K=1,LOCATS)  
      JYEAR = JULDAY/1000  
      IF (JYEAR.LT.100) THEN  
      JULDAY = JULDAY - JYEAR*1000  
      JYEAR = JYEAR + 1900  
      JULDAY = JULDAY + JYEAR*1000  
      ENDIF  
                     ELSE  
                     JDAY  = JULDAY  
                     TMDAY = TIMDAY  
C#### WCH, 7/22/96.  SAVE OLD THISTO TO SUBTRACT TO GET INTEREVENT TIME.  
                     THISLD = THISTO  
                     READ(LAST,END=2005,ERR=9070) JULDAY,TIMDAY,  
     +                                   THISTO,(Q(K),K=1,NSTA)  
      JYEAR = JULDAY/1000  
      IF (JYEAR.LT.100) THEN  
      JULDAY = JULDAY - JYEAR*1000  
      JYEAR = JYEAR + 1900  
      JULDAY = JULDAY + JYEAR*1000  
      ENDIF  
                     ENDIF  
      KREAD = KREAD + 1  
C=======================================================================  
C#### WCH, 8/7/95.  ADD CHECK FOR MIS-MATCH OF DATES.  
C=======================================================================  
      IF(KREAD.EQ.1) THEN  
           IF(IEND.EQ.0) GO TO 405  
           IF(JULDAY.LT.IEND) GO TO 405  
           IF(JULDAY.EQ.IEND.AND.TIMDAY.LT.TEND) GO TO 405  
C=======================================================================  
C     Here, starting time on file is later than end time requested  
C     on input.  Print error message and return.  
C=======================================================================  
           WRITE(N6,9455) JULDAY,LAST,IEND  
           WRITE(*,9455)  JULDAY,LAST,IEND  
           RETURN  
           ENDIF  
C  
  405 IF(LOCRQ.GT.0.AND.DELTA.EQ.0.0) GO TO 400  
C=======================================================================  
C     Check for ending date/time.  
C=======================================================================  
      IF(JULDAY.EQ.IEND.AND.TIMDAY.GT.TEND.AND.IEND.NE.0) GO TO 2000  
      IF(JULDAY.GT.IEND.AND.IEND.NE.0)                    GO TO 2000  
C=======================================================================  
C     Check for default value for starting date/time.  
C=======================================================================  
      IF(ISTART.EQ.0.AND.TSTART.EQ.0.0) GO TO 410  
C=======================================================================  
C     Find desired starting date/time on interface file.  
C=======================================================================  
      IF(JULDAY.LT.ISTART) GO TO 400  
      IF(JULDAY.LE.ISTART.AND.TIMDAY.LT.TSTART) GO TO 400  
C=======================================================================  
C     Establish starting point for period of analysis.  
C=======================================================================  
  410 IF(KTIME.EQ.1) THEN  
                     T1    = TIME  
                     JDAY  = JULDAY  
                     TMDAY = TIMDAY  
C#### 8/1/95.  LOCRN NOW CHARACTER.  
C####                     IF(LOCRN.GT.0) THEN  
                     IF(LOCRN.NE.' ') THEN  
                                    IDATEZ = JULDAY  
                                    TZERO  = TIMDAY  
C#### WCH, 7/22/96.  
                                    THISLD = THISTO  
                                    ENDIF  
                     ENDIF  
C#### 8/1/95.  LOCRN NOW CHARACTER.  
C####                     IF(LOCRN.GT.0) THEN  
      IF(LOCRN.NE.' ') THEN  
                     CALL NTIME(JDAY,TMDAY,DELT)  
                     DELTA = -DELT  
                     ENDIF  
      TOLD  = TIME  
      TIME  = TIME + DELTA  
C=======================================================================  
C     Caution in interpretting DELTA:  For flows etc. off interface  
C     file, DELTA is time step >prior< to current time (TIME).  That is,  
C     DELTA "looks backwards."  For rainfall interface file, DELTA is  
C     time since last rain >began< and also looks backwards.  
C=======================================================================  
C#### WCH, 11/30/93.  MAKE SUMMATIONS CONSISTENT WITH OTHER BLOCKS.  
C                     USE DELT FOR MULTIPLICATION FOR VOLUMES/LOADS IF  
C                     PREVIOUS TIME STEP WAS DRY.  OTHERWISE, USE  
C                     AVERAGE DELT = DMEAN.  
C=======================================================================  
      IF(LOCRQ.GT.0) THEN  
           DMEAN = 0.5 * (DELTA + DLAST)  
           IF(ITEST.EQ.0) DMEAN = DELTA  
           DLAST = DELTA  
           ITEST = 0  
           IF(Q(KK).GT.0.0) ITEST = 1  
           ELSE  
           DMEAN = DELTA  
           ENDIF  
C  
      CALL DATED  
C=======================================================================  
C     Print starting date/time if default value is chosen.  
C     Establish starting point for period of analysis.  
C=======================================================================  
CIM### 2/6/2000 I think that this next line should look at KTIME not KREAD  
C      IF(KREAD.EQ.1) THEN  
      IF(KTIME.EQ.1) THEN  
                     IEVNTB(1) = JULDAY  
                     TEVNTB(1) = TIMDAY/3600.0  
                     WRITE(N6,415) JULDAY,TIMDAY  
                     T1        = TZERO  
                     ENDIF  
      KTIME = KTIME + 1  
C=======================================================================  
C     Separate time series into events.  Event consists of at least  
C     one wet time step; interevent is a dry period at least as long  
C     as the minimum interevent time chosen.  
C=======================================================================  
C     If Q = 0.0, Time step is dry;  If Q > 0, Time step is wet.  
C=======================================================================  
C     Rainfall interface file.  
C=======================================================================  
C#### 8/1/95.  LOCRN NOW CHARACTER.  
C####                     IF(LOCRN.GT.0) THEN  
      IF(LOCRN.NE.' ') THEN  
                     NEXT = 1  
C=======================================================================  
C     If satisfy the following IF-statement, then have new event.  
C     Note that rainfall interface file is assumed to contain only  
C     non-zero values.  Thus, every record on interface file is either  
C     a new event or a continuation of an existing event.  There are no  
C     dry rainfall periods.  
C  
C#### WCH, 7/22/96.  DELTA IS TIME BETWEEN >START< OF TWO RAINFALL  
C     INCREMENTS.  THUS, ACTUAL INTEREVENT TIME IS DELTA - THISLD.  
C     THISLD = THISTO FOR PREVIOUS RAINFALL VALUE.  
C  
C     Note, for rainfall, interevent time, FLOWP(5), looks forward from  
C     event that will be placed on the scatch file.  
C=======================================================================  
C####                     IF(TIME-TOLD.GE.MIT) THEN  
                     IF(TIME-TOLD-THISLD.GE.MIT) THEN  
                                          NEXT     = 2  
                                          BACKSPACE LAST  
                                          FLOWP(4) = DURAT  
C#### WCH, 7/22/96.  
C####                                          FLOWP(5) = DELTA  
                                          FLOWP(5) = DELTA - THISLD  
                                          ENDIF  
                     IF(DELTA.EQ.0.0) NEXT = 3  
                     ENDIF  
C=======================================================================  
C     Flow and water quality interface file.  
C=======================================================================  
      IF(LOCRQ.GT.0) THEN  
	           IF(JNEG.EQ.0) THEN  
                     IF(Q(KK).GT.BASE) THEN  
                                       COND = 'WET'  
                                       ELSE  
                                       COND = 'DRY'  
                                       ENDIF  
	           ELSE  
                     IF(Q(KK).LT.BASE) THEN  
                                       COND = 'WET'  
                                       ELSE  
                                       COND = 'DRY'  
                                       ENDIF  
	           ENDIF  
                     IF(OLD.EQ.'WET'.AND.COND.EQ.'WET')   NEXT = 1  
                     IF(OLD.EQ.'WET'.AND.COND.EQ.'DRY')   NEXT = 2  
                     IF(OLD.EQ.'DRY'.AND.COND.EQ.'WET')   NEXT = 3  
                     IF(OLD.EQ.'DRY'.AND.COND.EQ.'DRY')   NEXT = 4  
C#### WCH, 7/23/96.  MISSING FIRST EVENT IF IT STARTS BEFORE TIME MIT.  
C####                     IF(NEXT.EQ.3.AND.DRYTS+DELTA.LT.MIT) NEXT = 1  
C#### WCH, 8/7/96.  STILL DIDN'T GET IT RIGHT.  SHOULD NOT ADD DELTA.  
C     OTHERWISE, SEPARATING EVENTS AT MIT-1.  
C####     IF(NEVNTS.GT.0.AND.NEXT.EQ.3.AND.DRYTS+DELTA.LT.MIT) NEXT = 1  
          IF(NEVNTS.GT.0.AND.NEXT.EQ.3.AND.DRYTS.LT.MIT) NEXT = 1  
                     IF(MIT.EQ.0.0)                       NEXT = 3  
                     OLD = COND  
                     ENDIF  
 1350 CONTINUE  
C=======================================================================  
C     Previous condition is wet; new condition is wet;  
C     Continue the event; increment event duration.  
C=======================================================================  
      IF(NEXT.EQ.1) THEN  
                    IF(LOCRQ.GT.0) THEN  
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA.  
                             FLOWP(1) = FLOWP(1) + Q(KK)*DMEAN  
C#### WCH, 7/21/93.  USE UNITS OF CFS OR CMS, NOT PER HOUR  
C                            IF(Q(KK)*HSEC.GT.FLOWP(3))  
C    +                                    FLOWP(3) = Q(KK)*HSEC  
                             IF(Q(KK).GT.FLOWP(3))  
     +                                    FLOWP(3) = Q(KK)  
                             ENDIF  
C#### 8/1/95.  LOCRN NOW CHARACTER.  
C####                    IF(LOCRN.GT.0) FLOWP(1) = FLOWP(1) +  
                    IF(LOCRN.NE.' ') FLOWP(1) = FLOWP(1) +  
     +                              Q(KK)*THISTO/3600.0  
                    DURAT = DURAT + DELTA  
                    DRYTS = 0.0  
                    ENDIF  
C=======================================================================  
C     Flow parameter 1 is Total flow.  
C     Flow parameter 2 is Average flow.  
C     Flow parameter 3 is Peak flow.  
C     Flow parameter 4 is Event duration.  
C     Flow parameter 5 is Interevent duration.  
C=======================================================================  
C     Previous condition is wet; new condition is dry.  
C=======================================================================  
      IF(NEXT.EQ.2) THEN  
C#### WCH, 7/23/96.  PUT THIS BEFORE ADDING NEW DELTA, OTHERWISE DURAT  
C     IS TOO LONG.  
                    IF(LOCRQ.GT.0) FLOWP(4) = DURAT  
                    DURAT    = DURAT + DELTA  
                    DRYTS    = DELTA  
                    ENDIF  
C=======================================================================  
C     Previous condition is dry; new condition is wet ==> new event.  
C=======================================================================  
      IF(NEXT.EQ.3) THEN  
                                 NEVNTS = NEVNTS + 1  
cim   need to write to 6 not * to get carriage control on writes to console  
                    WRITE(6,914) NEVNTS  
                    IPEVNT         = 0  
                    IEVNTB(NEVNTS) = NYEAR*10000 + MONTH*100 + NDAY  
                    TEVNTB(NEVNTS) = TIMDAY/3600.0  
                    DURAT          = DELTA  
                    FLOWP(4)       = DURAT  
                    IF(LOCRQ.GT.0) THEN  
C#### WCH, 7/23/96.  INTEREVENT TIME TOO GREAT WITH THIS.  
C####                                   DRYTS    = DRYTS+DELTA  
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA.  
                                   FLOWP(1) = Q(KK)*DMEAN  
C#### WCH, 7/21/93  
C                                  FLOWP(3) = Q(KK)*DELTA  
                                   FLOWP(3) = Q(KK)  
C=======================================================================  
C     Note, for flow etc., interevent time, FLOWP(5), looks backwards  
C     from event that will be placed on scratch file.  
C=======================================================================  
                                   FLOWP(5) = DRYTS  
                                   ENDIF  
C#### 8/1/95.  LOCRN NOW CHARACTER.  
C####                     IF(LOCRN.GT.0) THEN  
                    IF(LOCRN.NE.' ') THEN  
                                   FLOWP(1) = Q(KK)*THISTO/3600.0  
                                   FLOWP(3) = Q(KK)  
                                   DURAT    = THISTO  
                                   FLOWP(4) = DURAT  
                                   ENDIF  
                    DRYTS    = 0.0  
                    IF(MIT.EQ.0.0.AND.LOCRQ.GT.0) THEN  
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA.  
                                   FLOWP(1) = Q(KK)*DMEAN  
C#### WCH, 7/21/93  
C                                  FLOWP(2) = FLOWP(1)  
C                                  FLOWP(3) = FLOWP(1)  
                                   FLOWP(2) = Q(KK)  
                                   FLOWP(3) = Q(KK)  
                                   FLOWP(4) = DURAT  
                                   ENDIF  
C#### 8/1/95.  LOCRN NOW CHARACTER.  
C####                    IF(MIT.EQ.0.0.AND.LOCRN.GT.0) THEN  
                    IF(MIT.EQ.0.0.AND.LOCRN.NE.' ') THEN  
                                   IF(THISTO.EQ.0.0) THISTO = 1.0  
                                   FLOWP(1) = Q(KK)*THISTO/3600.0  
                                   FLOWP(2) = FLOWP(1)  
                                   FLOWP(3) = FLOWP(1)  
                                   FLOWP(4) = DURAT  
                                   ENDIF  
                    ENDIF  
C=======================================================================  
C      Previous condition is dry.  
C      New condition is dry.        Extend interevent time.  
C=======================================================================  
      IF(NEXT.EQ.4) THEN  
                    DRYTS = DRYTS + DELTA  
                    IF(DRYTS.LT.MIT) DURAT = DURAT + DELTA  
                    ENDIF  
C=======================================================================  
C     Calculation of pollutant parameters.  
C     If condition is dry, pollutant parameters will be unchanged.  
C=======================================================================  
C     Pollutant Parameter 1 is Total Load  
C                         2 is Average Load  
C                         3 is Peak Load  
C                         4 is Flow Weighted Average Concentration =  
C                               Event Mean Concentration (EMC)  
C                         5 is Peak Concentration  
C=======================================================================  
      IF(NEXT.EQ.2.OR.NEXT.EQ.4) GO TO 1500  
      IF(NPR.EQ.0) GO TO 1500  
      DO 1400 K = 1,NPR  
      JJ        = IPOLRQ(K)  
C=======================================================================  
C     Special exception to routine if MIT = 0.  
C=======================================================================  
       IF(MIT.EQ.0) THEN  
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA.  
                    POLLP(K,1) = POLL(JJ,KK)*DMEAN  
                    POLLP(K,2) = POLLP(K,1)  
                    POLLP(K,3) = POLLP(K,1)  
                    IF(Q(KK).NE.0.0) POLLP(K,4) = POLL(JJ,KK)/Q(KK)  
                    IF(Q(KK).EQ.0.0) POLLP(K,4) = POLL(JJ,KK)  
                    POLLP(K,5) = POLLP(K,4)  
                    ELSE  
                    TEAK       = POLL(JJ,KK)  
C#### WCH, 11/30/93.  MULT BY DMEAN, NOT DELTA.  
                    POLLP(K,1) = POLLP(K,1) + POLL(JJ,KK)*DMEAN  
                    IF(Q(KK).EQ.0.0) Q(KK)  = 1.0  
                    IF(TEAK*HSEC.GT.POLLP(K,3))  POLLP(K,3) = TEAK*HSEC  
                    IF(TEAK/Q(KK).GT.POLLP(K,5)) POLLP(K,5) = TEAK/Q(KK)  
                    ENDIF  
1400  CONTINUE  
C=======================================================================  
C     If dry period criterion has not been met, read next time step.  
C=======================================================================  
1500  IF(NNEND.EQ.0) THEN  
         IF(LOCRQ.GT.0.AND.DRYTS.LT.MIT) GO TO 1700  
         IF(IPEVNT.EQ.1)                 GO TO 1700  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####         IF(LOCRN.GT.0.AND.NEXT.NE.2)    GO TO 1700  
         IF(LOCRN.NE.' '.AND.NEXT.NE.2)    GO TO 1700  
         IPEVNT = 1  
         ENDIF  
C=======================================================================  
C     If first event has not yet been reached, continue reading.  
C=======================================================================  
      IF(NEVNTS.EQ.0) GO TO 1700  
C=======================================================================  
C     Otherwise, convert parameters to desired units and write event  
C     information to off-line file.  
C=======================================================================  
      IF(LOCRQ.GT.0) THEN  
C#### WCH, 11/30/93.  METRIC CORRECTION.  LEAVE FLTOT WITH METRIC  
C                     UNITS IF USED. DON'T MULT BY QCONV.  
            FLTOT    = FLOWP(1)  
            IF(JCUBE.EQ.0) THEN  
C#### WCH, 11/30/93.  HERE, CONVERT FLTOT TO CUBIC FEET, THEN TO DEPTH.  
C	Factor 3630 ft3/ac-in. = 43560 ft2/ac / 12 in/ft.  
C     Area, TRIBA is in acres, even when using metric units.   
C     In both statements below, SICONV = 25.4 mm/in for metric.   
               FLOWP(1) = FLTOT*QCONV*SICONV(1,METRIC)/(3630.0*TRIBA)  
C#### WCH, 7/21/93.  MULTIPLY BY 3600 TO GET DEPTH/HOUR.  
               FLOWP(3) = FLOWP(3)*QCONV*SICONV(3,METRIC)/(3630.0*TRIBA)  
     *                 *3600.0  
               ENDIF  
            FLOWP(4) = FLOWP(4)/3600.0  
            FLOWP(5) = FLOWP(5)/3600.0  
C#### WCH, 12/92  CHECK FOR ZERO DIVIDE BY FLOWP(4)  
              IF(ABS(FLOWP(4)).LT.1E-20) THEN  
                 FLOWP(2) = 0.0  
                 ELSE  
C#### WCH, 7/21/93. DIVIDE BY 3600. TO GET CFS OR CMS.  
Cwch, 11/24/03.  But only do this for JCUBE = 1.  Otherwise, need to  
C     divide inches or mm by hours, not seconds.   
                 IF(JCUBE.EQ.1) FLOWP(2) = FLOWP(1)/FLOWP(4)/3600.0  
                 IF(JCUBE.EQ.0) FLOWP(2) = FLOWP(1)/FLOWP(4)  
                 ENDIF  
            ENDIF  
C=======================================================================  
C     If statements added to test if total event flow is less than  
C     EBASE, the flow threshold input in line B1.  If total flow is  
C     less than EBASE, the event will not be included in the analysis.  
C     Note, if JCUBE = 1, and flows etc. are analyzed, then test against  
C     volume, not depth.  
C=======================================================================  
cim change below to abs(flowp(1) for negative flow events.  
      IF(ABS(FLOWP(1)).LT.EBASE.OR.FLOWP(4).LE.0.0) THEN  
          IF(NNEND.EQ.1) THEN  
                         IF(FLOWP(1).EQ.0.) GO TO 1619  
                         ENDIF  
          NEVNTS = NEVNTS - 1  
          GO TO 1619  
          ENDIF  
C=======================================================================  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(LOCRN.GT.0) THEN  
      IF(LOCRN.NE.' ') THEN  
                     FLOWP(4) = FLOWP(4)/3600.0  
                     FLOWP(5) = FLOWP(5)/3600.0  
                     IF(FLOWP(4).EQ.0.0) FLOWP(4) = 1.0  
                     FLOWP(2) = FLOWP(1)/FLOWP(4)  
                     ENDIF  
C=======================================================================  
C     Unit conversions for pollutant parameters.  For U.S. units,  
C        PCONV(1) = 16018.93 is equal to 0.03531 ft3/l * 453592.4 mg/lb  
C        Divide cuft*mg/l by 16016.35 to get pounds.  
C     For metric units, PCONV(1) = 1000. Divide cum*mg/l by 1000 to  
C        get kg.  
C     NDIM   METRIC   PCONV  
C       0      1      16018.93  
C       0      2      1000.  
C       1      1      0.0353157  
C       1      2      0.001  
C       2     1 & 2    1.0  
C=======================================================================  
C#### WCH, 11/30/93.  Can consolidate three loops into one.  
C=======================================================================  
      IF(NPR.GT.0) THEN  
           DO 1540 K = 1,NPR  
           JJ        = IPOLRQ(K)  
           IF(FLTOT.NE.0.0) POLLP(K,4) = POLLP(K,1)/FLTOT  
           IF(FLTOT.LE.0.0) POLLP(K,4) = 0.0  
           POLLP(K,1) = POLLP(K,1)/PCONV(JJ)  
           POLLP(K,2) = POLLP(K,1)/FLOWP(4)  
           POLLP(K,3) = POLLP(K,3)/PCONV(JJ)  
1540       CONTINUE  
C#### WCH, 11/30/93.  HERE, OLD LOOPS 1560 AND 1580 HAVE BEEN DELETED.  
           ENDIF  
C=======================================================================  
C     Write event information to off-line file.  
C=======================================================================  
      WRITE(NOUT)  IEVNTB(NEVNTS),TEVNTB(NEVNTS),(FLOWP(I),I=1,5)  
      IF(NPR.GT.0) WRITE(NOUT) ((POLLP(K1,J),J=1,5),K1=1,NPR)  
C=======================================================================  
C     If end of period of analysis or end of interface file,  
C     has been reached, go to event analysis.  
C=======================================================================  
1619  IF(NNEND.EQ.1) GO TO 2025  
C=======================================================================  
C     After writing event info, set appropriate parameters to zero.  
C=======================================================================  
      DO 1620 I1   = 1,3,2  
      FLOWP(I1)    = 0.0  
1620  CONTINUE  
      DO 1640 K2   = 1,NPR  
      DO 1630 I2   = 1,5,2  
      POLLP(K2,I2) = 0.0  
1630  CONTINUE  
1640  CONTINUE  
C=======================================================================  
C     Read another time step, provided that number of events has not  
C     reached its maximum value.  
C=======================================================================  
1700  IF(NEVNTS.LT.LIMIT) GO TO 400  
C=======================================================================  
C     If event maximum reached, check for termination of program;  
C     Iftermination not desired, begin event analysis.  
C=======================================================================  
      IF(KTERM.EQ.0) GO TO 1975  
C=======================================================================  
C     Otherwise, terminate program; first check for printing of series.  
C=======================================================================  
      WRITE(N6,1750) LIMIT,JULDAY,TIMDAY  
      IF(KTSEQS.GT.0) THEN  
                      WRITE(N6,1760) LIMIT  
                      NEXIT = 1  
                      GO TO 3400  
                      ENDIF  
      WRITE(N6,1790)  
      RETURN  
C=======================================================================  
C     T2 represents the end of the period of analysis.  
C=======================================================================  
1975  T2 = TIME  
      GO TO 2010  
C=======================================================================  
C     Print last date/time on interface file.  
C=======================================================================  
2000  T2       = TIME - DELTA  
      FLOWP(4) = DURAT  
      NEXT     = 1  
      WRITE(N6,1950) JULDAY,TIMDAY  
      GO TO 2010  
2005  T2       = TIME  
      IF(NEVNTS.EQ.0) THEN  
                      NEVNTS = 1  
                      WRITE(*,914) NEVNTS  
                      ENDIF  
      IF(NPR.GT.0)    THEN  
                      DO 3005 K   = 1,NPR  
                      JJ          = IPOLRQ(K)  
                      POLL(JJ,KK) = 0.0  
3005                  CONTINUE  
                      ENDIF  
      Q(KK)    = 0.0  
      FLOWP(4) = DURAT  
      NEXT     = 1  
      WRITE(N6,1950) JULDAY,TIMDAY  
C=======================================================================  
C     The elapsed time from the beginning to the end of the period of  
C     analysis is the difference between T2 and T1.  A rounded value for  
C     the number of months in this period can be found using 730.5 as the  
C     average number of hours per month.  NOMOS will be used to find the  
C     return period for an event of a given magnitude.  
C=======================================================================  
2010  IF(LRET.EQ.1) THEN  
                    NOMOS = INT(((T2-T1)/3600.0)/730.5  + 0.5)  
                    WRITE(N6,2020) NOMOS  
C#### WCH, 7/22/93. WARNING FOR T FOR LOW NUMBER OF MONTHS.  
                    IF(NOMOS.LT.1) WRITE(N6,2022)  
                    ELSE  
                    NOMOS = INT(((T2-T1)/3600.0)/8760.0 + 0.5)  
                    WRITE(N6,2021) NOMOS  
C#### WCH, 7/22/93. WARNING FOR T FOR LOW NUMBER OF YEARS.  
                    IF(NOMOS.LT.1) WRITE(N6,2023)  
                    ENDIF  
      NNEND = 1  
      GO TO 1350  
2025  WRITE(N6,2030) NEVNTS  
C=======================================================================  
C     Print message if needed.  
C=======================================================================  
      IF(NEVNTS.EQ.0) THEN  
                      WRITE(N6,2040)  
                      RETURN  
                      ENDIF  
      IF(NEVNTS.NE.LIMIT) GO TO 3300  
      WRITE(N6,2035) LIMIT  
C=======================================================================  
C     Check option to print sequential series; If so, Rewind NOUT and  
C     print date, time, flow volume, duration, interevent duration.  
C=======================================================================  
3300  IF(KSEQ.EQ.0) GO TO 4040  
3400  WRITE(N6,3500)  
C#### WCH, 7/23/96.  ADD DEFINITION OF DURATION AND INTEREVENT TIME FOR  
C     HYDROGRAPHS.  
      IF(LOCRQ.GT.0) WRITE(N6,3501)  
      WRITE(*,912)  
      IF(LOCRQ.GT.0) THEN  
             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3570)  
             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3580)  
             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3575)  
             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3585)  
	       IF(NPR.GT.0) THEN  
	       WRITE(N6,3549) '|<- EMC ----',('------------',K=1,NPR-2),  
     +	   '---------->|','<-TOT LOAD -',('------------',K=1,NPR-2),  
     +	   '---------->|'  
             WRITE(N6,3550) (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR)  
	         IF (METRIC.EQ.1) THEN  
	            WRITE(N6,3551) ENGLAB(1),ENGLAB(5),ENGLAB(5),  
     +                           (PUNIT(K),K=1,NPR),  
     +                           (PAA(K),K=1,NPR)  
	         ELSE  
	            WRITE(N6,3551) SILAB(1),SILAB(5),SILAB(5),  
     +                           (PUNIT(K),K=1,NPR),  
     +                           (PAA(K),K=1,NPR)  
	         ENDIF  
	        WRITE(N6,3552) ('  ----------',K=1,NPR*2)  
	       ENDIF  
c             IF(NPR.GT.0.AND.METRIC.EQ.1) WRITE(N6,3550)  
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR),  
c     +                       ENGLAB(1),ENGLAB(5),(PUNIT(K),K=1,NPR),  
c     +                       (PAA(K),K=1,NPR)  
c             IF(NPR.GT.0.AND.METRIC.EQ.2) WRITE(N6,3550)  
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR),  
c     +                       SILAB(1),SILAB(5),(PUNIT(K),K=1,NPR),  
c     +                       (PAA(K),K=1,NPR)  
             ELSE  
             IF(METRIC.EQ.1) WRITE(N6,3560)  
             IF(METRIC.EQ.2) WRITE(N6,3565)  
             ENDIF  
      REWIND (NOUT)  
      FLWSUM    = 0.0  
c  
c      P1LSUM    = 0.0  
c      P2LSUM    = 0.0  
c      P3LSUM    = 0.0  
c      P4LSUM    = 0.0  
c      P5LSUM    = 0.0  
      DO IP =1,NPR  
	PLSUM(IP) = 0.0  
	ENDDO  
C#### WCH, 7/23/96.  CHANGE FROM FFF5 = 0 TO FF5 = 0.  
      FF5       = 0.0  
      DO 3900 I = 1,NEVNTS  
      READ(NOUT,END=4040) I1,T1,(FLOWP(I2),I2=1,5)  
      IF(NPR.GT.0) READ (NOUT) ((POLLP(K1,J),J=1,5),K1=1,NPR)  
      FF1       = FLOWP(1)  
      FF4       = FLOWP(4)  
C=======================================================================  
C#### WCH, 7/23/96.  For rain, must save interevent time for next print,  
C     but not for flow.  
C=======================================================================  
      IF(LOCRQ.GT.0) THEN  
                   FFF5 = FLOWP(5)  
                   ELSE  
                   FFF5 = FF5  
                   ENDIF  
      FF5       = FLOWP(5)  
      IF(NPR.GT.0) THEN  
c                   P1EMC     = POLLP(1,4)  
c                   P2EMC     = POLLP(2,4)  
c                   P3EMC     = POLLP(3,4)  
c                   P4EMC     = POLLP(4,4)  
c                   P5EMC     = POLLP(5,4)  
c                   P1LOAD    = POLLP(1,1)  
c                   P2LOAD    = POLLP(2,1)  
c                   P3LOAD    = POLLP(3,1)  
c                   P4LOAD    = POLLP(4,1)  
c                   P5LOAD    = POLLP(5,1)  
      DO IP = 1,NPR  
	  PEMC(IP) = POLLP(IP,4)  
	  PLOAD(IP) = POLLP(IP,1)  
        PLSUM(IP) = PLSUM(IP) + POLLP(IP,1)  
	ENDDO  
c                   P1LSUM    = P1LSUM + POLLP(1,1)  
c                   P2LSUM    = P2LSUM + POLLP(2,1)  
c                   P3LSUM    = P3LSUM + POLLP(3,1)  
c                   P4LSUM    = P4LSUM + POLLP(4,1)  
c                   P5LSUM    = P5LSUM + POLLP(5,1)  
                   ENDIF  
      FLWSUM    = FLWSUM + FLOWP(1)  
C#### WCH, 7/23/96.  ADD EVENT ID NUMBER TO THESE PRINTS.  
      IF(LOCRQ.GT.0.AND.NPR.GT.0)  
c     +               WRITE(N6,3700) I,I1,T1,FF1,FF4,P1EMC,P2EMC,P3EMC,  
c     +               P4EMC,P5EMC,P1LOAD,P2LOAD,P3LOAD,P4LOAD,P5LOAD  
     +                 WRITE(N6,3700)  I,I1,T1,FF1,FF4,FFF5,  
     +				                 (PEMC(IP),IP=1,NPR),  
     +								 (PLOAD(IP),IP=1,NPR)  
      IF(LOCRQ.GT.0.AND.NPR.EQ.0) WRITE(N6,3701) I,I1,T1,FF1,FF4,FFF5  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(LOCRN.GT.0) WRITE(N6,3700) I1,T1,FF1,FF4,FFF5  
      IF(LOCRN.NE.' ') WRITE(N6,3701) I,I1,T1,FF1,FF4,FFF5  
C=======================================================================  
C  ELIMINATE INTERMEDIATE PRINTOUT  
c      IF(MOD(I,60).EQ.0) THEN  
c         WRITE(N6,3875)  
c         IF(LOCRQ.GT.0) THEN  
c             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3570)  
c             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.1) WRITE(N6,3580)  
c             IF(JCUBE.EQ.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3575)  
c             IF(JCUBE.GT.0.AND.NPR.EQ.0.AND.METRIC.EQ.2) WRITE(N6,3585)  
c             IF(NPR.GT.0.AND.METRIC.EQ.1) WRITE(N6,3550)  
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR),  
c     +                       ENGLAB(1),ENGLAB(5),(PUNIT(K),K=1,NPR),  
c     +                       (PAA(K),K=1,NPR)  
c             IF(NPR.GT.0.AND.METRIC.EQ.2) WRITE(N6,3550)  
c     +                       (PNAME(K),K=1,NPR),(PNAME(K),K=1,NPR),  
c     +                       SILAB(1),SILAB(5),(PUNIT(K),K=1,NPR),  
c     +                       (PAA(K),K=1,NPR)  
c             ELSE  
c             IF(METRIC.EQ.1) WRITE(N6,3560)  
c             IF(METRIC.EQ.2) WRITE(N6,3565)  
c             ENDIF  
c         ENDIF  
3900  CONTINUE  
C=======================================================================  
C     Check if program should be terminated after printing  
C     series; rewind off-line file; proceed with event  
C     analysis for flow parameters.  
C=======================================================================  
4040  CONTINUE  
        REWIND (NOUT)  
      IF(KSEQ.GT.0.AND.LOCRQ.GT.0) THEN  
C#### WCH, 11/30/93.  PRINT TOTAL LOADS FOR U.S. AND METRIC.  
c               IF(NPR.GT.0) WRITE(N6,6024) P1LSUM,P2LSUM,P3LSUM,  
c     +                                         P4LSUM, P5LSUM  
               IF(NPR.GT.0) THEN  
	         WRITE(N6,6022)  
	         WRITE(N6,6023) ('            ',IP = 1,NPR)  
			 WRITE(N6,6024) (PLSUM(IP),IP=1,NPR)  
	         ENDIF  
               IF (JCE.EQ.0) THEN  
                 IF(METRIC.EQ.1) WRITE(N6,6025) LOCRQ,FLWSUM,ENGLAB(1)  
                 IF(METRIC.EQ.2) WRITE(N6,6025) LOCRQ,FLWSUM,SILAB(1)  
                 ELSE  
                 IF(METRIC.EQ.1) WRITE(N6,6026) KOCRQ,FLWSUM,ENGLAB(1)  
                 IF(METRIC.EQ.2) WRITE(N6,6026) KOCRQ,FLWSUM,SILAB(1)  
               ENDIF  
               ENDIF  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(KSEQ.GT.0.AND.LOCRN.GT.0) THEN  
      IF(KSEQ.GT.0.AND.LOCRN.NE.' ') THEN  
               IF(METRIC.EQ.1) WRITE(N6,6030) LOCRN,FLWSUM,ENGLAB(1)  
               IF(METRIC.EQ.2) WRITE(N6,6030) LOCRN,FLWSUM,SILAB(1)  
               ENDIF  
      IF(NEXIT.EQ.1) RETURN  
      DO 4100 N = 1,NEVNTS  
C#### WCH, 2/27/95. READ IEVNTB,TEVNTB AGAIN TO AVOID CORRUPTED VALUES?  
      READ(NOUT,END=4140) IEVNTB(N),TEVNTB(N),(PARAM(N,I),I=1,5)  
C####      READ(NOUT,END=4140) I1,T1,(PARAM(N,I),I=1,5)  
      IF(NPR.GT.0) READ(NOUT) ((PDUM,J=1,5),K1=1,NPR)  
4100  CONTINUE  
4140  CONTINUE  
      DO 4600 J = 1,5  
      IF(IFPAR(J).EQ.0) GO TO 4600  
                     JMB = 1  
                     J1  = 1  
C#### WCH, 8/1/95.  LOCRN NOW CHARACTER.  
C####      IF(LOCRN.GT.0) THEN  
      IF(LOCRN.NE.' ') THEN  
                     JMB = 6  
                     J1  = J + 10  
                     ENDIF  
C=======================================================================  
C     Sort data if table or graph requested and generate/print table.  
C=======================================================================  
      IF(ISFLOW(JMB+1,J).EQ.1) THEN  
                               CALL SORT(J)  
                               CALL SBTABL(J,0,NOMOS)  
                               ENDIF  
C=======================================================================  
C     If graph of return period not desired, go to next option.  
C     Call curve to make graph of return period.  
C=======================================================================  
      IF(ISFLOW(JMB+2,J).EQ.1) THEN  
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO.  
      IF(ISFLOW(JMB+1,J).NE.1) CALL SORT(J)  
                               CALL POINTS(J,1,NOMOS)  
                               HTITLE(1) = RPTITL  
                               HTITLE(2) = BLANK  
                               HORIZ(1)  = RPHOR(1)  
C#### WCH, 7/21/93. PRINT CORRECT UNITS FOR RETURN PERIOD.  
                               IF(LRET.EQ.1) HORIZ(2)  = RPHOR(2)  
                               IF(LRET.EQ.0) HORIZ(2)  = RPHOR(3)  
                               VERT1     = VRTITL(J)  
                               IF(METRIC.EQ.2)  THEN  
                                                VERT2 = SILAB(J)  
                                                ELSE  
                                                VERT2 = ENGLAB(J)  
                                                ENDIF  
                               CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ)  
                               ENDIF  
C=======================================================================  
C     If graph of frequency not desired, go to next option.  
C=======================================================================  
      IF(ISFLOW(JMB+3,J).EQ.1) THEN  
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO.  
      IF(ISFLOW(JMB+1,J).NE.1.AND.ISFLOW(JMB+2,J).NE.1) CALL SORT(J)  
                               CALL POINTS(J,2,NOMOS)  
                               HTITLE(1) = PTITL  
                               HTITLE(2) = BLANK  
                               HORIZ(1)  = PHOR(1)  
                               HORIZ(2)  = PHOR(2)  
                               VERT1     = VRTITL(J)  
                               IF(METRIC.EQ.2) THEN  
                                               VERT2 = SILAB(J)  
                                               ELSE  
                                               VERT2 = ENGLAB(J)  
                                               ENDIF  
                               CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ)  
                               ENDIF  
C=======================================================================  
C     If moments desired call moments.  
C=======================================================================  
      IF(ISFLOW(JMB+4,J).EQ.1) THEN  
                IF(INLOG.GT.0) THEN  
                               WRITE(N6,6037)  
                               WRITE(N6,6038)  
                               ELSE  
                               WRITE(N6,6035)  
                               WRITE(N6,6036)  
                               ENDIF  
                CALL MOMENT(J,0)  
                ENDIF  
4600  CONTINUE  
C=======================================================================  
C     Statistical analysis for pollutants.  
C=======================================================================  
      IF(NPR.EQ.0) GO TO 6000  
C=======================================================================  
C     Read off-line file for pollutant requested.  
C=======================================================================  
      DO 5300 K = 1,NPR  
      REWIND (NOUT)  
      JJ        = IPOLRQ(K)  
      DO 4750 N = 1,NEVNTS  
      READ(NOUT,END=4760) I1,T1,(QDUM,I=1,5)  
      IF(NPR.GT.0) THEN  
                   READ(NOUT) ((POLLP(K1,J),J=1,5),K1=1,NPR)  
                   PARAM(N,1) = POLLP(K,1)  
                   PARAM(N,2) = POLLP(K,2)  
                   PARAM(N,3) = POLLP(K,3)  
                   PARAM(N,4) = POLLP(K,4)  
                   PARAM(N,5) = POLLP(K,5)  
                   ENDIF  
4750  CONTINUE  
4760  CONTINUE  
      DO 5200 J = 1,5  
      J1        = J + 5  
      IF(IPPAR(K,J).EQ.0) GO TO 5200  
C=======================================================================  
C     Generate and print table.  
C=======================================================================  
      IF(ISPOLL(K,2,J).EQ.1) THEN  
                             CALL SORT(J)  
                             CALL SBTABL(J,JJ,NOMOS)  
                             ENDIF  
C=======================================================================  
C     If graph of return period not desired, go to next option.  
C=======================================================================  
      IF(ISPOLL(K,3,J).EQ.1) THEN  
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO.  
      IF(ISPOLL(K,2,J).NE.1) CALL SORT(J)  
                             CALL POINTS(J,1,NOMOS)  
                             HTITLE(1) = RPTITL  
                             HTITLE(2) = BLANK  
                             HORIZ(1)  = RPHOR(1)  
C#### WCH, 7/21/93. PRINT CORRECT UNITS FOR RETURN PERIOD.  
                               IF(LRET.EQ.1) HORIZ(2)  = RPHOR(2)  
                               IF(LRET.EQ.0) HORIZ(2)  = RPHOR(3)  
                             VERT1     = VRTITL(J1)  
                             IF(METRIC.EQ.2) THEN  
                                             VERT2 = SILAB(J1)  
                                             ELSE  
                                             VERT2 = ENGLAB(J1)  
                                             ENDIF  
                             IF(NDIM(JJ).EQ.1.AND.J.LE.3) THEN  
                                              VERT2 = QUAN(J)  
                                              ENDIF  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND.  
     +                              METRIC.EQ.1) VERT2 = OTHER(1)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND.  
     +                              METRIC.EQ.2) VERT2 = OTHER(3)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND.  
     +                              METRIC.EQ.1) VERT2 = OTHER(2)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND.  
     +                              METRIC.EQ.2) VERT2 = OTHER(4)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND.  
     +                              METRIC.EQ.1) VERT2 = OTHER(2)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND.  
     +                              METRIC.EQ.2) VERT2 = OTHER(4)  
                             IF(J.GE.4)       THEN  
                                              VERT2 = PUNIT(JJ)  
                                              ENDIF  
                             CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ)  
                             ENDIF  
C=======================================================================  
C     If graph of frequency not desired, go to next option.  
C=======================================================================  
      IF(ISPOLL(K,4,J).EQ.1) THEN  
C#### WCH, 7/22/93. SORT IF NOT ALREADY DONE SO.  
      IF(ISPOLL(K,2,J).NE.1.AND.ISPOLL(K,3,J).NE.1) CALL SORT(J)  
                             CALL POINTS(J,2,NOMOS)  
                             HTITLE(1) = PTITL  
                             HTITLE(2) = BLANK  
                             HORIZ(1)  = PHOR(1)  
                             HORIZ(2)  = PHOR(2)  
                             VERT1     = VRTITL(J1)  
                             IF(METRIC.EQ.2) THEN  
                                             VERT2 = SILAB(J1)  
                                             ELSE  
                                             VERT2 = ENGLAB(J1)  
                                             ENDIF  
                             IF(NDIM(JJ).EQ.1.AND.J.LE.3) THEN  
                                              VERT2 = QUAN(J)  
                                              ENDIF  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND.  
     +                              METRIC.EQ.1) VERT2 = OTHER(1)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.1.AND.  
     +                              METRIC.EQ.2) VERT2 = OTHER(3)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND.  
     +                              METRIC.EQ.1) VERT2 = OTHER(2)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.2.AND.  
     +                              METRIC.EQ.2) VERT2 = OTHER(4)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND.  
     +                              METRIC.EQ.1) VERT2 = OTHER(2)  
                             IF(NDIM(JJ).EQ.2.AND.J.EQ.3.AND.  
     +                              METRIC.EQ.2) VERT2 = OTHER(4)  
                             IF(J.GE.4)       THEN  
                                              VERT2 = PUNIT(JJ)  
                                              ENDIF  
                             CALL CURVE(X,Y,NPT,1,LOCRQ,BMJ)  
                             ENDIF  
C=======================================================================  
C     Call moment subroutine for pollutant parameter (N,J); Print out.  
C=======================================================================  
5000  CONTINUE  
      IF(ISPOLL(K,5,J).EQ.1) THEN  
                IF(INLOG.GT.0) THEN  
                               WRITE(N6,6037)  
                               WRITE(N6,6038)  
                               ELSE  
                               WRITE(N6,6035)  
                               WRITE(N6,6036)  
                               ENDIF  
                CALL MOMENT(J,JJ)  
                ENDIF  
5200  CONTINUE  
5300  CONTINUE  
6000  WRITE(N6,6050)  
      IF (LLOCRQ.LT.0.AND.ILOCRQ.LT.LOCATS) GO TO 8100  
      RETURN  
9070  WRITE(N6,9080)  
      RETURN  
C=======================================================================  
34    FORMAT(//,  
     1' ######################################',/,  
     1' # Entry made to the Stats Block      #',/,  
     1' # Statistical Analysis Block written #',/,  
     1' #   by the University of Florida.    #',/,  
     1' #   Last updated Dec. 1996 at OSU.   #',/,  
     1' # See data examples or STATS.DOC for #',/,  
     1' # information on new parameters not  #',/,  
     1' # included in User''s Manual.         #',/,  
     1' ######################################',/)  
C#### WCH, 7/21/93.  SLIGHT CHANGE FOR PRINT OF LRET.  
C#### WCH, 7/23/96.  CORRECT DEFINITION OF JCUBE FOR VOLUMES.  
92    FORMAT(1X,/,  
     1'      ####################################',/,  
     1'      #      Stats Block input commands  #',/,  
     1'      ####################################',//,  
     1 1X,'Minimum interevent time (hours).......',F10.2,/,  
     1 1X,'NPOINT (number of printed events).....',I10,/,  
     1 1X,'METRIC (0-U.S. Customary, 1-Metric)...',I10,//,  
     1 1X,'LRET (return period units, 0=yr, 1=mo)',I10,/,  
     1 1X,'A (plotting position parameter).......',F10.3,/,  
     1 1X,'Calculate logarithmic moments.(INLOG).',I10,//,  
     1 1X,'Use inch or millimeter flow JCUBE = 0,',/,  
     1 1X,'or ft^3 or m^3 flow values  JCUBE = 1.',I10,/  
	1 1X,'Process positive flow events JNEG = 0,',/,  
	1 1x,'or negative flow events      JNEG = 1,',I10,/)  
C    1 1X,'Use storm event definition  JSEA  = 0,',/,  
C    1 1X,' or monthly events          JSEA  = 1,',/,  
C    1 1X,' or seasonal events         JSEA  = 2.',I10,/)  
C#### WCH, 7/23/96.  MODIFY THIRD LINE.  
   93 FORMAT(  
     1 1X,'Print sequential series (KSEQ)..............',I10,/,  
     1 1X,'Terminate program parameter (KTERM).........',I10,/,  
     1 1X,'Print series if reach event limit (KTSEQS)..',I10,/)  
  100 FORMAT(//,  
     +' ##################################################',/,  
     +' #  The period of time for which the statistical  #',/,  
     +' #              analysis is being performed is:   #',/,  
     +' ##################################################',//,  
     +'  Starting date...............',I8,'  Starting time...',F5.2,  
     +' hours',/,  
     +'  Ending date.................',I8,'  Ending time.....',F5.2,  
     +' hours')  
C#### WCH, 7/21/93.  ALTER FORMAT FOR OUTPUT OF SECONDS.  
101   FORMAT(//,  
     1' ##################################################',/,  
     1' #  The period of time for which the statistical  #',/,  
     1' #              analysis is being performed is:   #',/,  
     1' ##################################################',//,  
     1'  Starting Julian date........',I8,'  Starting time...',F6.0,  
     1' seconds',/,  
     1'  Ending Julian date..........',I8,'  Ending time.....',F6.0,  
     1' seconds')  
102   FORMAT(/,  
     1' ===> A zero starting date indicates that the analysis ',/,  
     2'      commences at the beginning of the record.  A zero ',/,  
     3'      ending date indicates that the analysis continues to',/,  
     4'      the end of the record.')  
105   FORMAT(/,' The minimum interevent time has been defined as ',F9.2,  
     1         ' hours.')  
110   FORMAT(/,  
     1' ******************************************************',/,  
     2' * The flow location number requested for Statistical *',/,  
     3' * Analysis is: ',I10,'                            *',/,  
     4' ******************************************************')  
1110  FORMAT(/,  
     1' ******************************************************',/,  
     2' * The flow location requested for Statistical        *',/,  
     3' * Analysis is: ',A10,'                            *',/,  
     4' ******************************************************')  
2110   FORMAT(/,  
     1' ******************************************************',/,  
     2' * The following analysis is for location number :    *',/,  
     3' * ',I10,'                                         *',/,  
     4' ******************************************************')  
2111  FORMAT(/,  
     1' ******************************************************',/,  
     2' * The following analysis is for location number :    *',/,  
     3' * ',A10,'                                         *',/,  
     4' ******************************************************')  
C#### WCH, 8/1/95.  CHANGE I7 TO A8.  
111   FORMAT(/,  
     1' ******************************************************',/,  
     2' * The rain location number requested for Statistical *',/,  
     3' * Analysis is: ',A8,'                               *',/,  
     4' ******************************************************')  
112   FORMAT(/,  
     1' The number of quality parameters',/,  
     2' requested for statistical analysis is..',I10,/,  
     3' The base flow to separate events is....',F10.4,' cfs.',/,  
     4' Threshold event flow inches (cfs)......',F10.4,/)  
1112  FORMAT(/,  
     1' The number of quality parameters',/,  
     2' requested for statistical analysis is..',I10,/,  
     3' The base flow to separate events is....',F10.4,' cms.',/,  
     4' Threshold event flow millimeters (cms).',F10.4,/)  
113   FORMAT(/,' U.S. customary units are used in input/output.')  
115   FORMAT(/,' Metric units are used in input/output.')  
114   FORMAT(/,' The pollutants requested for this run, ',/,  
     1' identified by number, are as follows: ',99I3)  
118   FORMAT(//,  
     1' ############################################',/,  
     1' #  The statistical options requested for   #',/,  
     1' #       flow rate are indicated by "1"     #',/,  
     1' ############################################',//,  
     241X,'   Total Flow  Average Flow     Peak Flow  Event Duratn  Inte  
     2revent Duratn',/,  
     341X,'  ------------ -------------  -----------  ------------  ----  
     3-------------',/,  
     4' Table of return period and frequency',T40,5I14,/,  
     5' Graph of return period',T40,5I14,/,  
     5' Graph of frequency',T40,5I14,/,' Moments',T40,5I14)  
119   FORMAT(/,  
     1' ############################################',/,  
     1' #  The statistical options requested for   #',/,  
     1' #       rainfall are indicated by "1"      #',/,  
     1' ############################################',//,  
     241X,'  Total Volume Average Inten  Peak Intens  Event Duratn  Inte  
     2revent Duratn',/,  
     341X,'  ------------ -------------  -----------  ------------  ----  
     3-------------',/,  
     4' Table of return period and frequency',T40,5I14,/,  
     5' Graph of return period',T40,5I14,/,  
     5' Graph of frequency',T40,5I14,/,' Moments',T40,5I14)  
120   FORMAT(//,  
     1' ####################################################',/,  
     1' #  The statistical options requested for           #',/,  
     1' #  quality parameter ',A8,' are indicated by "1" #',/,  
     1' ####################################################',//,  
     143X,'Total Load  Average Load     Peak Load Flow Wtd Conc     Peak  
     1 Conc',/,  
     143X,'----------  ------------     --------- -------------     ----  
     1-----',/,  
     4' Table of return period and frequency',T40,5I14,/,  
     5' Graph of return period',T40,5I14,/,  
     5' Graph of frequency',T40,5I14,/,' Moments',T40,5I14)  
142   FORMAT(/,' ===> Error  The location number requested was',/,  
     +         '      not found on the interface file.',/,  
     +         '      Location ',I10,' not found on interface file',/,  
     +         '      execution of Stats block terminated.')  
143   FORMAT(/,' ===> Error  The location number requested was',/,  
     +         '      not found on the interface file.',/,  
     +         '      Location ',A10,' not found on interface file',/,  
     +         '      execution of Stats block terminated.')  
334   FORMAT(//,  
     +' ***********************************************************',/,  
     +' *  Precipitation input was created using the Rain block   *',/,  
     +' *  NWS Precipitation station....',I9,'                 *',/,  
     +' ***********************************************************')  
375   FORMAT(//,' ===> Program execution continuing.  Data will be ',/,  
     +'      read from the interface file and separated into events.')  
415   FORMAT(/,' ===> The first date and time on the interface file',/,  
     1         '      are ',I7,' and ',F9.2,' seconds',/)  
911   FORMAT(/,' Reading interface file.')  
912   FORMAT(/,' Computing statistics.')  
913   FORMAT(/,' Reading event  #',/)  
914   FORMAT('+',I16)  
C   next format not used  
C1610  FORMAT(I6,F5.2,5G10.4,10(5G10.4))  
1750  FORMAT(/,' ===>  Number of events has reached ',I5,'.',/,  
     1 '       execution has been terminated.',/,  
     2 '       last date and time read are ',I7,1X,F5.2,' hours')  
1760  FORMAT(/,' ===> A table of the first ',I5,' events will be',/,  
     +                                          ' printed.')  
1790  FORMAT(/,' ===> As you requested, no output is provided.')  
1950  FORMAT(/,' ===> End of interface file reached.',//,  
     1         ' ===> Last Julian date and time read ',/,  
     2         '      are ',I7,' and ',F9.2,' seconds',//,  
     3         ' ===> Program continuing with analysis of events.')  
2020  FORMAT(/,' ===> The number of months within the period of',/,  
     1'      analysis rounded to the nearest month, is ',I6,'.')  
2021  FORMAT(/,' ===> The number of years within the period of',/,  
     1'      analysis rounded to the nearest year,  is ',I6,'.')  
C#### WCH, 7/22/93  
2022  FORMAT(/,' ###> WARNING. The rounded number of months is < 1.',/  
     1,'      Computed return periods are likely to be meaningless.')  
2023  FORMAT(/,' ###> WARNING. The rounded number of years is < 1.',/  
     1,'      Computed return periods are likely to be meaningless.')  
2030  FORMAT(/,' ===> The number of events within the period of',/,  
     1'      analysis is                               ',I6,'.')  
2035  FORMAT(/,' ===> Error  The maximum number of events has been',  
     +' reached.',/,  
     +'               No further time steps can be read.',/,  
     +'               The program is continuing with an analysis',/,  
     +'               of the first ',I5,' events.')  
2040  FORMAT(/,' ===> Error ')  
2115  FORMAT(//,  
     +' ********************************************************',/,  
     +' *  Precipitation output created using the Rain block   *',/,  
     +' *  Number of precipitation stations...',I9,'        *',/,  
     +' ********************************************************',/)  
C#### WCH, 8/1/95.  CHANGE I13 TO A13  
 2120 FORMAT(' Location Station number',/,  
     +       ' -------- --------------',/,  
     +       10(I9,'. ',A13,/))  
 3500 FORMAT('1',/,15X,27(1H#),/,15X,'Sequential Series of Events',  
     +           /,15X,27(1H#),/)  
 3501 FORMAT(' Note: SWMM hydrographs are instantaneous values at',  
     1' given time.',/,  
     +' Event duration is from first non-zero flow to trailing',  
     +' hydrograph zero.',/,  
     +' Interevent duration is from trailing hydrograph zero to next',  
     +' non-zero flow')  
c     +' (not printed when quality is printed).',/)  
C#### WCH, 7/23/96.  ADD EVENT NO. TO THIS PRINT-OUT AND FIX UNITS FMT.  
 3549 FORMAT(27X,'Flow      Event  Interevent',2X,99(A12))  
C     +'|<----------------------------EMC------------------------->|',  
C     +'<----------------------Total Load----------------------->|')  
 3550 FORMAT(' Event',12X,'Time   Volume   Duration    Duration',  
     +99(4X,A8))  
 3551 FORMAT('   No.   Date    (hour)',1X,A8,2X,A8,4X,A8,  
     +99(4X,A8))  
 3552 FORMAT('  ----   ----    ------ --------  --------   ---------',  
     +99(A12))  
c     +'   ---------  ----------  ----------   ---------   ---------',  
c     +'   ---------   ---------  ---------   ---------')  
C#### WCH, 7/23/96.  ALTER 3560-3585 FOR EVENT NO. PRINT-OUT.  
3560  FORMAT('                            Rain      Event  Interevent'  
     + ,/,  
     +     ' Event           Time     Volume   Duration    Duration',/,  
     +     '   No.   Date   (hour)   (inches)   (hours)     (hours)',/,  
     +     '  ----   ----   ------  --------    -------     -------')  
3565  FORMAT('                            Rain      Event  Interevent'  
     + ,/,  
     +     ' Event           Time     Volume   Duration    Duration',/,  
     +     '   No.   Date   (hour)      (mm)    (hours)     (hours)',/,  
     +     '  ----   ----   ------  --------    -------     -------')  
3570  FORMAT('                            Flow      Event  Interevent'  
     + ,/,  
     +     ' Event           Time     Volume   Duration    Duration',/,  
     +     '   No.   Date   (hour)   (inches)   (hours)     (hours)',/,  
     +     '  ----   ----   ------  --------    -------     -------')  
3575  FORMAT('                            Flow      Event  Interevent'  
     + ,/,  
     +     ' Event           Time     Volume   Duration    Duration',/,  
     +     '   No.   Date   (hour)      (mm)    (hours)     (hours)',/,  
     +     '  ----   ----   ------  --------    -------     -------')  
3580  FORMAT('                            Flow      Event  Interevent'  
     + ,/,  
     +     ' Event           Time     Volume   Duration    Duration',/,  
     +     '   No.   Date   (hour)   ( ft^3 )   (hours)     (hours)',/,  
     +     '  ----   ----   ------  --------    -------     -------')  
3585  FORMAT('                            Flow      Event  Interevent'  
     + ,/,  
     +     ' Event           Time     Volume   Duration    Duration',/,  
     +     '   No.   Date   (hour)  (meter^3)   (hours)     (hours)',/,  
     +     '  ----   ----   ------  --------    -------     -------')  
C#### WCH, 7/23/96.  ADD EVENT NO. AND CHANGE EMC ETC. PRINTS TO  
C     G-FORMAT, FROM F-FORMAT.  
3700  FORMAT(I4,2X,I8,1X,F8.2,1X,1PG9.3,0PF9.2,F12.2,99(3X,1PG9.3))  
C#### WCH, 7/23/96.  ADD FORMAT FOR EVENT NO. PRINT-OUT.  
3701  FORMAT(I4,2X,I8,F8.2,2X,1PG9.3,0PF9.2,F12.2)  
3875  FORMAT('1',/,15X,40(1H#),/,15X,  
     1'Sequential Series of Events  (continued)',/,15X,40(1H#),/)  
C#### WCH, 8/7/95.  THIS FORMAT NOT USED??  
C#### 4050  FORMAT(11X,5G10.4)  
6022  FORMAT('      Total Loads (see to right)--->:',  
     1'                 ',$)  
6023  FORMAT(A12,$)  
6024  FORMAT(3X,1PG9.3,99(3X,G9.3))  
6025  FORMAT(//,  
     1' ************************************************************',/,  
     2' * Total Flow at location ',I10,'is ',1PG11.4,' ',A9,'*',/,  
     3' ************************************************************',  
     4//)  
6026  FORMAT(//,  
     1' ************************************************************',/,  
     2' * Total Flow at location ',A10,'is ',1PG11.4,' ',A9,'*',/,  
     3' ************************************************************',  
     4//)  
C#### WCH, 8/1/95.  CHANGE I9 TO A9 FOR STATION ID.  
6030  FORMAT(//,  
     1' ************************************************************',/,  
     2' * Total Rain at location ',A9,' is ',1PG11.4,' ',A9,' *',/,  
     3' ************************************************************',  
     4//)  
6035  FORMAT(/,88(1H#),/,'  Moments',/,88(1H#))  
6037  FORMAT(/,90(1H#),/,  
     1'  Moments (Log-Normal [natural log] Distribution)',/,90(1H#))  
6036  FORMAT(/,  
     1' Constituent            Event                            Standard  
     1    Coef. of   Coef. of',/,  
     2'    Analyzed        Parameter        Mean    Variance   Deviation  
     2   Variation   Skewness',/,  
     3'  ----------  ---------------    --------    --------   ---------  
     3   ---------  ---------')  
6038  FORMAT(/,  
     1'  Constituent           Event <-----Logarithmic------>   <-------  
     1-----------Arithmetic-------------->',/,  
     2'     Analyzed       Parameter        Mean   Std. dev.        Mean  
     2   Std. dev.  C. of var.     Median',/,  
     3'  ------------  -------------   ---------   ---------    --------  
     3   ---------  ----------  ---------')  
6050  FORMAT(/,' ===>  Stats Block terminated normally.')  
C#### WCH, 8/1/95.  CHANGE I9 TO A9 AND ENHANCE ERROR MESSAGE.  
 9030 FORMAT(/,' WARNING Rainfall location (LOCRN)......... ',A8,/,  
     + ' is not located on the rainfall interface file.',/,  
     + ' Stats continues, using last station on rainfall interface file  
     += ',A8,/,' Possible cause is mis-match of alphanumeric station IDs  
     +.',/,' Try inputting LOCRN in exactly the same form as ISTA was in  
     +put in the Rain Block,',/,' including leading/trailing blanks.')  
C#### WCH, 8/1/95.  NEW ERROR MESSAGE.  
 9040 FORMAT(/,' ==> WARNING  Rainfall station ID, LOCRN, should be inp  
     1ut as alphanumeric',/,' value (8/1/95).  Your integer input =',I9,  
     2 ' entered successfully',/,' and converted to alphanumeric value,  
     3but please use correct',/,' alphanumeric format in future.')  
C#### WCH, 8/7/95.  
 9455 FORMAT(' ERROR BEGINNING JULIAN DATE =',I9,' ON UNIT',I3,' IS LAT  
     +ER THAN',/,  
     + ' REQUESTED ENDING JULIAN DATE =',I9,' ENTERED ON A1 LINE.',/,  
     + ' (DATES INCLUDE CONSIDERATION OF TIME OF DAY.)',/,  
     + ' STATS BLOCK ENDED.  RETURN TO MAIN PROGRAM.')  
 9080 FORMAT(/,' ===> Error reading rainfall interface file.')  
CIM  PROCESS ALL FILES  
 8005 FORMAT('LOCRQ ENTERED AS NEGATIVE NUMBER. ALL FLOW LOCATIONS IN',  
     +' THE INTERFACE FILE WILL BE PROCESSED')  
C=======================================================================  
 888  CALL IERROR  
      END  
ECHO is off.
REM File: STIME.FOR  
ECHO is off.
      SUBROUTINE STIME(DELTA)  
C#######################################################################  
C     JULDAY = JULIAN DAY  
C     TIMDAY = TIME OF DAY IN SECONDS  
C     DELTA  = NEW TIME STEP IN SECONDS  
C#######################################################################  
      INCLUDE 'STIMER.INC'  
      NYEAR = JULDAY/1000  
      IF (NYEAR.LT.100) THEN  
           JULDAY = JULDAY - NYEAR*1000  
           NYEAR = NYEAR + 1900  
           JULDAY = JULDAY + NYEAR*1000  
           ENDIF  
      TIMDAY = TIMDAY + DELTA  
 100  IF(TIMDAY.GE.86400.0) THEN  
                TIMDAY = TIMDAY - 86400.0  
                JULDAY = JULDAY + 1  
                IDAY   = JULDAY - 1000*(JULDAY/1000)  
                IF(MOD(NYEAR,4).EQ.0.AND.IDAY.EQ.367.OR.  
     +             MOD(NYEAR,4).NE.0.AND.IDAY.EQ.366) THEN  
                                         NYEAR  = NYEAR + 1  
                                         JULDAY = NYEAR*1000 + 1  
                                         ENDIF  
                CALL DATED  
                ENDIF  
      IF(TIMDAY.GE.86400.0) GO TO 100  
      RETURN  
      END  
  
ECHO is off.
REM File: STRT.FOR  
ECHO is off.
      SUBROUTINE STRT  
C=======================================================================  
C     STORAGE/TREATMENT MODEL  -- JUNE 1981. (UPDATED JANUARY 1988)  
C  
C     MODEL WRITTEN BY STEPHAN J. NIX  
C     UPDATED AND MODIFIED BY ROBERT E. DICKINSON  
C                      ENVIRONMENTAL ENGINEERING SCIENCES  
C                      UNIVERSITY OF FLORIDA  
C                      GAINESVILLE, FLORIDA 32611  
C     CURRENT (12/94) PHONE : 813-886-7724 AT XP SOFTWARE  
C     UPDATE HEADER, 5/93 BY WCH AT OREGON STATE UNIVERSITY  
C     ROB JAMES AND WCH, 8/4/93.  FIX METRIC CONVERSION WHILE  
C       WRITING TO INTERFACE FILE.  
C     WCH (RED), 9/23/93.  CHANGE A FORMAT FROM 2A4 TO A8.  
C     WCH, 12/5/94.  CHANGE SEVERAL FORMATS TO MOVE OUTPUT TO LEFT  
C       AND ADD PRINT-OUT OF PRINT AND DATE/TIME VARIABLES.  
C     WCH, 2/27/95.  CORRECT PRINT-OUTS OF POLLUTANT NAME, UNITS.  
C     WCH, 7/7/95.  CORRECT METRIC PRINT-OUT OF TRIBA.  
C     WCH, 7/7/95.  MAKE CORRECTIONS FOR METRIC CONVERSION ON INTERFACE  
C       FILE.  
C     CIM  4/99 MODIFIED TO INCREASE NUMBER OF CONSTITUENT FROM 10  
C          TO MQUAL.  
C     WCH 4/18/02. ERROR MESSAGE FOR INCOMPATIBLE $ANUM.  
C     WCH, 11/24/03.  Used POLL1 twice and spoiled linear interpolation.  
C       Correction suggested by Raymond He, Clarifica Inc.  
C       Do not need all the metric conversions off the interface file  
C       Eliminate.  
C=======================================================================  
C     NOTE, WHEN METRIC OPTION IS USED, THE S/T BLOCK USES METRIC UNITS  
C       INTERNALLY.  
C=======================================================================  
      INCLUDE 'TAPES.INC'  
      INCLUDE 'STIMER.INC'  
      INCLUDE 'INTER.INC'  
      INCLUDE 'S1.INC'  
C=======================================================================  
CIM   CHANGE 3 to MQUAL  
CIM	CHANGE 10 TO MQUAL  
      DIMENSION ANS(2),IPOLL(MQUAL),PCAR(MQUAL),PCAR1(MQUAL),TEMP(12),  
     1ALPHA(2)  
Cwch, 11/24/03. Add POLL2() for printing at statement 6730.  
      DIMENSION POLC(MQUAL),POLCL(MQUAL),POLL(MQUAL,NIE),  
     1POLL1(MQUAL,NIE),POLL2(MQUAL,NIE)  
      DIMENSION SPG(MQUAL),VIS(12),QO1(NIE),QO(NIE)  
C#### WCH, 2/27/95.  NEED THREE TEMPORARY ARRAYS FOR POLLUTANTS.  
      DIMENSION PNAMET(MQUAL), PUNITT(MQUAL), NDIMT(MQUAL)  
      CHARACTER PNAMET*8, PUNITT*8  
C  
      CHARACTER ANS*3,SOUR(3)*40,DMON(12)*4,PDUM1*2,ALPHA*80  
      DATA ANS/' NO','YES'/  
      DATA DMON/' JAN',' FEB',' MAR',' APR',' MAY','JUNE','JULY',' AUG',  
     1          'SEPT',' OCT',' NOV',' DEC'/,PDUM1/'TO'/  
C=======================================================================  
C     Define statement function for linear interpolation.  
C=======================================================================  
      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1)  
C=======================================================================  
      SOUR(1) = 'EXTERNAL FILE'  
      SOUR(2) = 'INPUT ON LINE J1'  
      SOUR(3) = 'INPUT ON LINE J1 AND EXTERNAL FILE'  
C=======================================================================  
      WRITE(*,150)  
      WRITE(N6,150)  
      LOCATS = 1  
      KDT    = 0  
      IPT    = 0  
      INCNT  = INCNT  + 1  
      IOUTCT = IOUTCT + 1  
      LAST   = JIN(INCNT)  
      NEXT   = JOUT(IOUTCT)  
C=======================================================================  
C     Open all input/output files for the Storage/Treatment Block.  
C=======================================================================  
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR.  
     +      FFNAME(INCNT).EQ.'JIN.UF'))  
     +      OPEN(JIN(INCNT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND.  
     +      FFNAME(INCNT).NE.'JIN.UF')  
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR.  
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF'))  
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH')  
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND.  
     +      FFNAME(25+IOUTCT).NE.'JIN.UF')  
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED',  
     +      STATUS='UNKNOWN')  
C=======================================================================  
C     MULTIPLY FLOWS ON INTERFACE FILE BY QCONV TO OBTAIN CFS.  
C     QCONV IS INPUT FROM PRIOR BLOCKS OR ELSE ALTERED LATER IF  
C       METRIC OPTION IS USED.  
C=======================================================================  
      QCONV  = 1.0  
      WRITE(*,9500)  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP A1  <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,TITLE(1)  
      READ(N5,*,ERR=888) CC,TITLE(2)  
      ALPHA(1) = TITLE(1)  
      ALPHA(2) = TITLE(2)  
      TITLE(3) = TITLE(1)  
      TITLE(4) = TITLE(2)  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP B1  <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,NOTAPE,JNS,NDT,DS,NU,NP,ICOST,METRIC,TRIBA  
      METRIC = METRIC + 1  
C#### WCH, 7/7/95.  TRIBA ALWAYS IN ACRES.  
      IF(METRIC.EQ.2) TRIBA = TRIBA*2.471  
C  
      IF(NOTAPE.EQ.1) THEN  
                      NLOC(1) = JNS  
                      JS      = 1  
                      ENDIF  
      IF(NU.LE.0)    NU    = 1  
      IF(ICOST.GT.1) ICOST = 1  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP C1 AND C2  <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,IDATE,TIME,ISUM,IDET,NPR  
      JYEAR = IDATE/10000  
      IF (JYEAR.LT.100) THEN  
       IDATE = IDATE-JYEAR*10000  
       JYEAR = JYEAR + 1900  
       IDATE = IDATE+JYEAR*10000  
       ENDIF  
      IF(ISUM.GT.2) ISUM=2  
      TZERO    = TIME*3600.0  
      TIMDAY   = TZERO  
      TIME     = TZERO  
      TCAR1    = TIME/3600.0  
      QCAR1    = 0.0  
	DO IP = 1,NP  
	PCAR1(IP) = 0.0  
c      PCAR1(1) = 0.0  
c      PCAR1(2) = 0.0  
c      PCAR1(3) = 0.0  
	ENDDO  
      NYEAR   = IDATE/10000  
      NDAY    = IDATE - NYEAR*10000  
      MONTH   = NDAY/100  
      NDAY    = NDAY - MONTH*100  
      IF(NDAY.LE.0) NDAY   = 2  
      IF(MONTH.LE.0) MONTH = 8  
      IF(NYEAR.LT.0) NYEAR = 1941  
CIM ### 9/8/00 for some reason I changed above to this  
C      IF (NDAY+MONTH+NYEAR.EQ.0) THEN  
C      NDAY = 2  
C      MONTH = 8  
C      NYEAR = 1941  
C      ENDIF  
      JULDAY               = 1000*NYEAR + JDATE(NDAY,MONTH,NYEAR)  
      CALL DATED  
      NBD(1) = NYEAR  
      NBD(2) = MONTH  
      NBD(3) = NDAY  
      NBD(4) = JHR  
      NBD(5) = MINUTE  
      NBD(6) = JSEC  
      JDAY   = JULDAY  
      TMDAY  = TIMDAY  
C=======================================================================  
C#### WCH, 12/5/94.  MOVE ECHO OF B1-C1 DATA TO HERE (FROM STMT 3000).  
C     ALSO, ADD ECHO OF PRINT CONTROL INPUT DATA.  
C#### WCH, 12/5/94.  ADD NOTAPE, INITIAL JULIAN DAY, DURATION TO  
C       PRINT-OUT.  
C=======================================================================  
      WRITE(N6,3010) NOTAPE,SOUR(NOTAPE+1)  
      WRITE(N6,3020)  JNS,NDT,DS,NU,ANS(ICOST+1),MONTH,NDAY,NYEAR,  
     1                JULDAY,JHR,MINUTE,JSEC  
C=======================================================================  
C#### WCH, 12/5/94.  Include print of ending Julian date.  
C     Calculate ending Julian day.  
C=======================================================================  
      DUR    = FLOAT(NDT)*DS  
      CALL NDATE(DUR,JEND,TMEND)  
      DURTON = FLOAT(NDT)*DS/3600.  
      WRITE (N6,3019) DURTON,JEND,TMEND/3600.  
C#### WCH, 12/5/94.  ECHO INPUT PRINT PARAMETERS.  
      IF(ISUM.EQ.1) WRITE (N6,3021)  
      IF(ISUM.EQ.2) WRITE (N6,3022)  
      IF(ISUM.EQ.0) WRITE (N6,3023)  
      IF(IDET.EQ.0) WRITE (N6,3024)  
      DURTON  = FLOAT(IDET)*DS/60.  
      IF(IDET.GT.0) WRITE (N6,3025) IDET,DURTON  
C  
C=======================================================================  
C#### WCH, 12/5/94.  CHECK FOR IDET > 0 AND NPR = 0 AND ALLOW FOR  
C     INPUTTING 0,0 FOR ISTART AND IEND AS IN RUNOFF BLOCK M2 LINES.  
C=======================================================================  
      IF(IDET.GT.0.AND.NPR.EQ.0) THEN  
           WRITE (N6,3026)  
           NPR = 1  
           ENDIF  
C=======================================================================  
C>>>>>>>> READ DATA GROUP C2 <<<<<<<<  
C=======================================================================  
      IF(IDET.GT.0) READ(N5,*,ERR=888) CC,(ISTART(L),IEND(L),L=1,NPR)  
      DO L=1,NPR  
      JYEAR = ISTART(L)/10000  
      IF ((ISTART(L).GT.0).AND.(JYEAR.LT.100)) THEN  
        ISTART(L) = ISTART(L)-JYEAR*10000  
        JYEAR = JYEAR + 1900  
        ISTART(L) = ISTART(L)+JYEAR*10000  
        ENDIF  
      JYEAR = IEND(L)/10000  
      IF ((IEND(L).GT.0).AND.(JYEAR.LT.100)) THEN  
        IEND(L) = IEND(L)-JYEAR*10000  
        JYEAR = JYEAR + 1900  
        IEND(L) = IEND(L)+JYEAR*10000  
        ENDIF  
      ENDDO  
C=======================================================================  
      DO 1000 L = 1,NPR  
C=======================================================================  
C#### WCH, 12/5/94.  ALLOW 0,0 ENTRY ON SINGLE C2 LINE FOR PRINTING  
C     FOR ENTIRE SIMULATION, AS IN RUNOFF BLOCK M2 LINES.  
C=======================================================================  
      IF(NPR.EQ.1.AND.ISTART(1).EQ.0.AND.IEND(1).EQ.0) THEN  
           WRITE (N6,3027)  
           ISTART(1) = JULDAY  
           IEND(1)   = JEND  
           GO TO 1000  
           ELSE  
           IF(L.EQ.1) WRITE (N6,3028)  
           WRITE (N6,3029) L,ISTART(L),IEND(L)  
           ENDIF  
C  
      N1        = ISTART(L)/10000  
      N3        = ISTART(L) - N1*10000  
      N2        = N3/100  
      N3        = N3 - N2*100  
      ISTART(L) = 1000*N1 + JDATE(N3,N2,N1)  
      N1        = IEND(L)/10000  
      N3        = IEND(L) - N1*10000  
      N2        = N3/100  
      N3        = N3 - N2*100  
      IEND(L)  = 1000*N1 + JDATE(N3,N2,N1)  
 1000 CONTINUE  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP D1  <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,(E(NM),NM=1,12)  
      IF(NP.EQ.0) GO TO 2000  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP E1  <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,(IPOLL(IP),NDIM(IP),IPART(IP),  
     1                       PNAME(IP),PUNIT(IP),IP=1,NP)  
      DO 1420 IP = 1,NP  
      IPT        = IPT+IPART(IP)  
      IF(NOTAPE.EQ.1) IPOLL(IP) = IP  
 1420 CONTINUE  
C=======================================================================  
C>>>>>>>>  READ DATA GROUPS E2 AND E3  <<<<<<<<  
C=======================================================================  
      IF(IPT.LE.0) GO TO 2000  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP E2 <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,NVS,NNR  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP E3 <<<<<<<<  
C=======================================================================  
      READ(N5,*,ERR=888) CC,(RAN(KJ,1),RAN(KJ,2),KJ=1,NNR)  
      IF(NVS.GT.0) THEN  
                   DO 1450 KJ = 1,NNR  
 1450              VS(KJ) = (RAN(KJ,1)+RAN(KJ,2))/2.0  
                   ELSE  
C=======================================================================  
C>>>>>>>>  READ DATA GROUPS E4 AND E5  <<<<<<<<  
C=======================================================================  
                   READ(N5,*,ERR=888) CC,(SPG(KJ),KJ=1,NNR)  
                   READ(N5,*,ERR=888) CC,(TEMP(NM),NM=1,12)  
                   DO 1470 NM = 1,12  
                   IF(METRIC.EQ.1) VIS(NM)=8.46E-4/(TEMP(NM)+10.0)  
 1470              IF(METRIC.EQ.2) VIS(NM)=0.78596/(1.8*TEMP(NM)+42.0)  
                   ENDIF  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP E6  <<<<<<<<  
C=======================================================================  
      DO 1495 IP = 1,NP  
      IF(IPART(IP).LE.0) GO TO 1495  
      READ(N5,*,ERR=888) CC,(PSD(IP,KJ),KJ=1,NNR)  
      TOTPSD     = 0.0  
      DO 1485 KJ = 1,NNR  
 1485 TOTPSD     = TOTPSD+PSD(IP,KJ)  
      IF(TOTPSD.LT.0.99999.OR.TOTPSD.GT.1.00001) THEN  
                                     WRITE(N6,1490) IPOLL(IP)  
                                     STOP  
                                     ENDIF  
 1495 CONTINUE  
C=======================================================================  
C     READ INPUT INTERFACE FILE HEADER INFORMATION  
C=======================================================================  
 2000 IF(NOTAPE.NE.1) CALL INFACE(1,LAST)  
C=======================================================================  
Cwch, 4/18/02.  Add error check for incompatible JCE.  
C	Allow program to continue but warn of impending error.   
C=======================================================================  
      IF(NJCE.NE.JCE) THEN  
		WRITE(N6,4005)   
	    WRITE(*,4005)  
	    ENDIF  
C  
      IF(NP.GT.0) THEN  
C#### WCH, 2/27/95.  NEED TO SET UP CORRECT NAME, UNITS, NDIM FROM  
C     POSITION OF POLLUTANT ON FILE ==> IPOLL().  
C     EASIEST WAY IS TO SAVE TEMPORARILY INCOMING NAME, UNITS, NDIM.  
                  DO 2260 IP = 1,NQUAL  
                  PNAMET(IP) = PNAME(IP)  
                  PUNITT(IP) = PUNIT(IP)  
 2260             NDIMT(IP)  = NDIM(IP)  
C  
                  DO 2270 IP = 1,NP  
c                  IF(IP.GT.NP) GO TO 2270  
C#### WCH, 2/27/95.  GIVE CORRECT NAME, UNIT, DIMENSIONS TO POLLUTANTS.  
                  IPX = IPOLL(IP)  
                  PNAME(IP) = PNAMET(IPX)  
                  PUNIT(IP) = PUNITT(IPX)  
                  NDIM(IP)  = NDIMT(IPX)  
C  
                  IF(METRIC.EQ.1) THEN  
                            PCONV(IP) = 16017.0  
                            IF(NDIM(IP).EQ.1) PCONV(IP)=3.5315E-2  
                            ELSE  
                            PCONV(IP) = 1000.0  
                            IF(NDIM(IP).EQ.1) PCONV(IP)=0.001  
                            ENDIF  
                  IF(NDIM(IP).GE.2) PCONV(IP) = 1.0  
 2270             CONTINUE  
                  ENDIF  
C=======================================================================  
C     WRITE THE OUTPUT INTERFACE HEADER INFORMATION  
C=======================================================================  
      IF(NEXT.GT.0) THEN  
C#### WCH, 8/4/93. SET QCONV FOR METRIC IF S/T IS FIRST BLOCK RUN.  
                    IF(METRIC.EQ.2.AND.NOTAPE.EQ.1) QCONV=CMET(8,2)  
                    REWIND NEXT  
                    SOURCE   = 'S/T BLOCK'  
                    TITLE(3) = ALPHA(1)  
                    TITLE(4) = ALPHA(2)  
                    WRITE(NEXT) LOCATS,NP  
                    WRITE(NEXT) (NLOC(JJS),JJS=1,LOCATS)  
                    CALL INFACE(2,NEXT)  
                    ENDIF  
C=======================================================================  
C      LOCATE INPUT INTERFACE NODE LOCATIONS  
C=======================================================================  
 2500 IF(NOTAPE.NE.1) THEN  
                      DO 2550 JS = 1,LOCATS  
                      IF(NLOC(JS).EQ.JNS) GO TO 3000  
 2550                 CONTINUE  
                      WRITE(N6,2570) JNS,LAST  
                      STOP  
                      ENDIF  
C=======================================================================  
C#### WCH, 12/5/94.  MOVE LINES B1-C2 I/O ECHO PRINTS TO EARLIER SPOT.  
C# 3000 WRITE(N6,3010) SOUR(NOTAPE+1)  
C#      WRITE(N6,3020)  JNS,NDT,DS,NU,ANS(ICOST+1),MONTH,NDAY,NYEAR,JHR,  
C#     +                MINUTE,JSEC  
 3000 IF(METRIC.EQ.1) WRITE(N6,3030) TRIBA  
C#### WCH, 7/7/95.  CORRECT METRIC PRINT-OUT OF TRIBA.  CONVERT TO HA.  
      IF(METRIC.EQ.2) WRITE(N6,3040) TRIBA/2.471  
      WRITE(N6,3060) NP  
      IF(NP.GT.0) THEN  
                  DO 3070 IP = 1,NP  
C#### WCH, 12/5/94.  ADD PRINT OF IPART().  
 3070             WRITE(N6,3080)IP,PNAME(IP),PUNIT(IP),IPART(IP),  
     1                    ANS(IPART(IP)+1)  
                  ENDIF  
C  
      IF(METRIC.EQ.1) WRITE(N6,3110)  
      IF(METRIC.EQ.2) WRITE(N6,3120)  
      WRITE(N6,3130) (DMON(NM),NM=1,12),(E(NM),NM=1,12)  
C  
      IF(IPT.LE.0) GO TO 4000  
      IF(NVS.LE.0) WRITE(N6,3210)  
      IF(NVS.GT.0) WRITE(N6,3220)  
      WRITE(N6,3230) (RAN(KJ,1),KJ=1,NNR)  
      IF(NVS.LE.0) WRITE(N6,3240) (PDUM1,KJ=1,NNR)  
      IF(METRIC.EQ.1.AND.NVS.GT.0) WRITE(N6,3250) (PDUM1,KJ=1,NNR)  
      IF(METRIC.EQ.2.AND.NVS.GT.0) WRITE(N6,3255) (PDUM1,KJ=1,NNR)  
      WRITE(N6,3230) (RAN(KJ,2),KJ=1,NNR)  
      IF(NVS.EQ.0) WRITE(N6,3260) (SPG(KJ),KJ=1,NNR)  
      DO 3280 IP = 1,NP  
 3280 WRITE(N6,3290) PNAME(IP),(PSD(IP,KJ),KJ=1,NNR)  
C  
 3300 IF(NVS.GT.0)   GO TO 4000  
      WRITE(N6,3350) (DMON(NM),NM=1,12)  
      IF(METRIC.EQ.1) WRITE(N6,3370)(TEMP(NM),NM=1,12),(VIS(NM),NM=1,12)  
      IF(METRIC.EQ.2) WRITE(N6,3390)(TEMP(NM),NM=1,12),(VIS(NM),NM=1,12)  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
 4000 WRITE(*,9510)  
      CALL STRDAT  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
      QOL     = 0.0  
      QCARL   = 0.0  
C#### WCH, 7/7/95.  QO(JS) is used twice.  Define new variable to keep  
C       separate.  
      QOJS    = 0.0  
C  
      QO(JS)  = 0.0  
      QO1(JS) = 0.0  
      IF(NP.GT.0) THEN  
                  DO 6010 IP = 1,NP  
 6010             POLCL(IP)  = 0.0  
                  ENDIF  
C=======================================================================  
C     MAIN TIME LOOP  
C=======================================================================  
      WRITE(*,23) NDT,JEND  
      DO 9000 KDT = 1,NDT  
C####      WRITE(*,22)   KDT  
      TIME        = TIME + DS  
      TIMEHR      = TIME/3600.0  
      CALL STIME(DS)  
      CALL DATED  
C#### WCH, 12/5/94.  MOVE WRITE TO HERE AND ADD JULIAN DAY.  
C***WCH, 9/27/99. WRITE TO UNIT 6 TO GET CARRIAGE CONTROL.  
C      WRITE(*,22)   KDT,JULDAY  
      WRITE(6,22)   KDT,JULDAY  
      IF(NP.GT.0) THEN  
                  DO 6110 IP  = 1,NP  
                  POLC(IP)    = 0.0  
                  PCRC(IP)    = 0.0  
 6110             PCTP(IP)    = 0.0  
                  ENDIF  
C=======================================================================  
C>>>>>>>>  READ DATA GROUP J1  <<<<<<<<  
C=======================================================================  
      IF(NOTAPE.GE.1) THEN  
 7050           IF(TIMEHR.GT.TCAR1) THEN  
                   TCAR = TCAR1  
                   QCAR = QCAR1  
                   IF(NP.GT.0) THEN  
						DO IP = 1,NP  
	                    PCAR(IP) = PCAR1(IP)  
	                    ENDDO  
c                               PCAR(1) = PCAR1(1)  
c                               PCAR(2) = PCAR1(2)  
c                               PCAR(3) = PCAR1(3)  
                               READ(N5,*,ERR=888) CC,TCAR1,QCAR1,  
     +                                        (PCAR1(IP),IP=1,NP)  
                               ELSE  
                               READ(N5,*,ERR=888) CC,TCAR1,QCAR1  
                               ENDIF  
                   IF(TCAR1.LT.TIMEHR) GO TO 7050  
                   ENDIF  
                QCARD = QLINTP(QCAR,QCAR1,TCAR,TCAR1,TIMEHR)  
                IF(NP.GT.0) THEN  
                            DO 6210 IP = 1,NP  
                            QQ1      = QCAR*PCAR(IP)  
                            QQ2      = QCAR1*PCAR1(IP)  
                            POLC(IP) = QLINTP(QQ1,QQ2,TCAR,TCAR1,TIMEHR)  
 6210                       CONTINUE  
                            ENDIF  
                ENDIF  
C=======================================================================  
C     READ INTERFACE FILE FLOWS AND LOADS  
C     During interpolation,  
C     Begin interface file dt			End interface file dt  
C     Flow:      QOJS()					     QO1()  
C     Pollutant  POLL()						 POLL1()  
C=======================================================================  
      IF(NOTAPE.NE.1) THEN  
 6400 IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN  
C#### WCH, 7/7/95.  HERE, USE NEW VARIABLE QOJS FOR OLD INFLOW.  
C####          QO(JS)    = QO1(JS)  
           QOJS = QO1(JS)  
C  
           IF(NP.GT.0) THEN  
                DO 4520 J  = 1,NP  
 4520           POLL(J,JS) = POLL1(J,JS)  
                ENDIF  
C=======================================================================  
C     On interface file, flow has units of cfs or cms, depending on  
C     parameter METRIC.   
C     Load has units of concentration*cfs or concentration*cms, also  
C     depending on METRIC.  
C     If METRIC = 2, QCONV = 35.3... ft3/m3.  
Cwch, 11/24/03.  
C     Since S/T uses metric units direction, should not need any  
C     conversions  
C=======================================================================  
           IF(NQUAL.EQ.0) READ(LAST,END=999) JDAY,TMDAY,DELTA,  
     +                                  (QO1(J),J=1,LOCATS)  
           IF(NQUAL.GT.0) READ(LAST,END=999) JDAY,TMDAY,DELTA,  
     +                    (QO1(J),(POLL1(IP,J),IP=1,NQUAL),J=1,LOCATS)  
           GO TO 2995  
  999      QO(JS)      = 0.0  
C#### WCH, 7/7/95  
           QOJS        = 0.0  
C  
           QO1(JS)     = 0.0  
           DO 2990  J  = 1,NQUAL  
           POLL1(J,JS) = 0.0  
           POLL(J,JS)  = 0.0  
 2990      CONTINUE  
           WRITE(N6,9200) TIME/3600.0  
           JDAY       = 9999999  
           TMDAY      = 0.0  
 2995      CONTINUE  
           TREF = TIMEHR  
           CALL NTIME(JDAY,TMDAY,TFILE)  
           IF(TFILE.LT.0.0) GO TO 6400  
           TFILE = TFILE/3600.0  
Cwch, 11/24/03. Eliminate back and forth conversions from metric.  
C           IF(NQUAL.GT.0.AND.NP.GT.0) THEN  
C                DO 6410 IP   = 1,NP  
C                IPX          = IPOLL(IP)  
C=======================================================================  
C     If METRIC = 2, internal flows are in cms and loads are cms*concen.  
C     Thus, multiply by 2.8317E-2 because will multiply by QCONV later.  
C     QCONV = 35.314667 cfs/cms = 1 / 0.28317E-2 when metric flows are on  
C     interface file.  Thus, interface flows and loads are converted  
C     properly whether in cfs or cms.  
C=======================================================================  
C                IF(METRIC.EQ.2) POLL1(IPX,JS) =  
C     +                                POLL1(IPX,JS)*2.8317E-2  
C 6410           POLL1(IPX,JS) = POLL1(IPX,JS)*QCONV  
C                ENDIF  
C=======================================================================  
C     If METRIC = 2 (metric units), QO1 has units of cms/35...  in line  
C     below.  But flow is multiplied by QCONV = 35...  later below  
C     and converted back to cms.  
C=======================================================================  
C           IF(METRIC.EQ.2) QO1(JS) = QO1(JS)*2.8317E-2  
           ENDIF  
C=======================================================================  
      THR = TIMEHR - TREF  
C#### WCH, 7/7/95.  HERE, USE NEW VARIABLE QOJS.  
C####      QQ1 = QO(JS)  
      QQ1 = QOJS  
      QQ2 = QO1(JS)  
Cwch, 11/24/03. Eliminate metric conversion with QCONV.  
C      IF(TFILE.EQ.0.0) QOO = QQ2*QCONV  
C      IF(TFILE.GT.0.0) QOO = QLINTP(QQ1,QQ2,0.0,TFILE,THR)*QCONV  
      IF(TFILE.EQ.0.0) QOO = QQ2  
      IF(TFILE.GT.0.0) QOO = QLINTP(QQ1,QQ2,0.0,TFILE,THR)  
C=======================================================================  
C     AT THIS POINT, QOO SHOULD HAVE UNITS OF CFS OR CMS, APPROPRIATELY.  
C=======================================================================  
      IF(NP.GT.0) THEN  
                  DO 4530 IP = 1,NP  
                  IPX        = IPOLL(IP)  
                  QQ1        = POLL(IPX,JS)  
                  QQ2        = POLL1(IPX,JS)  
C#######################################################################  
C#### WCH, 7/7/95.  ONE CONVERSION TOO MANY??  POLL1 AND POLL SHOULD  
C     ALREADY BE IN UNITS OF FLOW*CONC WHERE FLOW IS CFS OR CMS OR  
C     WHATEVER UNITS ARE ON INTERFACE FILE.  DON'T MULTIPLY AGAIN  
C     BY QCONV (= 35... FOR METRIC=2).  
C=======================================================================  
C####                  IF(TFILE.EQ.0.0) POLC(IP) = POLC(IP) + QQ2*QCONV  
C####                  IF(TFILE.GT.0.0) POLC(IP) = POLC(IP) +  
C####     +                         QLINTP(QQ1,QQ2,0.0,TFILE,THR)*QCONV  
                  IF(TFILE.EQ.0.0) POLC(IP) = POLC(IP) + QQ2  
                  IF(TFILE.GT.0.0) POLC(IP) = POLC(IP) +  
     +                         QLINTP(QQ1,QQ2,0.0,TFILE,THR)  
C  
 4530             CONTINUE  
                  ENDIF  
      ENDIF  
C=======================================================================  
C     Calculate average flow over the time interval.  
C     QQTP = will have units of cfs or cms appropriately.  
C=======================================================================  
      QQTP  = (QCARD + QCARL + QOO + QOL)/2.0  
C=======================================================================  
C     Save old flow values.  
C=======================================================================  
      QCARL = QCARD  
      QOL   = QOO  
C=======================================================================  
C     CALCULATE AVERAGE CONCENTRATION OVER THE TIME INTERVAL  
C=======================================================================  
      IF(NP.GT.0) THEN  
                  DO 6470 IP = 1,NP  
                  IPX        = IPOLL(IP)  
C######################################################################  
C#### WCH, 7/7/95.  DON'T CONVERT AGAIN HERE.  POLL(JS) = POLL1(JS)  
C     JUST BEFORE READING INTERFACE FILE.  SHOULD BE OK.  
C     TO GET AVG. CONC., SHOULD BE DIVIDING CFS*CONC / CFS OR  
C     CMS*CONC / CMS.  
C=======================================================================  
C####           IF(METRIC.EQ.2) POLL(IPX,JS) = POLL(IPX,JS)*2.8317E-2  
                  IF(QQTP.GT.0.0) PCTP(IP)     = (POLC(IP) + POLCL(IP))  
     +                                                     / (2.0*QQTP)  
                  POLCL(IP) = POLC(IP)  
 6470             CONTINUE  
                  ENDIF  
C=======================================================================  
C     COMPUTE SETTLING VELOCITIES (TO LABEL 6580).  THIS ROUTINE  
C     WAS DEVELOPED BY M.B. SONNEN, SEPTEMBER 1977.  
C=======================================================================  
      IF(IPT.LE.0.OR.NVS.GT.0)      GO TO 6600  
      IF(LTM.EQ.MONTH.AND.KDT.GT.1) GO TO 6600  
      IF(METRIC.EQ.2) VIS(MONTH) = VIS(MONTH)/929.03  
      DO 6580 KJ = 1,NNR  
      PSIZE      = (RAN(KJ,1)+RAN(KJ,2))/(2.0*304800.0)  
      IF(SPG(KJ).LT.1.0) SPG(KJ) = 1.0  
      CON1   = (4.0/3.0)*PSIZE*32.2*(SPG(KJ)-1.0)  
      CD     = 0.34  
      VS(KJ) = SQRT(CON1/CD)  
      R      = VS(KJ)*PSIZE/VIS(MONTH)  
      IF(R.GT.3000.0) GO TO 6580  
      CD     = 1.0  
      VS(KJ) = SQRT(CON1/CD)  
      R      = VS(KJ)*PSIZE/VIS(MONTH)  
      IF(R.GT.100.0) GO TO 6510  
      CD     = 10.0  
      VS(KJ) = SQRT(CON1/CD)  
      R      = VS(KJ)*PSIZE/VIS(MONTH)  
      IF(R.GT.2.0) GO TO 6510  
      CD     = 200.0  
      VS(KJ) = SQRT(CON1/CD)  
      R      = VS(KJ)*PSIZE/VIS(MONTH)  
      IF(R.GT.0.1) GO TO 6510  
      GO TO 6570  
 6510 KN = 0  
 6520 KN = KN+1  
      R  = VS(KJ)*PSIZE/VIS(MONTH)  
      IF(R.LT.0.1) GO TO 6570  
      F = CD-(24.0*VIS(MONTH)/PSIZE)/VS(KJ)-(3.0*(VIS(MONTH)/PSIZE)**  
     1    0.5)/VS(KJ)**0.5-0.34  
      IF(ABS(F).LT.0.005*CD) GO TO 6580  
      IF(KN.GT.1)            GO TO 6530  
      FL = F  
      IF(ABS(FL).LT.0.0049)      GO TO 6580  
 6530 IF(ABS(F).GT.10.0*ABS(FL)) GO TO 6540  
                      CD1 = CD-F  
      IF(CD1.LT.0.34) CD1 = 0.34  
      CD     = CD1  
      VS(KJ) = SQRT(CON1/CD)  
      IF(KN.LT.10) GO TO 6520  
 6540 WRITE(N6,6550) RAN(KJ,1),RAN(KJ,2)  
      STOP  
 6570 VS(KJ) = (32.2/18.0)*(SPG(KJ)-1.0)*PSIZE**2.0/VIS(MONTH)  
 6580 CONTINUE  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
 6600 CALL CONTRL  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
 6700 IF(NEXT.GT.0) THEN  
C#### ROB JAMES (BY WCH), 8/4/93.  REMOVE THIS CONVERSION IN ORDER  
C####   TO PLACE METRIC FLOWS (M^3/SEC) ON INTERFACE FILE.  
CC      IF(METRIC.EQ.2) QQRC = QQRC/2.8317E-2  
C=======================================================================  
C     HERE, ASSIGN OUTFLOW FROM PLANT TO QO(JS) AND SET FLOWS AT OTHER  
C     NODES ON INTERFACE FILE TO THEIR INFLOW VALUES.  
C=======================================================================  
           QO(JS)    = QQRC  
           DO 6720 J = 1,LOCATS  
           IF(J.EQ.JS) GO TO 6720  
           QO(J)     = QO1(J)  
 6720      CONTINUE  
           IF(NP.GT.0) THEN  
                  DO 6730 IP   = 1,NP  
Cwch, 11/24/03.  Need new POLL variable since here we change meaning  
C     from value saved for interpolation.  
C 6730             POLL1(IP,JS) = PCRC(IP)*QQRC  
C                  WRITE(NEXT) JULDAY,TIMDAY,DS,(QO(J),(POLL1(IP,J),  
 6730             POLL2(IP,JS) = PCRC(IP)*QQRC  
                  WRITE(NEXT) JULDAY,TIMDAY,DS,(QO(J),(POLL2(IP,J),  
     1                        IP=1,NP),J=1,LOCATS)  
                  ELSE  
                  WRITE(NEXT) JULDAY,TIMDAY,DS,(QO(J),J=1,LOCATS)  
                  ENDIF  
           ENDIF  
 9000 CONTINUE  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
      IF(ICOST.GT.0) CALL STCOST  
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  
      WRITE(*,8050)  
      WRITE(N6,8050)  
C=======================================================================  
C#### WCH, 12/5/94.  Alter 22 and 23 to add Julian dates.  
   22 FORMAT('+',I19,I22)  
   23 FORMAT(/,' Beginning loop through',I7,' time steps.',/,  
     1         ' End at Julian date:',I8,/,  
     2         ' Current time step #   Current Julian date ',/)  
  150 FORMAT(/,' ###########################################',/,  
     1         ' # Entry made to Storage/Treatment Block.  #',/,  
     2         ' # Storage/Treatment model written by the  #',/,  
     3         ' # University of Florida, June 1981.       #',/,  
     4         ' # Last updated July 1995 at Oregon St. U. #',/,  
     5         ' ###########################################',/)  
 1490 FORMAT(/,' ===> ERROR  THE PARTICLE SIZE OR V  
     1ELOCITY DISTRIBUTION FOR POLLUTANT ',I1,' DOES NOT SUM TO 1.0.',/,  
     232X,'SIMULATION TERMINATED.')  
 2570 FORMAT(/,' ===> ERROR  THE SELECTED EXTERNAL',  
     1' ELEMENT NUMBER, ',I4,' IS NOT AVAILABLE FROM',/,32X,'DATA-SET. '  
     2,I3,'.  SIMULATION TERMINATED.')  
C#### WCH, 12/5/94.  ADD PRINT OF NOTAPE.  
 3010 FORMAT(/,1X,'VALUE OF NOTAPE           :',I10,//,  
     1         1X,'INPUT DATA SOURCE         :',2X,A40)  
C#### WCH, 12/5/94.  NEW 3019 FORMAT.  
 3019 FORMAT(/,1X,'SIMULATION DURATION, HOURS:',F10.3,//,  
     1         1X,'ENDING JULIAN DATE        :',I10,//,  
     1         1X,'ENDING TIME OF DAY        :',F10.3,' HOURS')  
C#### WCH, 12/5/94.  CHANGE A BUNCH OF LEADING 10X SPACES TO 1X. THIS  
C     IS EQUIVALENT TO SUBTRACTING 9 LEADING SPACES IN MANY PLACES.  
C#### WCH, 12/5/94.  ADD STARTING JULIAN DATE.  
 3020 FORMAT(/,1X,'EXTERNAL ELEMENT NUMBER   :',I10,//,  
     1         1X,'NUMBER OF TIME STEPS      :',I10,//,  
     2         1X,'TIME STEP SIZE,SECONDS    :',F10.1,//,  
     3         1X,'NUMBER OF S/T UNITS       :',I10,//,  
     4         1X,'COST MODEL USED?          :',7X,A3,//,  
     5         1X,'STARTING DATE             :',4X,I2,'/',I2,'/',I4,//,  
     6         1X,'STARTING JULIAN DATE      :',I10,//,  
     7         1X,'STARTING TIME             :',2X,I3,':',I3,':',I3)  
C#### WCH, 12/5/94.  NEW 3021 - 3029 FORMATS.  
 3021 FORMAT(/,1X,'PRINT ANNUAL AND TOTAL SUMMARIES (ISUM = 1)')  
 3022 FORMAT(/,1X,'PRINT MONTHLY, ANNUAL AND TOTAL SUMMARIES (ISUM = 2)  
     1 ')  
 3023 FORMAT(/,1X,'PRINT TOTAL SIMULATION SUMMARY ONLY (ISUM = 0)')  
 3024 FORMAT(/,1X,'IDET = 0. NO DETAILED (TIME STEP) PRINT-OUTS.')  
 3025 FORMAT(/,1X,'DETAILED PRINT-OUT EVERY',I4,' (IDET) TIME STEPS = EV  
     1ERY',F8.2,'MIN.')  
 3026 FORMAT(/,1X,'WARNING. IDET > 0 AND NPR = 0.  PROGRAM WILL TRY TO R  
     1EAD AT LEAST ONE C2 LINE.')  
 3027 FORMAT(/,1X,'ZERO VALUES FOR ISTART, IEND (LINE C2).  PRINT FOR EN  
     1TIRE SIMULATION.')  
 3028 FORMAT(/,' TIME INTERVALS FOR DETAILED PRINT-OUTS (LINE C2):',/,  
     1 ' NUMBER     ISTART      IEND',/,  
     2 '          YR-MO-DAY  YR-MO-DAY')  
 3029 FORMAT(I5,I13,I11)  
C  
 3030 FORMAT(//,1X,'INPUT/OUTPUT UNITS        :   U.S. CUSTOMARY',//,  
     1          1X,'TRIBUTARY AREA, ACRES     :',F10.1)  
C#### WCH, 12/5/94.  CHANGE METRIC AREA TO HECTARES.  
 3040 FORMAT(//,1X,'INPUT/OUTPUT UNITS        :      METRIC',//,  
     1          1X,'TRIBUTARY AREA, HECTARES  :',F10.1)  
 3060 FORMAT(/,1X,'NUMBER OF POLLUTANTS      :',I10)  
 3080 FORMAT(/,1X,'POLLUTANT ',I1,'               :',4X,A8,//,  
     1         6X,'UNITS                :',4X,A8,/,  
     2         6X,'IPART                :',I10,/,  
     3         6X,'PART. SIZE/VEL. USED?:',7X,A3)  
 3110 FORMAT(//,10X,'MONTHLY EVAPORATION RATES, IN/DAY')  
 3120 FORMAT(//,10X,'MONTHLY EVAPORATION RATES, MM/DAY')  
 3130 FORMAT(/,1X,12(2X,A4,2X),//,1X,12(2X,F5.3,1X))  
 3210 FORMAT(//,1X,'PARTICLE SIZES AND POLLUTANT FRACTIONS',//)  
 3220 FORMAT(//,1X,'SETTLING VELOCITIES AND POLLUTANT FRACTIONS',//)  
 3230 FORMAT(1X,10(1X,E9.3))  
 3240 FORMAT(1X,'RANGE IN MICRONS    ',10(6X,1A2,2X))  
 3250 FORMAT(1X,'RANGE IN FEET/SEC   ',10(6X,A2,2X))  
 3255 FORMAT(1X,'RANGE IN CM/SEC     ',10(6X,A2,2X))  
 3260 FORMAT(/,1X,'SPECIFIC GRAVITY    ',10(2X,F8.3))  
C#### WCH (RED), 9/23/93.  CHANGE 2A4 TO A8.  
 3290 FORMAT(/,1X,'FRAC. OF ',A8,3X,10(5X,F5.3))  
 3350 FORMAT(//,1X,'MONTHLY WATER TEMPERATURES AND KINEMATIC VISCOSITIES  
     1',//,21X,12(2X,1A4,2X))  
 3370 FORMAT(/,1X,'TEMPERATURE, DEG. F ',12(2X,F4.1,2X),//,1X,  
     1            'VISCOSITY, SQ FT/SEC',12(1X,E7.2))  
 3390 FORMAT(/,1X,'TEMPERATURE, DEG. C ',12(2X,F4.1,2X),//,1X,  
     1            'VISCOSITY, SQ CM/SEC',12(1X,E7.2))  
Cwch, 4/18/02.  
 4005 FORMAT(/,' ERROR SAME ALPHANUMERIC OPTION ($ANUM) WAS NOT USED IN  
     1 ST/TREAT',/,' AS IN BLOCK THAT CREATED INTERFACE FILE.',/,  
	2' PROGRAM CONTINUES BUT UNPREDICTABLE ERROR WILL SOON RESULT.')  
C#### WCH, 12/5/94. ELIMINATE UNUSED 6311 FORMAT.  
 6550 FORMAT(/,' ===> WARNING  THE SETTLING VELOCITY  
     1 ROUTINE HAS NOT CONVERGED FOR THE RANGE',/,36X,F8.1,' TO ',F8.1,  
     2' MICRONS.  SIMULATION TERMINATED.')  
 8050 FORMAT(/,' ===> Storage/Treatment simulation ended normally.')  
CWCH, 11/11/99. INCREASE FIELD WITH FOR NUMBER OF HOURS.  
 9200 FORMAT(/,' ===> WARNING  END OF INPUT FILE REACHED AT TIME = ',  
     +         F10.1,' HOURS.',/,  
     +'                 SIMULATION CONTINUES WITH ZERO INFLOW.',/)  
 9500 FORMAT(/,' Reading general data and control information.')  
 9510 FORMAT(/,' Reading Storage/Treatment unit information.')  
C=======================================================================  
      RETURN  
  888 CALL IERROR  
      END  
ECHO is off.
REM File: swmm_WCH44_combined_1.FOR  
ECHO is off.
 
REM File: TEMP.FOR 
 
      SUBROUTINE TEMP 
C	TEMP BLOCK 
C======================================================================= 
C     CREATED APRIL, 1988 BY BOB DICKINSON 
C     UPDATED 11/92 BY WCH TO CORRECT FEBRUARY LENGTH CALCULATION 
C       AND TO CORRECT STATEMENT WITH EVAP. PAN COEF. MULTIPLICATION 
C     UPDATED 4/93 BY WCH TO READ PAN COEFS FOR KTYPE = 3 AND 6. 
C     WCH, 7/27/04. Fix subscript of PAN.    
C     WCH, 7/27/04. Major adjustments for units.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TEW.INC' 
      DIMENSION TMEAN(12),TMIN(12),TMAX(12) 
      CHARACTER*10 MMNTH(12) 
      DATA MMNTH/'JANUARY','FEBRUARY','MARCH','APRIL', 
     +           'MAY','JUNE','JULY','AUGUST','SEPTEMBER', 
     +           'OCTOBER','NOVEMBER','DECEMBER'/ 
C======================================================================= 
      INCNT  = INCNT + 1 
      IOUTCT = IOUTCT + 1 
      IO     = JIN(INCNT) 
      NEXT   = JOUT(IOUTCT) 
      IGO    = 0 
C======================================================================= 
      IF(JIN(INCNT).GT.0.AND.(FFNAME(INCNT).EQ.'JOT.UF'.OR. 
     +      FFNAME(INCNT).EQ.'JIN.UF')) 
     +      OPEN(JIN(INCNT),FORM='FORMATTED',STATUS='SCRATCH') 
      IF(JIN(INCNT).GT.0.AND.FFNAME(INCNT).NE.'JOT.UF'.AND. 
     +      FFNAME(INCNT).NE.'JIN.UF') 
     +      OPEN(JIN(INCNT),FILE=FFNAME(INCNT),FORM='FORMATTED', 
     +      STATUS='UNKNOWN') 
      IF(JOUT(IOUTCT).GT.0.AND.(FFNAME(25+IOUTCT).EQ.'JOT.UF'.OR. 
     +      FFNAME(25+IOUTCT).EQ.'JIN.UF')) 
     +      OPEN(JOUT(IOUTCT),FORM='UNFORMATTED',STATUS='SCRATCH') 
      IF(JOUT(IOUTCT).GT.0.AND.FFNAME(25+IOUTCT).NE.'JOT.UF'.AND. 
     +      FFNAME(25+IOUTCT).NE.'JIN.UF') 
     +      OPEN(JOUT(IOUTCT),FILE=FFNAME(25+IOUTCT),FORM='UNFORMATTED', 
     +      STATUS='UNKNOWN') 
C======================================================================= 
C     OPEN STATEMENT FOR VAX COMPUTERS 
C======================================================================= 
C     OPEN(IO,FILE=FFNAME(INCNT),FORM='FORMATTED', 
C    +                           STATUS='UNKNOWN',RECL=350) 
      REWIND IO 
      WRITE(N6,1000) 
      WRITE(*,1000) 
C======================================================================= 
      DO 10 J = 1,12 
  10  PAN(J)  = 0.70 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP A1 <<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,TITLE(1) 
      READ(N5,*,ERR=888) CC,TITLE(2) 
      WRITE(N6,68) TITLE(1),TITLE(2) 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP B1 <<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      READ(N5,*,ERR=888) CC,IFORM,ISTA,KTYPE,JYBEG,JYEND,IYEAR 
C#### WCH, 4/3/93.  ADD KTYPE = 3 AND 6. 
Cwch, 7/28/04. Add KTYPE = 5 
      IF(KTYPE.EQ.1.OR.KTYPE.EQ.3.OR.KTYPE.EQ.5.OR.KTYPE.EQ.6) THEN 
                      BACKSPACE N5 
                      READ(N5,*,ERR=888) CC,IFORM,ISTA,KTYPE,JYBEG, 
     +                         JYEND,IYEAR,PAN 
                      ENDIF 
C======================================================================= 
C FOR DATES, READ YR-MO-DAY AS 8 DIGIT NUMBER. 
C (1) = YEAR, (2) = MONTH, (3) = DAY 
C======================================================================= 
      JYEAR = JYBEG/10000 
      IF ((JYBEG.GT.0).AND.JYEAR.LT.100) THEN 
      JYBEG = JYBEG - JYEAR*10000 
      JYEAR = JYEAR + 1900 
      JYBEG = JYBEG + JYEAR*10000 
      ENDIF 
      JYEAR = JYEND/10000 
      IF ((JYEND.GT.0).AND.JYEAR.LT.100) THEN 
      JYEND = JYEND - JYEAR*10000 
      JYEAR = JYEAR + 1900 
      JYEND = JYEND + JYEAR*10000 
      ENDIF 
      IYBEG(1) = JYBEG/10000 
      IYBEG(2) = (JYBEG - IYBEG(1)*10000)/100 
      IYEND(1) = JYEND/10000 
      IYEND(2) = (JYEND - IYEND(1)*10000)/100 
      IYEND(3) = JYEND - IYEND(1)*10000 - IYEND(2)*100 
      IYBEG(3) = JYBEG - IYBEG(1)*10000 - IYBEG(2)*100 
      WRITE(N6,1021) ISTA,IYBEG,IYEND,IFORM,KTYPE,IYEAR 
      WRITE(NEXT) ISTA 
      IF(KTYPE.EQ.1) WRITE(N6,1022) PAN 
C#### WCH, 12/92.  IFORM = 1 NOT IMPLEMENTED. 
      IF(IFORM.EQ.1) THEN 
        WRITE(N6,2100)  
        WRITE(*,2100) 
        STOP 
      ENDIF 
C#### WCH, 12/92.  PRINT WARNING IF START/STOP DATES = 0. 
      IF(JYBEG.EQ.0.OR.JYEND.EQ.0) WRITE(N6,2150) 
C======================================================================= 
C >>>>>>>>>>>>>> READ DATA GROUP B2 <<<<<<<<<<<<<<<<<<<<< 
C======================================================================= 
      IF(IFORM.EQ.2) THEN 
                     IF(KTYPE.EQ.0) READ(N5,*,ERR=888) CC,FIRMAT, 
     +                        METRIC,KUNIT,CONV,F1,F2,F3,F4,F5,F6 
                     IF(KTYPE.GE.1) READ(N5,*,ERR=888) CC,FIRMAT, 
     +                        METRIC,KUNIT,CONV,F1,F2,F3,F4,F5 
                     WRITE(N6,1030) FIRMAT,METRIC,KUNIT,CONV, 
     +                              F1,F2,F3,F4,F5,F6 
Cwch, 7/27/04. Require METRIC = KUNIT. 
                     IF(METRIC.NE.KUNIT) THEN 
	                    WRITE(N6,2040) 
	                    METRIC = KUNIT 
	                    ENDIF 
                     METRIC = METRIC + 1 
                     ENDIF 
C======================================================================= 
      CALL GTCOLD(0,IGO) 
    7 WRITE(*,911) NEWYR 
      CALL GTCOLD(1,IGO) 
C======================================================================= 
C======================================================================= 
      DO 375 K = 1,12 
      TMIN(K)  = -99.0 
      TMAX(K)  = -99.0 
      TMEAN(K) = -99.0 
  375 CONTINUE 
      IF(KTYPE.EQ.0.OR.KTYPE.EQ.3.OR.KTYPE.EQ.4.OR.KTYPE.EQ.6) THEN 
      KWRITE   = 0 
      DO 400 K = 1,12 
                                                KMONTH = 31 
      IF(K.EQ.9.OR.K.EQ.4.OR.K.EQ.6.OR.K.EQ.11) KMONTH = 30 
C ### WCH, 11/92.  REVERSE FEBRUARY CALCULATION 
      IF(K.EQ.2.AND.MOD(NEWYR,4).EQ.0)         KMONTH = 29 
      IF(K.EQ.2.AND.MOD(NEWYR,4).NE.0)         KMONTH = 28 
      IF(BARAY(K,1).EQ.-99.0.AND.BARAY(K,KMONTH).EQ.-99.0.AND. 
     +   SARAY(K,1).EQ.-99.0.AND.SARAY(K,KMONTH).EQ.-99.0) GO TO 400 
      KWRITE  = KWRITE + 1 
Cwch, 7/27/04. Change titles for print of user input and metric. 
C      IF(KWRITE.EQ.1) WRITE(N6,970) TITLE(1),TITLE(2) 
      IF(KWRITE.EQ.1.AND.IFORM.EQ.0) WRITE(N6,970) TITLE(1),TITLE(2) 
	IF(KWRITE.EQ.1.AND.IFORM.EQ.2) THEN 
	     IF(METRIC.EQ.1) WRITE(N6,972) TITLE(1),TITLE(2) 
	     IF(METRIC.EQ.2) WRITE(N6,973) TITLE(1),TITLE(2) 
	     ENDIF 
	DO 450 J = 1,31 
      IF(SARAY(K,J).EQ.-99) SARAY(K,J) = BARAY(K,J) 
  450 IF(BARAY(K,J).EQ.-99) BARAY(K,J) = SARAY(K,J) 
C####################################################################### 
C WCH, 12/92. MODIFY PRINT AND STATISTICS FOR ARBITRARY START/STOP DATES 
C####################################################################### 
         IDB = 1 
         IF(IYBEG(1).EQ.NEWYR.AND.K.EQ.IYBEG(2)) IDB = IYBEG(3) 
         IDS = KMONTH 
         IF(IYEND(1).EQ.NEWYR.AND.K.EQ.IYEND(2)) IDS = IYEND(3) 
      IF(IYEAR.GT.0) WRITE(N6,990) (K,J,NEWYR,BARAY(K,J), 
     +                              SARAY(K,J),J=IDB,IDS) 
      TMIN(K)  =  200.0 
      TMAX(K)  = -100.0 
      TMEAN(K) =    0.0 
      DO 475 J = IDB,IDS 
      IF(SARAY(K,J).LT.TMIN(K)) TMIN(K) = SARAY(K,J) 
      IF(BARAY(K,J).GT.TMAX(K)) TMAX(K) = BARAY(K,J) 
      TMEAN(K) = TMEAN(K) + 0.5*(BARAY(K,J)+SARAY(K,J)) 
  475 CONTINUE 
C### WCH, 12/92  USE CORRECT NUMBER OF DAYS. 
      TMEAN(K) = TMEAN(K)/FLOAT(IDS-IDB+1) 
  400 CONTINUE 
      WRITE(N6,480) NEWYR 
      DO 490 K = 1,12 
      IF(TMEAN(K).EQ.-99.0) GO TO 490 
      WRITE(N6,485) MMNTH(K),TMIN(K),TMAX(K),TMEAN(K) 
  490 CONTINUE 
      ENDIF 
C======================================================================= 
      IF(KTYPE.EQ.1.OR.KTYPE.EQ.3.OR.KTYPE.GE.5) THEN 
      KWRITE   = 0 
      DO 500 K = 1,12 
                                                KMONTH = 31 
      IF(K.EQ.9.OR.K.EQ.4.OR.K.EQ.6.OR.K.EQ.11) KMONTH = 30 
C ### WCH, 11/92.  REVERSE FEBRUARY CALCULATION 
      IF(K.EQ.2.AND.MOD(NEWYR,4).EQ.0)         KMONTH = 29 
      IF(K.EQ.2.AND.MOD(NEWYR,4).NE.0)         KMONTH = 28 
      IF(EARAY(K,1).EQ.-99.AND.EARAY(K,KMONTH).EQ.-99) GO TO 500 
      KWRITE  = KWRITE + 1 
Cwch, 7/27/04. Change titles for print of user input and metric. 
C      IF(KWRITE.EQ.1) WRITE(N6,975) TITLE(1),TITLE(2) 
      IF(KWRITE.EQ.1.AND.IFORM.EQ.0) WRITE(N6,975) TITLE(1),TITLE(2) 
	IF(IFORM.EQ.2) THEN 
	     IF(METRIC.EQ.1) WRITE(N6,977) TITLE(1),TITLE(2) 
	     IF(METRIC.EQ.2) WRITE(N6,978) TITLE(1),TITLE(2) 
	     ENDIF 
C####################################################################### 
C WCH, 12/92. MODIFY PRINT AND STATISTICS FOR ARBITRARY START/STOP DATES 
C####################################################################### 
         IDB = 1 
         IF(IYBEG(1).EQ.NEWYR.AND.K.EQ.IYBEG(2)) IDB = IYBEG(3) 
         IDS = KMONTH 
         IF(IYEND(1).EQ.NEWYR.AND.K.EQ.IYEND(2)) IDS = IYEND(3) 
      IF(IYEAR.GT.0) WRITE(N6,995) (K,J,NEWYR,EARAY(K,J),J=IDB,IDS) 
  500 CONTINUE 
      ENDIF 
C======================================================================= 
      IF(KTYPE.EQ.2.OR.KTYPE.GE.4) THEN 
      KWRITE   = 0 
      DO 600 K = 1,12 
                                                KMONTH = 31 
      IF(K.EQ.9.OR.K.EQ.4.OR.K.EQ.6.OR.K.EQ.11) KMONTH = 30 
C ### WCH, 11/92.  REVERSE FEBRUARY CALCULATION 
      IF(K.EQ.2.AND.MOD(NEWYR,4).EQ.0)         KMONTH = 29 
      IF(K.EQ.2.AND.MOD(NEWYR,4).NE.0)         KMONTH = 28 
C### WCH, 12/92.  CHECK FOR CORRECT LAST DAY OF MONTH. 
      IF(WARAY(K,1).EQ.-99.AND.WARAY(K,KMONTH).EQ.-99) GO TO 600 
      KWRITE  = KWRITE + 1 
Cwch, 7/27/04. Change titles for print of user input and metric. 
C      IF(KWRITE.EQ.1) WRITE(N6,980) TITLE(1),TITLE(2) 
      IF(KWRITE.EQ.1.AND.IFORM.EQ.0) WRITE(N6,980) TITLE(1),TITLE(2) 
	IF(IFORM.EQ.2) THEN 
	     IF(METRIC.EQ.1) WRITE(N6,982) TITLE(1),TITLE(2) 
	     IF(METRIC.EQ.2) WRITE(N6,983) TITLE(1),TITLE(2) 
	     ENDIF 
C####################################################################### 
C WCH, 12/92. MODIFY PRINT AND STATISTICS FOR ARBITRARY START/STOP DATES 
C####################################################################### 
         IDB = 1 
         IF(IYBEG(1).EQ.NEWYR.AND.K.EQ.IYBEG(2)) IDB = IYBEG(3) 
         IDS = KMONTH 
         IF(IYEND(1).EQ.NEWYR.AND.K.EQ.IYEND(2)) IDS = IYEND(3) 
      IF(IYEAR.GT.0) WRITE(N6,995) (K,J,NEWYR,WARAY(K,J),J=IDB,IDS) 
  600 CONTINUE 
      ENDIF 
C======================================================================= 
C     WRITE THE INTERFACE FILE 
C======================================================================= 
      KDAY     = 0 
      DO 700 K = 1,12 
                                                KMONTH = 31 
      IF(K.EQ.9.OR.K.EQ.4.OR.K.EQ.6.OR.K.EQ.11) KMONTH = 30 
      IF(K.EQ.2.AND.MOD(NEWYR,4).EQ.0)         KMONTH = 29 
      IF(K.EQ.2.AND.MOD(NEWYR,4).NE.0)         KMONTH = 28 
      DO 700 J = 1,KMONTH 
      KDAY     = KDAY + 1 
      JULDAY   = NEWYR*1000 + KDAY 
      IF(BARAY(K,1).EQ.-99.0.AND.BARAY(K,KMONTH).EQ.-99.0.AND. 
     +   SARAY(K,1).EQ.-99.0.AND.SARAY(K,KMONTH).EQ.-99.0.AND. 
     +   WARAY(K,1).EQ.-99.0.AND.WARAY(K,KMONTH).EQ.-99.0.AND. 
     +   EARAY(K,1).EQ.-99.0.AND.EARAY(K,KMONTH).EQ.-99.0) GO TO 700 
C##### 
C WCH, 11/92.  CHANGE WARAY TO EARAY FOR EVAPORATION DATA 
C##### 
Cwch, 7/27/04 
cred  Mitch Heinemann (CDM) found a bug regarding the coefficient of the  
cred  pan coefficient array. It should be K(month) not J(day) - 6/10/01 
      IF(EARAY(K,J).NE.-99.0) EARAY(K,J) = EARAY(K,J)*PAN(K) 
cred  IF(EARAY(K,J).NE.-99.0) EARAY(K,J) = EARAY(K,J)*PAN(J) 
C======================================================================= 
C     Units 
C     Temperature (BARAY and SARAY): deg F regardless of Metric. 
C     Evaporation (EARAY): in/day or mm/day. NWS units are hundredths of 
C       inches per day.  
C     Wind speed (WARAY): miles/hr, regardless of Metric. NWS units 
C       are miles/day.  
C     Make necessary conversions as values are put on interface file.  
C     Note that mm/day are converted properly in Sub. WSHED. 
C======================================================================= 
Cwch, 7/27/04  WRITE(NEXT) JULDAY,BARAY(K,J),SARAY(K,J),EARAY(K,J),WARAY(K,J) 
      IF(IFORM.EQ.0) WRITE(NEXT) JULDAY,BARAY(K,J),SARAY(K,J), 
     1     EARAY(K,J)/100.,WARAY(K,J)/24. 
	IF(IFORM.EQ.2) WRITE(NEXT) JULDAY, 1.8*BARAY(K,J)+32., 
	1    1.8*SARAY(K,J)+32.,EARAY(K,J),WARAY(K,J)*CMET(11,METRIC) 
  700 CONTINUE 
C======================================================================= 
      NEWYR = NEWYR + 1 
      IF(IGO.EQ.1) THEN 
                   WRITE(*,2050) 
                   WRITE(N6,2050) 
                   CLOSE (JIN(INCNT)) 
                   RETURN 
                   ENDIF 
      GO TO 7 
C======================================================================= 
   68 FORMAT(/,1X,A80,/,2X,A80) 
  480 FORMAT(/,1H1,/, 
     +' **************************************************',/, 
     +' * MONTHLY MINIMUM, MAXIMUM, AND MEAN TEMPERATURE *',/, 
     +' **************************************************',/, 
     +' *                 YEAR ==> ',I4,'                  *',/, 
     +' **************************************************',//, 
     +' MONTH          MINIMUM     MAXIMUM        MEAN',/, 
     +' ----------     -------     -------      ------') 
  485 FORMAT(1X,A10,3F12.3) 
  911 FORMAT(' READ DATA FROM YEAR : ',I4) 
  970 FORMAT(/,1H1,' DAILY TEMPERATURE FROM WEATHER SERVICE FILE', 
     *' IN DEGREES FAHRENHEIT',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR  MAX TEMP MIN TEMP '),/, 
     *  1X,4('----------  -------- -------- ')) 
  972 FORMAT(/,1H1,' DAILY TEMPERATURE FROM USER INPUT', 
     *' IN DEGREES FAHRENHEIT',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR  MAX TEMP MIN TEMP '),/, 
     *  1X,4('----------  -------- -------- ')) 
  973 FORMAT(/,1H1,' DAILY TEMPERATURE FROM USER INPUT', 
     *' IN DEGREES CELCIUS',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR  MAX TEMP MIN TEMP '),/, 
     *  1X,4('----------  -------- -------- ')) 
Cwch, 7/27/04. Add note about pan coefficient.  
  975 FORMAT(/,1H1,' DAILY EVAPORATION FROM WEATHER SERVICE FILE', 
     *' IN HUNDRETHS OF AN INCH/DAY',/, 
     *' Values are multiplied by monthly pan coefficient prior to placem 
     *ent  on interface file.',/, 
     *1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR EVAPORATION '),/, 
     *  1X,4('---------- ----------- ')) 
  977 FORMAT(/,1H1,' DAILY EVAPORATION FROM USER INPUT', 
     *' IN INCHES/DAY',/, 
     *' Values are multiplied by monthly pan coefficient prior to placem 
     *ent  on interface file.',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR EVAPORATION '),/, 
     *  1X,4('---------- ----------- ')) 
  978 FORMAT(/,1H1,' DAILY EVAPORATION FROM USER INPUT', 
     *' IN MM/DAY',/, 
     *' Values are multiplied by monthly pan coefficient prior to placem 
     *ent  on interface file.',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR EVAPORATION '),/, 
     *  1X,4('---------- ----------- ')) 
  980 FORMAT(/,1H1,' DAILY WIND MOVEMENT FROM WEATHER SERVICE FILE', 
     *' IN MILES PER DAY',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR  WIND SPEED '),/, 
     *  1X,4('----------  ---------- ')) 
  982 FORMAT(/,1H1,' DAILY WIND MOVEMENT FROM USER INPUT', 
     *' IN MILES PER HOUR',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR  WIND SPEED '),/, 
     *  1X,4('----------  ---------- ')) 
  983 FORMAT(/,1H1,' DAILY WIND MOVEMENT FROM USER INPUT', 
     *' IN KILOMETERS PER HOUR',/,1X,A80,/,A80,//, 
     *  1X,4('MO/DY/YEAR  WIND SPEED '),/, 
     *  1X,4('----------  ---------- ')) 
  990 FORMAT(4(2(I2,'/'),I4,F9.1,1X,F9.1,1X)) 
  995 FORMAT(4(2(I2,'/'),I4,F13.2)) 
 1000 FORMAT(/,' ************************************************',/, 
     1         ' * ENTRY MADE TO THE TEMP BLOCK                 *',/, 
     2         ' * CREATED BY THE UNIVERSITY OF FLORIDA - 1988  *',/, 
     3         ' * LAST UPDATED, JULY 2004 AT O.S.U.            *',/, 
     4         ' ************************************************',//) 
 1021 FORMAT(1X,//, 
     1' *******************************',/, 
     1' *  TEMP BLOCK INPUT COMMANDS  *',/, 
     1' *******************************',//, 
     1 5X,'STATION, ISTA..........................',4X,I6,//, 
     2 5X,'BEGINNING DATE, IYBEG (YR/MO/DY).......', 
     22X,I4,'/',I2,'/',I2,//, 
     3 5X,'ENDING DATE, IYEND (YR/MO/DY)..........', 
     32X,I4,'/',I2,'/',I2,//, 
     6 5X,'NWS FORMAT, IFORM (SEE TEXT)...........',I6,//, 
     6 5X,'TYPE OF TIME SERIES DATA, KTYPE........',I6,//, 
     6 5X,'PRINT ALL INPUT DATA (IYEAR)...........',I6,/, 
     7 5X,'(O-NO PRINT; 1-PRINT ALL DATA; 2-PRINT SUMMARY)') 
 1022 FORMAT(/,' MONTHLY PAN COEFFICIENTS ',/,2X,12F5.2) 
 1030 FORMAT(1X,///, 
     +' *****************************',/, 
     +' * USER DEFINED INPUT FORMAT *',/, 
     +' *****************************',//, 
     + 5X,'USER FORMAT (FIRMAT)...................',A20,//, 
     + 5X,'INPUT/OUTPUT UNITS 0 = U.S. CUSTOMARY..',/, 
     + 5X,'                   1 = METRIC UNITS....',I6,//, 
     + 5X,'UNITS OF TEMPERATURE (KUNIT)...........',I6,/, 
     + 5X,' 0 --> DEGREES F; 1 --> DEGREES C......',//, 
     + 5X,'WIND/EVAP CONVERSION FACTOR (CONV).....',F7.2,//, 
     + 5X,'FIELD POSITION FOR STATION NUMBER, F1..',I6,//, 
     + 5X,'FIELD POSITION FOR YEAR, F2............',I6,//, 
     + 5X,'FIELD POSITION FOR MONTH, F3...........',I6,//, 
     + 5X,'FIELD POSITION FOR DAY, F4.............',I6,//, 
     + 5X,'FIELD POSITION FOR 1st VARIABLE, F5....',I6,//, 
     + 5X,'FIELD POSITION FOR 2nd VARIABLE, F6....',I6,//) 
C### WCH, 12/92 UNUSED FORMAT STATEMENT? 
C2020 FORMAT(I5,1X,2(I2,'/'),I4,I5,F7.0,3(1X,F6.2),1X,F6.0,2(2X,I5)) 
Cwch, 7/27/04 
 2040 FORMAT(/,' WARNING Parameter METRIC must equal parameter KUNIT.' 
     1,/,      ' METRIC has been set equal to KUNIT and run continues.') 
 2050 FORMAT(/,' TEMP BLOCK EXITED NORMALLY. ') 
 2100 FORMAT (/,' SORRY, IFORM=1 NOT IMPLEMENTED. RUN STOPPED IN TEMP BL 
     +OCK.') 
 2150 FORMAT (/,' *** WARNING ***.',/,' IF START/STOP DATES = 0, THEN PR 
     +INT AND STATISTICS',/,' FOR PARTIAL START/STOP MONTHS MAY BE INCOR 
     +RECT.') 
C======================================================================= 
 888  CALL IERROR 
      END 
 
 
REM File: TIDEFILE.FOR 
 
      SUBROUTINE INTIDEF 
C     EXTRAN BLOCK 
C     CREATE BY C.MOORE OF CDM  1998 
C     READ TIDAL HISTORY INFORMATION FROM EXTERNAL FILE 
C     Changed 9/8/00 to check for boundary conditions. 
C     Fix Y2K bug in NEWTIDE, RED, 5/6/01.  
      INCLUDE 'TAPES.INC' 
      INCLUDE 'TIDEFILE.INC' 
      INCLUDE 'CONTR.INC' 
      include 'tide.inc' 
      include 'bnd.inc' 
      include 'junc.inc' 
      include 'stimer.inc' 
C  FIRST CHECK THAT NSCRAT(5) WAS INITIALIZED CORRECTLY 
      IF (NSCRAT(5).EQ.0) THEN 
      WRITE(N6,*) 'ERROR - NSCRAT(5) MUST BE NON-ZERO TO USE OPTION', 
     A' TO READ TIDES FROM ASCII FILE' 
      STOP 'NSCRAT(5) IS ZERO' 
      ELSE 
      NTDN = NSCRAT(5) 
      ENDIF 
      IF (FFNAME(55).EQ.'SCRT5.UF') THEN 
      WRITE(N6,*) 'ERROR - YOU MUST SPECIFY THE NAME FOR NSCRAT(5)', 
     A' TO READ TIDES FROM ASCII FILE' 
      STOP 'NO NAME GIVEN FOR NSCRAT(5)' 
      ENDIF 
C 
C     NOW READ FIRST 3 LINES OF INPUT FILE 
C 
      READ(NTDN,*) NTIDS, NDUP 
      IF (NTIDS.GT.MAXTIDES) THEN 
      WRITE(N6,*) 'ERROR - NUMBER OF TIDES IN FILE (',NTIDS, 
     1') EXCEEDS MAXIMUM NUMBER ALLOWED (',MAXTIDES,')' 
      STOP 'ERROR - NUMBER OF TIDES IN FILE EXCEEDS MAXIMUM ALLOWED' 
      END IF 
      IF (NDUP.GT.MAXDUP) THEN 
      WRITE(N6,*) 'ERROR - NUMBER OF OUTFALLS THAT USE DUPLICATE ', 
     1'TIDAL HISTORY (',NDUP,') EXCEEDS MAXIMUM ALLOWED (',MAXDUP,')' 
      STOP 'ERROR - NUMBER OF DUPLICATE TIDES EXCEEDS MAXIMUM ALLOWED' 
      END IF 
C  PROCESSING IF NOT ALPHANUMERIC 
      IF (JCE.EQ.0) THEN 
      READ(NTDN,*) (JTIDS(J),J=1,NTIDS) 
      WRITE(N6,*) 'TIDAL TIME HISTORIES ARE READ FROM ASCII FILE', 
     A' (NSCRAT(5)) FOR THE FOLLOWING ',NTIDS,' BOUNDARY JUNCTIONS' 
      WRITE(N6,7000) (JTIDS(J),J=1,NTIDS) 
      IF (NDUP.GT.0) THEN 
      DO J=1,NDUP 
      READ(NTDN,*) (JDUP(J,K),K=1,2) 
      ENDDO 
      WRITE(N6,*) 'THE FOLLOWING ',NDUP,' JUNCTIONS USE DUPLICATE ', 
     1'TIDAL HISTORIES' 
      WRITE(N6,*) ' BOUNDARY  TIDE' 
      WRITE(N6,*) '   NODE   HISTORY' 
      DO J=1,NDUP 
      WRITE(N6,7000) (JDUP(J,K),K=1,2) 
      DO K=1,NTIDS 
      IF (JTIDS(K).EQ.JDUP(J,2)) THEN 
      JDUP(J,2) = -K 
      GO TO 20 
      ENDIF 
      ENDDO 
      WRITE(N6,*) 'ERROR - TIME HISTORY ASSOCIATED WITH OUTFALL ', 
     1JDUP(J,1),' WAS NOT FOUND (',JDUP(J,2),')' 
      STOP 'ERROR - DUPLICATE TIME HISTORY NOT FOUND' 
  20  CONTINUE 
      ENDDO 
      ENDIF 
C  CORRELATE JTIDS WITH BOUNDARY ELEMENTS AND CHECK THAT ALL ARE INCLUDED 
C   LOOP THROUGH ALL JUNCTIONS, IF MATCH SET JTIDE = 10000 + NUMBER OF TIDE 
C   HISTORY 
      DO K = 1,NTIDS 
      DO J = 1,NJ 
      IF (JTIDS(K).EQ.JUN(J)) THEN 
CIM## 9/8/00 Add check for boundary conditions 
      IF (NTIDE(JTIDES(J)).NE.6) THEN 
      WRITE(N6,8010) JUN(J) 
 8010 FORMAT(' ERROR --- JUNCTION ',I10,' FOUND IN TIDAL BOUNDARY', 
     a' DATA DOES NOT HAVE A BOUNDARY CONDITION NTIDE EQUAL TO 6') 
      NSTOP = NSTOP + 1 
      endif 
      JTIDES(J) = 10000 + K 
      GO TO 40 
      ENDIF 
      enddo 
      WRITE(N6,*) 'WARNING - JUNCTION ASSOCIATED WITH TIDE HISTORY ', 
     1JTIDS(K),' WAS NOT FOUND' 
   40 CONTINUE 
      ENDDO 
      DO K = 1,NDUP 
      DO J = 1,NJ 
      IF (JDUP(K,1).EQ.JUN(J)) THEN 
CIM## 9/8/00 Add check for boundary conditions 
      IF(NTIDE(JTIDES(J)).NE.6) THEN 
      WRITE(N6,8010) JUN(J) 
      NSTOP = NSTOP + 1 
      ENDIF 
      JTIDES(J) = 10000-JDUP(K,2) 
      GO TO 50 
      ENDIF 
      ENDDO 
      WRITE(N6,*) 'WARNING - JUNCTION ASSOCIATED WITH DUPLICATE', 
     1' TIDE HISTORY ',JDUP(K,1),' WAS NOT FOUND' 
   50 CONTINUE 
      ENDDO 
      ELSE 
C  PROCESSING IF ALPHANUMERIC  just a copy of above code but using 
c  alphanumeric variables 
      READ(NTDN,*) (ATIDS(J),J=1,NTIDS) 
      WRITE(N6,*) 'TIDAL TIME HISTORIES ARE READ FROM ASCII FILE', 
     A' (NSCRAT(5)) FOR THE FOLLOWING ',NTIDS,' BOUNDARY JUNCTIONS' 
      WRITE(N6,7010) (ATIDS(J),J=1,NTIDS) 
      IF (NDUP.GT.0) THEN 
      DO J=1,NDUP 
      READ(NTDN,*) (ADUP(J,K),K=1,2) 
      ENDDO 
      WRITE(N6,*) 'THE FOLLOWING ',NDUP,' JUNCTIONS USE DUPLICATE ', 
     1'TIDAL HISTORIES' 
      WRITE(N6,*) ' BOUNDARY  TIDE' 
      WRITE(N6,*) '   NODE   HISTORY' 
      DO J=1,NDUP 
      WRITE(N6,7010) (ADUP(J,K),K=1,2) 
      DO K=1,NTIDS 
      IF (ATIDS(K).EQ.ADUP(J,2)) THEN 
      JDUP(J,2) = -K 
      GO TO 120 
      ENDIF 
      ENDDO 
      WRITE(N6,*) 'ERROR - TIME HISTORY ASSOCIATED WITH OUTFALL ', 
     1ADUP(J,1),' WAS NOT FOUND (',ADUP(J,2),')' 
      STOP 'ERROR - DUPLICATE TIME HISTORY NOT FOUND' 
 120  CONTINUE 
      ENDDO 
      ENDIF 
C  CORRELATE ATIDS WITH BOUNDARY ELEMENTS AND CHECK THAT ALL ARE INCLUDED 
C   LOOP THROUGH ALL JUNCTIONS, IF MATCH SET JTIDE = 10000 + NUMBER OF TIDE 
C   HISTORY 
      DO K = 1,NTIDS 
      DO J = 1,NJ 
      IF (ATIDS(K).EQ.AJUN(J)) THEN 
CIM## 9/8/00 Add check for boundary conditions 
      IF (NTIDE(JTIDES(J)).NE.6) THEN 
      WRITE(N6,8020) AJUN(J) 
 8020 FORMAT(' ERROR --- JUNCTION ',A10,' FOUND IN TIDAL BOUNDARY', 
     a' DATA DOES NOT HAVE A BOUNDARY CONDITION NTIDE EQUAL TO 6') 
      NSTOP = NSTOP + 1 
      ENDIF 
      JTIDES(J) = 10000 + K 
      GO TO 140 
      ENDIF 
      enddo 
      WRITE(N6,*) 'WARNING - JUNCTION ASSOCIATED WITH TIDE HISTORY ', 
     1ATIDS(K),' WAS NOT FOUND' 
  140 CONTINUE 
      ENDDO 
      DO K = 1,NDUP 
      DO J = 1,NJ 
      IF (ADUP(K,1).EQ.AJUN(J)) THEN 
CIM## 9/8/00 Add check for boundary conditions 
      IF (NTIDE(JTIDES(J)).NE.6) THEN 
      WRITE(N6,8020) AJUN(J) 
      NSTOP = NSTOP + 1 
      ENDIF 
      JTIDES(J) = 10000-JDUP(K,2) 
      GO TO 150 
      ENDIF 
      ENDDO 
      WRITE(N6,*) 'WARNING - JUNCTION ASSOCIATED WITH DUPLICATE', 
     1' TIDE HISTORY ',ADUP(K,1),' WAS NOT FOUND' 
  150 CONTINUE 
      ENDDO 
      ENDIF 
C  somehow check that all boundary assigned to type 6 have a JTIDE greater 
C  than 10000 
c  do free first 
      do i=1,nfree 
      ijunc = jfree(i) 
cim      write(n6,*) m2s2,i,ijunc,ajun(ijunc),jtides(ijunc) 
      if (jtides(ijunc).eq.m2s2) then 
      write(n6,*) 'Error - Free outfall junction assigned to type 6', 
     a' was not found in file' 
      if (jce.eq.0) then 
      write(n6,*) '        for outfall junction ',jun(ijunc) 
      else 
      write(n6,*) '        for outfall junction ',ajun(ijunc) 
      endif 
      stop 'Free outfall not found in ASCII file' 
      endif 
      enddo 
c  do gated now 
      do i=1,ngate 
      ijunc = jgate(i) 
cim      write(n6,*) m2s2,i,ijunc,ajun(ijunc),jtides(ijunc) 
      if (jtides(ijunc).eq.m2s2) then 
      write(n6,*) 'Error - Gates outfall junction assigned to type 6', 
     a' was not found in file' 
      if (jce.eq.0) then 
      write(n6,*) '        for outfall junction ',jun(ijunc) 
      else 
      write(n6,*) '        for outfall junction ',ajun(ijunc) 
      endif 
      stop 'Gated outfall type 6 not found in ASCII file' 
      endif 
      enddo 
c 
c now read first line in input file 
c 
      read(NTDN,*,end=9000) ityear,itmonth,itday,thour, 
     1(tideel(j,2),j=1,ntids) 
c      if (ityear.gt.99) ityear=ityear-1900 
      if (ityear.lt.100) ityear=ityear+1900 
      tiddate(2) = tjulday + thour/24.0 
      write(n6,8000) tiddate(2), 
     +                                     (tideel(j,2),j=1,ntids) 
 8000 format(/,'New tide data - ',500f12.3) 
c read next line in input file 
      call newtide(dble(0.0)) 
      RETURN 
 9000 write(n6,*) 'ERROR - No tide date in input file' 
      stop 'No tide date in input file' 
 7000 FORMAT(10I10) 
 7010 format(10a10) 
      END 
      SUBROUTINE newtide(sdate) 
c read new tide data 
c repeats until #1 and #2 straddle sdate (simulation date) 
      include 'tidefile.inc' 
      include 'tapes.inc' 
      DOUBLE PRECISION SDATE 
  10  continue 
c first shift 1 to 2 
      tiddate(1) = tiddate(2) 
      do j=1,ntids 
      tideel(j,1) = tideel(j,2) 
      enddo 
c read next data 
      read(NTDN,*,end=9000) ityear,itmonth,itday,thour, 
     1(tideel(j,2),j=1,ntids) 
cim      write(*,*) ityear,itmonth,itday,thour, 
cim     1(tideel(j,2),j=1,ntids) 
CIM      write(n6,*) ityear,itmonth,itday,thour, 
CIM     1(tideel(j,2),j=1,ntids) 
c      if (ityear.gt.99) ityear=ityear-1900 
       if (ityear.lt.100) ityear=ityear+1900 
CIM      WRITE(N6,"(2F20.10)") THOUR,TJULDAY 
      THOUR = THOUR/24.0 
CIM      WRITE(N6,"(2F20.10)") THOUR,TJULDAY 
      tiddate(2) = tjulday + thour 
CIM      WRITE(N6,"(F20.10)") TIDDATE(2) 
      if (tiddate(2).le.tiddate(1)) then 
      WRITE(N6,*) 
      write(n6,*) 'Tide dates in ASCII file do not increase ', 
     a'at following date and time : ', ityear,itmonth,itday,thour 
      stop 'tide dates in ascii file do not increase' 
      endif 
      if (tiddate(2).le.sdate) go to 10 
      write(n6,7000) tiddate(2), 
     +                                    (tideel(j,2),j=1,ntids) 
 7000 format(/,'New tide data - ',500f12.3) 
      return 
c end if input file, tide remains constant 
c  set date #2 to a large number 
cred  the large date is not large enough for y2k 
cred  the symptom is 5 to 6 GB output files - 5/6/01 
cred  ....found by RDM of CDM 
cred  make the ending tiddate the year 9999 
cred9000 tiddate(2) = 99365.0 
 9000 tiddate(2) = 9999365.0 
      WRITE(N6,*) 
      write(n6,*) 'WARNING - End of file reached in tide file.', 
     1'Tide will remain constant for duration of simulation' 
      return 
      end 
      FUNCTION TIDEFILE(ICASE) 
CIM  CALL TO INTERPOLATE TIDE DATA 
CIM  ICASE SHOULD BE THE POSITION IN THE ASCII FILE + 10000 
CIM 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'TIDEFILE.INC' 
      DOUBLE PRECISION TIMENOW 
      TIMENOW = JULDAY+TIMDAY/24.0/60.0/60.0 
      ICSE = ICASE-10000 
C READ NEW TIDE LINE IF NECESSARY 
      DO WHILE (TIMENOW.GE.TIDDATE(2)) 
      CALL NEWTIDE(TIMENOW) 
      ENDDO 
C 
C NOW INTERPOLATE 
      Temp = HLINTP(TIDEEL(ICSE,1),TIDEEL(ICSE,2), 
     1                 TIDDATE(1),TIDDATE(2),TIMENOW) 
c     write(n6,*) icse,TIDEEL(ICSE,1),TIDEEL(ICSE,2), 
c    1                 TIDDATE(1),TIDDATE(2),TIMENOW,temp 
      TIDEFILE = temp 
      RETURN 
      END 
      FUNCTION HLINTP(H1,H2,T1,T2,T) 
      DOUBLE PRECISION T1,T2,T,RATIO,maxratio,minratio 
      minratio = 0.0 
      maxratio = 1.0 
      RATIO = (T-T1)/(T2-T1) 
      RATIO = DMAX1(RATIO,minratio) 
      RATIO = DMIN1(RATIO,maxratio) 
      HLINTP = H1 + (H2-H1)*RATIO 
      RETURN 
      END 
 
REM File: TRANS.FOR 
 
      SUBROUTINE TRANS 
C	TRANSPORT BLOCK 
C======================================================================= 
C     UNIVERSITY OF FLORIDA TRANSPORT MODEL 
C 
C     This large subroutine runs the main computational loops of the 
C     Transport.   Updated December, 1990 BY R.E.D. 
C     Updated 4/6/93 by WCH for metric conversion on output interface 
C       file. 
C     WCH (CDM - Chuck Moore), 8/93.  Check for subscript out of range 
C       and not enough R1 lines. 
C     WCH, 10/6/93.  Include storage unit pollutants in initial quality 
C       load summary. 
C     James L. Martin, AScI Corp., 10/93.  Provide code for writing out 
C       WASP linkage file. 
C     RED, 11/29/93.  Eliminate third argument in FIRST call statement. 
C     RED, 12/31/93.  Fix loop in R1 read statement for IFLIP = 1. 
C     WCH (Steve Merrill, Brown and Caldwell), 3/28/94.  Add provision 
C       to store depths from storage units (using I2 input lines). 
C     WCH, 5/12/94.  Include number of barrels in initial volume and 
C       mass computation. 
C     WCH, 10/14/94.  Allow depth prints without hydrograph prints. 
C     WCH, 8/7/96.  Increase field width for time step print out. 
C     WCH, 8/7/96.  Rewind scratch files. 
C     WCH, 8/29/00. Improve output for design routine. 
C     CIM, 9/8/00.Changes for outputing head and velocity 
C          to interface file. 
C     WCH, 2/15/01. Change time variables to double precision.  
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'DRWF.INC' 
      INCLUDE 'TABLES.INC' 
      INCLUDE 'NAMES.INC' 
      INCLUDE 'TST.INC' 
      INCLUDE 'NEW81.INC' 
      INCLUDE 'HUGO.INC' 
      INCLUDE 'NEWTR.INC' 
C======================================================================= 
      DIMENSION QI(NET),QO(NET),SURGE2(NET),IAMFL(NET), 
     1          WELL2(NET),QO1(NET),QO2(NET),OUTTAP(NTHO), 
Change dimensions to MQUAL 
     1          PFILEI(MQUAL,NTHI),PFILEO(MQUAL,NTHO) 
      CHARACTER BLANK*1,ASTER*1,QQQ*1,BMJ*10 
Cwch, 2/15/01.  Make time variables double precision 
      REAL*8 TIMEHR,TFLOW,TREF,THR 
      EQUIVALENCE (QO(1),Q(1,2,2)),(QI(1),Q(1,1,2)),(SURGE2(1),P2(1)) 
      EQUIVALENCE (QO1(1),QMAX(1)),(QO2(1),QFULL(1)),(WELL2(1),ROUGH(1)) 
      DATA ASTER/'*'/,BLANK/' '/ 
C======================================================================= 
C     DEFINE STATEMENT FUNCTION FOR LINEAR INTERPOLATION. 
C======================================================================= 
      QLINTP(Q1,Q2,T1,T2,T) = Q1 + (Q2-Q1)*(T-T1)/(T2-T1) 
C======================================================================= 
C     CALL SUBROUTINE INTRAN FOR DATA INPUT 
C======================================================================= 
      DO 500 I  = 1,NET 
      NODSGN(I) = 0 
 500  CONTINUE 
      CALL INTRAN 
      NSCRT1   = NSCRAT(1) 
      NSCRT2   = NSCRAT(2) 
      NSCRT7   = NSCRAT(7) 
C======================================================================= 
C#### WCH, 8/7/96.  REWIND THESE FILES  FYI, NSCRAT(1) IS USED EARLIER 
C     IN SUBROUTINE FILTH. 
C======================================================================= 
      IF(NSCRT1.GT.0) REWIND NSCRT1 
      IF(NSCRT2.GT.0) REWIND NSCRT2 
      IF(NSCRT7.GT.0) REWIND NSCRT7 
C 
      OLDDAY   = NDAY 
CIMT  change from 50 to 10+6*MQUAL 
      DO 100 I = 1,(10+6*MQUAL) 
 100  XNT(I)   = 0.0 
CIMQP INITIALIZE ARRAY FOR TYPE 27 QUALITY SPLIT ELEMENTS 
      DO I=1,NE+1 
	DO J=1,MQUAL 
	XNT27(I,J) = 0.0 
	ENDDO 
	ENDDO 
CIMQP 
C======================================================================= 
C     CALCULATE INITIAL CONDUIT VOLUME 
C======================================================================= 
      DO 1000 I  = 1,NE 
      M          = JR(I) 
      IAMFL(M)   = 0 
      SURLEN(M)  = 0.0 
      RANQ(M)    = 0.0 
      QR(M)      = 0.0 
      QBIG(M)    = 0.0 
      SBIG(M)    = 0.0 
      SMAL(M)    = 100000.0 
      SMEAN(M)   = 0.0 
      SPEAK(M)   = 0.0 
      EMAX(M)    = 0.0 
	DO J=0,MQUAL 
      STOTAL(M,J)  = 0.0 
	ENDDO 
      KITMAX(M)  = 0 
      KITER(M)   = 0 
      DO 110  J  = 1,2 
      ISTIME(M,J)= 0 
  110 JSTIME(M,J)= 0 
      IF(NPOLL.GT.0) THEN 
CIMT   CHANGE upper range from 8 to 2*MQUAL 
                     DO 1100 K  = 1,2*MQUAL 
 1100                RANK(M,K)  = 0.0 
                     DO 1150 K  = 1,NPOLL 
CIMT    change from 4 to MQUAL 
                     K1         = K + MQUAL 
 1150                RANK(M,K1) = SCOUR(M,K) 
                     ENDIF 
      IF(NTYPE(M).EQ.22) THEN 
           IS     = KSTORE(M) 
           XNT(5) = XNT(5) + STORE(IS) 
C#### WCH, 10/6/93.  INCLUDE INITIAL POLLUTANT LOAD. 
           IF(NPOLL.GT.0) THEN 
                DO 1155 K = 1,NPOLL 
CIMT  CHANGE FROM 12 to (8+MQUAL) 
 1155           XNT((8+MQUAL)+K) = XNT((8+MQUAL)+K) + 
     1                       CPOL2(M,1,K)*STORE(IS)*28.3E-06 
                ENDIF 
           ENDIF 
      IF(NTYPE(M).GT.18) GO TO 1000 
C#### WCH, 5/12/94. INCLUDE NUMBER OF BARRELS IN VOLUME/MASS CALC. 
      AAA        = 0.5*(A(M,1,1)+A(M,2,1))*DIST(M)*BARREL(M) 
      XNT(5)     = XNT(5) + AAA 
      IF(NPOLL.GT.0) THEN 
               DO 1160 K  = 1,NPOLL 
CIMT CHANGE FROM 12 to (8+MQUAL) 
               XNT((8+MQUAL)+K)  = XNT((8+MQUAL)+K) + 
     1                        CPOL2(M,1,K)*AAA*28.3E-06 
 1160          CONTINUE 
               ENDIF 
 1000 CONTINUE 
C======================================================================= 
C     GENERATE FIRST LINE OF OUTPUT TAPE TO BE USED BY INTERFACING MODEL 
C======================================================================= 
      IF(NEXT.GT.0.AND.NOUTS.GT.0) THEN 
              DELTA     = 0.0 
              DO 1666 J = 1,NOUTS 
              IF(JCE.EQ.0.AND.NOE(M).NE.JN(J))  GO TO 1666 
              IF(JCE.EQ.1.AND.KOE(M).NE.KJN(J)) GO TO 1666 
C#### WCH, 4/6/93.  ADD METRIC CONVERSION FOR OUTPUT INTERFACE FILE. 
              OUTTAP(J) = QO(M)/CMET(8,METRIC) 
              IF(NPOLL.GT.0) THEN 
                         DO 1620 K  = 1,NPOLL 
C#### WCH, 4/6/93.  ADD METRIC CONVERSION FOR OUTPUT INTERFACE FILE. 
 1620                    PFILEO(K,J) = CPOL2(M,2,K)*QO(M)/CMET(8,METRIC) 
                         ENDIF 
              GO TO 1667 
 1666         CONTINUE 
CIM### 9/8/00    move 1667 to here 
 1667         CONTINUE 
CIM### 9/8/00    GET HEAD AND VELOCITIES TO LAST 2 ARRAY SPACES 
              IF (NPOLL2.GT.NPOLL) CALL GETHV(PFILEO) 
CIM### 9/8/00   CHANGE NPOLL TO NPOLL2 
              IF(NPOLL2.LE.0) WRITE(NEXT) JULDAY,TIMDAY, 
     +                       DELTA,(OUTTAP(K),K=1,NOUTS) 
              IF(NPOLL2.GT.0) WRITE(NEXT) JULDAY,TIMDAY,DELTA, 
     +           (OUTTAP(K),(PFILEO(J,K),J=1,NPOLL2),K=1,NOUTS) 
              ENDIF 
C======================================================================= 
C     BEGIN MAIN LOOPS OF PROGRAM 
C     OUTER LOOP ON TIME, INNER LOOP ON ELEMENT NUMBER 
C======================================================================= 
      TREF   = 0.0 
      TIME   = TIMDAY 
      TFLOW  = TIMDAY/3600.0 
      JDAY   = JULDAY 
      TMDAY  = TIMDAY 
      WRITE(*,23)  NDT 
      DO 200 N = 1,NDT 
cim   need to write to 6 not * to get carriage control on writes to console 
      WRITE(6,22) N 
C======================================================================= 
C     UPDATE TIME OF DAY. 
C     TIME   = RUNNING TIME OF SIMULATION, SECONDS. 
C     TIMEHR = RUNNING TIME IN HRS, BEGINNING AT TZERO. 
C     TIMDAY = TIME OF DAY IN HRS. 
C======================================================================= 
      CALL STIME(DT) 
      CALL DATED 
      TIME   = TIME + DT 
      TIMEHR = TIME/3600.0 
      IF(NINPUT.GT.0) THEN 
                      DO 4510 I  = 1,NE 
                      RNOFF(I)   = 0.0 
                      IF(NPOLL.GT.0) THEN 
                                     DO 4511 K  = 1,NPOLL 
 4511                                PLUTO(K,I) = 0.0 
                                     ENDIF 
 4510                 CONTINUE 
                      ENDIF 
C======================================================================= 
C     READ INPUT FROM INTERFACE FILE AT REQUIRED TIMES. 
C     PERFORM LINEAR INTERPOLATION FOR INTERMEDIATE VALUES. 
C======================================================================= 
      IF(NCNTRL.EQ.0) THEN 
 4515 IF(JULDAY.GT.JDAY.OR.(JULDAY.EQ.JDAY.AND.TIMDAY.GE.TMDAY)) THEN 
              DO 4523 I = 1,LOCATS 
              QF1(I)    = QF2(I) 
              IF(NPOLL.GT.0) THEN 
                             DO 4520 J = 1,NPOLL 
 4520                        PF1(J,I)  = PF2(J,I) 
                             ENDIF 
 4523         CONTINUE 
              IF(NQUAL.LE.0) READ(LAST,END=205) JDAY,TMDAY, 
     +                       DELTA,(QF2(I),I=1,LOCATS) 
              IF(NQUAL.GT.0) READ(LAST,END=205) JDAY,TMDAY, 
     +           DELTA,(QF2(I),(PFILEI(J,I),J=1,NQUAL),I=1,LOCATS) 
              JYEAR = JDAY/1000 
              IF (JYEAR.LT.100) then 
                   JDAY = JDAY - JYEAR*1000 
                   JYEAR = JYEAR + 1900 
                   JDAY = JDAY + JYEAR*1000 
                   ENDIF 
              TREF = TIMEHR 
              CALL NTIME(JDAY,TMDAY,TFILE) 
              IF(TFILE.LT.0.0) GO TO 4515 
              IF(TFILE.LT.DT/10.0) TFILE = 0.0 
              TFILE = TFILE/3600.0 
              IF(NPOLL.GT.0) THEN 
                             DO 4530 I = 1,LOCATS 
                             DO 4540 J = 1,NPOLL 
                             KPOL      = IPOLX(J) 
                             IF(KPOL.NE.0) PF2(J,I) = PFILEI(KPOL,I) 
 4540                        CONTINUE 
 4530                        CONTINUE 
                             ENDIF 
C======================================================================= 
C             CONTINUE READING BEYOND THE END OF THE INTERFACE FILE 
C======================================================================= 
              GO TO 9320 
  205         JDAY      = 9999999 
              TMDAY     = 0.0 
              TREF      = TZERO/3600.0 + DT*FLOAT(NDT)/3600.0 
              DO 9300 I = 1,LOCATS 
              QF1(I)    = 0.0 
              QF2(I)    = 0.0 
C*************** MODIFIED FOLLOWING STATEMENTS - TRANSPOSITION ERROR **** 
C*************** CHANGED PF1(I,J) TO PF1(J,I), PF2 ALSO              **** 
C*************** JANUARY 1992    -   LISA BENSON, CSC                **** 
CIMT CHANGE UPPER RANGE OF J FROM NQUAL TO NPOLL to be consistent 
CIMT with other loops in this routine concerning PF1 and PF2. 
              IF(NQUAL.GT.0) THEN 
                             DO 9310 J  = 1,NPOLL 
                             PF1(J,I)   = 0.0 
 9310                        PF2(J,I)   = 0.0 
                             ENDIF 
 9300         CONTINUE 
              ENDIF 
 9320 THR       = TIMEHR - TREF 
      DO 4570 I = 1,LOCATS 
      NNEED     = NLOC(I) 
      BMJ       = KAN(I) 
      IF(NNEED.LT.0) GO TO 4570 
      NS2 = NIN(NNEED,BMJ) 
      QQ1 = QF1(I) 
      QQ2 = QF2(I) 
      IF(TFILE.EQ.0.0) RNOFF(NS2) = QQ2*QCONV 
      IF(TFILE.GT.0.0) RNOFF(NS2) = QLINTP(QQ1,QQ2,0.0,TFILE,THR)*QCONV 
      XNT(1) = XNT(1) + RNOFF(NS2)*DT 
      IF(NPOLL.GT.0) THEN 
                     DO 4560 J = 1,NPOLL 
                     QQ1       = PF1(J,I) 
                     QQ2       = PF2(J,I) 
                     IF(TFILE.EQ.0.0) PLUTO(J,NS2) = QQ2*QCONV 
                     IF(TFILE.GT.0.0) PLUTO(J,NS2) = QLINTP(QQ1,QQ2, 
     +                                 0.0,TFILE,THR)*QCONV 
 4560                CONTINUE 
                     ENDIF 
 4570 CONTINUE 
      ENDIF 
C======================================================================= 
C     Read input from R1 lines at required times. 
C======================================================================= 
      IF(NINPUT.GT.0) THEN 
      IF(TIMEHR.LE.TFLOW) GO TO 4650 
 4610 TFLW      = TFLOW 
C======================================================================= 
C>>>>>>>>>>>> READ DATA GROUP R1 <<<<<<<<<<<< 
C======================================================================= 
C     Input flow and water quality on multiple R1 lines. 
C======================================================================= 
      IF(IFLIP.EQ.0) THEN 
           DO 4640 I = 1,NINPUT 
           QE1(I)    = QE2(I) 
           IF(NPOLL.GT.0) THEN 
                DO 4620 J = 1,NPOLL 
 4620           PE1(J,I)  = PE2(J,I) 
                ENDIF 
C#### WCH (CDM), 8/93.  ADD CHECK FOR CORRECT CC NAME. 
           IF(NPOLL.EQ.0) THEN 
                READ(N5,*,ERR=888) CC,TFLOW,QE2(I) 
                ELSE 
                READ(N5,*,ERR=888) CC,TFLOW,QE2(I),(PE2(J,I),J=1,NPOLL) 
                ENDIF 
           IF(CC.NE.'R1') THEN 
                WRITE(N6,9150) TIMEHR,CC 
                WRITE(*,9150)  TIMEHR,CC 
                STOP 
                ENDIF 
 4640      CONTINUE 
           ENDIF 
C======================================================================= 
C     INPUT FLOW AND WATER QUALITY ON ONE R1 LINE 
C======================================================================= 
      IF(IFLIP.EQ.1) THEN 
           DO 4645 I = 1,NINPUT 
           IF(NPOLL.GT.0) THEN 
                     DO 4625 J = 1,NPOLL 
 4625                PE1(J,I)  = PE2(J,I) 
                     ENDIF 
 4645      QE1(I)    = QE2(I) 
C#### WCH (CDM), 8/93.  ADD CHECK FOR CORRECT CC NAME. 
           IF(NPOLL.EQ.0) THEN 
C#### RED (WCH), 12/31/93. FIX MISSING DO LOOP.  (SHOULDN'T BE SAME AS 
C####                      FOR IFLIP = 0.) 
C 
C####           READ(N5,*,ERR=888) CC,TFLOW,QE2(I) 
C####           ELSE 
C####           READ(N5,*,ERR=888) CC,TFLOW,QE2(I),(PE2(J,I),J=1,NPOLL) 
C####           ENDIF 
C 
                READ(N5,*,ERR=888) CC,TFLOW,(QE2(I),I=1,NINPUT) 
                ELSE 
                READ(N5,*,ERR=888) CC,TFLOW,(QE2(I), 
     1                         (PE2(J,I),J=1,NPOLL),I=1,NINPUT) 
                ENDIF 
           IF(CC.NE.'R1') THEN 
                WRITE(N6,9150) TIMEHR,CC 
                WRITE(*,9150)  TIMEHR,CC 
                STOP 
                ENDIF 
           ENDIF 
C======================================================================= 
      IF(TFLOW.LT.TIMEHR) GO TO 4610 
 4650 DO 4670 I  = 1,NINPUT 
      NNEED      = KORDER(I) 
      BMJ        = BORDER(I) 
      NS2        = NIN(NNEED,BMJ) 
C#### WCH (CDM), 8/93.  ADD CHECK FOR SUBSCRIPT OUT OF RANGE. 
      IF(NS2.LE.0.OR.NS2.GT.NET) WRITE (N6,9100) TFLOW,TIMEHR,NS2, 
     1                       I,NNEED,BMJ 
      QQ1        = QE1(I) 
      QQ2        = QE2(I) 
      FLOW       = QLINTP(QQ1,QQ2,TFLW,TFLOW,TIMEHR)*CMET(8,METRIC) 
      XNT(1)     = XNT(1)     + FLOW*DT 
C#### WCH (CDM), 8/93.  ADD CHECK FOR SUBSCRIPT OUT OF RANGE. 
      IF(NS2.GT.0.AND.NS2.LE.NET) RNOFF(NS2) = RNOFF(NS2) + FLOW 
      IF(NPOLL.GT.0) THEN 
             DO 4660 J = 1,NPOLL 
             QQ1       = PE1(J,I) 
             QQ2       = PE2(J,I) 
C#### WCH (CDM), 8/93.  ADD CHECK FOR SUBSCRIPT OUT OF RANGE. 
             IF(NS2.GT.0.AND.NS2.LE.NET) PLUTO(J,NS2) = PLUTO(J,NS2) + 
     +                     QLINTP(QQ1,QQ2,TFLW,TFLOW,TIMEHR)*FLOW 
 4660        CONTINUE 
             ENDIF 
 4670 CONTINUE 
      ENDIF 
C======================================================================= 
C     NNOTE, PRECEDING QUALITY INPUTS HAVE UNITS OF CFS*CONCENTRATION 
C            FLOW HAS UNITS OF CFS. 
C======================================================================= 
C     BEGIN INNER LOOP ON ELEMENT NUMBER 
C     M = CURRENT ELEMENT NUMBER,(INTERNAL NUMBER). 
C======================================================================= 
      DO 150 I = 1,NE 
      M        = JR(I) 
      NTPE    = NTYPE(M) 
      KCIM    = KLASS(NTPE) 
C======================================================================= 
C     STORE INPUT HYDROGRAPHS AND POLLUTOGRAPHS 
C           FOR DESIRED ELEMENTS IF INFLEW = 0 (DEFAULT). 
C======================================================================= 
      IF(NNYN.GT.0.AND.INFLEW.EQ.0) THEN 
                    DO 70 J = 1,NNYN 
                    IF(JCE.EQ.0.AND.NOE(M).NE.NYN(J)) GO TO 70 
                    IF(JCE.EQ.1.AND.KOE(M).NE.KYN(J)) GO TO 70 
                    IF(NPOLL.GT.0) THEN 
                                   DO 68 K = 1,NPOLL 
                                   CPPP(K) = 0.0 
                                   IF(RNOFF(M).GT.0.0) CPPP(K) = 
     +                                        PLUTO(K,M)/RNOFF(M) 
   68                              CONTINUE 
                                   WRITE (NSCRT1) RNOFF(M), 
     +                                            (CPPP(K),K=1,NPOLL) 
                                   ELSE 
                                   WRITE (NSCRT1) RNOFF(M) 
                                   ENDIF 
                    GO TO 71 
   70               CONTINUE 
                    ENDIF 
   71 INPUT     = M 
      DO 4680 K = 1,NPOLL 
 4680 POLDWF(K) = 0.0 
      DUMY1     = 0.0 
C======================================================================= 
C     CORRECT DWF FOR TEMPORAL VARIATIONS 
C     CORRECT SEWAGE FOR DAILY AND HOURLY VARIATION 
C 
C     WDWF(INPUT,1) IS B O D IN MG/L * CFS 
C     WDWF(INPUT,2) IS SS IN MG/L * CFS 
C     WDWF(INPUT,3) IS COLIFORM IN MPN/L * CFS 
C======================================================================= 
      IF(NFILTH.GT.0) THEN 
                    KHR = JHR + 1 
      IF(KHR.LT.0)  KHR = 1 
      IF(KHR.GT.24) KHR = 24 
C======================================================================= 
C     Update the day of the week(KDAY) for dry weather flow. 
C======================================================================= 
      IF(NDAY.NE.OLDDAY) THEN 
                         KDAY = KDAY + 1 
                         IF(KDAY.GT.7) KDAY = 1 
                         OLDDAY = NDAY 
                         ENDIF 
cim monthly variation 
      IF (NTPE.EQ.19) THEN 
                       BFF = BFFMONTH(2,NINT(GEOM3(INPUT))) 
	ELSE 
	   BFF = 1.0 
	ENDIF 
cim 
      IF(NPOLL.GT.0)  THEN 
                      WDWF1     = WDWF(INPUT,1)*DVBOD(KDAY)*DVDWF(KDAY) 
                      WDWF2     = WDWF(INPUT,2)*DVSS(KDAY)*DVDWF(KDAY) 
                      WDWF3     = WDWF(INPUT,3)*DVDWF(KDAY) 
cim monthly variation 
                       WDWF1 = WDWF1 * BFF 
                       WDWF2 = WDWF2 * BFF 
                       WDWF3 = WDWF3 * BFF 
cim 
                      POLDWF(1) = WDWF1*HVBOD(KHR)*HVDWF(KHR) 
                      POLDWF(2) = WDWF2*HVSS(KHR)*HVDWF(KHR) 
                      POLDWF(3) = WDWF3*HVCOLI(KHR)*HVDWF(KHR) 
CIMT  21 = (8+3*MQUAL+1), 22 = (8+3*MQUAL+2), 23 = (8+3*MQUAL+3) 
                      XNT(8+3*MQUAL+1)   = XNT(8+3*MQUAL+1) + POLDWF(1) 
                      XNT(8+3*MQUAL+2)   = XNT(8+3*MQUAL+2) + POLDWF(2) 
                      XNT(8+3*MQUAL+3)   = XNT(8+3*MQUAL+3) + POLDWF(3) 
                      ENDIF 
      DDWF      = QDWF(INPUT)*DVDWF(KDAY) 
cim monthly variation 
     *            * BFF 
      DUMY1     = DDWF*HVDWF(KHR) 
      XNT(2)    = XNT(2) + DUMY1*DT 
      ELSE 
      DUMY1     = 0.0 
      ENDIF 
C======================================================================= 
C     Sum upstream flows. 
C======================================================================= 
      TOTAL   = 0.0 
      DO 80 J = 1,3 
      NNEED   = INUE(M,J) 
      IF(NNEED.GT.NE) GO TO 80 
      NTPEU     = NTYPE(NNEED) 
C======================================================================= 
C     HERE IF UPSTREAM ELEMENT IS OF FLOW DIVIDER TYPE. 
C     MODIFY TO INCLUDE NEW TYPE 27 QUALITY SPLITTER TYPE (CIM 4/99) 
C======================================================================= 
      IF(NTPEU.LE.20.OR.NTPEU.EQ.27) THEN 
                    TOTAL = TOTAL + QO(NNEED) 
                    ELSE 
                    L     = GEOM3(NNEED) 
                    BMJ   = KGEOM(NNEED) 
                    QQ    = QO2(NNEED) 
                    IF(JCE.EQ.0.AND.NOE(M).EQ.L)   QQ = QO1(NNEED) 
                    IF(JCE.EQ.1.AND.KOE(M).EQ.BMJ) QQ = QO1(NNEED) 
                    TOTAL = TOTAL + QQ 
                    ENDIF 
   80 CONTINUE 
      KFULL = 2 
C======================================================================= 
C     Assume If QI = exactly QFULL, conduit has been determined 
C                    to be surcharging. 
C======================================================================= 
      IF(KCIM.LE.2) THEN 
                 IF(BARREL(M).GE.1.0) QI(M) = TOTAL/BARREL(M) 
                 IF(BARREL(M).LT.1.0) QI(M) = TOTAL*BARREL(M) 
                 IF(IAMFL(M).EQ.1.OR.QI(M).EQ.QFULL(M)) THEN 
                                           QI(M) = QFULL(M) 
                                           KFULL = 1 
                                           ITER  = 0 
                                           ELSE 
                                           ITER  = NITER 
                                           ENDIF 
                 ELSE 
                                          QMANHO = 0.0 
CIM  CHANGE FOR VARIABLE BASE FLOW IN TRANSPORT  TYPE 19 ONLY 
CIM                 IF(NTPE.EQ.19.OR.NTPE.EQ.22) QMANHO = DIST(M) 
CIM 2/96 CALL BFFMONTH TO GET CORRECT FACTOR 
            IF(NTPE.EQ.19) QMANHO = DIST(M)*BFFMONTH(1,NINT(GEOM3(M))) 
cim type 22???? not documented then remove, inconsistent elsewhere 
CIM 
cim         IF(NTPE.EQ.19.OR.NTPE.EQ.22) QMANHO = DIST(M) 
                 QI(M)     = TOTAL + RNOFF(M) + SURGE2(M)/DT + DUMY1 + 
     +                       QINFIL(M) + QMANHO 
                 XNT(3)    = XNT(3)    + QINFIL(M)*DT 
                 XNT(4)    = XNT(4)    + QMANHO*DT 
                 RANQ(M)   = RANQ(M)   + RNOFF(M) + DUMY1 + 
     +                       QINFIL(M) + QMANHO 
                 IF(NPOLL.GT.0) THEN 
                                DO 1200 KK = 1,NPOLL 
 1200                           RANK(M,KK) = RANK(M,KK) + PLUTO(KK,M) 
                                ENDIF 
CIM  REMOVE THE NTPE.EQ.22 TO REMAIN CONSISTANCY EVERYWHERE 
CIM  ALTERNATIVE IS TO ADD EVERYWHERE 
CIM                 IF(NTPE.EQ.19.OR.NTPE.EQ.22) THEN 
                 IF(NTPE.EQ.19) THEN 
                 IF(NPOLL.GT.0) THEN 
                                DO 1250 KK = 1,NPOLL 
CIMT                                IF(KK.EQ.1) PMAN = GEOM1(M) 
CIMT                                IF(KK.EQ.2) PMAN = SLOPE(M) 
CIMT                                IF(KK.EQ.3) PMAN = ROUGH(M) 
CIMT                                IF(KK.EQ.4) PMAN = GEOM2(M) 
                   PMAN = PMANN(M,KK) 
CIM  CHANGE FOLLOWING TO INCLUDE MONTHLY BASE FLOW FACTORS 
	IF (NTPE.EQ.19)  PMAN = PMAN*BFFMONTH(1,NINT(GEOM3(M))) 
CIM 
CIMT  30 becomes (10+5*MQUAL) 
 1250              XNT((10+5*MQUAL)+KK) = XNT((10+5*MQUAL)+KK) + PMAN 
                                ENDIF 
                 ENDIF 
                 IF(QI(M).LT.0.0) QI(M) = 0.0 
                 ITER = 0 
                 ENDIF 
C======================================================================= 
C     Route flow through element. 
C======================================================================= 
  115 KKK    = 0 
  116 WSLOPE = 0.0 
      CALL ROUTE(DELQ,WSLOPE) 
      IF(NTPE.EQ.22) GO TO 130 
      KKK  = KKK  + 1 
      ITER = ITER + 1 
      IF(ITER.GT.NITER) GO TO 116 
C======================================================================= 
C     SURCHARGE ROUTINE. 
C     CHECK THE ELEMENTS DOWNSTREAM FROM A NON-CONDUIT 
C     FOR POSSIBLE SURCHARGING. 
C======================================================================= 
  130                     DENOM = QFULL(M) 
      IF(QFULL(M).EQ.0.0) DENOM = 1.0 
      IF(DELQ/DENOM.GT.EMAX(M)) EMAX(M) = DELQ/DENOM 
                           KITER(M)  = KITER(M) + KKK 
      IF(KKK.GT.KITMAX(M)) KITMAX(M) = KKK 
      SMEAN(M)  = SMEAN(M)  + WSLOPE 
      STOTAL(M,0) = STOTAL(M,0) + QO(M)*DT 
      IF(WSLOPE.EQ.0.0)           WSLOPE   = SLOPE(M) 
      IF(WSLOPE.GT.SBIG(M))       SBIG(M)  = WSLOPE 
      IF(WSLOPE.LT.SMAL(M))       SMAL(M)  = WSLOPE 
      IF(KCIM.EQ.3.AND.I.LT.NE) THEN 
      NODO      = 0 
      II        = 1 
 1162 MI        = JR(I+II) 
C======================================================================= 
C     CHECK TO SEE IF NEXT ELEMENT ROUTED IS DOWNSTREAM ELEMENT. 
C======================================================================= 
      IF(INUE(MI,1).EQ.M) GO TO 1163 
 1164 II = II+1 
      IF(I+II-NE) 1162,1162,1170 
 1163 IFD    = 1 
      IF(NODO.EQ.0) SURTMP = 0.0 
      IAMFL(MI) = 0 
      NTPEI       = NTYPE(MI) 
      KI        = KLASS(NTPEI) 
C======================================================================= 
C     IS CURRENT ELEMENT A FLOW DIVIDER ? 
C     SET PARAMETERS FOR FLOW DIVIDER. 
C     MODIFY TO ADD NEW TYPE 27  CIM 4/99 
C======================================================================= 
      IF(NTPE.LE.20.OR.NTPE.EQ.25.OR.NTPE.EQ.27)          GO TO 1165 
      IF(JCE.EQ.0.AND.NTPE.EQ.22.AND.GEOM3(M).LE.0.0) GO TO 1165 
      IF(JCE.EQ.1.AND.NTPE.EQ.22.AND.KGEOM(M).EQ.' ') GO TO 1165 
      IFD = 2 
      L   = GEOM3(M) 
      BMJ = KGEOM(M) 
      IF(MI.EQ.NIN(L,BMJ)) GO TO 1164 
      IF(KI.EQ.3) GO TO 1167 
      IF(BARREL(MI).GE.1.0) QINN = QO2(M)/BARREL(MI) 
      IF(BARREL(MI).LT.1.0) QINN = QO2(M)*BARREL(MI) 
      GO TO 1166 
 1165 IF(KI.EQ.3) GO TO 1169 
      IF(BARREL(MI).GE.1.0) QINN = QO(M)/BARREL(MI) 
      IF(BARREL(MI).LT.1.0) QINN = QO(M)*BARREL(MI) 
 1166 IF(QINN.LE.QMAX(MI).AND.IFD.EQ.1) GO TO 1169 
      IF(QINN.LE.QMAX(MI))              GO TO 1167 
C======================================================================= 
C     IF CONDUIT CAPACITY EXCEEDED, STORE EXCESS AT UPSTREAM NON-CONDUIT 
C     CONDUIT ASSUMED TO FLOW FULL AT UPSTREAM END. 
C     QFULL BASED ON CONDUIT SLOPE. 
C======================================================================= 
      IF(NDESN.EQ.0.OR.NODSGN(MI).EQ.1) THEN 
         IF(ISTIME(MI,1).EQ.0) THEN 
                               ISTIME(MI,1) = JULDAY 
                               ISTIME(MI,2) = TIMDAY 
                               ENDIF 
         JSTIME(MI,1) = JULDAY 
         JSTIME(MI,2) = TIMDAY 
         QFULL(MI)    = P1(MI)*SQRT(SLOPE(MI)) 
         IF(BARREL(MI).GE.1.0) SURGE2(M) = (QINN - QFULL(MI)) * 
     +                                      DT*BARREL(MI) + SURTMP 
         IF(BARREL(MI).LT.1.0) SURGE2(M) = (QINN-QFULL(MI))*DT + SURTMP 
         QRATIO       = QINN/QFULL(MI) 
         SURTMP       = SURGE2(M) 
         SURLEN(MI)   = SURLEN(MI) + DT 
         IF(SURTMP.GT.SPEAK(MI)) SPEAK(MI) = SURGE2(M) 
         IF(QRATIO.GT.QR(MI))       QR(MI) = QRATIO 
         ENDIF 
C====================================================================== 
C     DESIGN ROUTINE. 
C     INCREASE CONDUIT DIMENSION UNTIL SURCHARGE ELIMINATED. 
C     INCREASE DIAMETER OF CIRCULAR CONDUITS BY STANDARD AMOUNTS (NTPEI=1). 
C     INCREASE WIDTH OF RECTANGULAR CONDUIT BY 0.5 FT (NTPEI=2). 
C     IF NOT CIRCULAR OR RECT., REPLACE BY CIRCULAR OF EQUAL AREA, USING 
C     STANDARD PIPE SIZES. 
C======================================================================= 
      IF(NDESN.GT.0.AND.NODSGN(MI).EQ.0) THEN 
                     SURTMP     = 0.0 
                     KSTORE(MI) =  1 
                     IF(NTPEI.EQ.1) THEN 
                            DEL = 0.25 
                            IF(GEOM1(MI).GE.3.0) DEL = 0.50 
                            IF(GEOM1(MI).LT.1.0) DEL = 1.0-GEOM1(MI) 
                            GEOM1(MI) = GEOM1(MI) + DEL 
C#### RED, 11/29/93.  ELIMINATE THIRD PARAMETER IN FIRST ARG. LIST. 
                            CALL FIRST(MI,1) 
                            IF(JCE.EQ.0) WRITE(N6,480) 
     +                                   NOE(MI),DEL,GEOM1(MI) 
                            IF(JCE.EQ.1) WRITE(N6,481) 
     +                                   KOE(MI),DEL,GEOM1(MI) 
                            GO TO 1166 
                            ENDIF 
                     IF(NTPEI.EQ.2) THEN 
                            GEOM2(MI) = GEOM2(MI) + 0.50 
C#### RED, 11/29/93.  ELIMINATE THIRD PARAMETER IN FIRST ARG. LIST. 
                            CALL FIRST(MI,1) 
                            IF(JCE.EQ.0) WRITE(N6,400) NOE(MI),GEOM2(MI) 
                            IF(JCE.EQ.1) WRITE(N6,401) KOE(MI),GEOM2(MI) 
                            GO TO 1166 
                            ENDIF 
                     NTYPE(MI) = 1 
                     NTPEI       = 1 
                     GE        = 1.12838*SQRT(AFULL(MI)) 
                     IF(GE.LE.3.0) THEN 
                           GEOM1(MI) = FLOAT(IFIX(GE*100.)/25+1)*0.25 
                           ELSE 
                           GEOM1(MI) = FLOAT(IFIX(GE*100.)/50+1)*0.50 
                           ENDIF 
C#### RED, 11/29/93.  ELIMINATE THIRD PARAMETER IN FIRST ARG. LIST. 
                     CALL FIRST(MI,1) 
                     IF(JCE.EQ.0) WRITE(N6,415) NOE(MI),GEOM1(MI) 
                     IF(JCE.EQ.1) WRITE(N6,416) KOE(MI),GEOM1(MI) 
                     GO TO 1166 
                     ENDIF 
      IF(IFD.EQ.1) GO TO 1168 
      IF(BARREL(MI).GE.1.0) QO2(M) = QFULL(MI)*BARREL(MI) 
      IF(BARREL(MI).LT.1.0) QO2(M) = QFULL(MI) 
      QO(M)  = QO1(M) + QO2(M) 
C======================================================================= 
C     CHECK CAPACITY OF SECOND ELEMENT DOWNSTREAM FROM FLOW-DIVIDER. 
C======================================================================= 
 1167 L   = GEOM3(M) 
      BMJ = KGEOM(M) 
      MI  = NIN(L,BMJ) 
      NTPEI = NTYPE(MI) 
      KI  = KLASS(NTPEI) 
      IF(KI.EQ.3) GO TO 1169 
      IF(BARREL(MI).GE.1.0) QINN = QO1(M)/BARREL(MI) 
      IF(BARREL(MI).LT.1.0) QINN = QO1(M) 
      IFD  = 1 
      GO TO 1166 
 1168 IF(BARREL(MI).GE.1.0) THEN 
                            QO1(M) = QFULL(MI) * BARREL(MI) 
                            QO(M)  = QO1(M)    + QO2(M) 
                            ELSE 
                            IF(NODO.EQ.0) THEN 
                                          QO1(M)    = QFULL(MI) 
                                          QO2(M)    = QI(M)-QFULL(MI) 
                                          IAMFL(MI) = 1 
                                          ENDIF 
                            IF(NODO.EQ.1) THEN 
                                          QO2(M)    = QFULL(MI) 
                                          IAMFL(MI) = 1 
                                          ENDIF 
                            QO(M) = QO1(M) + QO2(M) 
                            ENDIF 
      GO TO 1170 
 1169 IF(NTPE.NE.22) SURGE2(M) = SURTMP 
      IF(NTPE.EQ.22) SURGE2(M) = SURGE2(M) + SURTMP 
 1170 CONTINUE 
      IF(BARREL(MI).LT.1.0) THEN 
                            NODO = NODO + 1 
                            GO TO 1164 
                            ENDIF 
      ENDIF 
C====================================================================== 
C     Multiply flow by number of barrels if barrels > 1.0 
C======================================================================= 
      IF(BARREL(M).GE.1.0) THEN 
                           QI(M) = QI(M)*BARREL(M) 
                           QO(M) = QO(M)*BARREL(M) 
                           ENDIF 
      IF(QO(M).GT.QBIG(M)) QBIG(M) = QO(M) 
C======================================================================= 
C     Route quality parameters through element. 
C======================================================================= 
      IF(NPOLL.GT.0) CALL QUAL(1) 
C======================================================================= 
C     STORE DESIRED OUTFLOWS TO BE GENERATED ONTO OUTPUT TAPE 
C     POLLUTANTS ON INTERFACE FILE HAVE UNITS OF CFS*CONCENTRATION. 
C======================================================================= 
      IF(NORDER(I).EQ.1) THEN 
                         XNT(7)    = XNT(7) + QO(M)*DT 
                         IF(NPOLL.GT.0) THEN 
                         DO 5555 K = 1,NPOLL 
CIMT    8 is ok 
 5555                    XNT(8+K)  = XNT(8+K) + 
     +                               DT*CPOL2(M,2,K)*QO(M) 
                         ENDIF 
                         ENDIF 
CIMQP   ADD TOTAL OUTFLOW CONCENTRATION PRINTOUT FOR ALL ELEMENTS 
                         DO K=1,NPOLL 
                         STOTAL(M,K) = STOTAL(M,K)+ 
     +                                 DT*CPOL2(M,2,K)*QO(M) 
	                   ENDDO 
      IF(NOUTS.GT.0.AND.NEXT.GT.0) THEN 
               DO 6666 J = 1,NOUTS 
               IF(JCE.EQ.0.AND.NOE(M).NE.JN(J))  GO TO 6666 
               IF(JCE.EQ.1.AND.KOE(M).NE.KJN(J)) GO TO 6666 
C#### WCH, 4/6/93.  ADD METRIC CONVERSION FOR OUTPUT INTERFACE FILE. 
               OUTTAP(J) = QO(M)/CMET(8,METRIC) 
               IF(NPOLL.GT.0) THEN 
                        DO 6620 K  = 1,NPOLL 
C#### WCH, 4/6/93.  ADD METRIC CONVERSION FOR OUTPUT INTERFACE FILE. 
 6620                   PFILEO(K,J) = CPOL2(M,2,K)*QO(M)/CMET(8,METRIC) 
                        ENDIF 
 6666          CONTINUE 
               ENDIF 
C======================================================================= 
C     STORE DESIRED OUTFLOWS TO BE GENERATED ON SCRATCH TAPE 
C                                      FOR PRINTING PURPOSES 
C======================================================================= 
      IF(NNPE.GT.0) THEN 
                    DO 122 J = 1,NNPE 
                    IF(JCE.EQ.0.AND.NOE(M).NE.NPE(J)) GO TO 122 
                    IF(JCE.EQ.1.AND.KOE(M).NE.KPE(J)) GO TO 122 
                    IF(NPOLL.EQ.0) WRITE (NSCRT2) QO(M) 
                    IF(NPOLL.GT.0) WRITE (NSCRT2) QO(M), 
     +                            (CPOL2(M,2,K),K=1,NPOLL) 
                    GO TO 124 
  122               CONTINUE 
                    ENDIF 
  124 CONTINUE 
C======================================================================= 
C     STORE DESIRED DEPTHS TO BE GENERATED ON SCRATCH TAPE 
C                                    FOR PRINTING PURPOSES 
C======================================================================= 
      IF(NSURF.GT.0) THEN 
                     DO 132 J = 1,NSURF 
                     IF(JCE.EQ.0.AND.NOE(M).NE.JSURF(J)) GO TO 132 
                     IF(JCE.EQ.1.AND.M.NE.JSURF(J))      GO TO 132 
C####################################################################### 
C#### WCH (Steve Merrill), 3/28/94.  ADD IF STATEMENT TO GET DEPTHS 
C       FROM STORAGE UNITS. 
C======================================================================= 
                     IF(NTYPE(M).LE.18) THEN 
                          A1   = A(M,1,2)/AFULL(M) 
                          A2   = A(M,2,2)/AFULL(M) 
                          A1   = 0.5 * (DEPTH(A1) + DEPTH(A2)) 
                          A1   = A1*GEOM1(M) 
C####################################################################### 
C#### WCH, 3/28/94.  HERE, STORE LAST DEPTH FROM STORAGE IN A1 TO BE 
C       PLACED ON NSCRAT7.  STORAGE NODES ARE IDENTIFIED SIMPLY ON 
C       INPUT LINE I2. 
C======================================================================= 
                          ELSE IF(NTYPE(M).EQ.22) THEN 
                               IS = KSTORE(M) 
                               A1 = DEPTHL(IS) 
                          ENDIF 
                     WRITE(NSCRT7) A1 
                     GO TO 134 
  132                CONTINUE 
                     ENDIF 
  134 CONTINUE 
C======================================================================= 
C     STORE INPUT HYDROGRAPHS AND POLLUTOGRAPHS 
C           FOR DESIRED ELEMENTS IF INFLEW = 1 (NEW OPTION). 
C======================================================================= 
      IF(NNYN.GT.0.AND.INFLEW.EQ.1) THEN 
                    DO 170 J = 1,NNYN 
                    IF(JCE.EQ.0.AND.NOE(M).NE.NYN(J)) GO TO 170 
                    IF(JCE.EQ.1.AND.KOE(M).NE.KYN(J)) GO TO 170 
                    IF(NPOLL.GT.0) THEN 
                                   DO 168 K = 1,NPOLL 
                                   CPPP(K) = 0.0 
                                   IF(QI(M).GT.0.0) CPPP(K) = 
     +                                        CPOL1(M,2,K)*QI(M) 
  168                              CONTINUE 
                                   WRITE(NSCRT1) QI(M), 
     +                                           (CPPP(K),K=1,NPOLL) 
                                   ELSE 
                                   WRITE(NSCRT1) QI(M) 
                                   ENDIF 
                    GO TO 171 
  170               CONTINUE 
                    ENDIF 
  171 CONTINUE 
C======================================================================= 
C     REPLACE VALUES AT OLD TIME STEP BY VALUES AT NEW ONE 
C======================================================================= 
C#### JLM, 10/93.  MOVE TO OUTSIDE OF SPATIAL DO-LOOP. 
C####      A(M,1,1) = A(M,1,2) 
C####      A(M,2,1) = A(M,2,2) 
C####      IF(NPOLL.GT.0) THEN 
C####                     DO 126 IP     = 1,NPOLL 
C####                     CPOL1(M,1,IP) = CPOL1(M,2,IP) 
C####  126                CPOL2(M,1,IP) = CPOL2(M,2,IP) 
C####                     ENDIF 
C####      IF(BARREL(M).GE.1.0) Q(M,1,1)  = Q(M,1,2)/BARREL(M) 
C####      IF(BARREL(M).LT.1.0) Q(M,1,1)  = Q(M,1,2) 
C####      IF(BARREL(M).GE.1.0) Q(M,2,1)  = Q(M,2,2)/BARREL(M) 
C####  150 IF(BARREL(M).LT.1.0) Q(M,2,1)  = Q(M,2,2) 
C 
  150 CONTINUE 
C 
C####################################################################### 
         IF(ISUMRY.GT.0) CALL LINK(1) 
C======================================================================= 
C     REPLACE VALUES AT OLD TIME STEP BY VALUES AT NEW ONE 
C#### NOTE:  THIS COMPUTATION WAS MOVED UNTIL AFTER 
C                 COMPLETION OF THE SPATIAL LOOP, JLM 10/93 
C======================================================================= 
      DO 160 I=1,NE 
      M = JR(I) 
      A(M,1,1) = A(M,1,2) 
      A(M,2,1) = A(M,2,2) 
      IF(NPOLL.GT.0) THEN 
                     DO 126 IP     = 1,NPOLL 
                     CPOL1(M,1,IP) = CPOL1(M,2,IP) 
  126                CPOL2(M,1,IP) = CPOL2(M,2,IP) 
                     ENDIF 
      IF(BARREL(M).GE.1.0) Q(M,1,1)  = Q(M,1,2)/BARREL(M) 
      IF(BARREL(M).LT.1.0) Q(M,1,1)  = Q(M,1,2) 
      IF(BARREL(M).GE.1.0) Q(M,2,1)  = Q(M,2,2)/BARREL(M) 
  160 IF(BARREL(M).LT.1.0) Q(M,2,1)  = Q(M,2,2) 
C======================================================================= 
C     GENERATE OUTPUT TAPE TO BE USED BY INTERFACING MODEL 
C======================================================================= 
      IF(NEXT.GT.0.AND.NOUTS.GT.0) THEN 
CIM### 9/8/00   GET HEADS AND VELOCITIES 
      IF (NPOLL2.GT.NPOLL) CALL GETHV(PFILEO) 
CIM### 9/8/00   CHANGE NPOLL TO NPOLL+2  (3 places) 
                     IF(NPOLL2.LE.0) WRITE (NEXT) JULDAY,TIMDAY, 
     +                              DT,(OUTTAP(K),K=1,NOUTS) 
                     IF(NPOLL2.GT.0) WRITE (NEXT) JULDAY,TIMDAY, 
     +                              DT,(OUTTAP(K),(PFILEO(J,K),J=1, 
     +                              NPOLL2),K=1,NOUTS) 
                     ENDIF 
  200 CONTINUE 
C======================================================================= 
C     CALL NEW OUTPUT SUBROUTINE 
C======================================================================= 
      CALL OTRAIN 
C======================================================================= 
C     WRITE NEW ELEMENT TABLE. 
C======================================================================= 
      IF(NDESN.GT.0) THEN 
                     WRITE (N6,930) 
C#### RED, 11/29/93.  ELIMINATE THIRD PARAMETER IN FIRST ARG. LIST. 
                     CALL FIRST(MI,2) 
                     KARIGE = 0 
                     IF(METRIC.EQ.1) WRITE (N6,916) KARIGE 
                     IF(METRIC.EQ.2) WRITE (N6,919) KARIGE 
                     DO 300 I = 1,NE 
                     NTPE       = NTYPE(I) 
                     IF(NTPE.LE.18) THEN 
                           QQQ = BLANK 
                           IF(KSTORE(I).EQ.1) QQQ = ASTER 
                           DIST(I)  = DIST(I)/CMET(1,METRIC) 
                           GEOM1(I) = GEOM1(I)/CMET(1,METRIC) 
                           GEOM2(I) = GEOM2(I)/CMET(1,METRIC) 
                           GEOM3(I) = GEOM3(I)/CMET(1,METRIC) 
                           AFULL(I) = AFULL(I)/CMET(1,METRIC)**2.0 
                           QFULL(I) = QFULL(I)/CMET(8,METRIC) 
                           QMAX(I)  = QMAX(I)/CMET(8,METRIC) 
                           IF(JCE.EQ.0) WRITE(N6,931) NOE(I),NTPE,QQQ, 
     +                           NAME(NTPE),SLOPE(I),DIST(I),ROUGH(I), 
     +                           GEOM1(I),GEOM2(I),GEOM3(I),BARREL(I), 
     +                           AFULL(I),QFULL(I),QMAX(I),SCF(I) 
                           IF(JCE.EQ.1) WRITE(N6,932) KOE(I),NTPE,QQQ, 
     +                           NAME(NTPE),SLOPE(I),DIST(I),ROUGH(I), 
     +                           GEOM1(I),GEOM2(I),GEOM3(I),BARREL(I), 
     +                           AFULL(I),QFULL(I),QMAX(I),SCF(I) 
                           ENDIF 
  300                CONTINUE 
                     ENDIF 
C======================================================================= 
C     PRINT SELECTED INPUT AND OUTPUT HYDROGRAPHS AND POLLUTOGRAPHS. 
C======================================================================= 
      IF(NPOLL.LE.0.AND.JPRINT.GT.0) CALL PRINTF(0) 
C#### WCH, 10/14/94.  ALLOW DEPTH PRINTING WITHOUT HYDROGRAPH PRINTS. 
      IF(JPRINT.EQ.0.AND.NSURF.GT.0) CALL PRINTF(1) 
      IF(NPOLL.GT.0.AND.JPRINT.GT.0) THEN 
                                     CALL PRINTQ 
                                     CALL PRINTF(1) 
                                     ENDIF 
      WRITE(*,4850) 
      WRITE(N6,4850) 
C======================================================================= 
C#### WCH, 8/7/96.  INCREASE FIELD WIDTH FOR TIME STEP NUMBER TO 7. 
   22 FORMAT('+',5X,I7) 
   23 FORMAT(/,' Beginning loop through ',I7,' time steps.',/, 
     +         ' Time step # ',/) 
  400 FORMAT(' INCREASE WIDTH OF EXT ELEMENT ',I10,' BY 0.50 TO ',F7.3, 
     1' FT.') 
  401 FORMAT(' INCREASE WIDTH OF EXT ELEMENT ',A10,' BY 0.50 TO ',F7.3, 
     1' FT.') 
  415 FORMAT(' REPLACE EXT ELEMENT ',I10,' BY CIRCULAR CONDUIT OF DIAMET 
     1ER ',F7.3,'FT.') 
  416 FORMAT(' REPLACE EXT ELEMENT ',A10,' BY CIRCULAR CONDUIT OF DIAMET 
     1ER ',F7.3,'FT.') 
  480 FORMAT(' INCREASE DIAMETER OF EXT ELEMENT ',I10,' BY ',F6.2, 
     1' TO ',F8.3,'FT.') 
  481 FORMAT(' INCREASE DIAMETER OF EXT ELEMENT ',A10,' BY ',F6.2, 
     1' TO ',F8.3,'FT.') 
  910 FORMAT (//, ' THE TOTAL SIMULATION TIME =',F12.1,' SECONDS.'/, 
     1            '                            ',F12.2,' MINUTES.',/, 
     2            '                            ',F12.3,'   HOURS.',/, 
     3            '         THE TIME STEP(DT) =',F12.1,' SECONDS.') 
Cwch, 8/29/00.  Align headings better with output. 
  916 FORMAT(I1,/, 
     1' *****************************************************',/, 
     1' *           TRANSPORT ELEMENT PARAMETERS            *',/, 
     1' *                                                   *',/, 
     *' * CAUTION: COLUMN HEADINGS ARE FOR CONDUITS.  REFER *',/, 
     2' * TO USERS MANUAL FOR MEANING FOR NON-CONDUITS.     *',/, 
     1' *****************************************************',//, 
	19X,'EXT.                      SLOPE  DISTANCE  MANNING    GEOM1  G 
     3EOM2  GEOM3  NUMBER   AFULL     QFULL     QMAX   SUPER-CRITICAL' 
     3,/,9X'ELE. TY                  (FT/FT)   (FT)   ROUGHNESS   (FT) 
     3 (FT)   (FT)    OF    (SQ.FT)    (CFS)    (CFS)   FLOW WHEN LESS' 
     4,/,9X, 
	4'NUM. PE TYPE NAME 
     5         BARRELS                              THAN 95% FULL?',/, 
	59X,'---- -- -----------       -------  ------  --------   ------ 
     6-----  ----- -------  -------   ------  -------  --------------') 
  919 FORMAT(I1,/, 
     1' *****************************************************',/, 
     1' *           TRANSPORT ELEMENT PARAMETERS            *',/, 
     1' *                                                   *',/, 
     *' * CAUTION: COLUMN HEADINGS ARE FOR CONDUITS.  REFER *',/, 
     2' * TO USERS MANUAL FOR MEANING FOR NON-CONDUITS.     *',/, 
     1' *****************************************************',//, 
     29X,'EXT.                       SLOPE  DISTANCE  MANNING    GEOM1 
     2GEOM2  GEOM3  NUMBER   AFULL     QFULL     QMAX   SUPER-CRITICAL' 
     3,/,9X,'ELE. TY                     (M/M)    (M)   ROUGHNESS    (M) 
     4    (M)    (M)    OF      (SQ.M)    (CMS)    (CMS)   FLOW WHEN LES 
     4S',/, 
     49X,'NUM. PE TYPE NAME 
     5            BARRELS                              THAN 95% FULL?' 
     5,/,9X, 
     6'---- -- -----------       -------  ------  --------   ------  --- 
     6--  ----- -------  -------   ------  -------  --------------') 
  925 FORMAT (//,' THE ENDING DATE (YR/MO/DAY)....',I4,'/',I2,'/',I2,/, 
     1           ' THE ENDING TIME OF DAY.........',F9.3,' SECONDS.',//) 
  930 FORMAT(/,1H1,/, 
     1' **********************************************************',/, 
     1' *         HYDRAULIC DESIGN ROUTINE FINAL RESULTS.        *',/, 
     1' *  FINAL CONDUIT DIMENSIONS. ASTERISK INDICATES ALTERED  *',/, 
     2' *  CONDUITS.  ==> NOTE, PIPE SIZES ARE INCREASED BY U.S. *',/, 
     2' *                 STD. SIZES (E.G., 6 INCHES) AND MAY    *',/, 
     2' *                 NOT AGREE WITH METRIC STANDARDS.       *',/, 
     2' **********************************************************',/) 
  931 FORMAT(1X,I10,I5,1X,A1,A16,F8.5,F9.2,F9.4,F9.3,2F7.3,F6.1, 
     +                                           6X,3G9.2,5X,A4) 
  932 FORMAT(1X,A10,I5,1X,A1,A16,F8.5,F9.2,F9.4,F9.3,2F7.3,F6.1, 
     +                                           6X,3G9.3,5X,A4) 
 4750 FORMAT(//,11X,A80,/,11X,A80) 
 4850 FORMAT(/,1X,'Transport simulation ended normally.') 
C#### WCH (CDM), 8/93. 
 9100 FORMAT(/,' WARNING. While reading R1 lines, subscript NS2 in Sub. 
     1Trans out of range (LE.0 or GT.NET) at TIMHR =',F7.3,' hrs.',/, 
     2' Input flow time =',F7.3,' hrs.  Subscript NS2 =',I4,/, 
     3' Occurs for input element no.',I3,' (Sequence no.)  Parameters NN 
     3EED =',I4,' and BMS =',I4) 
 9150 FORMAT(/,' ERROR. R1 line not found in Sub. TRANS for simulation t 
     1ime =',F7.3,' hrs.',/,' Line found had ID =',A2,' Run stopped.') 
C======================================================================= 
      RETURN 
  888 CALL IERROR 
      END 
 
REM File: TRANSX.FOR 
 
      SUBROUTINE TRANSX 
C	EXTRAN BLOCK 
C======================================================================= 
C     Subroutine TRANSX of the Extran model calls subroutines 
C     XROUTE, YROUTE AND ZROUTE for the solution of the link 
C     momentum equation and the nodal continuity equation. 
C     Modified 7/14/93 by WCH based on CDM memo from Chuck Moore 
C       to correct for equality check for surface flooding. 
C     Slight format change for NSCRAT1 error message, WCH, 11/5/93. 
C     Correct DO 892 loop to avoid possible negative subscript 
C       when dealing with variable area junctions, WCH (RED), 12/7/94. 
C     Correct power function calculation for volume and change minimum 
C       area assumptions for irregular storage, WCH, 12/8/94. 
C     Correction to above correction.  Include VINIT and VLEFT in 
C       summations since these variables sum over all pipes and 
C       junctions.  WCH (C. Moore), 6/5/95. 
C     Alter IOSTAT for Lahey. WCH, 8/4/95. 
C     Correct inflow calculation for ISOL = 2 following changes to 
C       Sub. INFLOW of 10/17/95. WCH, 7/25/96. 
C     Put in error check for zero QFULL.  WCH, 1/22/97. 
C     Significant changes by CDM (C.I.Moore) for SWMM 4.4, 96-97. 
C     FIX TRANSX not to save maximums before NSTART.  This allows 
C       spurious startup values from being saved for the conduit and 
C       junction summary output. CIM, 7/15/97. 
C     CHANGE FOR MULTIPLE OUTPUT PERIODS, CHANGE CHECK FOR NSTART TO 
C     A CHECK AGAINST IBESTART(IBE) AND IBEEND(IBE).  UPDATE IBE AS 
C     NECESSARY.  cim 5/98 
C     Fix initialization of QQI() and QOU(), WCH from RED, 9/8/00. 
C     Added call to COMPTHRESH to compare computed elevations against 
C       input file is being used. 
C     Add checks for optional no-print of change of steady-state status. 
C       WCH for Mitch Heineman, 7/20/04. 
C     Add double XTIME for cumulative time keeping. WCH from RED, 7/20/04 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'BND.INC' 
      INCLUDE 'HYFLOW.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'TIDE.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'WEIR.INC' 
      INCLUDE 'VOLDAT.INC' 
      INCLUDE 'FCHAN.INC' 
cim TRANAID START 
CIM include common block for tranaid transfer file 
      INCLUDE 'TRANAID.INC' 
c new include for detailed ASCII output 
      INCLUDE 'ASCOUT1.INC' 
cim common for variable base flow 
      INCLUDE 'MOBFF.INC' 
CIM 1/99 CHANGE FOR BA OUTPUT CONTROLS    - OUTPUT CONTROLS 
      INCLUDE 'BALINES.INC' 
CIM 6/99 EXTRAN TO WASP LINK 
	INCLUDE 'WASP.INC' 
      character*20 ifile 
      DOUBLE PRECISION RAYTIME 
CIM  TRANAID END 
CIM  NEW COMMON FOR WRITING OF RESULTS TO ASCII FILE 
      INCLUDE 'CWRITE.INC' 
CIM 
CIM  NEW COMMON FOR WRITING INTERMEDIATE CONTINUITY CALCS 
      INCLUDE 'INTCON.INC' 
CIM END 
CIM  MULTIPLE PRINTOUT PERIODS  5/98 
      INCLUDE 'BE.INC' 
      DIMENSION QOUT(NEE),VTEMP(NEE),BADTIM(NEE),BADMAX(NEE),PSF(NPO,2) 
      LOGICAL FAIL 
C======================================================================= 
C     Define Statement function for linear interpolation. 
C======================================================================= 
      QLINTP(Q1,Q2,T2,T) = Q1 + (Q2-Q1)*T/T2 
C======================================================================= 
C     Initialization. 
C======================================================================= 
Cwch, 7/20/04. Initialize XTIME 
      XTIME      = TIME 
      ICYC       = 0 
      LTIME      = 0 
      NPTOT      = 0 
      MTIME      = 0 
      NERROR     = 0 
      ITMXXX     = 0 
      ITTOTL     = 0 
      JTIME      = 0 
      NUSE       = 4 
      SUMERR     = 0.0 
      NOUT       = NSCRAT(1) 
      NREDO      = NSCRAT(2) 
      XDELT      = RDELT 
      YOOMIN     = RDELT 
      YOOMAX     = 0.0 
      T2         = RDELT/3600.0 
      FMAX       = 3.0 
      FMIN       = 1.0 
      FACT       = 3.0 
      AFACT      = 0.0 
      ITURN      = 0 
cim speed  initialize stuff for head routine 
cim  make fudge smaller 
cim      FUDGE = 0.0001 
      FUDGE = 0.00001 
cim speed 
C======================================================================= 
C     Calculate JPRINT for output arrays. 
C======================================================================= 
      IF(NHPRT.GT.0.AND.NQPRT.GT.0.AND.NSURF.GT.0) JPRINT = 1 
      IF(NHPRT.GT.0.AND.NQPRT.GT.0.AND.NSURF.EQ.0) JPRINT = 2 
      IF(NHPRT.GT.0.AND.NQPRT.EQ.0.AND.NSURF.EQ.0) JPRINT = 3 
      IF(NHPRT.GT.0.AND.NQPRT.EQ.0.AND.NSURF.GT.0) JPRINT = 4 
      IF(NHPRT.EQ.0.AND.NQPRT.GT.0.AND.NSURF.GT.0) JPRINT = 5 
      IF(NHPRT.EQ.0.AND.NQPRT.GT.0.AND.NSURF.EQ.0) JPRINT = 6 
      IF(NHPRT.EQ.0.AND.NQPRT.GT.0.AND.NSURF.GT.0) JPRINT = 7 
C======================================================================= 
C     Save Junction and conduit names or numbers on NOUT. 
C======================================================================= 
      REWIND NOUT 
cim change write to nout to a sequential unformatted write 
      WRITE(NOUT) JCE,NHPRT,NQPRT,NSURF 
      IF(JCE.EQ.0) THEN 
      IF(NHPRT.GT.0) WRITE(NOUT) (JUN(JPRT(J)),J=1,NHPRT) 
      IF(NQPRT.GT.0) WRITE(NOUT) (NCOND(CPRT(J)),J=1,NQPRT) 
      IF(NSURF.GT.0) WRITE(NOUT) (NCOND(JSURF(J)),J=1,NSURF) 
      ELSE 
      IF(NHPRT.GT.0) WRITE(NOUT) (AJUN(JPRT(J)),J=1,NHPRT) 
      IF(NQPRT.GT.0) WRITE(NOUT) (ACOND(CPRT(J)),J=1,NQPRT) 
      IF(NSURF.GT.0) WRITE(NOUT) (ACOND(JSURF(J)),J=1,NSURF) 
      ENDIF 
Cwch, 9/8/00.  Use Bob Dickinson's correction for initialization. 
cred  misplaced initialization of qqi and qou if a hot-restart file is used 
cred  this was moved to a location before the reading of the 
cred  hot restart file - 9/7/00 
	DO J = 1,NJ 
         QQI(J)   = 0.0 
         QOU(J)   = 0.0 
         ENDDO 
C======================================================================= 
C     Read hot-start file NREDO. 
C======================================================================= 
      IF(NREDO.GT.0) THEN 
         REWIND NREDO 
         IF(JREDO.EQ.1.OR.JREDO.EQ.3) THEN 
             WRITE(N6,2100) 
             READ(NREDO,ERR=8888,END=8888) MTL,NJJ,NPP 
             READ(NREDO,ERR=8888) (Q(N),N=1,MTL),(QO(N),N=1,MTL) 
             READ(NREDO,ERR=8888) (V(N),N=1,MTL),(VT(N),N=1,MTL) 
             READ(NREDO,ERR=8888) (A(N),N=1,MTL),(AT(N),N=1,MTL) 
             READ(NREDO,ERR=8888) (ASFULL(N),N=1,NJJ) 
             READ(NREDO,ERR=8888) (Y(N),N=1,NJJ),(YT(N),N=1,NJJ) 
             READ(NREDO,ERR=8888) (VWELL(N),N=1,NPP),(JPFUL(N),N=1,NPP) 
             GO TO 666 
             ENDIF 
         ENDIF 
C======================================================================= 
C     Calculate initial volume in conduits (VINIT).  Use average of 
C     YNORM's at Junctions unless initial Junction depths are specified. 
C======================================================================= 
      DO 10 J  = 1,NJ 
Cwch, 9/8/00.  Use Bob Dickinson's correction.  Move initialization to 
C     before reading the hotstart file. 
Cred      QQI(J)   = 0.0 
cim initialized qou(j) 5/97 
Cred      QOU(J)   = 0.0 
      IF(Y(J).GT.0.01) GO TO 10 
      DO 20 JJ = 1,NCHN 
      IF(NCHAN(J,JJ).EQ.0) GO TO 11 
      N       = NCHAN(J,JJ) 
      IF(QO(N).NE.0.0) THEN 
                       CALL DEPTHX(N,NKLASS(N),QO(N),YC,YNORM) 
                       Y(J)    = Y(J) + YNORM 
                       ENDIF 
   20 CONTINUE 
C#### WCH, 12/8/94.  CAN THERE BE A JUNCTION WITH NO CONNECTING PIPES? 
C     CHECK, JUST IN CASE TO AVOID ZERO DIVIDE. 
   11 IF(JJ.GT.1) Y(J) = Y(J)/FLOAT(JJ-1) 
   10 CONTINUE 
C======================================================================= 
C     Initialize AT,VT,Q,Y arrays 
C     calculate initial system volume (VINIT). 
C======================================================================= 
CIM START  OOOOOOOO 
CIM     DETERMINE INITIAL GATED GATE OPENING INITIAL DEPTH Y 
CIM     USE LARGE DELTA T TO SET INITIAL CONDITIONS  (11.6 DAYS) 
  666 CALL OGATES(999999.9,Y,V) 
CIM END  OOOOOOOO 
      DO 25 N   = 1,NTC 
      IFULL(N)=0 
      NFIRST(N)=0 
      FHOUR(N)=0.0 
      NLAST(N)=0 
      FLHOUR(N)=0.0 
      BADTIM(N) = 0.0 
      BADMAX(N) = 0.0 
CIM TRANAID START 
      SUMQ(N) = 0.0 
CIM TRANAID END 
      AOVERB(N) = DEEP(N) 
      SLOPE     = (ZU(N)-ZD(N))/LEN(N) 
      IF(SLOPE.EQ.0.0) SLOPE = 0.01/LEN(N) 
      VDSGN     = SQRT(GRVT*SLOPE/ROUGH(N))*RFULL(N)**0.6666667 
      QFULL(N)  = AFULL(N)*VDSGN 
C####################################################################### 
C#### WCH, 1/22/97.  CHECK FOR ZERO QFULL. 
C======================================================================= 
      IF(QFULL(N).LE.0.0) THEN 
           IF(JCE.EQ.0) THEN 
                        WRITE(N6,9400) NCOND(N),N 
           ELSE 
                        WRITE(N6,9401) ACOND(N),N 
           ENDIF 
           WRITE(N6,9402) QFULL(N),VDSGN,RFULL(N),AFULL(N),SLOPE 
           ENDIF 
      NL        = NJUNC(N,1) 
      NH        = NJUNC(N,2) 
      H(N,1)    = AMAX1(Y(NL) + Z(NL),ZU(N)) 
      H(N,2)    = AMAX1(Y(NH) + Z(NH),ZD(N)) 
      IF(JREDO.EQ.0.OR.JREDO.EQ.2) THEN 
                       CALL NHEAD(N,NL,NH,H(N,1),H(N,2),QO(N), 
     +                             A(N),V(N),HRAD,ANH,ANL,RNL,RNH, 
     +                             IDOIT,LINK(N),AS) 
                                   VT(N)     = V(N) 
                                   AT(N)     = A(N) 
                                   Q(N)      = QO(N) 
                                   ELSE 
                       CALL NHEAD(N,NL,NH,H(N,1),H(N,2),QT(N), 
     +                             AT(N),VT(N),HRAD,ANH,ANL,RNL,RNH, 
     +                             IDOIT,LINK(N),AS) 
                                   ENDIF 
CIM TRANAID START 
CIM   HYDRAULIC RADIUS SAVED IN r ARRAY IN SUBROUTINE VOLUME 
CIM      YO(N)     = HRAD 
CIM TRANAID END 
C======================================================================= 
C     Note, initial volume will never be zero because FUDGE = 0.0001 is 
C     used in Sub. HEAD instead of zeroes for cross sectional areas 
C     (and other cross section parameters).  Thus, initial volume will 
C     approximately equal sum of pipe lengths x FUDGE, plus corrections 
C     for Courant violations plus new equivalent pipes, e.g., for 
C     orifices.  I.e., in equation below, ANL = ANH = 0.0001 even if 
C     zero flows and depths are specified as initial conditions. 
C======================================================================= 
CIM TRANAID START 
CIM VOLUME CALCULATION MOVED TO SUBROUTINE VOLUME 
CIM   25  VINIT     = VINIT + (ANL+ANH)*LEN(N)/2.0 
CIM 
  25  CONTINUE 
c  compute initial total volume and volume for each junction 
      CALL VOLUME(VINIT,.TRUE.) 
cim INTERCON 
CIM  call IINTERCON to initialized intermediate continuity output data 
      VNOW = VINIT 
      call IINTERCON(.true.) 
CIM INTERCON END 
CIM 5/99 CALL WASPINIT TO INITIAL EXTRAN TO WASP HYRDODYNAMICS INTERFACE FILE 
      CALL WASPINIT 
c....................................................................... 
c       Open hydraulic output file, and initialize variables 
c....................................................................... 
	if (idump .gt. 0) then 
	ihyd = ihydwr - 1 
	ihydwr = nint(dthyd/delt) 
cim test write 
c        write(n6,*) idump,ihyd,ihydwr,dthyd,hydstr 
	write(*,6789) 
6789    format(' Enter hydraulic output file name: ',$) 
	read(*,'(a20)') ifile 
	open(20, file=ifile, status='unknown', form='unformatted') 
	write(20) nfree,(ntl-nfree),nj,(qinst(j),j=1,nj), 
     &            (jfree(j),j=1,nfree) 
	write(20) (len(n),n=1,ntl) 
	write(20) ((njunc(n,i),i=1,2),n=1,ntl) 
	write(20) (jun(j),j=1,nj) 
	write(20) (ncond(n),n=1,ntl) 
	write(20) (sqrt(rough(n)/grvt)*cmet(9,metric), n=1,ntl) 
		if (hydstr .le. time/3600.) then 
cim note time is not double precision in this program, convert to raytime which is 
                raytime=time/3600. 
		write(20) raytime 
		write(20) (q(n),n=1,ntl) 
		write(20) (a(n),n=1,ntl) 
		write(20) (r(n),n=1,ntl) 
		write(20) (vol(j),j=1,nj) 
		write(20) (qin(j),j=1,nj) 
		write(20) ((y(j)+z(j)),j=1,nj) 
		ihyd = 0 
		end if 
	end if 
CIM      VOLUME CALCULATION NOW IN SUBROUTINE VOLUME 
C 25  IF(NKLASS(N).LE.8) VINIT = VINIT + (ANL+ANH)*LEN(N)/2.0 
CIM TRANAID END 
C======================================================================= 
C     Write initial information. 
C======================================================================= 
      WRITE(N6,1598) TIME/3600.0 
      WRITE(N6,1501) 
cim 1/99 write all 10 digits and characters 
CIM old write statements for JP10 = 0 
      IF(JP10.EQ.0) THEN 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1502) (JUN(J),Y(J),JCHECK(J), 
     +                                 Y(J)+Z(J),J=1,NJ) 
          ELSE 
                   WRITE(N6,1512) (AJUN(J),Y(J),JCHECK(J), 
     +                                  Y(J)+Z(J),J=1,NJ) 
          ENDIF 
      WRITE(N6,1503) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1505) (NCOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ELSE 
                   WRITE(N6,1515) (ACOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ENDIF 
      WRITE(N6,1506) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),V(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),V(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1507) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),A(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),A(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1508) 
CIM  TRANAID START 
CIM  NOTE HYDRAULIC RADIUS IS NOW SAVED IN R ARRAY IN SUBROUTINE VOLUME 
CIM  CHANGE YO TO R IN FOLLOWING TWO LINES 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),R(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),R(N),N=1,NTC) 
          ENDIF 
CIM  TRANAID END 
      WRITE(N6,1509) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1517) (NCOND(N),H(N,1),H(N,2),N=1,NTC) 
          ELSE 
                   WRITE(N6,1518) (ACOND(N),H(N,1),H(N,2),N=1,NTC) 
          ENDIF 
      ELSE 
C     FOLLOWING WRITE ALL 10 DIGITS AND CHARACTERS 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61502) (JUN(J),Y(J),JCHECK(J), 
     +                                 Y(J)+Z(J),J=1,NJ) 
          ELSE 
                   WRITE(N6,61512) (AJUN(J),Y(J),JCHECK(J), 
     +                                  Y(J)+Z(J),J=1,NJ) 
          ENDIF 
      WRITE(N6,1503) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61505) (NCOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ELSE 
                   WRITE(N6,61515) (ACOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ENDIF 
      WRITE(N6,1506) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),V(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),V(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1507) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),A(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),A(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1508) 
CIM  TRANAID START 
CIM  NOTE HYDRAULIC RADIUS IS NOW SAVED IN R ARRAY IN SUBROUTINE VOLUME 
CIM  CHANGE YO TO R IN FOLLOWING TWO LINES 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),R(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),R(N),N=1,NTC) 
          ENDIF 
CIM  TRANAID END 
      WRITE(N6,1509) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61517) (NCOND(N),H(N,1),H(N,2),N=1,NTC) 
          ELSE 
                   WRITE(N6,61518) (ACOND(N),H(N,1),H(N,2),N=1,NTC) 
          ENDIF 
      ENDIF 
C 
C======================================================================= 
C     Calculate QFULL for each orifice. 
C======================================================================= 
       IF(NORIF.GT.0) THEN 
                      DO 35 I  = 1,NORIF 
                      N        = NC + I 
                      QFULL(N) = AORIF(I)*SQRT(2.0*GRVT*DEEP(N)) 
     +                                                 *CORIF(I) 
   35                 CONTINUE 
                      ENDIF 
C======================================================================= 
C     Calculate YCROWN for each Junction. 
C======================================================================= 
      DO 30 J   = 1,NJ 
      IF(ZCROWN(J).EQ.Z(J)) ZCROWN(J) = Z(J) + 1.0 
                                   YCROWN(J) = ZCROWN(J)-Z(J) 
      IF(GRELEV(J)-ZCROWN(J).GT.0) YCROWN(J) = 0.96*(ZCROWN(J)-Z(J)) 
   30 YT(J)     = Y(J) 
CIM TRANAID START 
CIM VOLUME CALC FOR IRREGULAR STORAGE ELEMENTS MOVED TO VOLUME SUBROUTINE 
CIM VINIT CALCS COMMENTED OUT OF NEXT LOOP 
C======================================================================= 
C     New Computation of Volume for Irregular Storage Elements. 
C======================================================================= 
cim   DO 70 I = 1,NSTORE 
cim   J       = JSTORE(I) 
cim   IF(ASTORE(I).GE.0.0) THEN 
CIM                         VINIT  = VINIT + Y(J)*ASTORE(I) 
cim                      ELSE IF(NUMV(I).LT.0) THEN 
cim                         IF(Y(J).EQ.0.0) Y(J) = 0.0001 
C======================================================================= 
C#### WCH, 12/8/94.  ERROR HERE.  MUST >>INTEGRATE<< AREA POWER 
C     FUNCTION TO GET VOLUME  ALSO, LET MINIMUM AREA = AMEN. 
C======================================================================= 
C####                         VINIT = VINIT + 
C####     +                           VCURVE(I,1,1)*Y(J)**VCURVE(I,2,1) 
C======================================================================= 
C#### WCH (C.MOORE), 6/5/95.  CORRECTION TO CORRECTION.  MUST INCLUDE 
C     VINIT IN SUMMATION SINCE VINIT IS GRAND TOTAL FOR ALL 
C     PIPES/JUNCTIONS. 
C======================================================================= 
C####                            VINIT = Y(J)*AMEN 
CIM                            VINIT = VINIT + Y(J)*AMEN 
CIM                            VINIT = VINIT + VCURVE(I,1,1) * 
CIM     +         Y(J)**(VCURVE(I,2,1)+1)/(VCURVE(I,2,1)+1) 
cim                      ELSE 
cim                      NTOX       = NUMV(I) 
cim                      RESELV     = Y(J) 
C#### WCH, 12/8/94.  MIN. AREA = AMEN NOT USED IN SUB. BOUND, SO 
C     DON'T INCLUDE IT HERE.  BUT ADD CHECK IN SUB. INDAT2 TO ENSURE 
C     THAT MIN. AREA NOT = ZERO.   ALSO, START WITH SUBSCRIPT IX = 2 
C     TO ENSURE THAT IX-1 NOT = 0. 
C####                         VINIT      = VINIT + RESELV*AMEN 
cim                      DO 1891 IX = 2,NTOX 
cim 1891                    IF(RESELV.LT.VCURVE(I,2,IX)) GO TO 1892 
cim 1892                    DELTA = (RESELV-VCURVE(I,2,IX-1))/ 
cim     +                           (VCURVE(I,2,IX)-VCURVE(I,2,IX-1)) 
CIM                         VINIT = VINIT+DELTA*(VCURVE(I,3,IX) - 
CIM     +                           VCURVE(I,3,IX-1))+VCURVE(I,3,IX-1) 
cim                         ENDIF 
cim   70 CONTINUE 
CIM TRANAID END 
C======================================================================= 
C     Write first line of output interface file. 
C======================================================================= 
      IF(NEXT.GT.0) THEN 
                    BELT = 0.0 
                    WRITE(NEXT) JULDAY,TIMDAY,BELT,(QOUT(N),N=1,MJSW) 
                    ENDIF 
C 
C here call ASCOUT to output head information 
C 
      IF (IASCII.NE.0) CALL ASCOUT(1) 
C 
C======================================================================= 
C     Major Program loop through time. 
C======================================================================= 
C ### RHF 10/16/96 
      NTIMCS = 0 
      QMINCS = 999999.999 
      QMOUCS = 999999.999 
C   NEWQIN IS 1 IF STEADY, 0 IF NOT STEADY 
      NEWQIN = 0 
      NOROUT = 0 
      CONSTINFLOW = .FALSE. 
      SMALLOUTFLOW = .FALSE. 
      EQUALINOUT = .FALSE. 
      CONSTINFLOWO = .FALSE. 
      SMALLOUTFLOWO = .FALSE. 
      EQUALINOUTO = .FALSE. 
      IBAD = 1 
      JBAD = 1 
      WRITE(*,23) 
      IF (ISOLSKIP.EQ.1)  WRITE(*,923) 
      WRITE(*,924) 
      WRITE(*,24)   NJ,NTL,NTCYC 
      IF (ISOLSKIP.NE.1) THEN 
            WRITE(*,27) 
            ELSE 
            WRITE(*,28) 
            ENDIF 
      MP          = (NTCYC+200)/200 + 1 
      DO 750 MCY  = 1,NTCYC,MP 
      NPTOT       = NPTOT + 1 
      IF(MTIME+MP.GT.NTCYC) MP = NTCYC - MTIME 
      DO 640 MCYY = 1,MP 
C======================================================================= 
C     Calculate and update time. 
C======================================================================= 
      LIT         = 0 
      MTIME       = MTIME + 1 
      ICYC        = ICYC  + 1 
C  CHECK IF IBE NEEDS UPDATED 
   39 IF (ICYC.LT.IBEEND(IBE)) GO TO 40 
      IBE = IBE + 1 
      GO TO 39 
   40 CONTINUE 
      TIMEX       = TIME 
      JLAST       = JULDAY 
      TLAST       = TIMDAY 
cred  try to accumulate time differently - 1/28/2002 
Cwch, 7/20/04. XTIME is double precision for time keeping.  
C      TIME        = TIME + DELT 
      XTIME       = XTIME + DELT 
      TIME        = XTIME 
C 
      TIME2       = TIME - DELT/2.0 
      CALL STIME(DELT) 
      CALL DATED 
C======================================================================= 
C     Surcharge parameters. 
C======================================================================= 
      ERROR = 0.0 
      TOL   = 1.0 
      IT    = 0 
      NSUR  = 1 
      CALL INFLOW 
      IF (ISOLSKIP.EQ.1) THEN 
C   NEWQTAPE IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY 
C   NEWQCARD IS RETURNED AS 1 IF STEADY, 0 IF NOT STEADY 
           NOROUTO = NOROUT 
           IF (NEWQTAPE.EQ.0.or.NEWQCARD.EQ.0) THEN 
                NEWQIN = 0 
                NOROUT = 0 
                CONSTINFLOWO = CONSTINFLOW 
                CONSTINFLOW = .FALSE. 
Cwch (Mitch Heineman), 7/20/04. Add check for optional no-print  
C     of status. 
C      IF (NOROUTO.EQ.1) CALL SSSTATUS(1) 
                IF (NOROUTO.EQ.1.AND.TOLCS1.GE.0) CALL SSSTATUS(1) 
                ELSE 
                NEWQIN = 1 
                ENDIF 
           ENDIF 
c     write(n6,*) 'transx1',NEWQTAPE,NEWQCARD,Newqin 
C======================================================================= 
C     Save beginning time step values. 
C======================================================================= 
      MSURGE    = 0 
cim move if statment out of the loop 
      DO 9000 J = 1,NJ 
cim      IF(ISOL.GE.2) THEN 
cim                    YT(J)    = Y(J) 
cim                    VTEMP(J) = VWELL(J) 
cim                    ENDIF 
 9000 IF(Y(J).GT.YCROWN(J)) MSURGE = MSURGE + 1 
      IF(ISOL.GE.2) THEN 
      DO 9001 J = 1,NJ 
                    YT(J)    = Y(J) 
                    VTEMP(J) = VWELL(J) 
 9001 CONTINUE 
      ENDIF 
      MNORM     = 0 
      YDELT     = XDELT/FACT 
      XDELT     = RDELT 
      DO 9010 N = 1,NTC 
      NL        = NJUNC(N,1) 
      NH        = NJUNC(N,2) 
      IF(ISOL.GE.2) QT(N)  = Q(N) 
CIM START <><><><><><> 
CIM      THIS IS FOR TRAPEZOID, IRREGULAR(PARABOLIC) OPEN CHANNELS 
CIM      IF(NKLASS(N).GE.5.AND.NKLASS(N).LT.9) THEN 
         IF(NKLASS(N).EQ.22.OR.NKLASS(N).EQ.23) THEN 
CIM END  <><><><><><><> 
                            DIFF   = AOVERB(N) 
                            ELSE 
                            DIFF1 = H(N,1) - ZU(N) 
                            DIFF2 = H(N,2) - ZD(N) 
                            DIFF  = AMAX1(DIFF1,DIFF2) 
                            ENDIF 
      VEL       = ABS(V(N)) 
      IF(VEL.GT.0.0)  THEN 
                      IF(DIFF.GT.0.0) VEL = VEL + SQRT(GRVT*DIFF) 
                                      VEL = LEN(N)/VEL 
                      IF(ISOL.GE.2) THEN 
                          BADTIM(N) = BADTIM(N) + VEL*FLOAT(NUSE) 
                          IF(YDELT.GE.VEL) BADMAX(N) = BADMAX(N) + RDELT 
                          IF(VEL.LT.XDELT) XDELT = VEL 
                          ELSE 
                          IF(RDELT.GE.VEL) BADMAX(N) = BADMAX(N)+RDELT 
                                           BADTIM(N) = BADTIM(N)+VEL 
                          ENDIF 
                      ELSE 
                      IF(ISOL.LE.1) THEN 
                        BADTIM(N)=BADTIM(N)+RDELT 
                        else 
                        BADTIM(N)=BADTIM(N)+VEL*FLOAT(NUSE) 
                      ENDIF 
                      ENDIF 
 9010 IF(ICHECK(N).EQ.IND(2)) MNORM = MNORM + 1 
                       FACT  = FMAX 
      IF(MSURGE.GE.1)  FACT  = FMIN 
                      XDELT  = XDELT*FACT 
cim clean if statements here and add additional parameters 
cim      IF(MTIME.GT.1)  THEN 
      IF(JCE.EQ.0) THEN 
                   IF (ISOLSKIP.NE.1) THEN 
                   WRITE(6,22) MTIME,ITTOTL,MNORM,MSURGE,NCOND(IBAD), 
     +                         QMAX,JUN(JBAD),YMAX 
                   ELSE 
                   WRITE(6,22) MTIME,ITTOTL,MNORM,MSURGE,NCOND(IBAD), 
     +                         QMAX,JUN(JBAD),YMAX,NOROUT,NEWQIN,NTIMCS 
                   ENDIF 
      ELSE 
                   IF (ISOLSKIP.NE.1) THEN 
                   WRITE(6,21) MTIME,ITTOTL,MNORM,MSURGE,ACOND(IBAD), 
     +                         QMAX,AJUN(JBAD),YMAX 
                   ELSE 
                   WRITE(6,21) MTIME,ITTOTL,MNORM,MSURGE,ACOND(IBAD), 
     +                         QMAX,AJUN(JBAD),YMAX,NOROUT,NEWQIN,NTIMCS 
                   ENDIF 
      endif 
cim   read(*,*) intemp 
cim      ELSE 
cim      IF(XDELT.EQ.RDELT) XDELT = RDELT/4.0 
cim      IF(JCE.EQ.0)  WRITE(*,22) MTIME,ITTOTL,MNORM,MSURGE 
cim      IF(JCE.EQ.1)  WRITE(*,21) MTIME,ITTOTL,MNORM,MSURGE 
cim      ENDIF 
C======================================================================= 
C     Call modified EULER solution's. 
C======================================================================= 
CIM SPEEDY USE CASE STATEMENTS HERE (COULD BE REPLACED BY COMPUTED GOTO) 
      SELECT CASE (ISOL) 
cim   IF(ISOL.EQ.0) THEN 
      CASE(0) 
         IF (NOROUT.EQ.0) THEN 
                    CALL XROUTE 
                    LIT = IT + 2 
                    ntimcs = ntimcs + 1 
         ENDIF 
cim                    ENDIF 
cim      IF(ISOL.EQ.1) THEN 
      CASE(1) 
         IF (NOROUT.EQ.0) THEN 
                    CALL YROUTE 
                    LIT = IT + 2 
                    ntimcs = ntimcs + 1 
         ENDIF 
cim                    ENDIF 
C======================================================================= 
C      Call the iterative solution.  Determine the time step size based 
C      on the shortest conduit and the previous maximum velocity. 
C======================================================================= 
cim      IF(ISOL.GE.2) THEN 
      CASE(2) 
                    FAIL      = .FALSE. 
                    IPICK     = 0 
                    N1        = 1 
                    CDELT     = 0.0 
                    IF(XDELT.EQ.0.0) THEN 
                                     NUSE   = 4 
                                     ELSE 
                                     NUSE   = IFIX(RDELT/XDELT) 
                                     IF(NUSE.LE.0) NUSE = 1 
                                     ENDIF 
 8999               CONTINUE 
                    DELT      = RDELT/FLOAT(NUSE) 
                    DELT2     = DELT/2.0 
                    IF(DELT.LT.YOOMIN) YOOMIN = DELT 
                    IF(DELT.GT.YOOMAX) YOOMAX = DELT 
                    TIME      = TIMEX 
                    JULDAY    = JLAST 
                    TIMDAY    = TLAST 
                    DO 9040 N = N1,NUSE 
                    IT        = 1 
                    TIME2     = TIME + DELT/2.0 
                    TIME      = TIME + DELT 
                    CALL STIME(DELT) 
                    CALL DATED 
C======================================================================= 
C     Interpolate for inflows at this time. 
C======================================================================= 
                    DO 9045 J = 1,NJ 
                    QQ1       = QINN(J,1) 
                    QQ2       = QINN(J,2) 
                    T         = FLOAT(N)*DELT/3600.0 
                    T1        = FLOAT(N-1)*DELT/3600.0 
                    QIN(J)    = QLINTP(QQ1,QQ2,T2,T1)/2.0 + 
CIM  change to implement monthly base flow factors 
CIM     +                          QLINTP(QQ1,QQ2,T2,T)/2.0  + QINST(J) 
     +                          QLINTP(QQ1,QQ2,T2,T)/2.0  + 
     +                          QINST(J)*BFFMONTH(1,IWHICH(J)) 
C####################################################################### 
C#### WCH, 7/25/96.  FROM CHANGES TO SUB. INFLOW OF 10/17/95, K3-LINE 
C     INPUT IN SUB. INFLOW NOW KEPT SEPARATE FROM INTERFACE FILE 
C     INPUT, IN ARRAY QINNK3.  NEED TO INTERPOLATE ON THAT ARRAY HERE 
C     NOW AS WELL. 
C======================================================================= 
                    QQ1       = QINNK3(J,1) 
                    QQ2       = QINNK3(J,2) 
                    QIN(J)    = QLINTP(QQ1,QQ2,T2,T1)/2.0 + 
     +                          QLINTP(QQ1,QQ2,T2,T)/2.0  + QIN(J) 
 9045               CONTINUE 
                    CALL ZROUTE(FAIL) 
                    IF(FAIL.AND.IPICK.LE.1) THEN 
                                DO 9055 J = 1,NJ 
                                VWELL(J)  = VTEMP(J) 
 9055                           Y(J)      = YT(J) 
                                DO 9056 M = 1,NTC 
 9056                           Q(M)      = QT(M) 
                                IPICK     = IPICK + 1 
                                LIT       = LIT   + IT 
                                ITURN     = ITURN + 1 
                                N1        = 2*(N-1)+ 1 
                                IF(N.EQ.1) N1 = 1 
                                NUSE      = NUSE*2 
                                FACT      = FACT/2.0 
                                GO TO 8999 
                                ENDIF 
                    LIT       = LIT   + IT 
                    AFACT     = AFACT + FACT 
                    CDELT     = CDELT + DELT 
                    JTIME     = JTIME + 1 
                    TIMEX     = TIME 
                    JLAST     = JULDAY 
                    TLAST     = TIMDAY 
                    IF(ABS(ERROR).GT.SUMERR) SUMERR=ABS(ERROR) 
c inflow and outflow 
                    DO 9050 J = 1,NJ 
                    IF(QIN(J).LT.0.0) QOU(J) = QOU(J) - QIN(J)*DELT 
                    IF(QIN(J).GE.0.0) QQI(J) = QQI(J) + QIN(J)*DELT 
C###### WCH, 7/14/93, BASED ON CDM MEMO FROM CHUCK MOORE, 6/25/93. 
C       ALTER CHECK FOR EQUALITY OF DEPTH TO GROUND - INVERT. 
C###### 
CIM 5/99 USE SURELEV IN PLACE OF GRELEV 
CIM I THINK THIS IS REJECTED INFLOW IF SURCHARGED 
                    IF(Y(J).GE.SURELEV(J)-Z(J)-0.000001) THEN 
                       QOU(J) = QOU(J)  +  SUMQ(J)*DELT 
					 VOL(J) = VOL(J)  -  SUMQ(J)*DELT 
	ENDIF 
cim intercont 
cim sumqin is reset and computed in OUTPUT 
cim 9050               IF(QIN(J).GE.0.0) SUMQIN = SUMQIN + QIN(J)*DELT 
 9050 CONTINUE 
                    I         = 0 
c these are boundary conduit flows 
                    DO 9060 M = NTC+1,NTL 
                    J         = NJUNC(M,1) 
                    IF(NJUNC(M,2).LE.0) THEN 
                                  QOU(J)  = QOU(J) + Q(M)*DELT 
                                  I       = I+1 
                                  QOUT(I) = Q(M) 
                                  ENDIF 
 9060               CONTINUE 
C======================================================================= 
C     Check for maximum flow and velocity in conduits. 
C======================================================================= 
CIM add check for nstart 
cim change to call to IPRNTIT (see end of this file) 
cim       IF (ICYC.GE.NSTART) THEN 
      IF (IPRNTIT(ICYC).EQ.1) THEN 
CIM 
                    DO 9070 M = 1,NTL 
                    IF(M.LE.NTC.AND.ICHECK(M).EQ.IND(2)) 
     +                              SUPLEN(M) = SUPLEN(M) + DELT 
                    IF(ABS(Q(M)).GT.ABS(QMAXX(M))) THEN 
                                        QMAXX(M) = Q(M) 
                                        IQHR(M)  = IFIX(TIME/3600.0) 
                                        IQMIN(M) = MINUTE 
                                        ENDIF 
                    IF(MTIME.GT.1.AND.ABS(V(M)).GT.ABS(VMAXX(M))) THEN 
                                        VMAXX(M) = V(M) 
                                        IVHR(M)  = IFIX(TIME/3600.0) 
                                        IVMIN(M) = MINUTE 
                                        ENDIF 
                   IF(M.LE.NTC) THEN 
                   IF(H(M,1).GT.PMAX(M,1)) PMAX(M,1) = H(M,1) 
                   IF(H(M,2).GT.PMAX(M,2)) PMAX(M,2) = H(M,2) 
CIM SPEED can do away with these four ifs  link is now integer not string 
                   CTIME(M,link(m))   = CTIME(M,link(m)) + DELT 
cim                   IF(LINK(M).EQ.'DR1') CTIME(M,1)   = CTIME(M,1) + DELT 
cim                   IF(LINK(M).EQ.'SUB') CTIME(M,2)   = CTIME(M,2) + DELT 
cim                   IF(LINK(M).EQ.'CR1') CTIME(M,3)   = CTIME(M,3) + DELT 
cim                   IF(LINK(M).EQ.'CR2') CTIME(M,4)   = CTIME(M,4) + DELT 
                                ENDIF 
 9070              CONTINUE 
C======================================================================= 
C     Check for surcharge and maximum depth at junctions. 
C======================================================================= 
                   DO 9080 J = 1,NJ 
                   IF((Z(J)+Y(J)).GT.ZCROWN(J)) SURLEN(J)=SURLEN(J)+DELT 
C###### WCH, 7/14/93, BASED ON CDM MEMO FROM CHUCK MOORE, 6/25/93. 
C       ALTER CHECK FOR EQUALITY OF DEPTH TO GROUND - INVERT. 
C###### 
C     HERE USE SURELEV IN PLACE OF GRELEV 
                   IF((Z(J)+Y(J)).GE.SURELEV(J)-0.000001) 
     *                                  FLDLEN(J) = FLDLEN(J)+DELT 
                   IF(AS(J).GT.ASMAXX(J))       ASMAXX(J) = AS(J) 
                   IF(Y(J).GT.DEPMAX(J)) THEN 
                                 DEPMAX(J) = Y(J) 
                                 IDHR(J)   = IFIX(TIME/3600.0) 
                                 IDMIN(J)  = MINUTE 
                                 ENDIF 
 9080              CONTINUE 
cim check for NSTART 
      ENDIF 
CIM 
 9040              CONTINUE 
                   DELT  = RDELT 
                   DELT2 = DELT/2.0 
cim eliminated by case statements        ENDIF 
C======================================================================= 
C     End of segment for ISOL = 2. 
C======================================================================= 
      END SELECT 
C======================================================================= 
C     Surcharge summary information. 
C======================================================================= 
      IF(IT+1.GT.ITMXXX) ITMXXX = IT + 1 
                         ITTOTL = ITTOTL + LIT 
                         IF(ABS(ERROR).GT.SUMERR) SUMERR = ABS(ERROR) 
C======================================================================= 
C     Calculate total depth and total flow for junctions and conduits . 
C======================================================================= 
      YMAX      = 0.0 
      JBAD      = 1 
C ### RHF 12/23/96 
      QMAX = 0.0 
      IF (NOROUT.EQ.1) GO TO 9610 
C --- 
      DO 9500 J = 1,NJ 
      YDIFF     = (Y(J) - YO(J))/YCROWN(J) 
      IF(ABS(YDIFF).GT.ABS(YMAX)) THEN 
                                  YMAX = YDIFF 
                                  JBAD = J 
                                  ENDIF 
      YDEV(J)   = YDEV(J) + ABS(YDIFF) 
 9500 YTOT(J)   = YTOT(J) + Y(J) 
      QMAX      = 0.0 
      IBAD      = 1 
      DO 9600 N = 1,NTL 
      IF(N.LE.NTC) THEN 
           QDIFF     = (Q(N) - QO(N))/QFULL(N) 
           IF(ABS(QDIFF).GT.ABS(QMAX)) THEN 
                                       QMAX = QDIFF 
                                       IBAD = N 
                                       ENDIF 
           ENDIF 
      QDEV(N)   = QDEV(N) + ABS(QDIFF) 
 9600 QTOT(N)   = QTOT(N) + Q(N) 
C======================================================================= 
C     Compute continuity parameters. 
C======================================================================= 
C #### RHF 8/14/96 
 9610  CONTINUE 
C ---- 
      IF(ISOL.LE.1) THEN 
C ### RHF 12/20/96 
      QOUTCS = 0. 
      QINCS = 0. 
C --- 
C    COMPUTE MODEL INFLOWS AND OUTFLOWS 
C   FIRST DO INFLOW AND OUTFLOWS 
            DO 950 J = 1,NJ 
            IF(QIN(J).LT.0.0) QOU(J) = QOU(J) - QIN(J)*DELT 
            IF(QIN(J).GE.0.0) QQI(J) = QQI(J) + QIN(J)*DELT 
C###### WCH, 7/14/93, BASED ON CDM MEMO FROM CHUCK MOORE, 6/25/93. 
C       ALTER CHECK FOR EQUALITY OF DEPTH TO GROUND - INVERT. 
C###### 
C  5.99 
C     HERE USE SURELEV IN PLACE OF GRELEV 
C  THIS IS OVERFLOW? 
           IF(ABS(Y(J)-(SURELEV(J)-Z(J))).LE.0.000001) THEN 
		        QOU(J) = QOU(J) + SUMQS(J)*DELT 
*				VOL(J) = VOL(J) - SUMQS(J)*DELT 
	ENDIF 
C ### RHF 12/20/96 
c     IF (NOROUT .EQ. 1) GO TO 950 
            IF(QIN(J).LT.0.0) QOUTCS = QOUTCS - QIN(J) 
            IF(QIN(J).GE.0.0) QINCS = QINCS + QIN(J) 
C     HERE USE SURELEV IN PLACE OF GRELEV 
            IF(ABS(Y(J)-(SURELEV(J)-Z(J))).LE.0.000001) 
     *                                 QOUTCS = QOUTCS + SUMQS(J) 
C --- 
CIM INTERCONT 
CIM  SUMQIN now computed in output.for 
cim 950        IF(QIN(J).GE.0.0)          SUMQIN = SUMQIN + QIN(J)*DELT 
  950 continue 
            I        = 0 
C  THESE ARE BOUNDARY CONDUITS 
            DO 960 N = NTC+1,NTL 
            J        = NJUNC(N,1) 
            IF(NJUNC(N,2).LE.0) THEN 
                                QOU(J)  = QOU(J) + Q(N)*DELT 
                                I       = I+1 
                                QOUT(I) = Q(N) 
C ### RHF 12/20/96 
      QOUTCS = QOUTCS + Q(N) 
C --- 
                                ENDIF 
  960       CONTINUE 
C ### RHF 12/20/96 CHECK TOTAL OUTFLOW TO  DETERMINE IF ROUTING SHOULD 
C     BE STOPPED 
      IF (ISOLSKIP .NE. 1) GO TO 965 
cim change this if statement from rhf's original code 
C   NEWQIN IS 1 IF STEADY, 0 IF NOT STEADY 
cim   IF (NOROUT.EQ.0 .AND. NEWQIN.EQ.0) THEN 
cim      WRITE(N6,*) 'QQS',QINCS,QOUTCS 
c     IF (NOROUT.EQ.0) THEN 
      NOROUTO = NOROUT 
      QMINCS = AMIN1(QMINCS,QINCS) 
      QMOUCS = AMIN1(QMOUCS,QOUTCS) 
      NOROUT = 1 
      IF (QOUTCS.GE.QLOWCS) THEN 
c  this is case where outflow is greater than minimum 
           NOROUT = 0 
           SMALLOUTFLOWO = SMALLOUTFLOW 
           SMALLOUTFLOW = .FALSE. 
           ELSE 
           SMALLOUTFLOWO = SMALLOUTFLOW 
           SMALLOUTFLOW = .TRUE. 
           ENDIF 
      IF (NEWQIN.EQ.0) then 
c  this is case where inflow at any location changed 
           NOROUT = 0 
           CONSTINFLOWO = CONSTINFLOW 
           CONSTINFLOW = .FALSE. 
           ELSE 
           CONSTINFLOWO = CONSTINFLOW 
           CONSTINFLOW = .TRUE. 
           end if 
c     IF ((QOUTCS.LT.QLOWCS).AND.(NEWQIN.EQ.1)) THEN 
cim      IF (QOUTCS .GT. QLOWCS) GO TO 965 
cim      RAT = 1.0 
cim      IF (QINCS .GT. 0.01) RAT = QOUTCS / QINCS 
cim      IF (RAT .GT. TOLCS1 .OR. RAT .LT. TOLCS2) GO TO 965 
      DELTFLOW = ABS(QOUTCS-QINCS) 
c      IF (DELTFLOW.LT.ABS(TOLCS1*QINCS)) NOROUT = 1 
      IF (DELTFLOW.GT.ABS(TOLCS1*QINCS)) then 
c   this is case where outflow differs from inflow 
           NOROUT = 0 
           EQUALINOUTO = EQUALINOUT 
           EQUALINOUT = .FALSE. 
           ELSE 
           EQUALINOUTO = EQUALINOUT 
           EQUALINOUT = .TRUE. 
           END IF 
c     WRITE(N6,*) 'TRANSX2',QOUTCS, QINCS, DELTFLOW, NOROUT 
cim      NOROUT = 1 
c     ENDIF 
c     IF (NOROUT.EQ.1) Then 
      IF ((NOROUTO.EQ.1).AND.(NOROUT.EQ.0)) THEN 
C  PROGRAM GOES TO NONSTEADY STATE CONDITIONS 
Cwch (Mitch Heineman), 7/20/04. Add checks for optional no-print  
C     of status. 
C      CALL SSSTATUS(1) 
           IF(TOLCS1.GE.0) CALL SSSTATUS(1) 
           ENDIF 
      IF ((NOROUTO.EQ.0).AND.(NOROUT.EQ.1)) THEN 
C  PROGRAM GOES TO NONSTEADY STATE CONDITIONS 
Cwch, 7/20/04 
           IF(TOLCS1.GE.0) CALL SSSTATUS(4) 
C  Reset everything to initial conditions here 
           IF(NREDO.GT.0 .AND. KREDO.GT.0) THEN 
                REWIND NREDO 
                READ(NREDO,ERR=8888,END=8888) MTL,NJJ,NPP 
                READ(NREDO,ERR=8888) (Q(N),N=1,MTL),(QO(N),N=1,MTL) 
                READ(NREDO,ERR=8888) (V(N),N=1,MTL),(VT(N),N=1,MTL) 
                READ(NREDO,ERR=8888) (A(N),N=1,MTL),(AT(N),N=1,MTL) 
                READ(NREDO,ERR=8888) (ASFULL(N),N=1,NJJ) 
                READ(NREDO,ERR=8888) (Y(N),N=1,NJJ),(YT(N),N=1,NJJ) 
              READ(NREDO,ERR=8888) (VWELL(N),N=1,NPP),(JPFUL(N),N=1,NPP) 
                DO 962 N   = 1,NTC 
                NL        = NJUNC(N,1) 
                NH        = NJUNC(N,2) 
                H(N,1)    = AMAX1(Y(NL) + Z(NL),ZU(N)) 
                H(N,2)    = AMAX1(Y(NH) + Z(NH),ZD(N)) 
 962            CONTINUE 
                ENDIF 
           ENDIF 
      IF (NOROUT.EQ.0) THEN 
           DO 963 J = 1, NJ 
           YO(J) = Y(J) 
  963      CONTINUE 
           DO 967 N = 1, NTL 
cim this should be N not J 
cim   QO(J) = Q(J) 
           QO(N) = Q(N) 
cim  I think that this next line is needed but will leave in for now 
           QOUT(N) = Q(N) 
 967       CONTINUE 
           ENDIF 
 965  CONTINUE 
C --- 
            ENDIF 
C======================================================================= 
C     Write output interface file. 
C======================================================================= 
      IF(NEXT.GT.0) WRITE(NEXT) JULDAY,TIMDAY,DELT,(QOUT(N),N=1,MJSW) 
CIM===================================================================== 
C     SAVE AND WRITE FLOWS TO ASCII FILE 
CIM===================================================================== 
      if (noflow.gt.0) CALL WRTFLOW 
cim ===================================================================== 
C     SAVE INTERMEDIATE CONTINUITY RESULTS 
CIM===================================================================== 
      CALL INTERCON(.false.) 
C======================================================================= 
C     Check for normal flow, conduit maximum flow and velocity. 
C======================================================================= 
cim add check for NSTART 
cim change check for NSTART to function IPRNTIT (see end of this file) 
cim   IF(ISOL.LE.1.AND.ICYC.GE.NSTART) THEN 
      IF(ISOL.LE.1.AND.IPRNTIT(ICYC).EQ.1) THEN 
C####      IF(ISOL.LE.1) THEN 
      DO 902 N = 1,NTL 
      IF(N.LE.NTC.AND.ICHECK(N).EQ.IND(2)) SUPLEN(N) = SUPLEN(N) + DELT 
C #### RHF 8/14/96 
      IF (NOROUT.EQ.1) GO TO 901 
C ---- 
      IF(ABS(Q(N)).GT.ABS(QMAXX(N))) THEN 
                                     QMAXX(N) = Q(N) 
                                     IQHR(N)  = IFIX(TIME/3600.0) 
                                     IQMIN(N) = MINUTE 
                                     ENDIF 
      IF(MTIME.GT.1.AND.ABS(V(N)).GT.ABS(VMAXX(N))) THEN 
                                     VMAXX(N) = V(N) 
                                     IVHR(N)  = IFIX(TIME/3600.0) 
                                     IVMIN(N) = MINUTE 
                                     ENDIF 
C #### RHF 8/14/96 
  901 CONTINUE 
C ---- 
      IF(N.LE.NTC) THEN 
                   IF(H(N,1).GT.PMAX(N,1)) PMAX(N,1) = H(N,1) 
                   IF(H(N,2).GT.PMAX(N,2)) PMAX(N,2) = H(N,2) 
cim speed can do away with these four ifs 
                  CTIME(N,link(n))   = CTIME(n,link(n)) + DELT 
cim                   IF(LINK(N).EQ.'DR1') CTIME(N,1) = CTIME(N,1) + DELT 
cim                   IF(LINK(N).EQ.'SUB') CTIME(N,2) = CTIME(N,2) + DELT 
cim                   IF(LINK(N).EQ.'CR1') CTIME(N,3) = CTIME(N,3) + DELT 
cim                   IF(LINK(N).EQ.'CR2') CTIME(N,4) = CTIME(N,4) + DELT 
                   ENDIF 
  902 CONTINUE 
      ENDIF 
C======================================================================= 
C     Check for surcharge and maximum depth at junctions. 
C======================================================================= 
cim include check for nstart 
cim change from check to nstart to function IPRNTIT 
c      IF(ISOL.LE.1.AND.ICYC.GE.NSTART) THEN 
      IF(ISOL.LE.1.AND.IPRNTIT(ICYC).EQ.1) THEN 
C####      IF(ISOL.LE.1) THEN 
      DO 906 J = 1,NJ 
      IF((Z(J)+Y(J)).GT.ZCROWN(J)) SURLEN(J) = SURLEN(J)+DELT 
C ### RHF 12/23/96 
      IF (NOROUT.EQ.1) GO TO 906 
C --- 
C###### WCH, 7/14/93, BASED ON CDM MEMO FROM CHUCK MOORE, 6/25/93. 
C       ALTER CHECK FOR EQUALITY OF DEPTH TO GROUND - INVERT. 
C###### 
C     HERE USE SURELEV IN PLACE OF GRELEV 
      IF((Z(J)+Y(J)).GE.SURELEV(J)-0.000001) 
     *                             FLDLEN(J) = FLDLEN(J)+DELT 
      IF(AS(J).GT.ASMAXX(J))       ASMAXX(J) = AS(J) 
      IF(Y(J).GT.DEPMAX(J)) THEN 
                            DEPMAX(J) = Y(J) 
                            IDHR(J)   = IFIX(TIME/3600.0) 
                            IDMIN(J)  = MINUTE 
                            ENDIF 
  906 CONTINUE 
CIM### 9/8/00 
C======================================================================= 
C     Compute junction elevation statistics 
C======================================================================= 
      CALL COMPTHRESH 
CIM### 9/8/00 
      ENDIF 
CIM  CALL WASPCOMP TO COMPUTE AVERAGE FLOWS 
CIM  AND WRITE RESULTS AS NECESSARY  5/99 
      CALL WASPCOMP 
CIM 
CIM   TRANAID START 
c....................................................................... 
c       Update and write out hydraulics data 
c....................................................................... 
	if (idump .gt. 0) then 
		if (time/3600 .ge. hydstr) then 
c.....  Add flows to sum-flow array 
		ihyd = ihyd + 1 
		do n=1,ntl 
                qsum(n) = qsum(n) + 0.5*(q(n)+qo(n)) 
                qisum(n) = qisum(n) + qin(n) 
                end do 
cim test write 
c                write(n6,*) ihyd,ihydwr 
c.....  Check to see if it's time to write out information 
			if (ihyd .eq. ihydwr) then 
			IF (LVCALC) call volume(vsys,LVCALC) 
cim note time is not double precision in this program, convert to raytime which is 
                        raytime = time/3600. 
			write(20) raytime 
			write(20) (qsum(n)/float(ihydwr),n=1,ntl) 
			write(20) (a(n),n=1,ntl) 
			write(20) (r(n),n=1,ntl) 
			write(20) (vol(j),j=1,nj) 
                        write(20) (qisum(n)/float(ihydwr),n=1,nj) 
			write(20) ((y(j)+z(j)),j=1,nj) 
			do n=1,ntl 
			qsum(n) = 0.0 
                        qisum(n) = 0.0 
			end do 
			ihyd = 0 
			end if 
		end if 
	end if 
CIM  TRANAID END 
C======================================================================= 
C     Check intermediate printout requirements. 
C======================================================================= 
C 
CIM change check for NSTART to FUNCTION IPRNTIT 
cim      IF(MOD(ICYC,INTER).EQ.0.AND.ICYC.GE.NSTART) THEN 
      IF(MOD(ICYC,INTER).EQ.0.AND.IPRNTIT(ICYC).EQ.1) THEN 
C  here call ASCOUT 
      IF (IASCII.NE.0) THEN 
         CALL ASCOUT(2) 
         ELSE 
         TMIN   = FLOAT(MINUTE) + FLOAT(JSEC)/60.0 
         KHR    = IFIX(TIME/3600.0) 
         IF(IT.LE.0.OR.ISOL.GE.2) THEN 
                     WRITE(N6,1499) ICYC,KHR,TMIN 
                     ELSE 
                     WRITE(N6,1500) ICYC,KHR,TMIN,ERROR,IT 
                     ENDIF 
         WRITE(N6,1501) 
CIM 1/99 Write 10 digits and characters 
CIM THESE ARE ORIGINAL FORMATS 
         IF (JP10.EQ.0) THEN 
            IF(JCE.EQ.0) THEN 
                      WRITE(N6,1502) (JUN(J),Y(J),JCHECK(J), 
     +                                Y(J)+Z(J),J=1,NJ) 
            ELSE 
                      WRITE(N6,1512) (AJUN(J),Y(J),JCHECK(J), 
     +                                Y(J)+Z(J),J=1,NJ) 
            ENDIF 
         WRITE(N6,1503) 
             IF(JCE.EQ.0) THEN 
                      WRITE(N6,1505) (NCOND(N),Q(N),ICHECK(N),N=1,NTL) 
             ELSE 
                      WRITE(N6,1515) (ACOND(N),Q(N),ICHECK(N),N=1,NTL) 
             ENDIF 
         ELSE 
CIM THIS ARE REVISED FORMATS 
            IF(JCE.EQ.0) THEN 
                      WRITE(N6,61502) (JUN(J),Y(J),JCHECK(J), 
     +                                Y(J)+Z(J),J=1,NJ) 
            ELSE 
                      WRITE(N6,61512) (AJUN(J),Y(J),JCHECK(J), 
     +                                Y(J)+Z(J),J=1,NJ) 
            ENDIF 
         WRITE(N6,1503) 
             IF(JCE.EQ.0) THEN 
                      WRITE(N6,61505) (NCOND(N),Q(N),ICHECK(N),N=1,NTL) 
             ELSE 
                      WRITE(N6,61515) (ACOND(N),Q(N),ICHECK(N),N=1,NTL) 
             ENDIF 
         ENDIF 
         DO 570 J = 1,NJ 
C###### WCH 7/14/93, BASED ON CDM MEMO FROM CHUCK MOORE, 6/25/93 
C       ALTER CHECK FOR EQUALITY OF DEPTH TO GROUND - INVERT 
C###### 
C     HERE USE SURELEV IN PLACE OF GRELEV 
         IF(ABS(Y(J)-(SURELEV(J)-Z(J))).LE.0.000001) THEN 
cim 1/99 option to print 10 characters 
         IF(JP10.EQ.0) THEN 
CIM THESE ARE ORIGINAL FORMATS 
         IF(JCE.EQ.0) THEN 
         IF(METRIC.EQ.1)WRITE(N6,514) JUN(J),QOU(J),SUMQS(J),TIME/3600. 
         IF(METRIC.EQ.2)WRITE(N6,515) JUN(J),QOU(J),SUMQS(J),TIME/3600. 
         ELSE 
         IF(METRIC.EQ.1)WRITE(N6,524)AJUN(J),QOU(J),SUMQS(J),TIME/3600. 
         IF(METRIC.EQ.2)WRITE(N6,525)AJUN(J),QOU(J),SUMQS(J),TIME/3600. 
         ENDIF 
         ELSE 
CIM THESE ARE REVISED FORMATS 
         IF(JCE.EQ.0) THEN 
         IF(METRIC.EQ.1)WRITE(N6,6514)JUN(J),QOU(J),SUMQS(J),TIME/3600. 
         IF(METRIC.EQ.2)WRITE(N6,6515)JUN(J),QOU(J),SUMQS(J),TIME/3600. 
         ELSE 
        IF(METRIC.EQ.1)WRITE(N6,6524)AJUN(J),QOU(J),SUMQS(J),TIME/3600. 
        IF(METRIC.EQ.2)WRITE(N6,6525)AJUN(J),QOU(J),SUMQS(J),TIME/3600. 
         ENDIF 
         ENDIF 
         ENDIF 
  570    CONTINUE 
         ENDIF 
         ENDIF 
C####################################################################### 
C     Store HGL, flow and velocity for printout in Subroutine Output. 
C####################################################################### 
      IF(MOD(MTIME,JNTER).EQ.0) THEN 
      LTIME         = LTIME + 1 
      IF(NHPRT.GT.0) THEN 
                     DO 600    I   = 1,NHPRT 
                     J             = JPRT(I) 
                     PRTY(I)       = Y(J) 
  600                PRTH(I)       = Y(J) + Z(J) 
                     ENDIF 
C####################################################################### 
      IF(NQPRT.GT.0) THEN 
                     DO 620 I      = 1,NQPRT 
                     L             = CPRT(I) 
                     PRTQ(I)       = Q(L) 
  620                PRTV(I)       = V(L) 
                     ENDIF 
C####################################################################### 
C     Save water surface slope. 
C####################################################################### 
      IF(NSURF.GT.0) THEN 
                     DO 630 I      = 1,NSURF 
                     L             = JSURF(I) 
                     PSF(I,1)      = H(L,1) 
  630                PSF(I,2)      = H(L,2) 
                     ENDIF 
C####################################################################### 
C     Write NOUT scratch file every JNTER times. 
C####################################################################### 
C#### WCH, 11/5/93.  ADD IOSTAT TO OUTPUT. 
cim change nout to sequential unformatted 
      IF(JPRINT.EQ.1) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     +            JSEC,(PRTY(K),PRTH(K),K=1,NHPRT),(PRTQ(J), 
     +             PRTV(J),J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.2) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     +  JSEC,(PRTY(K),PRTH(K),K=1,NHPRT),(PRTQ(J),PRTV(J),J=1,NQPRT) 
      IF(JPRINT.EQ.3) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     +                   JSEC,(PRTY(K),PRTH(K),K=1,NHPRT) 
      IF(JPRINT.EQ.4) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     + JSEC,(PRTY(K),PRTH(K),K=1,NHPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.5) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     + JSEC,(PRTQ(J),PRTV(J),J=1,NQPRT),(PSF(J,1),PSF(J,2),J=1,NSURF) 
      IF(JPRINT.EQ.6) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     +                           JSEC,(PRTQ(J),PRTV(J),J=1,NQPRT) 
      IF(JPRINT.EQ.7) WRITE(NOUT,ERR=8900,IOSTAT=IOS) TIME,MINUTE, 
     +                         JSEC,(PSF(J,1),PSF(J,2),J=1,NSURF) 
      ENDIF 
C####################################################################### 
  640 CONTINUE 
C======================================================================= 
C     Store HGL*flow for printer plot routine, save every MP'th step. 
C======================================================================= 
      TPLT(NPTOT) = TIME/3600.0 
      IF(NPLT.GT.0) THEN 
                    DO 700     N       = 1,NPLT 
                    J                  = JPLT(N) 
  700               YPLT(NPTOT,N)      = Y(J) + Z(J) 
                    ENDIF 
      IF(LPLT.GT.0) THEN 
                    DO 725      N      = 1,LPLT 
                    L                  = KPLT(N) 
  725               QPLT(NPTOT,N)      =  Q(L) 
                    ENDIF 
  750 CONTINUE 
      IF (ICONTER.LT. 2147483647) call intercon(.true.) 
C======================================================================= 
C     Write the final model condition heads and flows. 
C======================================================================= 
      WRITE(N6,1599) TIME/3600.0 
      WRITE(N6,5815) JULDAY,NYEAR,MONTH,NDAY, 
     +               TIMDAY/3600. 
      WRITE(N6,1501) 
cim 1/99 write all 10 digits and characters 
CIM THESE ARE ORIGINAL FORMATS 
      IF(JP10.EQ.0) THEN 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1502) (JUN(J),Y(J),JCHECK(J), 
     +                                 Y(J)+Z(J),J=1,NJ) 
          ELSE 
                   WRITE(N6,1512) (AJUN(J),Y(J),JCHECK(J), 
     +                                  Y(J)+Z(J),J=1,NJ) 
          ENDIF 
      WRITE(N6,1503) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1505) (NCOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ELSE 
                   WRITE(N6,1515) (ACOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ENDIF 
      ELSE 
CIM THESE ARE REVISED FORMATS 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1502) (JUN(J),Y(J),JCHECK(J), 
     +                                 Y(J)+Z(J),J=1,NJ) 
          ELSE 
                   WRITE(N6,1512) (AJUN(J),Y(J),JCHECK(J), 
     +                                  Y(J)+Z(J),J=1,NJ) 
          ENDIF 
      WRITE(N6,1503) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61505) (NCOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ELSE 
                   WRITE(N6,61515) (ACOND(N),Q(N),ICHECK(N),N=1,NTL) 
          ENDIF 
      ENDIF 
C======================================================================= 
C     Compute water volume left in storage. 
CIM   TRANAID START 
CIM  NOTE THIS IS MOVED TO VOLUME SUBROUTINE 
      CALL VOLUME(VLEFT,LVCALC) 
CIM TRANAID END 
C======================================================================= 
C   call ASCOUT for last time 
      IF (IASCII.NE.0) CALL ASCOUT(3) 
C======================================================================= 
C     Save ending information on file NREDO. 
C======================================================================= 
      IF(NREDO.GT.0.AND.JREDO.GE.2) THEN 
               REWIND NREDO 
               WRITE(N6,2200) 
               WRITE(NREDO,ERR=8889) NTL,NJ,NPUMP 
               WRITE(NREDO,ERR=8889) (Q(N),N=1,NTL),(QO(N),N=1,NTL) 
               WRITE(NREDO,ERR=8889) (V(N),N=1,NTL),(VT(N),N=1,NTL) 
               WRITE(NREDO,ERR=8889) (A(N),N=1,NTL),(AT(N),N=1,NTL) 
               WRITE(NREDO,ERR=8889) (ASFULL(N),N=1,NJ) 
               WRITE(NREDO,ERR=8889) (Y(N),N=1,NJ),(YT(N),N=1,NJ) 
               WRITE(NREDO,ERR=8889) (VWELL(N),N=1,NPUMP), 
     +                               (JPFUL(N),N=1,NPUMP) 
               ENDIF 
C======================================================================= 
C     Volume remaining in conduit with tide gate not included in VLEFT. 
C     THIS IS MOVED TO VOLUME.FOR CALLED ABOVE 
C     LEAVE LOOP HERE IN CASE NEED UPDATES TO A,V, LINK, h ETC 
C======================================================================= 
      DO 840 N = 1,NTC 
      NL       = NJUNC(N,1) 
      NH       = NJUNC(N,2) 
C     IF(NKLASS(N).GE.9) GO TO 840 
        H(N,1)    = AMAX1(Y(NL) + Z(NL),ZU(N)) 
        H(N,2)    = AMAX1(Y(NH) + Z(NH),ZD(N)) 
      CALL NHEAD(N,NL,NH,H(N,1),H(N,2),Q(N),A(N),V(N),HRAD,ANH,ANL, 
     +                                      RNL,RNH,IDOIT,LINK(N),AS) 
CIM TRANAID START 
CIM  Hydraulic radius is saved in R() array in VOLUME 
CIM      ASFULL(N) = HRAD 
CIM TRANAID END 
      QO(N)     = A(N)*LEN(N) 
      IF(NGATE.GT.0) THEN 
                     DO 845 I = 1,NGATE 
                     IF(JGATE(I).EQ.NH.OR.JGATE(I).EQ.NL) GO TO 840 
  845                CONTINUE 
                     ENDIF 
CIM  TRANAID START 
CIM  volume calcs now in subroutine VOLUME 
CIM      VLEFT     = VLEFT + 0.5*(ANH + ANL)*LEN(N) 
CIM  TRANAID END 
  840 CONTINUE 
C======================================================================= 
C     Write further final condition information. 
C======================================================================= 
CIM 1/99 WRITE ALL 10 DIGITS AND CHARACTERS 
      IF (JP10.EQ.0) THEN 
CIM THESE ARE ORIGINAL FORMATS 
      WRITE(N6,1506) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),V(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),V(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1507) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),A(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),A(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1527) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),QO(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),QO(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1508) 
CIM TRANAID START 
CIM NOTE THAT R ARRAY NOW HAS HYDRAULIC RADIUS SET IN VOLUME. 
CIM CHANGE ASFULL TO R IN FOLLOWING LINES 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1514) (NCOND(N),R(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,1516) (ACOND(N),R(N),N=1,NTC) 
          ENDIF 
CIM TRANAID END 
      WRITE(N6,1509) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,1517) (NCOND(N),H(N,1),H(N,2),N=1,NTC) 
          ELSE 
                   WRITE(N6,1518) (ACOND(N),H(N,1),H(N,2),N=1,NTC) 
          ENDIF 
      ELSE 
CIM THESE ARE REVISED WRITE STATEMENTS 
      WRITE(N6,1506) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),V(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),V(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1507) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),A(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),A(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1527) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),QO(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),QO(N),N=1,NTC) 
          ENDIF 
      WRITE(N6,1508) 
CIM TRANAID START 
CIM NOTE THAT R ARRAY NOW HAS HYDRAULIC RADIUS SET IN VOLUME. 
CIM CHANGE ASFULL TO R IN FOLLOWING LINES 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61514) (NCOND(N),R(N),N=1,NTC) 
          ELSE 
                   WRITE(N6,61516) (ACOND(N),R(N),N=1,NTC) 
          ENDIF 
CIM TRANAID END 
      WRITE(N6,1509) 
          IF(JCE.EQ.0) THEN 
                   WRITE(N6,61517) (NCOND(N),H(N,1),H(N,2),N=1,NTC) 
          ELSE 
                   WRITE(N6,61518) (ACOND(N),H(N,1),H(N,2),N=1,NTC) 
          ENDIF 
      ENDIF 
C======================================================================= 
C     Call print and plot subroutine (OUTPUT). 
C======================================================================= 
      IF(ISOL.LE.1) THEN 
      ITT    = ITTOTL - 2*NTCYC 
      DENOM  = FLOAT(NTCYC) 
      AVGIT  = FLOAT(ITTOTL)/DENOM 
      IF(METRIC.EQ.1) WRITE(N6,1600)ITMXXX,ITTOTL,AVGIT,ITT,SUMERR,NTCYC 
      IF(METRIC.EQ.2) WRITE(N6,1605)ITMXXX,ITTOTL,AVGIT,ITT,SUMERR,NTCYC 
      WRITE(N6,1620) 
      IF(JCE.EQ.0) THEN 
	   WRITE(N6,1621) (NCOND(N),BADMAX(N)/60.0,N=1,NTC) 
	ELSE 
         WRITE(N6,1622) (ACOND(N),BADMAX(N)/60.0,N=1,NTC) 
	ENDIF 
      WRITE(N6,1625) 
      IF(JCE.EQ.0) THEN 
	   WRITE(N6,1621) (NCOND(N),BADTIM(N)/DENOM,N=1,NTC) 
	ELSE 
         WRITE(N6,1622) (ACOND(N),BADTIM(N)/DENOM,N=1,NTC) 
	ENDIF 
      ELSE 
      DENOM   = FLOAT(NTCYC) 
      WENOM   = FLOAT(JTIME) 
      AVGIT   = FLOAT(ITTOTL)/WENOM 
      ARAT    = WENOM/DENOM 
      AVGSIZ  = DENOM*RDELT/WENOM 
      AFACT   = AFACT/WENOM 
      WRITE(N6,1606) ITMXXX,ITTOTL,SUMERR,JTIME,ARAT,AVGIT, 
     +               AVGSIZ,YOOMIN,YOOMAX,ITURN,AFACT 
      WRITE(N6,1620) 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,1621) (NCOND(N),BADMAX(N)/60.0,N=1,NTC) 
	ELSE 
          WRITE(N6,1622) (ACOND(N),BADMAX(N)/60.0,N=1,NTC) 
	ENDIF 
      WRITE(N6,1625) 
      IF(JCE.EQ.0) THEN 
	    WRITE(N6,1621) (NCOND(N),BADTIM(N)/WENOM,N=1,NTC) 
	ELSE 
          WRITE(N6,1622) (ACOND(N),BADTIM(N)/WENOM,N=1,NTC) 
	ENDIF 
      ENDIF 
C ### RHF 10/16/96 
      IF (ISOLSKIP.EQ.1) write(n6,8700)NTIMCS,QMINCS,QMOUCS 
 8700 FORMAT(/,' NUMBER OF DYNAMIC ROUTING TIME STEPS (NTIMCS):',I11,/, 
     +' MINIMUM TOTAL INFLOW  = ',f10.3,'CFS',/, 
     +' MINIMUM TOTAL OUTFLOW = ',f10.3,'CFS',/) 
C --- 
      RETURN 
C======================================================================= 
C#### WCH, 11/5/93.  ALSO WRITE TO THE SCREEN AND ADD IOSTAT TO 8905. 
 8888 WRITE(N6,8885) 
      WRITE(*,8885) 
      STOP 
 8889 WRITE(N6,8886) 
      WRITE(*,8886) 
      STOP 
C#### WCH, 8/4/95.  ALTER IOSTAT FOR LAHEY. 
 8900 WRITE(N6,8905) MOD(IOS,256) 
      WRITE(*,8905)  MOD(IOS,256) 
      STOP 
C======================================================================= 
cim change format to avoid stars for very long runs  4/30/97 
cim   21 FORMAT('+',6X,I5,9X,3I9,1X,2(A8,F7.3)) 
cim   22 FORMAT('+',6X,I5,9X,3I9,1X,2(I8,F7.3)) 
   21 FORMAT('+',I10,I10,2I4,2(1X,A10,F7.3),2I2,I10) 
   22 FORMAT('+',I10,I10,2I4,2(1X,I10,F7.3),2I2,I10) 
   23 FORMAT(/ 
     +' ************************************************************',/, 
     +' * STEP ==>  Time step                                      *',/, 
     +' * ITER ==>  # of iterations (including surcharge)          *',/, 
     +' *  NRM ==>  # of conduits using normal flow equation       *',/, 
     +' *   SJ ==>  # of surcharged junctions.                     *',/, 
     +' * COND ==>  # conduit with the greatest flow change        *',/, 
     +' *             ( Q(n+1) - Q(n) ) / Qfull = QMAX             *',/, 
     +' * JUNC ==>  # junction with the greatest depth change      *',/, 
     +' *             ( Y(n+1) - Y(n) ) / Yfull = YMAX             *') 
 923  FORMAT( 
     +' *   I1 ==>  = 1 when steady state conditions (ISOL 4)      *',/, 
     +' *   I2 ==>  = 1 when inflows are steady                    *',/, 
     +' * CALL ==>  Number of calls to routing subroutines         *') 
 924  FORMAT( 
     +' ************************************************************',/) 
   24 FORMAT( 
     +' TOTAL # OF JUNCTIONS ==> ',I5,/ 
     +' TOTAL # OF CONDUITS  ==> ',I5,//, 
     +' BEGINNING LOOP THRU ',I11,' TIME STEPS',/) 
   27 FORMAT( 
     +6X,'STEP',6X,'ITER',1X,'NRM',2X,'SJ',7X,'COND',3X,'QMAX',7X, 
     +'JUNC',3X,'YMAX',/) 
   28 FORMAT( 
     +6X,'STEP',6X,'ITER',1X,'NRM',2X,'SJ',7X,'COND',3X,'QMAX',7X, 
     +'JUNC',3X,'YMAX','I1I2',6X,'CALL',/) 
  514 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',I9,1PE10.2, 
     +         ' CU.FT.  FLOOD FLOW =  ',0PF10.1,' CFS AT HOUR ',F6.2) 
  515 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',I9,1PE10.2, 
     +         ' CU.MET.  FLOOD FLOW =  ',0PF10.1,' CMS AT HOUR ',F6.2) 
  524 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',A9,1PE10.2, 
     +         ' CU.FT.  FLOOD FLOW =  ',0PF10.1,' CFS AT HOUR ',F6.2) 
  525 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',A9,1PE10.2, 
     +         ' CU.MET.  FLOOD FLOW =  ',0PF10.1,' CMS AT HOUR ',F6.2) 
cim 1/99  print all 10 characters 
 6514 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',I10,1X,1PE10.2, 
     +         ' CU.FT.  FLOOD FLOW =  ',0PF10.1,' CFS AT HOUR ',F6.2) 
 6515 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',I10,1X,1PE10.2, 
     +         ' CU.MET.  FLOOD FLOW =  ',0PF10.1,' CMS AT HOUR ',F6.2) 
 6524 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',A10,1X,1PE10.2, 
     +         ' CU.FT.  FLOOD FLOW =  ',0PF10.1,' CFS AT HOUR ',F6.2) 
 6525 FORMAT(/,' CUMULATIVE OVERFLOW VOLUME FROM NODE ',A10,1X,1PE10.2, 
     +         ' CU.MET.  FLOOD FLOW =  ',0PF10.1,' CMS AT HOUR ',F6.2) 
cim  change to avoid stars on long simulations 
cim 1499 FORMAT(/,1X,'CYCLE ',I5,6X,'TIME ',I4,' HRS - ',F5.2,' MIN') 
cim 1500 FORMAT(/,1X,'CYCLE ',I5,6X,'TIME ',I4,' HRS - ',F5.2, 
 1499 FORMAT(/,1X,'CYCLE ',I10,1X,'TIME ',I4,' HRS - ',F5.2,' MIN') 
 1500 FORMAT(/,1X,'CYCLE ',I10,1X,'TIME ',I4,' HRS - ',F5.2, 
     *' MIN  FLOW DIFFERENTIAL IN SURCHARGED AREA = ',F6.2, 
     *'CFS  ITERATIONS REQUIRED = ',I3,/) 
 1501 FORMAT(/,' JUNCTION / DEPTH  / ELEVATION ', 
     +         '   ===>  "*" JUNCTION IS SURCHARGED.') 
 1502 FORMAT(3(I10,'/',F7.2,A1,'/',F9.2)) 
61502 FORMAT(3(1X,I10,'/',F7.2,A1,'/',F9.2)) 
 1503 FORMAT(/,'   CONDUIT/       FLOW', 
     +         '   ===> "*" CONDUIT USES THE NORMAL FLOW OPTION.') 
 1505 FORMAT(4(I10,'/',F11.2,A1)) 
61505 FORMAT(4(1X,I10,'/',F11.2,A1)) 
 1506 FORMAT(/,'   CONDUIT/   VELOCITY') 
 1507 FORMAT(/,'   CONDUIT/ CROSS SECTIONAL AREA') 
 1508 FORMAT(/,'   CONDUIT/ HYDRAULIC RADIUS') 
 1509 FORMAT(/,'   CONDUIT/ UPSTREAM/ DOWNSTREAM ELEVATION') 
 1512 FORMAT(3(1X,A9,'/',F7.2,A1,'/',F9.2)) 
61512 FORMAT(3(1X,A10,'/',F7.2,A1,'/',F9.2)) 
 1514 FORMAT(4(I10,'/',F11.2,1X)) 
61514 FORMAT(4(1X,I10,'/',F11.2,1X)) 
 1515 FORMAT(4(1X,A9,'/',F11.2,A1)) 
61515 FORMAT(4(1X,A10,'/',F11.2,A1)) 
 1516 FORMAT(4(1X,A9,'/',F11.2,1X)) 
61516 FORMAT(4(1X,A10,'/',F11.2,1X)) 
 1517 FORMAT(3(I10,'/',F9.2,'/',F9.2)) 
61517 FORMAT(3(1X,I10,'/',F9.2,'/',F9.2)) 
 1518 FORMAT(3(1X,A9,'/',F9.2,'/',F9.2)) 
61518 FORMAT(3(1X,A10,'/',F9.2,'/',F9.2)) 
 1527 FORMAT(/,'   CONDUIT/  FINAL VOLUME ') 
 1598 FORMAT(/, 
     +' ***********************************',/, 
     +' *    INITIAL MODEL CONDITION      *',/, 
     +' * INITIAL TIME = ',F9.2,' HOURS  *',/, 
     +' ***********************************') 
 1599 FORMAT(/, 
     +' *********************************',/, 
     +' *     FINAL MODEL CONDITION     *',/, 
     +' *  FINAL TIME = ',F9.2,' HOURS *',/, 
     +' *********************************') 
cim print final date and time 
C#### WCH, 7/25/96. 
 5815 FORMAT(/,' >>> ENDING DATE AND TIME OF EXTRAN RUN ARE:',/, 
     2' JULIAN DATE:',I8,/, 
     3' YR/MO/DA:   ',I4,'/',I2,'/',I2,/, 
     4' TIME OF DAY:',F7.3,' HRS') 
c 
 1600 FORMAT(///, 
     +' ###################################################',/, 
     +' #           Surcharge Iteration Summary           #',/, 
     +' ###################################################',//, 
     +' Maximum number of iterations in a time step.....',I9,/, 
cim change format to avoid stars for very long runs  4/30/97 
     +' Total number of iterations in the simulation..',I11,/, 
     +' Average number of iterations per time step......',F9.2,/, 
     +' Surcharge iterations during the simulation......',I9,/, 
     +' Maximum surcharge flow error during simulation..',1PE9.2,' cfs', 
cim change format to avoid stars for very long runs  4/30/97 
     +/,' Total number of time steps during simulation..',I11,/) 
 1605 FORMAT(///, 
     +' ###################################################',/, 
     +' #           Surcharge Iteration Summary           #',/, 
     +' ###################################################',//, 
     +' Maximum number of iterations in a time step.....',I9,/, 
cim change format to avoid stars for very long runs  4/30/97 
     +' Total number of iterations in the simulation..',I11,/, 
     +' Average number of iterations per time step......',F9.2,/, 
     +' Surcharge iterations during the simulation......',I9,/, 
     +' Maximum surcharge flow error during simulation..',1PE9.2,' cms', 
cim change format to avoid stars for very long runs  4/30/97 
     +/,' Total number of time steps during simulation..',I11,/) 
 1606 FORMAT(///, 
     +' ####################################################',/, 
     +' #             Extran Iteration Summary             #',/, 
     +' ####################################################',//, 
     +' Maximum number of iterations in a time step.....',I9,/, 
cim change format to avoid stars for very long runs  4/30/97 
     +' Total number of iterations in the simulation..',I11,/, 
     +' Maximum continuity error during simulation......',F9.4, 
     +' fraction',/, 
cim change format to avoid stars for very long runs  4/30/97 
     +' Total number of time steps during simulation..',I11,/, 
     +' Ratio of actual # of time steps / NTCYC.........',F9.1,/, 
     +' Average number of iterations per time step......',F9.2,/, 
     +' Average  time step size(seconds)................',F9.2,/, 
     +' Smallest time step size(seconds)................',F9.1,/, 
     +' Largest  time step size(seconds)................',F9.1,/, 
     +' Number of times ITMAX exceeded..................',I9,/, 
     +' Average Courant Factor Tf.......................',F9.2) 
 1620 FORMAT(/,1H1,/, 
     +' ***************************************************',/, 
     +' *         CONDUIT COURANT CONDITION SUMMARY       *',/, 
     +' * TIME IN MINUTES DELT > COURANT TIME STEP        *',/, 
     +' ***************************************************',/, 
     +' * SEE BELOW FOR EXPLANATION OF COURANT TIME STEP. *',/, 
     +' ***************************************************',//, 
     +'  CONDUIT #  TIME(MN)  CONDUIT #  TIME(MN)  CONDUIT #  TIME(MN) 
     +CONDUIT #  TIME(MN)',/, 
     +'  ---------  --------  ---------  --------  ---------  -------- 
     +---------  --------') 
 1621 FORMAT(4(1X,I10,F10.2)) 
 1622 FORMAT(4(1X,A10,F10.2)) 
 1625 FORMAT(/,1H1,/, 
     +' ************************************************',/, 
     +' *         CONDUIT COURANT CONDITION SUMMARY    *',/, 
     +' ************************************************',/, 
     +' * COURANT   =            CONDUIT LENGTH        *',/, 
     +' * TIME STEP = -------------------------------- *',/, 
     +' *             VELOCITY + SQRT(GRVT*AREA/WIDTH) *',/, 
     +' ************************************************',/, 
     +' * AVERAGE COURANT CONDITION TIME STEP(SECONDS) *',/, 
     +' ************************************************',//, 
     +'  CONDUIT # TIME(SEC)  CONDUIT # TIME(SEC)  CONDUIT # TIME(SEC) 
     +CONDUIT # TIME(SEC)',/, 
     +'  ---------  --------  ---------  --------  ---------  -------- 
     +---------  --------') 
 2100 FORMAT(/, 
     +' *****************************************************',/, 
     +' *        READING HOT START FILE ON NSCRAT(2)        *',/, 
     +' * SEE INITIAL MODEL CONDITIONS FOR HOT START VALUES *',/, 
     +' *****************************************************',/) 
 2200 FORMAT(/, 
     +' ***************************************************',/, 
     +' *      WRITING HOT START FILE ON NSCRAT(2)        *',/, 
     +' * SEE FINAL MODEL CONDITIONS FOR HOT START VALUES *',/, 
     +' ***************************************************',/) 
cim 7000 FORMAT(200(I10,1X)) 
cim 7010 FORMAT(200(A10,1X)) 
cim 7020 FORMAT(E12.5,2I7,200(E12.5,1X)) 
 8885 FORMAT(/,' ===> Error  Reading the Hot-start file.',/, 
     +         '               Usual cause - empty file.',/) 
 8886 FORMAT(/,' ===> Error  Writing the Hot-start file.',/, 
     +'               Usual cause - Unformatted record length problem', 
     +/,'               use the /R DOS option to extend the unformatted 
     +record length.',/) 
 8905 FORMAT(/,' ===> Error  Writing NSCRAT(1) file.',/, 
     1 ' Fortran error no. =',I5,'. A common cause is that you',/, 
     2 ' have run out of space on your hard disk needed by this',/, 
     3 ' voluminous scratch file.  Run stopped from Extran.',/) 
C#### WCH, 1/22/97. 
 9400 FORMAT(/,' WARNING FOR CONDUIT ',I10,', SEQUENCE NO.',I4,/, 
     1 ' QFULL .LE. 0.  DIVIDE BY ZERO ERROR LIKELY IN FUTURE.') 
 9401 FORMAT(/,' WARNING FOR CONDUIT ',A10,', SEQUENCE NO.',I4,/, 
     1 ' QFULL .LE. 0.  DIVIDE BY ZERO ERROR LIKELY IN FUTURE.') 
 9402 FORMAT(' QFULL=',F9.3,' VEL=',F9.3,' RFULL=',F9.3,/, 
     1 ' AFULL=',F9.3,' SLOPE=',F9.4) 
C======================================================================= 
      END 
      FUNCTION IPRNTIT(ICYC) 
C   RETURNS 1 IF IN RANGE OF STARTING AND ENDING OF CURRENT PRINT PERIOD 
      INCLUDE 'BE.INC' 
      IF ((ICYC.GE.IBESTART(IBE)).AND.(ICYC.LE.IBEEND(IBE))) THEN 
      IPRNTIT = 1 
      ELSE 
      IPRNTIT = 0 
      ENDIF 
      RETURN 
      END 
 
REM File: VERSION.FOR 
 
      SUBROUTINE VERSION 
C 
C    SUBROUTINE VERSION 
C    CREATE 9/15/97 by 
C       Charles I. Moore 
C       CDM Annandale, Va. 
C 
C    Make it easier to update and trace program version numbers. 
C 
      INCLUDE 'VERSION.INC' 
CIM VERID IS THE VERSION NUMBER THAT APPEARS IN VARIOUS LOCATIONS 
CIM IS 6 CHARACTER STRING 
      VERID = '4.4H' 
CIM DESTRING IS 45 CHARACTER STRING WITH ADDITIONAL INFORATION 
C                   000000000111111111122222222223333333333444444 
C                   123456789012345678901234567890123456789012345 
      DESTRING(1) ='       CDM/OSU Ongoing Version 4.4h          ' 
      DESTRING(2) ='       Release Date - July 23, 2004          ' 
      DESTRING(3) ='  Camp Dresser & McKee and Oregon St. Univ.  ' 
      DESTRING(4) =' Chuck Moore, Bob Dickinson, and Wayne Huber ' 
C      DESTRING(5) =' Compiled using KAI GUIDE 3.5 Dual Processor ' 
      DESTRING(5) ='  Compiled using Compaq Visual Fortran v.6.6 ' 
      RETURN 
      END 
 
REM File: WSHED.FOR 
 
      SUBROUTINE WSHED(REIN,KWIK) 
C     RUNOFF BLOCK 
C     CALLED BY HYDRO NEAR LINE 349 
C======================================================================= 
C     WSHED last updated December, 1990 by Bob Dickinson 
C     Green-Ampt infiltration option added Feb 79 by Russell G. Mein. 
C 
C     This subroutine computes the instantaneous water depth 
C          and flow rate for the watershed areas. 
C======================================================================= 
C      UPDATED 11/92 BY WCH TO READ EVAP DATA FROM NSCRAT(3) WHEN IVAP=4 
C      UPDATED 3/93 BY RED TO CORRECT FOR RETURNING INFILTRATION FROM 
C        SUBROUTINE GROUND. 
C      UPDATED 8/93 BY CHUCK MOORE, CDM, TO ADD SUBCATCHMENT STATISTICS. 
C      METRIC FIX AND NEW IF-STMT, 9/23/93.  WCH (RED). 
C      OPTION FOR NO EVAPORATION DURING RAINY TIME STEP, WCH (CDM, 
C        CHUCK MOORE), 10/5/93. 
C      CORRECTION FOR MORE THAN ONE AIR TEMPERATURE PER DAY, RED (WCH), 
C        1/31/94. 
C      INITIALIZE VARIABLE  KWIKSN  TO INDICATE PRESENCE OF SNOW IN 
C        ORDER TO USE  WET  TIME STEP, WCH, 4/7/94. 
C      CHANGE LOCATION OF CHECK FOR GROUNDWATER FLOW, WCH, 4/7/94. 
C      CHECK TO SEE IF K=1 CALCS HAVE BEEN MADE FOR USE BY K=3 SUBAREA, 
C        WCH, 5/25/94. 
C      SEVERAL CHANGES TO ALLOW FOR REROUTING OF OVERLAND FLOW  
C        INTERNALLY WITHIN A SUBCATCHMENT AND FROM SUBCATCHMENT TO 
C        SUBCATCHMENT, WCH, 12/20/00. 
C      SAVE RAINFALL + MELT (RFLOW) FOR EACH SUBCATCHMENT FOR SUBCAT TO  
C        SUBCAT FLOWS AND FOR EROSION CALCULATIONS, WCH, 5/8/01.  
C      CHECK FOR ZERO PERV AND IMPERV AREAS DURING OVERLAND FLOW 
C        REROUTING.  WCH, 6/7/01. 
C      FIX METRIC CONVERSION FOR GROUNDWATER, 3/1/02. WCH FROM SANDY 
C        ELLIOT AND BOB DICKINSON.  
C      ADD SUBCAT CONTINUITY SUM FOR RLOSS FOR PERVIOUS AREAS TO ACCOUNT   
C        FOR SUBCAT TO SUBCAT ROUTING AND OTHER FIX. 3/28/02. WCH 
C      STREAMLINE LOSS CALC WHEN SUBCAT GOES DRY. 4/11/02. WCH 
C      ADD FLOW2SUB(J) TO DRY CHECK FOR ALL SUBAREAS. 4/11/02. WCH 
C      ADD ADDITIONAL GROUNDWATER PRINTS PLUS CORRECTIONS. 7/1/03. WCH 
C      DELETE IF STMT THAT SKIPS SOME CONTINUITY SUMMATIONS, 8/8/03, WCH 
C      DOUBLE PRECISION FIX, 7/22/04, WCH.  
C####################################################################### 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'INTER.INC' 
      INCLUDE 'TIMER.INC' 
      INCLUDE 'STIMER.INC' 
      INCLUDE 'DETAIL.INC' 
      INCLUDE 'SUBCAT.INC' 
      INCLUDE 'QUALTY.INC' 
      INCLUDE 'GRWTR.INC' 
C#### C. MOORE, CDM, 8/93 
      INCLUDE 'RUNSTAT.INC' 
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
CIM   MAXINF  C.Moore B. Cunningham CDM 
      INCLUDE 'MAXINF.INC' 
Cwch, 12/20/00 
      INCLUDE 'OVERLAND.INC' 
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
CIM INCREASE HYETOGRAPHS   ~~~~~ 
      DIMENSION IDXSNO(4),TP(NW),REIN(MAXRG) 
CIM      DIMENSION IDXSNO(4),TP(NW),REIN(10) 
CIM  ~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
      DIMENSION GWFLWB(NGW),STPOLL(2,NGW) 
      CHARACTER*3 CTYPE 
      DATA IDXSNO/3,2,3,1/ 
C======================================================================= 
C####################################################################### 
C WCH, 11/92  ADD OPTION FOR IVAP=4 TO READ TEMP BLOCK OUTPUT 
C               FOR EVAPORATION DATA 
C####################################################################### 
      IF((ISNOW.EQ.2.OR.IVAP.EQ.4).AND.MTIME.EQ.1) THEN 
               IF(NSCRAT(3).EQ.0) CALL ERROR(20) 
C### WCH 11/92 
               REWIND NSCRAT(3) 
C### 
               READ(NSCRAT(3)) ISTA 
               WRITE(N6,9200) ISTA 
 5             READ(NSCRAT(3)) JTDAY,TMAX,TMIN,EVAPOR,WINDER 
               JYEAR = JTDAY / 1000 
               IF (JYEAR.LT.100) THEN 
                    JTDAY = JTDAY - JYEAR*1000 
                    JYEAR = JYEAR + 1900 
                    JTDAY = JTDAY + JYEAR*1000 
                    ENDIF 
C#### WCH (RED), 9/93.  METRIC FIX. 
               EVAPOR = EVAPOR/CMET(7,METRIC) 
               TMAX1 = TMAX 
               IF(JTDAY.LT.JULDAY) GO TO 5 
               ENDIF 
C======================================================================= 
      IF(MTIME.EQ.1) THEN 
                     JDREF   = JULDAY - 1 
                     RINE    = 0.0 
                     XSINFL  = 0.0 
                     WINDER  = 0.0 
                     DO 10 N = 1,NW 
   10                TP(N)   = 0.0 
                                    KKK = 3 
                     IF(ISNOW.GE.1) KKK = 4 
                     ENDIF 
C======================================================================= 
      IF(ISNOW.EQ.1) THEN 
                     INDT = (TIME-TZERO)/(DTAIR*3600.0) 
                     IF(INDT.LT.1) INDT = 1 
Cwch, 1/23/04.  Need "end of array" error message here. 
                     IF(INDT.GT.NAIRT) INDT = NAIRT 
                     TA = TAIR(INDT) 
                     ENDIF 
C======================================================================= 
C     Here, compute melt factors for different days. 
C     Assume sinusoidal variation between min on Dec 21 & 
C     Max on June 21.  Compute only when starting a new day. 
C     The number 0.0172615 = PI/182. 
C======================================================================= 
C#################### 
C WCH 11/92  CHANGE TO READ NSCRAT3 FOR EVAP ALONE 
C#################### 
      IF((ISNOW.EQ.2.OR.IVAP.EQ.4).AND.JTDAY.LT.JULDAY) THEN 
               TMAX1 = TMAX 
Cwch, 1/23/04.  Need end of file error message here 
               READ(NSCRAT(3)) JTDAY,TMAX,TMIN,EVAPOR,WINDER 
               JYEAR = JTDAY / 1000 
               IF (JYEAR.LT.100) THEN 
                    JTDAY = JTDAY - JYEAR*1000 
                    JYEAR = JYEAR + 1900 
                    JTDAY = JTDAY + JYEAR*1000 
                    ENDIF 
C#### WCH (RED), 9/93.  METRIC FIX. 
               EVAPOR = EVAPOR/CMET(7,METRIC) 
               ENDIF 
C======================================================================= 
      IF(ISNOW.GT.1.AND.JULDAY.GT.JDREF) THEN 
                     JDREF   = JULDAY 
                     MDAY    = JULDAY - 1000*(JULDAY/1000) 
                     DAYNO   = FLOAT(MDAY) 
                     SEASON  = SIN(0.0172615*(DAYNO-81.0)) 
                     DO 80 N = 1,NOW 
                     DO 80 I = 1,3 
   80                DH(I,N) = DHMAX(I,N)+DHMIN(I,N)*SEASON 
C======================================================================= 
C******** COMPUTE HOUR OF DAY OF SUNRISE AND SUNSET. 
C******** THEN MIN. TEMP. IS ASSUMED TO OCCUR AT SUNRISE. 
C******** MAX. TEMP. IS ASSUMED TO OCCUR AT SUNSET MINUS THREE HOURS. 
C 
C******** COMPUTE EARTH'S DECLINATION. 
C******** THE NUMBER 0.40928 = 23.45 (DEGREES) * PI / 180. 
C******** THE NUMBER 0.017202 = 2 PI / 365. 
C 
C******** COMPUTE THE HOUR ANGLE OF SUNRISE/SUNSET. 
C******** THE NUMBER 3.8197 = 12 / PI. 
C 
C******** COMPUTE HOURLY TEMPERATURE USING SINSUOIDAL INTERPOLATION. 
C======================================================================= 
                     DECL  = 0.40928*COS(0.017202*(172.0-DAYNO)) 
                     HRANG = 3.8197*ACOS(-TAN(DECL)*ANGLAT) 
                     HRSR  = 12.0 - HRANG + DTLONG + 0.5 
                     HRSS  = 12.0 + HRANG + DTLONG - 2.5 
                     DHRDY =  HRSR - HRSS 
                     DYDIF =  24.0 + HRSR - HRSS 
                     HRDAY = (HRSR + HRSS)/2.0 
                     TAVE  = (TMAX + TMIN) / 2.0 
                     TRNG  = (TMAX - TMIN) / 2.0 
                     TRNG1 = (TMAX1 - TMIN) 
                     ENDIF 
C#### RED (WCH), 1/31/94.  SHOULD HAVE ENDIF HERE, OTHERWISE 
C####   ONLY ONE AIR TEMPERATURE PER DAY.  BUT ALSO NEED ADDITIONAL 
C####   IF-STMT HERE TO PERFORM FOLLOWING ONLY FOR ISNOW > 1. 
      IF(ISNOW.GT.1) THEN 
                     HR    = TIMDAY/3600.0 
                     IF(HR.LT.HRSR) TA = TMIN + 
     +                  TRNG1 * SIN(3.14159 / DYDIF * (HRSR - HR)) 
                     IF(HR.GE.HRSR.AND.HR.LE.HRSS) TA = TAVE 
     +                 + TRNG * SIN(3.14159 / DHRDY * (HRDAY - HR)) 
                     IF(HR.GT.HRSS) TA  = TMAX - 
     +                  TRNG * SIN(3.14159 / DYDIF *(HR - HRSS)) 
                     ENDIF 
C======================================================================= 
C     Do prior to main loop for WSHED. 
C======================================================================= 
      RI       = 0.0 
      RIN      = 0.0 
      IF(IVAP.LE.2) EVAP = VAP(MONTH) 
      IF(IVAP.EQ.3) THEN 
                    INDX = 12*(NYEAR - NVAP(1)) + MONTH 
                    IF(INDX.LE.0.OR.INDX.GT.NVAP(2)) CALL ERROR(153) 
                    EVAP = VAP(INDX) 
                    ENDIF 
      IF(IVAP.EQ.4) EVAP = EVAPOR 
                        WINDY  = WINDER 
      IF(WINDER.EQ.0.0) WINDY  = WIND(MONTH) 
      KWIK     = 0 
      KOMPUT   = 0 
C#### WCH, 4/7/94.  USE ONLY VARIABLE KWIKSN FOR SNOW. 
C#### WCH (RED), 9/93.  ADD IF-STMT. 
C####      IF(ISNOW.EQ.1) KWIK = 1 
C#### WCH, 4/7/94.  INITIALIZE SNOW INDICATOR VARIABLE. 
      KWIKSN   = 0 
C======================================================================= 
Cwch, 12/20/00.  Must compute flows from other subcatchments *before* 
C    main loop since WFLOW() set back to zero inside loop. 
C======================================================================= 
C	Check for inflow from another subcatchment(s).  Distribute 
C     uniformly over all subcatchment subareas. 
C======================================================================= 
	IF(ISC2SC.EQ.1) THEN 
		DO 150 J = 1,NOW 
		FLOW2SUB(J) = 0.0 
		DO JJ = 1,NCP 
			IF(NWTOW(JJ,J).EQ.0) GO TO 145 
			JJJ = NWTOW(JJ,J) 
			FLOW2SUB(J) = FLOW2SUB(J) + WFLOW(JJJ) 
			ENDDO 
C  Convert from flow to flow per unit area (ft/sec). 
  145		IF(FLOW2SUB(J).GT.0.0.AND.WAREA(J).GT.0.0)  
     +       FLOW2SUB(J) = FLOW2SUB(J)/WAREA(J) 
  150		CONTINUE 
		ENDIF 
Cwch, 7/1/03. Set up GW output index. 
      LU = 0 
C======================================================================= 
C    Main loop on subcatchments for WSHED calculations.   
C======================================================================= 
      DO 390 J = 1,NOW 
      NGAG     = NHYET(J) 
      RI       = REIN(NGAG)/CMET(4,METRIC) 
      IF(ISNOW.EQ.2.AND.TA.LE.SNOTMP)  RI = -RI * SCF 
      IF(ISNOW.EQ.1.AND.NGAG.GT.1) KOMPUT = 0 
C####################################################################### 
C     WCH (CDM, Chuck Moore), 10/5/93.  If IIVAP > 0 then use zero 
C     evaporation during time steps with precipitation. 
C     IF ABS(IIVAP) = 1 evap is allowed from channels. 
C     IF ABS(IIVAP) = 2 evap is not allowed from channels. 
C     SVAP = evaporation from this subcatchment that will be set to 
C     zero if it is raining or snowing. 
C     GVAP = evaporation from channel surfaces that will be set to 
C     zero if there is rain or snow over any subcatchment. 
C===> NOTE EVAP changed to SVAP from here to end of subroutine (5 
C     locations) and to SVAP or GVAP in subroutines GAMP, HORTON, 
C     GROUND, and GUTTER. 
C####################################################################### 
C#### WCH (CDM), 10/5/93.  NEW PARAMS FOR NO EVAP DURING RAIN. 
      IF(IIVAP.GT.0) THEN 
           IF(RI.LE.0.0) THEN 
                SVAP = EVAP 
                GVAP = EVAP 
                IF (IIVAP.EQ.2) GVAP = 0.0 
                ELSE 
                SVAP = 0.0 
                GVAP = 0.0 
                ENDIF 
            ELSE 
            SVAP = EVAP 
            GVAP = EVAP 
            IF (IIVAP.EQ.-2) GVAP = 0.0 
           ENDIF 
C 
      RIN      = RI 
      RINE     = 0.0 
      IF(RIN.GT.0.0) RINE = RIN 
C======================================================================= 
Cwch, 12/20/00  Initialize for subcat to subcat flows.  
C    Initialize for every time step. 
C======================================================================= 
      FL2PV       = FLOW2PV(J) 
	FLOW2PV(J)  = 0.0 
	FL2IMP      = FLOW2IMP(J) 
	FLOW2IMP(J) = 0.0 
C     RFLOW will be rainfall over each subcat, as a flow rate (cfs).  
	RFLOW(J)     = 0.0 
C 
      WFLOW(J) = 0.0 
      IF(WAREA(J).EQ.0.0) GO TO 390 
C======================================================================= 
C     Begin loop on 3 or 4 subareas within each subcatchment. 
C 
C     Subscripts for different areas --- 
C 
C     K=1 -- IMPERVIOUS AREA WITH DEPRESSION STORAGE.  NORMALLY BARE, 
C            BUT MAY HAVE SNOW FOR ISNOW=2. 
C     K=2 -- PERVIOUS AREA WITH DEPRESSION STORAGE.  SNOW COVER VARIES 
C            ACCORDING TO AREAL DEPLETION CURVE FOR ISNOW=2 AND IS CONSTANT 
C            FOR ISNOW=1. 
C     K=3 -- IMPERVIOUS AREA WITH ZERO DEPRESSION STORAGE.  SNOW COVER 
C            IS SAME AS FOR K=1. 
C     K=4 -- IMPERVIOUS AREA WITH DEPRESSION STORAGE.  USED ONLY WHEN 
C            SNOW CALCS ARE MADE.  SNOW COVER VARIES ACCORDING TO AREAL 
C            DEPLETION CURVE FOR ISNOW=2 AND IS 100% FOR ISNOW=1. 
C 
C     SUBSCRIPTS FOR SNOW VARIABLES --- 
C        FOR K =  1 II = 3 
C            K =  2 II = 2 
C            K =  3 II = 3 (SAME SNOW PACK AS K=1) 
C            K =  4 II = 1 
C======================================================================= 
C#### WCH, 5/25/94.  INDICATOR VARIABLE TO SEE IF K=1 IS USED. 
      K3CALC = 0 
      DO 380 K = 1,KKK 
      IF(WAR(K,J).LT.0.01) GO TO 380 
Cwch, 12/20/00 
      FINF   = 0.0 
      WFLO   = 0.0 
      SMIMED = 0.0 
      ASC    = 0.0 
      II     = IDXSNO(K) 
                 RLOSS  = 0.0 
      IF(K.NE.2) RLOSS  = SVAP 
C======================================================================= 
C     Treat melt in same manner as rain on area. 
C     SMIMED = immediate melt. 
C     Start out with: 
C     RI = RIN = precip, positive for rain, negative for snow. 
C     RINE   = rain, if raining, else zero if snow. 
C     (Note, RI is in COMMON "Detail.inc") 
C     End with: 
C     RI     = melt, after routing melt through snowpack.  
C     RINE   = melted precip on bare area or = rain, if not snowing. 
C======================================================================= 
      IF(K.EQ.1) THEN 
C#### WCH, 5/25/94. NEED K=1 CALCS FOR K=3.  CHECK IF CALCULATED. 
                 K3CALC = 1 
                 IF(ISNOW.GT.0) CALL SNOW(TA,SMIMED,J,K,II,RIN,RINE, 
     +                                    ASC,WINDY,KOMPUT) 
C======================================================================= 
C     This weighted average to get mix of contribution from  
                 RI     = RI*ASC + (1.0-ASC)*RINE + SMIMED 
                 RISAVE = RI 
                 DOI    = WDEPTH(K,J) - WSTORE(1,J) 
                 WSTOR  = WSTORE(1,J) 
Cwch, 4/11/02.  Add FLOW2SUB 
                 IF(WDEPTH(K,J).LE.0.0.AND.RI.LE.0.0.AND. 
     1              FL2IMP.LE.0.0.AND.FLOW2SUB(J).LE.0.0) GO TO 350 
                 ENDIF 
C======================================================================= 
      IF(K.EQ.3) THEN 
C#### WCH, 5/25/94. BE SURE THAT K=1 CALCS HAVE BEEN MADE 
                 IF(K3CALC.EQ.0) THEN 
                      IF(ISNOW.GT.0) CALL SNOW(TA,SMIMED,J,K,II,RIN, 
     +                                    RINE,ASC,WINDY,KOMPUT) 
                      RI     = RI*ASC + (1.0-ASC)*RINE + SMIMED 
                      RISAVE = RI 
                      ENDIF 
                 RI     = RISAVE 
                 DOI    = WDEPTH(K,J) 
                 WSTOR  = 0.0 
Cwch, 4/11/02.  Add FLOW2SUB 
                 IF(WDEPTH(K,J).LE.0.0.AND.RI.LE.0.0.AND. 
     1              FLOW2SUB(J).LE.0.0) GO TO 350 
                 ENDIF 
C======================================================================= 
      IF(K.EQ.4) THEN 
                 IF(ISNOW.GT.0) CALL SNOW(TA,SMIMED,J,K,II,RIN,RINE, 
     +                                    ASC,WINDY,KOMPUT) 
                 RI     = RI*ASC + (1.0-ASC)*RINE + SMIMED 
                 DOI    = WDEPTH(K,J) - WSTORE(1,J) 
                 WSTOR  = WSTORE(1,J) 
Cwch, 4/11/02.  Add FLOW2SUB 
                 IF(WDEPTH(K,J).LE.0.0.AND.RI.LE.0.0.AND. 
     1              FLOW2SUB(J).LE.0.0) GO TO 350 
                 ENDIF 
C======================================================================= 
C     K = 2 Calls infiltration routines for pervious areas. 
C                 Treat melt in same manner as rain on area. 
C     Note, when return from infiltration subroutines, RLOSS =  
C       actual evap + infiltration loss.  Must subtract 
C       evaporation to get infiltration alone.  
C======================================================================= 
      IF(K.EQ.2) THEN 
                 IF(ISNOW.GT.0) CALL SNOW(TA,SMIMED,J,K,II,RIN,RINE, 
     +                                    ASC,WINDY,KOMPUT) 
                 RI     = RI*ASC + (1.0-ASC)*RINE + SMIMED 
                 DOI   = WDEPTH(K,J) - WSTORE(2,J) 
                 WSTOR = WSTORE(2,J) 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
CIM FIX FOR INFILM =2 or 3 
Cwch, 12/20/00. Add new argument in HORTON call. 
C	Add rerouted flow to water available for infiltration. 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
	           FFL2 = FL2PV/WAR(2,J) + FLOW2SUB(J) 
                 IF(INFILM.EQ.0.OR.INFILM.EQ.2)  
     +              CALL HORTON(TP(J),K,J,FFL2) 
                 IF(INFILM.EQ.1.OR.INFILM.EQ.3) 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
Cwch, 12/20/00.  Add another argument at end of GAMP call. 
C   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
     +           CALL GAMP(WLMAX(J),SMD(J),DECAY(J), 
     1                  IFLAG(J),FU(J),FTOT(J),WLMIN(J),WDEPTH(K,J), 
     2                  TP(J),DELT,TIME,RI,RLOSS,UL(J),SVAP, 
     3                  KAMEW(J),NAMEW(J),FFL2) 
C======================================================================= 
C     Call groundwater subroutine. 
C======================================================================= 
cim   the following line causes the number of subcatchments with 
cim   groundwater to have to exceed or equal the number of subcatchments 
cim   I changed array of NMSUB to NW in GRWTR.INC. 
                 IF(NMSUB(J).GT.0) THEN 
					       ENFIL = RLOSS - SVAP 
						   IF(ENFIL.LT.0.0) ENFIL = 0.0 
                             CALL GROUND(J,XSINFL) 
C#### WCH, 4/7/94.  CHECK HERE FOR GROUNDWATER FLOW IN ORDER TO 
C     USE WETDRY TIME STEP. 
                             IF(GWFLOW(J).GT.0.0) KWIK = 1 
C#### CORRECTION BY RED, 3/93. DIVIDE BY DELT. 
                             ENFIL   = ENFIL - XSINFL/DELT 
                             IF(ENFIL.LT.0.0) ENFIL = 0.0 
C#### CORRECTION BY RED, 3/93. DIVIDE BY DELT. 
                             RLOSS   = RLOSS - XSINFL/DELT 
                             IF(RLOSS.LT.0.0) RLOSS = SVAP 
                             CNT(11) = CNT(11) + ETU*WAR(2,J)*DELT 
Cwch, 7/1/03 Deep ET also occurs only over pervious area. 
C                             CNT(12) = CNT(12) + ETD*WAREA(J)*DELT 
                             CNT(12) = CNT(12) + ETD*WAR(2,J)*DELT 
                             CNT(14) = CNT(14) + DEPPRC*WAREA(J)*DELT 
                             CNT(17) = CNT(17) + ENFIL*WAR(K,J)*DELT 
Cwch, 7/1/03. Save more groundwater variables for printing, units of cfs. 
	                       IF(NGWGW(J).EQ.1) THEN 
                                LU         = LU + 1 
                                ETUPR(LU) = ETU*WAR(2,J) 
	                          ETDPR(LU) = ETD*WAR(2,J) 
Cwch  Save combined ET for total ET save later.  
                                ETGR2     = (ETU+ETD)*WAR(2,J) 
	                          DEPPR(LU) = DEPPRC*WAREA(J) 
	                          ENFPR(LU) = ENFIL*WAR(2,J) 
                                ENDIF                          
                             ENDIF 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C CHANGED IF BECAUSE TOTAL INFILTRATION CALCULATIONS SHOULD NOT BE 
C BYPASSED DURING A DRY TIME STEP 
C                IF(WDEPTH(K,J).LE.0.0.AND.RI.LE.0.0) GO TO 350 
Cwch, 12/20/00.  Include rerouted flow in check. 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
Cwch 3/28/02.  Add flow2sub 
Cwch 8/8/03. It appears this IF-statement is not needed and in fact 
C     avoids inclusion of important continuity sums for groundwater. 
C     The main purpose is to avoid unnecessary calcuations, but there 
C     are several IF-statements imbedded between here and Stmt 350  
C     that serve the same purpose.  So delete and hope for the best 
C     Reommended by Carlos Diaz of GeoSyntec.   
C        IF(WDEPTH(K,J).LE.0.0.AND.RI.LE.0.0.AND.FL2PV.LE.0.0. 
C     +     AND.FLOW2SUB(J).LE.0.0.AND.INFILM.LT.2) GO TO 350 
CIM  Fix to limit maximum infiltration volume and track infiltration 
C%%% here 
                 IF (INFILM.GE.2) THEN 
                      FINF = DMAX1((RLOSS - SVAP),DBLE(0.0)) 
                      TEMPIN=TOTINF(J) + FINF*DELT 
                      FAVAIL = AMAX1((RMAXINF(J)-TEMPIN)/DELT,0.0) 
                      IF (FAVAIL.LE.FINF) THEN 
CIM  REDUCE FINF BECAUSE INFILTRATION VOLUME IS USED UP 
                          FINF=FAVAIL 
                          TEMPIN=TOTINF(J) + FINF*DELT 
                          RLOSS=FINF+SVAP 
                          ENDIF 
                      TOTINF(J)=TEMPIN 
                      ENDIF 
C======================================================================= 
Cwch, 12/20/00. Need to save infiltration value for possible  
C     subcatchment quality routing.   
C======================================================================= 
			   ENFILW(J) = RLOSS - SVAP 
			   IF(ENFILW(J).LT.0.0) ENFILW(J) = 0.0 
			   ENFILW(J) = ENFILW(J)*WAR(2,J) 
C endif for k=2 
			   ENDIF 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
Cwch, 12/20/00.  Add rerouted overland flow. 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      RSTAR = RI - RLOSS + FLOW2SUB(J) 
	IF(K.EQ.1) RSTAR = RSTAR + FL2IMP/WAR(1,J) 
	IF(K.EQ.2) RSTAR = RSTAR + FL2PV/WAR(2,J) 
C 
                                        CTYPE = 'DR2' 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C CHANGED STATEMENT BELOW BECAUSE ROUNDOFF ERROR WAS CAUSING DR1s TO BE 
C DR2s 
C      IF(RSTAR+WDEPTH(K,J)/DELT.LE.0.0) CTYPE = 'DR1' 
      IF(RSTAR*DELT+WDEPTH(K,J).LE.0.000001) CTYPE = 'DR1' 
c%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
      IF(RSTAR*DELT+DOI.GT.0.0)         CTYPE = 'WET' 
C======================================================================= 
C     DR1 - No water is available to run off. 
C     Evaporation (first) and infiltration (second) take away all water. 
Cwch 12/20/00. Add rerouted overland flow to infiltration. 
Cwch, 4/11/02. 
C     Loss is all available water.  RSTAR includes all necessary  
C       vertical inflows.  Add back RLOSS to RSTAR and add WDEPTH 
C       to get this total.  But for K = 2, RLOSS already includes  
C       WDEPTH.  
C======================================================================= 
      IF(CTYPE.EQ.'DR1') THEN 
           RLOSS       = RSTAR + RLOSS + WDEPTH(K,J)/DELT 
C                         IF(K.EQ.2) RLOSS = RLOSS + FFL2 
           WDEPTH(K,J) = 0.0 
           WFLO        = 0.0 
           ENDIF 
C======================================================================= 
C     DR2 - Depth less than depression storage but > 0. 
C     Here, depth is filling (RSTAR > 0) or draining (RSTAR < 0) while 
C       staying below depression storage depth.  
C======================================================================= 
      IF(CTYPE.EQ.'DR2') THEN 
                         WFLO  = 0.0 
                         DCORR = WDEPTH(K,J) + RSTAR*DELT 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C HOW CAN DCORR EVER BE LESS THAN 0.0?  IF DCORR IS LESS THAN 0.0, CTYPE 
C IS 'DR1' BY DEFINITION.  GET RID OF IF? 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C                         IF(DCORR.LT.0.0) THEN 
C                                          RLOSS = WDEPTH(K,J)/DELT + RI 
C                                          DCORR = 0.0 
C                                          ENDIF 
                         WDEPTH(K,J) = DCORR 
                         ENDIF 
C======================================================================= 
C     Storage greater than depression storage - Call flow routing. 
C======================================================================= 
      IF(CTYPE.EQ.'WET') THEN 
                          WCC = WCON(1,J) 
               IF(K.EQ.2) WCC = WCON(2,J) 
C======================================================================= 
C              Test for the condition in which old DOI is negative but 
C              the new DOI will be positive based on RI - RLOSS. 
C======================================================================= 
               IF(DOI.LT.0.0) THEN 
                              RSTAR       = RSTAR + DOI/DELT 
                              DOI         = 0.0 
                              WDEPTH(K,J) = WSTOR 
                              ENDIF 
               CALL OVERLND(J,WCC,RSTAR,DOI,DEL,DELT) 
               DCORR = WDEPTH(K,J) + DEL 
               IF(DCORR.GT.WSTOR) THEN 
                        WFLO = -WCC*WAR(K,J)*(DCORR-WSTOR)**1.666667 
                        ELSE 
                        WFLO  = 0.0 
                        DCORR = WDEPTH(K,J) + RSTAR*DELT 
                        IF(DCORR.LT.0.0) THEN 
                                         RLOSS = WDEPTH(K,J)/DELT + RI 
                                         DCORR = 0.0 
                                         ENDIF 
                        ENDIF 
               WDEPTH(K,J) = DCORR 
               KWIK        = 1 
               ENDIF 
C======================================================================= 
C     Sum for continuity check. 
C     CNT(4) = infiltration 
C     CNT(6) = evaporation 
C======================================================================= 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C FINF HAS ALREADY BEEN CALCULATED IF INFILM=2, SO ADD IF 
      IF(K.EQ.2) THEN 
C%%%%% 
                 IF(INFILM.LT.2) THEN 
                                 FINF= RLOSS - SVAP 
                      IF(FINF.LT.0.0) FINF = 0.0 
                      ENDIF 
C%%%%% 
                 RLOSS                  = RLOSS - FINF 
                 IF(RLOSS.LT.0.) RLOSS  = 0.0 
                 CNT(4)      = CNT(4) + FINF*WAR(K,J)*DELT 
                 CNT(6)      = CNT(6) + RLOSS*WAR(K,J)*DELT 
Cwch, 7/1/03 
                 IF(NGWGW(J).EQ.1) EVGWPR(LU) = ETGR2 + RLOSS*WAR(K,J) 
Cwch 3/28/02 
                 SUBQLOSS(J) = SUBQLOSS(J) + (RLOSS+FINF)*WAR(K,J)*DELT 
                 ELSE 
                 CNT(6)      = CNT(6) + RLOSS*WAR(K,J)*DELT 
                 ENDIF 
C####################################################################### 
C  C. MOORE, CDM, 8/93.  STATISTICS FOR SUBCATCHMENTS. 
C####################################################################### 
      IF (SUBQPEAK(K,J).LT.WFLO)  SUBQPEAK(K,J) = WFLO 
      SUBDEP(K,J) = SUBDEP(K,J) + WFLO*DMEAN 
C### 
C  CNT(21) = surface runoff from subcatchments. 
C  Only sum if water not being rerouted over further overland flow planes. 
C  Move to end of 380 loop. 
C      CNT(21)  = CNT(21)  + WFLO*DMEAN 
C####################################################################### 
Cwch, 12/20/00 Here, provide for rerouting of overland flow. 
C####################################################################### 
      IF((IFLOWP(J).EQ.0.OR.IFLOWP(J).EQ.3).OR. 
     +    ((IFLOWP(J).EQ.1.OR.IFLOWP(J).EQ.4).AND.K.EQ.2).OR. 
     +    ((IFLOWP(J).EQ.2.OR.IFLOWP(J).EQ.5).AND.K.NE.2)) 
     +    WFLOW(J) = WFLOW(J) + WFLO 
Cwch, 6/7/01. Add check for zero pervious and impervious areas.  
	IF((IFLOWP(J).EQ.1.OR.IFLOWP(J).EQ.4).AND.K.NE.2) THEN 
		IF(WAR(2,J).GT.0.01) THEN 
            	FLOW2PV(J) = FLOW2PV(J) + WFLO 
	        ELSE 
	        WFLOW(J) = WFLOW(J) + WFLO 
	        ENDIF 
	    ENDIF 
      IF((IFLOWP(J).EQ.2.OR.IFLOWP(J).EQ.5).AND.K.EQ.2) THEN 
	     IF(WAR(1,J).GT.0.01) THEN 
	        FLOW2IMP(J) = WFLO 
	        ELSE 
	        WFLOW(J) = WFLOW(J) + WFLO 
	        ENDIF 
	     ENDIF 
C 
 350  CNT(1)   = CNT(1)   + ABS(RIN)*WAR(K,J)*DELT 
      CNT(2)   = CNT(2)   + RINE*WAR(K,J)*DELT 
C     Save RFLOW for both subcat to subcat flows and for erosion calcs.  
	RFLOW(J) = RFLOW(J) + RINE*WAR(K,J) 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C   CIM     track total infiltration volume 
C%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
C  REGENERATE TOTINF 
      IF(K.EQ.2.AND.INFILM.EQ.2) THEN 
        IF(TOTINF(J).GE.RMAXINF(J)) TOTINF(J)=RMAXINF(J) 
        IF(WDEPTH(K,J).LE.0.0.AND.RI.LE.0.0) THEN 
          IF(TOTINF(J).LE.RMAXINF(J)*.01) THEN 
            TOTINF(J)=0.0 
          ELSE 
            TOTINF(J)=RMAXINF(J)*EXP(-DECAY(J)*REGEN*(DELT-ALOG(TOTINF(J 
     *)/RMAXINF(J))/(DECAY(J)*REGEN))) 
          ENDIF 
        ENDIF 
      ENDIF 
c  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  380 CONTINUE 
C####################################################################### 
Cwch, 12/20/00. Sum surface runoff continuity variable here, to 
C  allow for rerouting of surface flows. 
C####################################################################### 
      IF(IFLOWP(J).LE.2) CNT(21) = CNT(21) + WFLOW(J)*DMEAN 
C####################################################################### 
C  C. MOORE, CDM, 8/93.  STATISTICS FOR SUBCATCMENTS. 
C  PEAK TOTAL IMPERVIOUS AREA RUNOFF 
Cwch, 1/17/01. Subarea type 4 is also impervious.  Add here, remove 
C     below.  
C======================================================================= 
      TEMP = SUBQPEAK(1,J) + SUBQPEAK(3,J)+ SUBQPEAK(4,J) 
      IF (SUBQPEAK(5,J).LT.TEMP) SUBQPEAK(5,J) = TEMP 
C======================================================================= 
C  PEAK TOTAL RUNOFF RATE 
Cwch, 12/20/00. If overland flow is rerouted internally, can't add to 
C     get peak from subcat.  Use SUBQPEAK(2) for IFLOWP = 1 or 4 and  
C     use TEMP for IFLOWP = 2 or 5.  
C======================================================================= 
C      TEMP = TEMP + SUBQPEAK(2,J)  
      IF (SUBQPEAK(6,J).LT.TEMP+SUBQPEAK(2,J).AND. 
     1  (IFLOWP(J).EQ.0.OR.IFLOWP(J).EQ.3))  
     2            SUBQPEAK(6,J) = TEMP + SUBQPEAK(2,J) 
	IF (SUBQPEAK(6,J).LT.TEMP.AND.(IFLOWP(J).EQ.2.OR.IFLOWP(J).EQ.5)) 
     1            SUBQPEAK(6,J) = TEMP 
	IF (SUBQPEAK(6,J).LT.SUBQPEAK(2,J).AND. 
     1 (IFLOWP(J).EQ.1.OR.IFLOWP(J).EQ.4)) SUBQPEAK(6,J) = SUBQPEAK(2,J) 
C####################################################################### 
  390 CONTINUE 
C======================================================================= 
C     Save Subsurface plot information. 
C======================================================================= 
      IF(NSVGW.GT.0) THEN 
                     MCOUN     = 0 
Cwch, 7/1/03. Loop through all NOW subcats 
C                     DO 395 JH = 1,NOGWSC 
                     DO 395 JH = 1,NOW 
C#### WCH, 4/7/94.  MAKE THIS CHECK EARLIER. 
C####                     IF(GWFLOW(JH).GT.0.0) KWIK = 1 
C                     IF(NSCSFG(JH).EQ.0) GO TO 395 
                     IF(NSCSFG(JH).EQ.1) THEN 
				      MCOUN           = MCOUN+1 
Cwch 3/1/02 Metric conversion error found by Sandy Elliot and RED.   
C     Reverse the conversions, to CMET8 for flow and CMET1 for stage. 
                        GWFLWB(MCOUN)   = GWFLOW(JH)/CMET(8,METRIC) 
                        STPOLL(1,MCOUN) = STG(JH)/CMET(1,METRIC) 
                        STPOLL(2,MCOUN) = TH1(JH) 
	                  ENDIF 
  395                CONTINUE 
                     WRITE(NSCRAT(6)) JULDAY,TIMDAY,TIME,(GWFLWB(JI), 
     .                               (STPOLL(JV,JI),JV=1,2),JI=1,NSVGW) 
                     ENDIF 
C======================================================================= 
Cwch, 12/20/00. Save desired subcatch outflow for printing. 
C     Need to do this only for subcats that flow to other subcats but 
C     array will allow for any to be saved.  
C     Save quality loads in Sub. QSHED.  
C======================================================================= 
      IF(MSUBC.GT.0) THEN 
           IF(JSTART(1).GT.0) THEN 
               DO 600 L = 1,NDET 
               IF(JULDAY.GE.JSTART(L).AND.JULDAY.LE.JSTOP(L)) GO TO 605 
  600          CONTINUE 
               GO TO 610 
  605          CONTINUE 
               ENDIF 
           WRITE(NSCRAT(9),ERR=779) JULDAY,TIMDAY,DELT, 
     +                           (WFLOW(ISUBC(N)),N=1,MSUBC) 
  610      CONTINUE 
           ENDIF 
C======================================================================= 
      RETURN 
  779 WRITE(N6,9779) 
      STOP ' Error in WSHED writing subcat flows to file NSCRAT(9).' 
C======================================================================= 
 9200 FORMAT(/,' Reading station number ',I10,' from NSCRAT(3) for', 
     +' Temperature, Wind Speed, or Evaporation data.') 
 9779 FORMAT(/,' ===> ERROR   WRITING SUBCATCHMENT FLOWS ON THE', 
     +         ' NSCRAT(9) FILE IN SUBROUTINE WSHED.') 
C======================================================================= 
      END 
 
REM File: YROUTE.FOR 
 
C this version of yroute attempts to improve numerical consistency 
c by reading the previous values of variables sumq,sums,sumal, and as. 
      SUBROUTINE YROUTE 
C	EXTRAN BLOCK 
C	CALLED BY TRANSX NEAR LINE 613 
C 
C     WCH (RED and L. Rossman), 7/20/04. Fix second DELQ4 calc.  
C======================================================================= 
C     THIS IS SUBROUTINE YROUTE OF THE SEWER MODEL 
C     IT PERFORMS THE MODIFIED EULER SOLUTION OF THE 
C     MOTION AND CONTINUITY EQUATIONS LAST UPDATED NOVEMBER, 1989 
C======================================================================= 
      INCLUDE 'TAPES.INC' 
      INCLUDE 'BD.INC' 
      INCLUDE 'BND.INC' 
      INCLUDE 'HYFLOW.INC' 
      INCLUDE 'CONTR.INC' 
      INCLUDE 'JUNC.INC' 
      INCLUDE 'PIPE.INC' 
      INCLUDE 'TIDE.INC' 
      INCLUDE 'OUT.INC' 
      INCLUDE 'ORF.INC' 
      INCLUDE 'WEIR.INC' 
      INCLUDE 'FLODAT.INC' 
      DOUBLE PRECISION AKON,QNEW,DELQ1,DELQ2,DELQ3,DELQ4,DELQ5 
      DIMENSION SUMQ1(NEE),SUMQS1(NEE),SUMAL1(NEE),AS1(NEE) 
      DIMENSION SUMQL(NEE),SUMQSL(NEE),SUMALL(NEE),ASL(NEE) 
C======================================================================= 
C     STORE OLD TIME STEP FLOW VALUES 
C======================================================================= 
      DO 60 N   = 1,NTL 
   60 QO(N)     = Q(N) 
C======================================================================= 
C     INITIALIZE CONTINUITY PARAMETERS 
C======================================================================= 
      DO 80 J  = 1,NJ 
      YO(J)    = Y(J) 
      AS(J)    = AMEN 
      SUMQ(J)  = QIN(J) 
      SUMQS(J) = QIN(J) 
   80 SUMAL(J) = 0.0 
CIM START  OOOOOO 
CIM        SET HALFSTEP GATED ORIFICE PARAMETERS 
CIM        FLOWS COMPUTED WILL BE BASED ON FULLSTEP DEPTHS (Y) AT CONTROL NODE 
      CALL OGATES(DELT2,Y,V) 
CIM END    OOOOOOOO 
C======================================================================= 
C     HALF-STEP AREA, RADIUS : VELOCITY 
C     FULL-STEP AREA, RADIUS : VELOCITY 
C     HALF-STEP FLOW 
C======================================================================= 
C$OMP PARALLEL 
C$OMP& PRIVATE(N,NL,NH,HRAD,IDOIT,AKON,DQDH,ANH,ANL,J) 
C$OMP& PRIVATE(DELQ1,DELQ2,DELQ3,DELQ4,DELQ5,QNEW,DELH,DELZP,DIFF1) 
C$OMP& PRIVATE(DIFF2,RNL,QNORM,ANH,RNH,SUMQ1,SUMQS1,SUMAL1) 
C$OMP& PRIVATE(AS1) 
C 
CWRM CLEAR THE PARTIAL SUMS 
CWRM STARTING AS1 AT AMEN IMPROVES NUMERICAL CONSISTENCY 
      DO J = 1, NJ 
        SUMQ1(J)  = QIN(J) 
        SUMQS1(J) = QIN(J) 
        SUMAL1(J) = 0.0 
        AS1(J)    = AMEN 
      ENDDO 
C 
C$OMP DO SCHEDULE(GUIDED) 
      DO 100 N = 1,NTC 
      NL       = NJUNC(N,1) 
      NH       = NJUNC(N,2) 
      H(N,1)    = AMAX1(Y(NL) + Z(NL),ZU(N)) 
      H(N,2)    = AMAX1(Y(NH) + Z(NH),ZD(N)) 
      CALL NHEAD(N,NL,NH,H(N,1),H(N,2),QO(N),A(N),V(N),HRAD, 
     +                       ANH,ANL,RNL,RNH,IDOIT,LINK(N),AS1) 
      IF(HRAD.GT.HMAX(N)) HMAX(N) = HRAD 
      IF(A(N).GT.AMAX(N)) AMAX(N) = A(N) 
      IF(IDOIT.EQ.0) THEN 
                     QT(N) = 0.0 
                     AKON  = 0.0 
                     GO TO 95 
                     ENDIF 
c 
c calculate additional loss terms per red incorporated by cim cdm 9/97 
c 
c    Q/ANH = velocity at downstream end used for exit loss 
c    Q/ANL = velocity at upstream end used for entrance loss 
c       The loss = 1/2*K*V^2/g is factored into momentum 
c       equation similarly to the friction slope 
c       The loss momentum term = g*A*[1/2*K*V^2/g] 
c                              = g*A*[1/2*K*Q/A*Q/A/g] 
C                               =g  *[1/2*K*|Q*A|  /g] * Q 
C                               =    [1/2*K*|Q*A|    ] * Q 
c     DELQ5 is sum of losses 
      DELQ5 = 0.0 
      IF (ANH.NE.0.0)  DELQ5 =  DELQ5 + 0.5 * ABS(QO(N)/ANH)*ENTK(N) 
      IF (ANL.NE.0.0)  DELQ5 =  DELQ5 + 0.5 * ABS(QO(N)/ANL)*EXITK(N) 
      IF (A(N).NE.0.0) DELQ5 =  DELQ5 + 0.5 * ABS(QO(N)/A(N))*OTHERK(N) 
      DELQ5 =  DELQ5 * DELT2/LEN(N) 
C 
      DELQ4 =  DELT2*QO(N)*(ANH-ANL)/(AT(N)*A(N)*LEN(N)) 
      DELQ3 =  2.0*(A(N)-AT(N))/A(N) 
      DELQ2 =  DELT2*GRVT*A(N)*(H(N,2)-H(N,1))/LEN(N) 
      DELQ1 =  DELT2*(ROUGH(N)/HRAD**1.33333)*ABS(V(N)) 
      QNEW  =  QO(N) - DELQ2 
      AKON  =  DELQ1 + DELQ5 - DELQ4 - DELQ3 
c     IF (delq5.NE.0.0) write(n6,*) 'delq5',delq5,N 
      IF ((1.0+akon).eq.0.0) THEN 
      WRITE(n6,*) delq1,delq2,delq3,delq4,delq5,akon,delt2 
      write(n6,*) qo(n),n 
      write(n6,*) a(n),at(n),QNEW,H(N,2),H(N,1),LEN(N),V(N) 
      WRITE(N6,*) rough(n),hrad 
c      CLOSE(N6) 
c      stop 'zero denom.  AKON = -1.0' 
      WRITE(N6,*) ' SET AKON = -1.0000001 AND CONTINUE' 
      AKON = -1.0000001 
      ENDIF 
      QT(N) =  QNEW/(1.0+AKON) 
C======================================================================= 
C     CHECK FOR NORMAL FLOW - IF THE WATER SURFACE SLOPE IS LESS THAN 
C                             THE CONDUIT SLOPE THE FLOW IS SUPERCRIT. 
C======================================================================= 
      ICHECK(N) = IND(1) 
CIM   START OOOOOOOO 
CIM      ORIFICES 
      IF(KSUPER.EQ.0.OR.NKLASS(N).GE.51.OR.JSKIP(NL).GT.0. 
CIM END OOOOOOOO 
     +                                 OR.JSKIP(NH).GT.0) THEN 
      IF(QT(N).GT.0.0.AND.H(N,1).LE.ZCROWN(NL)) THEN 
      DELH      = H(N,1) - H(N,2) 
      DELZP     = ZU(N)  - ZD(N) 
      IF(DELH-DELZP.LT.0.0) THEN 
               QNORM = SQRT(GRVT*(ZU(N)-ZD(N))/ 
     +                   (LEN(N)*ROUGH(N)))*ANL*RNL**0.666667 
               IF(QNORM.LE.QT(N)) THEN 
                                  ICHECK(N) = IND(2) 
                                  QT(N)     = QNORM 
                                  ENDIF 
               ENDIF 
      ENDIF 
      ENDIF 
C======================================================================= 
C     CHECK FOR NORMAL FLOW - IF THE FROUDE NUMBER IS > 1. 
C                             THE FLOW IS SUPERCRITICAL. 
C======================================================================= 
CIM START   <><><><><> 
CIM  ALL BUT ORIFICES 
      IF(NKLASS(N).LE.50.AND.H(N,1).LE.ZCROWN(NL).AND.JSKIP(NL).EQ.0. 
CIM END      <><><><><> 
     +                  AND.JSKIP(NH).EQ.0) THEN 
      IF(QT(N).GT.0.0.AND.H(N,1).LE.ZCROWN(NL)) THEN 
      DIFF1 = H(N,1) - ZU(N) 
      DIFF2 = H(N,2) - ZD(N) 
      IF(KSUPER.EQ.1.AND.DIFF1.GT.0.0.AND.DIFF2.GT.0.0) THEN 
               FF1 = ABS(QT(N))/ANL/SQRT(GRVT*(DIFF1)) 
               FF2 = ABS(QT(N))/ANH/SQRT(GRVT*(DIFF2)) 
               QNORM = SQRT(GRVT*(ZU(N)-ZD(N))/ 
     +                   (LEN(N)*ROUGH(N)))*ANL*RNL**0.666667 
                                            ITEST = 0 
               IF(FF1.GE.1.0.OR.FF2.GE.1.0) ITEST = 1 
               IF(QNORM.LE.QT(N).AND.ITEST.EQ.1) THEN 
                                                 ICHECK(N) = IND(2) 
                                                 QT(N)     = QNORM 
                                                 ENDIF 
               ENDIF 
      ENDIF 
      ENDIF 
C======================================================================= 
C     COMPUTE CONTINUITY PARAMETERS 
C======================================================================= 
      SELECT CASE (INGATE(N)) 
      CASE (1) 
      QT(N) = AMAX1(QT(N),0.0) 
c      IF(INGATE(N).EQ.1.AND.QT(N).LT.0.0) QT(N) = 0.0 
      CASE (2) 
      QT(N) = AMIN1(QT(N),0.0) 
c      IF(INGATE(N).EQ.2.AND.QT(N).GT.0.0) QT(N) = 0.0 
      END SELECT 
      IF (NKLASS(N).LE.21) THEN 
      QT(N) = AMAX1(STHETA(N),QT(N)) 
      QT(N) = AMIN1(SPHI(N),QT(N)) 
      ENDIF 
  95  DQDH      = 1.0/(1.0+AKON)*GRVT*DELT2*A(N)/LEN(N) 
      SUMQ1(NL)  = SUMQ1(NL)  - 0.5*(QT(N)+QO(N)) 
      SUMQS1(NL) = SUMQS1(NL) - QT(N) 
      SUMAL1(NL) = SUMAL1(NL) + DQDH 
      SUMQ1(NH)  = SUMQ1(NH)  + 0.5*(QT(N)+QO(N)) 
      SUMQS1(NH) = SUMQS1(NH) + QT(N) 
      SUMAL1(NH) = SUMAL1(NH) + DQDH 
  100 CONTINUE 
C$OMP END DO NOWAIT 
CWRM COMBINE THE PARTIAL SUMS 
CWRM SPLIT CRITICAL SECTIONS REDUCES CONTENTION FOR LOCKS 
C$OMP CRITICAL (TOP) 
      DO J = 1, NJ 
        SUMQ(J)  = SUMQ(J)  + (SUMQ1(J) - QIN(J)) 
        SUMQS(J) = SUMQS(J) + (SUMQS1(J) - QIN(J)) 
      ENDDO 
C$OMP END CRITICAL 
C$OMP CRITICAL (BOTTOM) 
      DO J = 1, NJ 
        SUMAL(J) = SUMAL(J) + SUMAL1(J) 
        AS(J)    = AS(J)    + (AS1(J) - AMEN) 
      ENDDO 
C$OMP END CRITICAL 
C$OMP END PARALLEL 
C======================================================================= 
C     SET HALF STEP OUTFLOWS AND INTERNAL TRANSFERS 
C======================================================================= 
      CALL BOUND(Y,YT,QT,TIME2,DELT2) 
C======================================================================= 
      DO 130 N  = NTC+1,NTL 
      NL        = NJUNC(N,1) 
CC$$$$5/3/92 
      IF(ABS(QT(N)).LT.1E-10) QT(N) = 0.0 
      SUMQ(NL)  = SUMQ(NL)  - (QT(N)+QO(N)) 
      SUMQS(NL) = SUMQS(NL) - QT(N) 
      NH        = NJUNC(N,2) 
      IF(NH.GT.0) THEN 
                  SUMQ(NH)  = SUMQ(NH)  + 0.5*(QT(N)+QO(N)) 
                  SUMQS(NH) = SUMQS(NH) + QT(N) 
                  ENDIF 
  130 CONTINUE 
C======================================================================= 
C     CALCULATE THE HALF-STEP HEAD 
C======================================================================= 
      DO 320 J = 1,NJ 
      IF(JSKIP(J).GT.0) GO TO 320 
C======================================================================= 
C     COMPUTE YT FOR FREE SURFACE JUNCTIONS 
C======================================================================= 
      IF(Y(J)-YCROWN(J).LE.0.0) THEN 
           YT(J)                  = YO(J)  + SUMQ(J)*DELT2/AS(J) 
           ASFULL(J)              = AS(J) 
           IF(YT(J).LT.0.0) YT(J) = FUDGE 
           ELSE 
                                      DENOM = SUMAL(J) 
           IF(Y(J).LT.1.25*YCROWN(J)) DENOM = SUMAL(J) + 
     + (ASFULL(J)/DELT2-SUMAL(J))*EXP(-15.*(Y(J)-YCROWN(J))/YCROWN(J)) 
                               CORR     = 0.50 
           IF(NCHAN(J,2).EQ.0) CORR     = 0.30 
           YT(J)                        = Y(J) + CORR*SUMQS(J)/DENOM 
           IF(YT(J).LT.YCROWN(J)) YT(J) = YCROWN(J) - FUDGE 
           ENDIF 
C     HERE USE SURELEV IN PLACE OF GRELEV 
           IF((YT(J)+Z(J)).GT.SURELEV(J)) YT(J) = SURELEV(J)-Z(J) 
C======================================================================= 
C     CALCULATE THE ALLOWABLE SURCHARGE TOLERANCE 
C======================================================================= 
      QAVE     = 0.0 
      DO 280 K = 1,NCHN 
      IF(NCHAN(J,K).LE.0) GO TO 290 
  280 QAVE = QAVE + ABS(Q(NCHAN(J,K))) 
  290 K    = K-1 
      QAVE = SURTOL*QAVE/FLOAT(K) 
      TOL  = (TOL*(NSUR-1)+QAVE)/NSUR 
      NSUR = NSUR+1 
C======================================================================= 
C     INITIALIZE FOR FULL STEP FLOWS 
C======================================================================= 
  300 AS(J)    = AMEN 
      SUMQ(J)  = QIN(J) 
      SUMQS(J) = QIN(J) 
      SUMAL(J) = 0.0 
  320 CONTINUE 
C======================================================================= 
C======================================================================= 
C     HALF-STEP AREA, RADIUS : VELOCITY 
C     FULL-STEP FLOW 
C======================================================================= 
C======================================================================= 
CIM BEGIN   OOOOOOOO 
CIM   FIRST COMPUTE GATED ORIFICE PARAMETERS 
CIM   BASED ON HALFSTEP DEPTHS AT CONTROL NODE 
      CALL OGATES(DELT2,YT,VT) 
CIM END      OOOOOOO 
      DO 1000 KLOOP = 1,100000 
      ERROR         = 0.0 
CWRM SAVING THE PREVIOUS VALUES IMPROVES NUMERICAL CONSISTENCY 
      DO J = 1, NJ 
        SUMQL(J)  = SUMQ(J) 
        SUMQSL(J) = SUMQS(J) 
        SUMALL(J) = SUMAL(J) 
        ASL(J) = AS(J) 
      ENDDO 
C$OMP PARALLEL 
C$OMP& PRIVATE(N,NL,NH,HRAD,IDOIT,AKON,DQDH,ANH,ANL,HRAD,J) 
C$OMP& PRIVATE(DELQ1,DELQ2,DELQ3,DELQ4,DELQ5,QNEW,DELH,DELZP,DIFF1) 
C$OMP& PRIVATE(DIFF2,RNL,QNORM,ANH,RNH,DIRQ,DIRQT,SUMQ1,SUMQS1,SUMAL1) 
C$OMP& PRIVATE(AS1) 
C 
CWRM CLEAR THE PARTIAL SUMS 
CWRM STARTING PARTIAL SUMS AT PREVIOUS VALUE IMPROVES NUMERICAL CONSISTENCY 
      DO J = 1, NJ 
        SUMQ1(J)  = SUMQL(J) 
        SUMQS1(J) = SUMQSL(J) 
        SUMAL1(J) = SUMALL(J) 
        AS1(J) = ASL(J) 
      ENDDO 
C 
C$OMP DO SCHEDULE(GUIDED) 
      DO 360 N      = 1,NTC 
      NL            = NJUNC(N,1) 
      NH            = NJUNC(N,2) 
C======================================================================= 
C     CHECK WHETHER SURCHARGE ITERATIONS OCCURRING 
C======================================================================= 
      IF(IT.GT.0.AND.JCHECK(NH).EQ.IND(1).AND.JCHECK(NL).EQ.IND(1)) 
     +                                        GO TO 360 
      H(N,1)    = AMAX1(YT(NL) + Z(NL),ZU(N)) 
      H(N,2)    = AMAX1(YT(NH) + Z(NH),ZD(N)) 
      CALL NHEAD(N,NL,NH,H(N,1),H(N,2),QT(N),AT(N),VT(N),HRAD, 
     +                         ANH,ANL,RNL,RNH,IDOIT,LINK(N),AS1) 
      IF(IDOIT.EQ.0) THEN 
                     Q(N)  = 0.0 
                     AKON  = 0.0 
                     GO TO 995 
                     ENDIF 
c 
c calculate additional loss terms per red incorporated by cim cdm 9/97 
c 
c    Q/ANH = velocity at downstream end used for exit loss 
c    Q/ANL = velocity at upstream end used for entrance loss 
c       The loss = 1/2*K*V^2/g is factored into momentum 
c       equation similarly to the friction slope 
c       The loss momentum term = g*A*[1/2*K*V^2/g] 
c                              = g*A*[1/2*K*Q/A*Q/A/g] 
C                               =g  *[1/2*K*|Q*A|  /g] * Q 
C                               =    [1/2*K*|Q*A|    ] * Q 
c     DELQ5 is sum of losses 
      DELQ5 = 0.0 
      IF (ANH.NE.0.0)   DELQ5 = DELQ5 + 0.5 * ABS(QT(N)/ANH)*ENTK(N) 
      IF (ANL.NE.0.0)   DELQ5 = DELQ5 + 0.5 * ABS(QT(N)/ANL)*EXITK(N) 
      IF (AT(N).NE.0.0) DELQ5 = DELQ5 + 0.5 * ABS(QT(N)/AT(N))*OTHERK(N) 
      DELQ5 =  DELQ5 * DELT/LEN(N) 
C 
cred  the delt mulplier was changed due to note from Lew Rossman  
cred  of the EPA in the re-development of SWMM 5 
cred  why is this DELT2??? - should be delt; september 2003  
cred  this was fixed in swmm 4.99 in september of 2003 
Cwch, 7/20/04. Omit optional use of buggy version in OSU SWMM4.4h.  
C      DELQ4 =  DELT2*QT(N)*(ANH-ANL)/(AT(N)*A(N)*LEN(N)) 
	DELQ4 =  DELT*QT(N)*(ANH-ANL)/(AT(N)*A(N)*LEN(N)) 
      DELQ3 =  4.0*(AT(N)-A(N))/AT(N) 
      DELQ2 =  DELT*GRVT*AT(N)*(H(N,2)-H(N,1))/LEN(N) 
      DELQ1 =  DELT*(ROUGH(N)/HRAD**1.33333)*ABS(VT(N)) 
      QNEW  =  QO(N) - DELQ2 
      AKON  =  DELQ1 - DELQ4 - DELQ3 + DELQ5 
      Q(N)  =  QNEW/(1.0+AKON) 
C======================================================================= 
C     CHECK FOR NORMAL FLOW - IF THE WATER SURFACE SLOPE IS LESS THAN 
C                             THE CONDUIT SLOPE THE FLOW IS SUPERCRIT. 
C======================================================================= 
      ICHECK(N) = IND(1) 
CIM BEGIN OOOOOOOO 
CIM     ORIFICES 
      IF(KSUPER.EQ.0.OR.NKLASS(N).GE.51.OR.JSKIP(NL).GT.0. 
CIM END      OOOOOOOOO 
     +                                 OR.JSKIP(NH).GT.0) THEN 
      IF(Q(N).GT.0.0.AND.H(N,1).LE.ZCROWN(NL)) THEN 
      DELH      = H(N,1) - H(N,2) 
      DELZP     = ZU(N)  - ZD(N) 
      IF(DELH-DELZP.LT.0.0) THEN 
               QNORM = SQRT(GRVT*(ZU(N)-ZD(N))/ 
     +                   (LEN(N)*ROUGH(N)))*ANL*RNL**0.666667 
               IF(QNORM.LE.Q(N)) THEN 
                                 ICHECK(N) = IND(2) 
                                 Q(N)      = QNORM 
                                 ENDIF 
               ENDIF 
      ENDIF 
      ENDIF 
C======================================================================= 
C     CHECK FOR NORMAL FLOW - IF THE FROUDE NUMBER IS > 1. 
C                             THE FLOW IS SUPERCRITICAL. 
C======================================================================= 
CIM BEGIN <><><><><><><> 
CIM ALL BUT ORIFICES 
      IF(NKLASS(N).LE.50.AND.H(N,1).LE.ZCROWN(NL).AND.JSKIP(NL).EQ.0. 
CIM END <><><><><><><> 
     +                  AND.JSKIP(NH).EQ.0) THEN 
      IF(Q(N).GT.0.0.AND.H(N,1).LE.ZCROWN(NL)) THEN 
      DIFF1 = H(N,1) - ZU(N) 
      DIFF2 = H(N,2) - ZD(N) 
      IF(KSUPER.EQ.1.AND.DIFF1.GT.0.0.AND.DIFF2.GT.0.0) THEN 
               FF1 = ABS(Q(N))/ANL/SQRT(GRVT*(DIFF1)) 
               FF2 = ABS(Q(N))/ANH/SQRT(GRVT*(DIFF2)) 
               QNORM = SQRT(GRVT*(ZU(N)-ZD(N))/ 
     +                   (LEN(N)*ROUGH(N)))*ANL*RNL**0.666667 
                                            ITEST = 0 
               IF(FF1.GE.1.0.OR.FF2.GE.1.0) ITEST = 1 
               IF(QNORM.LE.Q(N).AND.ITEST.EQ.1) THEN 
                                                ICHECK(N) = IND(2) 
                                                Q(N)      = QNORM 
                                                ENDIF 
               ENDIF 
      ENDIF 
      ENDIF 
C======================================================================= 
C     DO NOT ALLOW A FLOW REVERSAL IN ONE TIME STEP 
C======================================================================= 
      DIRQT = SIGN(1.0,QT(N)) 
      DIRQ  = SIGN(1.0,Q(N)) 
      IF(DIRQT/DIRQ.LT.0.0) Q(N) = 0.001*DIRQ 
C======================================================================= 
C     COMPUTE CONTINUITY PARAMETERS 
C======================================================================= 
      SELECT CASE (INGATE(N)) 
      CASE (1) 
      Q(N) = AMAX1(Q(N),0.0) 
c      IF(INGATE(N).EQ.1.AND.Q(N).LT.0.0) Q(N) = 0.0 
      CASE (2) 
      Q(N) = AMIN1(Q(N),0.0) 
c      IF(INGATE(N).EQ.2.AND.Q(N).GT.0.0) Q(N) = 0.0 
      END SELECT 
      IF (NKLASS(N).LE.21) THEN 
      Q(N) = AMAX1(STHETA(N),Q(N)) 
      Q(N) = AMIN1(SPHI(N),Q(N)) 
      ENDIF 
  995 DQDH      = 1.0/(1.0+AKON)*GRVT*DELT*AT(N)/LEN(N) 
      SUMQ1(NL)  = SUMQ1(NL)  - 0.5*(Q(N)+QO(N)) 
      SUMQS1(NL) = SUMQS1(NL) - Q(N) 
      SUMAL1(NL) = SUMAL1(NL) + DQDH 
      SUMQ1(NH)  = SUMQ1(NH)  + 0.5*(Q(N)+QO(N)) 
      SUMQS1(NH) = SUMQS1(NH) + Q(N) 
      SUMAL1(NH) = SUMAL1(NH) + DQDH 
  360 CONTINUE 
C$OMP END DO NOWAIT 
CWRM COMBINE THE PARTIAL SUMS 
CWRM SPLIT CRITICAL SECTIONS REDUCES CONTENTION FOR LOCKS 
C$OMP CRITICAL (TOP) 
      DO J = 1, NJ 
        SUMQ(J)  = SUMQ(J)  + (SUMQ1(J) - SUMQL(J)) 
        SUMQS(J) = SUMQS(J) + (SUMQS1(J) - SUMQSL(J)) 
      ENDDO 
C$OMP END CRITICAL 
C$OMP CRITICAL (BOTTOM) 
      DO J = 1, NJ 
        SUMAL(J) = SUMAL(J) + (SUMAL1(J) - SUMALL(J)) 
        AS(J)    = AS(J)    + (AS1(J) - ASL(J)) 
      ENDDO 
C$OMP END CRITICAL 
C$OMP END PARALLEL 
C======================================================================= 
C     SET FULL STEP OUTFLOWS AND INTERNAL TRANSFERS 
C======================================================================= 
      CALL BOUND(YT,Y,Q,TIME,DELT) 
C======================================================================= 
      N1       = NTC+1 
      DO 370 N = N1,NTL 
      NL       = NJUNC(N,1) 
      NH       = NJUNC(N,2) 
CC$$$$$5/3/92 
      IF(ABS(Q(N)).LT.1E-10) Q(N) = 0.0 
C======================================================================= 
C     CHECK WHETHER SURCHARGE ITERATIONS OCCURRING 
C======================================================================= 
      IF(NH.GT.0) THEN 
                  IF(IT.GT.0.AND.JCHECK(NH).EQ.IND(1).AND. 
     +                 JCHECK(NL).EQ.IND(1))           GO TO 370 
                  ENDIF 
C======================================================================= 
C     DO NOT ALLOW FLOW REVERSAL IN ONE TIME STEP 
C======================================================================= 
      DIRQT = SIGN(1.0,QT(N)) 
      DIRQ  = SIGN(1.0,Q(N)) 
      IF(DIRQT/DIRQ.LT.0.0) Q(N) = 0.001*DIRQ 
      SUMQ(NL)  = SUMQ(NL)  - 0.5*(Q(N)+QO(N)) 
      SUMQS(NL) = SUMQS(NL) - Q(N) 
      IF(NH.NE.0) THEN 
                  SUMQ(NH)  = SUMQ(NH) + 0.5*(Q(N)+QO(N)) 
                  SUMQS(NH) = SUMQS(NH)+ Q(N) 
                  ENDIF 
  370 CONTINUE 
C======================================================================= 
C     CALCULATE THE FULL-STEP HEAD 
C======================================================================= 
      DO 560 J = 1,NJ 
      IF(JSKIP(J).GT.0) GO TO 560 
C======================================================================= 
C     CHECK WHETHER SURCHARGE ITERATIONS OCCURRING 
C     COMPUTE Y FOR FREE SURFACE JUNCTIONS 
C======================================================================= 
      IF(YT(J)-YCROWN(J).LE.0.0) THEN 
           IF(IT.GT.0) GO TO 560 
           JCHECK(J)             = IND(1) 
           Y(J)                  = YO(J)  + SUMQ(J)*DELT/AS(J) 
c     sum total volumes here and below. 
           VOL(J) = VOL(J) + SUMQ(J)*DELT 
cend 
           ASFULL(J)             = AS(J) 
C  CIMoore     10/98 
C  If QIN is negative and computed Y is less than zero then 
C  Adjust QIN appropriately. Fix for continuity when negative 
C  flow is specified on D1 or K3 cards 
c           IF(Y(J).LT.0.0) Y(J) = FUDGE 
           IF(Y(J).LT.0.0) THEN 
            IF(QIN(J).LT.0.0) THEN 
            FLOWNEG = Y(J)*AS(J)/DELT 
c         write(n6,*) 'TESTING',J,Y(J),AS(J),DELT,FLOWNEG,QIN(J) 
            QIN(J) = AMIN1(QIN(J)-FLOWNEG,0.0) 
c         write(n6,*) qin(j) 
            ENDIF 
           Y(J) = FUDGE 
           ENDIF 
           ELSE 
                                       DENOM = SUMAL(J) 
           IF(YT(J).LT.1.25*YCROWN(J)) DENOM = SUMAL(J) + 
     +  (ASFULL(J)/DELT-SUMAL(J))*EXP(-15.*(YT(J)-YCROWN(J))/YCROWN(J)) 
                               CORR   = 1.00 
           IF(NCHAN(J,2).EQ.0) CORR   = 0.60 
           Y(J)                       = YT(J) + CORR*SUMQS(J)/DENOM 
c     sum total volumes here 
           VOL(J) = VOL(J) + CORR*SUMQS(J)*DELT 
cend 
           IF(Y(J).LT.YCROWN(J)) Y(J) = YCROWN(J) - FUDGE 
           JCHECK(J)                  = IND(2) 
C     HERE USE SURELEV IN PLACE OF GRELEV 
           IF((Y(J)+Z(J)).LT.SURELEV(J)) ERROR = ERROR + SUMQS(J) 
           ENDIF 
           IF((Y(J)+Z(J)).GT.SURELEV(J)) Y(J)  = SURELEV(J)-Z(J) 
  560 CONTINUE 
C======================================================================= 
C     CHECK CONVERGENCE OF THE FLOW ERROR IN SURCHARGED AREAS 
C                       OR INITIALIZE FOR NEXT ITERATION 
C======================================================================= 
      IF(ABS(ERROR)-TOL.LE.0.0.OR.IT-ITMAX+1.GT.0) RETURN 
      IT       = IT+1 
      DO 570 J = 1,NJ 
      IF(JCHECK(J).EQ.IND(2)) THEN 
                              YT(J)    = Y(J) 
                              SUMQ(J)  = QIN(J) 
                              SUMQS(J) = QIN(J) 
                              SUMAL(J) = 0.0 
                              ENDIF 
  570 CONTINUE 
 1000 CONTINUE 
      RETURN 
      END 
 
REM File: BND.INC 
 
      COMMON/BND/JFREE(NTG),JTIDE(NTG),JGATE(NTG),NBCF(NTG), 
     1           NBCG(NTG),NFREE,NGATE,KFREE(NTG),KGATE(NTG) 
       CHARACTER*10 KFREE,KGATE 
 
REM File: COMB.INC 
 
C#### WCH, 11/19/93.  ADD CHARACTER KUNC1 AND KUNC2 ARRAYS FOR APHANUMERIC. 
C                     AND IPOLLU VARIABLE. 
CIMT  change dimensions from 10 to MQUAL 
      CHARACTER    PNAM2*10,PUNIT2*10,PNAM1*10,PUNIT1*10, 
     1             KODEX*10,KODER*10,KUNC1*10,KUNC2*10 
      COMMON/COLL1/IPOLLU  
	  COMMON/COLL2/CPOLL(MQUAL,NIE),POLL1(MQUAL,NIE), 
     1             POLL2(MQUAL,NIE),POLL3(MQUAL,NIE),POLD1(MQUAL,NIE), 
     2             POLD2(MQUAL,NIE),QO1(NIE),QO2(NIE),QO3(NIE), 
     3             QQO(NIE),QOLD1(NIE),QOLD2(NIE),TDIF1(NIE),TDIF2(NIE) 
      COMMON/COLL2/NODEX(NIE),NODER(NIE),JCOMB(NIE),JUNC1(NIE), 
     1             JUNC2(NIE),INPOS1(NIE),INPOS2(NIE),NDIM1(MQUAL), 
     2             NDIM2(MQUAL),NPOS1(MQUAL),NPOS2(MQUAL),NUMX, 
     3             KODEX(NIE),KODER(NIE),PNAM2(MQUAL),PUNIT2(MQUAL), 
     4             PNAM1(MQUAL),PUNIT1(MQUAL),KUNC1(NIE),KUNC2(NIE) 
 
 
REM File: CONTR.INC 
 
C     EXTRAN BLOCK 
C#### WCH, 4/11/94.  ADD IDATZ AND REARRANGE ORDER. 
      COMMON/CONTR/XTIME,DELT,DELT2,TIME,TIME2,RDELT,IDATZ,MJSW,JSLOT, 
     1             NJ,NC,NTC,NTL,ICYC,NJSW,METRIC, 
     2             NTCYC,ISOL,MSUR,NSTOP,MTIME,MURGE,KSUPER,NEQUAL, 
     3             JDOWN,GRVT,FUDGE,ALPHA1,ALPHA2 
      CHARACTER*80 ALPHA1,ALPHA2 
      REAL         DELT,TIME,RDELT,DELT2,TIME2 
Cwch, 7/20/04. Add double precision XTIME for Extran time keeping. 
      REAL*8 XTIME 
C ### RHF 12/20/96 
      COMMON /ROUTE4/ TOLCS1,TOLCS2,QLOWCS,KREDO 
      COMMON /ROUTE4A/ NOROUT,NEWQIN,NEWQTAPE,NEWQCARD,ISOLSKIP 
c  additional variables for handling of M1 drawdown condition 
      COMMON /ROUTE5/ IM2 
Cwch, 7/23/04. Add variables for optional weights in NHEAD. 
      COMMON /ROUTE6/ WUP(3),WMD(3),WDN(3),NAVER,NFASNH 
 
REM File: HUGO.INC 
 
      CHARACTER SCF*4,KINNUM*10,BORDER*10,KYN*10,KPE*10,KJN*10, 
     +                                  KUE*10,KOE*10,KGEOM*10 
CIMT 
CIMT  Changes made by C. Moore to increase number of constituents in 
CIMT  Transport 
cIMT   dimensions changed from 4 to MQUAL for appropriate variables 
cIMT       4/99 
C    Note, value of NQP = NET in Tapes.inc.  
CIM  NOTE XNT HAS DIMENSIONS OF 10+6*MQUAL 
      DOUBLE PRECISION XNT 
      COMMON/HUGO1/A(NET,2,2),Q(NET,2,2) 
      COMMON/HUGO2/CPOL1(NQP,2,MQUAL),CPOL2(NQP,2,MQUAL) 
      COMMON/HUGO3/TIME,QFULL(NET),AFULL(NET),DXDT(NET),C1(NET), 
     1       SLOPE(NET),DIST(NET),GEOM1(NET),ROUGH(NET),DWDAYS,EPSIL,DT 
Cwch, 2/15/01.  Make TIME double precision 
      REAL*8 TIME 
      COMMON/HUGO4/QDWF(NET),P1(NET),RNOFF(NET),QINFIL(NET), 
     1       WDWF(NET,MQUAL),PLUTO(MQUAL,NET),P2(NET),P5(NET),P6(NET), 
     2       P7(NET),BARREL(NET),GEOM2(NET),QMAX(NET),GEOM3(NET), 
     3       P4(NET),SCOUR(NET,MQUAL),XNT(10+6*MQUAL) 
      COMMON/HUGO5/KSTORE(NET),NPE(NTOA),NYN(NTOA),NORDER(NET), 
     1       JSURF(NTOA), 
     1       NINNUM(NET),INUE(NET,3),NTYPE(NET),JR(NET), 
     2       IOLD(NET),NOE(NET),NUE(NET,3),NNYN,NNPE,NSURF,NPLOT,JPRINT, 
     3       NOUTS,INTPRT,NFILTH,NDESN,NCNTRL,NINFIL,KSPG,NINPUT,NKLASS, 
     4       NE,NDT,KFULL,NOS,NPOLL,NPRINT,ITER,NITER,M,N 
      COMMON/HUGO6/KOE(NET),KUE(NET,3),KYN(NTOA),KINNUM(NET), 
     1       KPE(NTOA),KJN(NTHO),BORDER(NTHR),KGEOM(NET),SCF(NET) 
C#### JLM, 10/93.  ADD FOR WASP LINKAGE. 
      COMMON/WASP/ ISUMRY 
CIMHV## 9/8/00 change to have depth and velocity output to interface. 
      COMMON/CIMHV/ NPOLL2 
CIMHV 
Cwch, 10/3/01 
      COMMON/HUGO7/ NOHEAD 
ECHO is off.
 
REM File: HYFLOW.INC 
 
      COMMON/HYFLOW/QTAPE(NIE,2),QCARD(NEH,2),JSW(NEH),TSTART, 
     +              TEND,NSTEPS,NINREC 
 
REM File: ORF.INC 
 
C======================================================================= 
C     NVORF  ==> Number of variable orifices. 
C     NVOTIM ==> Number of data points for variable orifices. 
C======================================================================= 
C#### WCH, 7/30/97.  Move PARAMETER statement to TAPES.INC. 
C####      PARAMETER(NVORF=20,NVOTIM=25) 
      COMMON/ORF/LORIF(NEO),AORIF(NEO),CORIF(NEO), 
     +           VORIF(NVORF,NVOTIM,3),NVOR,NORIF 
Cwch, 7/22/04. 
cred  add a place holder for F2 type orifice - 4/15/2002 
      integer f2_line,f2_limit 
      common/f2_orf/f2_line(neo),f2_limit(neo) 
CIM START      
CIM======================================================================= 
CIM DATA FOR GATES  
      COMMON/ORF2/NOGATES,ICNODE(NEO),OOPEN(NEO),OCLOSE(NEO), 
     .OCAREA(NEO),ORATE(NEO),IDIR(NEO),IOPRNT(NEO),IOINV(NEO) 
CIM END      
 
 
REM File: PRECIP.INC 
 
C#### WCH, 7/30/97.  Put PARAMETER statement in TAPES.INC. 
C####      PARAMETER(LIMRN=5000,LSTORM=5000) 
C#### WCH, 8/93.  ADD PARAMETER  HIST. 
C#### WCH, 11/12/93.  ADD PARAMETER IHH. 
C#### WCH, 4/26/94.   ADD PARAMETER KODEA AND ACODE (CHARACTER) 
C#### WCH, 8/1/95.  REARRANGE ORDER SOMEWHAT. 
      COMMON/PRECIP/KODEA,KUNIT,IFORM,IHH,IO,NEWYR,F1,F2,F3,F4, 
     *       F5,F6,F7,NSTORM,METRIC,NUVAL,IYEND(3),IYBEG(3), 
     *       THISTO,CONV,HIST,SUM(2) 
      COMMON/PRECP1/RDAY(LIMRN),RRAIN(LIMRN) 
      COMMON/PRECP2/RTIME(LIMRN) 
C#### WCH, 11/5/93.  BREAK UP THESE LARGE COMMONS INTO SEPARATE LABELED 
C                    COMMONS. 
      COMMON/PRECP3/HOUR(366,27) 
      COMMON/PRECP4/X1(LSTORM,3) 
      COMMON/PRECP5/X2(LSTORM,3) 
C#### WCH, 8/1/95.  ADD ISTA TO CHARACTER AND PUT CHARACTER VARIABLES 
C     IN SEPARATE COMMON. 
Cwch, 7/28/04. Add IFORM1 
      COMMON/PRECP6/IFORM1,FIRMAT,ISTA,ACODE(366,4) 
      CHARACTER FIRMAT*80,ACODE*1,ISTA*8 
      INTEGER F1,F2,F3,F4,F5,F6,F7,RDAY,RRAIN,HOUR 
 
REM File: RDII.INC 
 
C NRDI = NNTK = NUMBER OF TK BASINS   (MAY END UP BEING EQUAL TO NUMBER OF SUBCATCHMENTS) 
C  
      PARAMETER(NTK=50) 
cim 9/97 change to allow input of 12 parameters for months 
      COMMON/RDII/RDIIT(NTK,3,12),RDIIK(NTK,3,12),RDIIR(NW,3,12), 
     1 SEWAREA(NW),NRDHYET(NTK),ICURVE(NW),DSTORE(NTK,3,12), 
     2 DREC(NTK,3,12),STORAGE(NTK,3,12),FLOWII(NW),CONCII(MQUAL), 
     3 SUMRDII(MQUAL) 
      COMMON/RDII2/RDTIM(2),NRDII,JRDDAY(2),RDFLOW(NTK,3,2), 
     1 IZERO(NTK,3,2),IIRDII,NNTK 
      DOUBLE PRECISION  CNTRDII,CNRAIN,CNEXCESS,SUMOFRS 
      COMMON/RDII3/TSTEP,TSTEP2,IRATIOS,RDIIAREA,RRMAX 
      COMMON/RDII4/CNTRDII(3),CNRAIN,CNEXCESS,SUMOFRS 
      LOGICAL IZERO 
 
 
REM File: S1.INC 
 
C#### WCH, 8/93.  INCREASE DIMENSIONS FOR IEND,ISTART 
C#### WCH, 12/5/94.  ADD COMMON/S3/ 
CIM   INCREASE DIMENSION OF CONSTITUENT FROM 3 to MQUAL 4/99 
CIM   INCREASE NUMBER OF UNITS FROM 5 to MSTU 
      COMMON/S1/DS,DSTART(MSTU,2),DSTOP(MSTU),A(MSTU,MQUAL,16), 
     1    ALEN(MSTU),AMAN(MSTU),ATN,CCC(MSTU,5),DEPTHL(MSTU),DOP(MSTU), 
     2          E(12),ICOST,IDENT(MSTU),IDIREC(MSTU,3),IDRAW(MSTU), 
     3          IEND(45),INPUT(MSTU,MQUAL,11),IOUT(MSTU),IPART(MQUAL), 
     4          IPT,IROUTE(MSTU),ISTART(45),ISUM,KDT,IDET,KPC(MSTU,2), 
     5          LTM,METRIC,NDT,NINT(MSTU),NNR,NP,NPR,NPSL(MSTU),NU, 
     6          NVS,PCONV(MQUAL),PCRC(MQUAL),PCTP(MQUAL), 
     7          PC0(MSTU,MQUAL),PMBY(MSTU,MQUAL),PMIN(MQUAL), 
     8          PMIT(MSTU,MQUAL),PMOU(MSTU,MQUAL),PMRM(MQUAL), 
     9          PMRN(MSTU,MQUAL),PMRS(MSTU,MQUAL),PSBY(MSTU,MQUAL,10), 
     1          PSC(MSTU),PSD(MSTU,10),PSIT(MSTU,MQUAL,10), 
     2          PSOU(MSTU,MQUAL,10),PSRS(MSTU,MQUAL,10),VOLINC(MSTU), 
     3          POLINC(MSTU,MQUAL) 
      COMMON/S2/QMAX(MSTU),QMAXS(MSTU),QPUMP(MSTU,2),QQBY(MSTU), 
     1          QQEV(MSTU),QQIN(MSTU),QQIT(MSTU),QQOU(MSTU),QQRC, 
     2          QQRS(MSTU),QQTP,QRF(MSTU),RAN(10,2),RMX(MSTU,MQUAL), 
     3          SAREA(MSTU,17),SDEPTH(MSTU,17),SLDEN(MSTU), 
     4          SLDMAX(MSTU),SLVOL(MSTU),SQQOU(MSTU,17),SQQRS(MSTU,17), 
     5          SSTORE(MSTU,17),VMAX(MSTU),VMAXS(MSTU),VS(10), 
     6          WARN(MSTU),UNAME(MSTU) 
      COMMON/S3/JDLAST(MSTU),JFDAY(MSTU,3),JFLOOD(MSTU,3) 
      CHARACTER*18 UNAME 
C### RED, 5/93.  No longer:      DOUBLE PRECISION DS 
 
REM File: STIMER.INC 
 
      COMMON/STIMER/TIMDAY,JULDAY,NYEAR,MONTH,NDAY,JHR,MINUTE,JSEC 
 
REM File: TEW.INC 
 
Cwch, 7/28/04. Add F7 and F8. 
      COMMON/TEW/IYEND(3),IYBEG(3),FIRMAT,KUNIT,CONV,KTYPE,PAN(12), 
     *           IFORM,IO,NEWYR,ISTA,F1,F2,F3,F4,F5,F6,F7,F8,METRIC, 
     *           BARAY(12,31),SARAY(12,31),WARAY(12,31),EARAY(12,31) 
      CHARACTER FIRMAT*80 
      INTEGER F1,F2,F3,F4,F5,F6,F7,F8 
 
REM File: Threshold.inc 
 
C   Common block for printout of threshold elevation values for junctions. 
C   Added 10/14/99  by C. Moore  CDM 
C 
      Common /ThreshIN/ NTHRESH,NJUNTHR,THRESH(MTHRESH,NEE), 
     A                JUNTHR(NEE),THRESHID(MTHRESH) 
      Common /ThreshOUT/TFIRST(MTHRESH,NEE),TDUR(MTHRESH,NEE), 
     a                ITCOUNT(MTHRESH,NEE),TLASTTIME(MTHRESH,NEE) 
      Character*32 THRESHID 
      LOGICAL TLASTTIME 
 
REM File: TIDE.INC 
 
      COMMON/TIDE1/A1(NTE),A2(NTE),A3(NTE),A4(NTE),A5(NTE),A6(NTE), 
     1             A7(NTE),W(NTE),HTIDE(NEE),PHLAGS(NTE),PHLAG, 
     2             NUMTID(NTE),JTIDES(NEE),NTIDE(NTE),IC,M2S2 
      COMMON/TIDE2/YY(NTVAL),TT(NTVAL),AA(10),XX(10),SXX(10,10),SXY(10), 
     1             STIDE(NTE,2,NTVAL) 
 
 
REM File: TIMER.INC 
 
C#### WCH, 12/31/93.  REARRANGE ORDER OF COMMON/TIMER/ 
C#### DWD (CSC) - Begin change. 
C     Date: Tuesday, 10 May 1994.  Time: 12:33:51. 
C     Moved TIME to end of common block to correct warning generated 
C     during compilation using Lahey 32-bit FORTRAN, version 5.01 
CWarning - Previous common variable causes misalignment of DOUBLE PRECISION  
Cvariable (TIME) , File TIMER.INC, line 2. 
Cwch, 4/10/00. Possible alignment problems. Rearrange COMMON.  
C 
Cwch      COMMON/TIMER/IPRNGW,LUNIT,DELT,WET,DRY,WETDRY,LONG,DMEAN,DLAST, 
Cwch     1             JSTART(10),JSTOP(10),IPRN(7),PMONTH(12),TIME 
C     1             TIME,JSTART(10),JSTOP(10),IPRN(7),PMONTH(12) 
C 
Cwch, 12/20/00. Add parameter NOHEAD and LANDUPR 
      COMMON/TIMER/WET,DRY,WETDRY,DMEAN,DLAST, 
     1   IPRNGW,LUNIT,JSTART(10),JSTOP(10),IPRN(7),NOHEAD,LANDUPR 
	  COMMON/TIMER2/TIME,DELT,LONG 
	  COMMON/TIMER3/PMONTH(12) 
C 
C#### DWD (CSC) - End change. 
C     Date: Tuesday, 10 May 1994.  Time: 12:33:51. 
C 
C#### WCH (RED), 9/93. CHANGE "TIME" TO DOUBLE PRECISION. 
Cwch, 4/10/00.  Tried making LONG double precision but got bizzare errors 
C in GUTNR, possibly caused by alignment, but who knows?  Couldn't solve.  
C Solution was to read LONG in RHYDRO1 as a double variable to handle 
C 4-digit year dates, but leave LONG as real*4 during computations. 
      REAL         LONG,WET,DRY,WETDRY,DMEAN,DLAST 
      DOUBLE PRECISION TIME 
      CHARACTER*10 PMONTH 
